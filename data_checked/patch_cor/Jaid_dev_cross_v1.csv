0,"index 8228589..3cc4138 100644 */ public Week(Date time, TimeZone zone) { // defer argument checking... -        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault()); +        this(time, zone, Locale.getDefault()); }  /**"
0,* @return true if the locale is a known locale */ public static boolean isAvailableLocale(Locale locale) { -        return cAvailableLocaleSet.contains(locale); +        return org.apache.commons.lang.LocaleUtils.availableLocaleList().contains(locale); }  //-----------------------------------------------------------------------
1,"/** {@inheritDoc} */ public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { -        return solve(min, max); +        return solve(f, min, max); }  /** {@inheritDoc} */ fmin = f.value(min); fm = f.value(m);  -            if (fm * fmin > 0.0) { +            if (fm * fmin > 0.0||fmin == fm) { // max and m bracket the root. min = m; } else {"
0,"index 22df685..8cd3ab9 100644 for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { +        case '\0': sb.append(""\\0""); break; case '\n': sb.append(""\\n""); break; case '\r': sb.append(""\\r""); break; case '\t': sb.append(""\\t""); break;"
0,"index df71405..c5342ae 100644 * @since 1.1 */ public static int gcd(int u, int v) { -        if (u * v == 0) { +        if ((u == 0) || (v == 0)) { return (Math.abs(u) + Math.abs(v)); } // keep u and v negative, as negative integers range down to"
1,"* Check to see if the given block comment looks like it should be JSDoc. */ private void handleBlockComment(Comment comment) { -    if (comment.getValue().indexOf(""/* @"") != -1 || comment.getValue().indexOf(""\n * @"") != -1) { +    if (true) { errorReporter.warning( SUSPICIOUS_COMMENT_WARNING, sourceName, "
0,"index 08d3b95..f81ff0a 100644 long overflow = Integer.MAX_VALUE; double r0 = value; long a0 = (long)FastMath.floor(r0); -        if (a0 > overflow) { +        if (FastMath.abs(a0) > overflow) { throw new FractionConversionException(value, a0, 1l); }  long a1 = (long)FastMath.floor(r1); p2 = (a1 * p1) + p0; q2 = (a1 * q1) + q0; -            if ((p2 > overflow) || (q2 > overflow)) { +            if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) { throw new FractionConversionException(value, p2, q2); } "
1,"/* Handle special case x<0 */ if (x < 0) { // y is an even integer in this case -            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) { +            if ((y >= TWO_POWER_52 || y <= -TWO_POWER_52) && !(y == (long) y)) { return pow(-x, y); } "
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if(((fa)==0.0)||((fa*fb)> 0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,"index 4c14509..886d424 100644 String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { -                str.getChars(0, strLen, buffer, size); +                str.getChars(0, width, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size);"
1,break;  case Token.STRING: -        return getStringNumberValue(n.getString()); +        break;  case Token.ARRAYLIT: case Token.OBJECTLIT: 
0,"index d4f98ec..7b22e21 100644 * @return String with escaped values, <code>null</code> if null string input */ public static String escapeJava(String str) { -        return escapeJavaStyleString(str, false); +        return escapeJavaStyleString(str, false, false); }  /** * @throws IOException if error occurs on underlying Writer */ public static void escapeJava(Writer out, String str) throws IOException { -        escapeJavaStyleString(out, str, false); +        escapeJavaStyleString(out, str, false, false); }  /** * @return String with escaped values, <code>null</code> if null string input */ public static String escapeJavaScript(String str) { -        return escapeJavaStyleString(str, true); +        return escapeJavaStyleString(str, true, true); }  /** * @throws IOException if error occurs on underlying Writer **/ public static void escapeJavaScript(Writer out, String str) throws IOException { -        escapeJavaStyleString(out, str, true); +        escapeJavaStyleString(out, str, true, true); }  /** * @param escapeForwardSlash TODO * @return the escaped string */ -    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) { +    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes, boolean escapeForwardSlash) { if (str == null) { return null; } try { StringWriter writer = new StringWriter(str.length() * 2); -            escapeJavaStyleString(writer, str, escapeSingleQuotes); +            escapeJavaStyleString(writer, str, escapeSingleQuotes, escapeForwardSlash); return writer.toString(); } catch (IOException ioe) { // this should never ever happen while writing to a StringWriter * @param escapeForwardSlash TODO * @throws IOException if an IOException occurs */ -    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException { +    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote, +            boolean escapeForwardSlash) throws IOException { if (out == null) { throw new IllegalArgumentException(""The Writer must not be null""); } out.write('\\'); break; case '/' : +                        if (escapeForwardSlash) { out.write('\\'); +                        } out.write('/'); break; default :"
0,"public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); +         if (isNaN || rhs.isNaN) { +             return NaN; +         } return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); } "
0,index d96c916..02c22b5 100644 continue; } Integer basicRow = getBasicRow(colIndex); +          if (basicRow != null && basicRow == 0) { // if the basic row is found to be the objective function row // set the coefficient to 0 -> this case handles unconstrained // variables that are still part of the objective function -          if (basicRows.contains(basicRow)) { +              coefficients[i] = 0; +          } else if (basicRows.contains(basicRow)) { // if multiple variables can take a given value // then we choose the first and set the rest equal to 0 coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);
0,"index 4472638..30b19e0 100644 Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP -          ) { +          && assign.getParent().getType() == Token.EXPR_RESULT) { // We want to exclude the assignment itself from the usage list boolean isChainedProperty = n.getFirstChild().getType() == Token.GETPROP;"
1,"if (start < 0) { throw new IllegalArgumentException(""Requires start >= 0.""); } -        if (end < start) { +        if ((end < start) && (this.data.size() > 0)) { throw new IllegalArgumentException(""Requires start <= end.""); } TimeSeries copy = (TimeSeries) super.clone(); "
0,"Preconditions.checkState(block.hasOneChild()); Node stmt = block.getFirstChild(); if (stmt.isReturn()) { -        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler); +        int start = 0; } } // CALL NODE: [ NAME, ARG1, ARG2, ... ] "
1,"String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { -                str.getChars(0, strLen, buffer, size); +                ensureCapacity(((size) + 5)); +str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size);"
0,"break; case REGULA_FALSI: // Nothing. -                    if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                    if (x == x1) + f0 = computeObjectiveValue(x0); -                    } + break; default: // Should never happen. "
0,markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent();   markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); 
1,"for (final StepHandler handler : stepHandlers) { -                    handler.handleStep(interpolator, isLastStep); +                    if (org.apache.commons.math3.ode.AbstractIntegrator.this.stepHandlers.size() == orderingSign) { +                        handler.handleStep(interpolator, isLastStep); +                    } } "
0,"index da86fdb..dd2f5cf 100644 return INDEX_NOT_FOUND; } int csLen = cs.length(); +        int csLast = csLen - 1; int searchLen = searchChars.length; +        int searchLast = searchLen - 1; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { +                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { // ch is a supplementary character +                        if (searchChars[j + 1] == cs.charAt(i + 1)) { +                            return i; +                        } +                    } else { return i; +                    } } } } * <code>false</code> if no match or null input * @since 2.4 */ -    public static boolean containsAny(CharSequence cs, char[] searchChars) { +    public static boolean containsAny(String cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return false; } char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { -                    if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { +                    if (Character.isHighSurrogate(ch)) { +                        if (j == searchLast) { // missing low surrogate, fine, like String.indexOf(String) -                        if (searchChars[j + 1] == cs.charAt(i + 1)) { +                            return true; +                        } +                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { return true; } } else { * @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input * @since 2.4 */ -    public static boolean containsAny(CharSequence cs, String searchChars) { +    public static boolean containsAny(String cs, String searchChars) { if (searchChars == null) { return false; } return INDEX_NOT_FOUND; } int csLen = cs.length(); +        int csLast = csLen - 1; int searchLen = searchChars.length; +        int searchLast = searchLen - 1; outer: for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { +                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { +                        if (searchChars[j + 1] == cs.charAt(i + 1)) { +                            continue outer; +                        } +                    } else { continue outer; +                    } } } return i; int strLen = str.length(); for (int i = 0; i < strLen; i++) { char ch = str.charAt(i); -            if (searchChars.indexOf(ch) < 0) { +            boolean chFound = searchChars.indexOf(ch) >= 0; +            if (i + 1 < strLen && Character.isHighSurrogate(ch)) { +                char ch2 = str.charAt(i + 1); +                if (chFound && searchChars.indexOf(ch2) < 0) { return i; +                } +            } else { +                if (!chFound) { +                    return i; +                } } } return INDEX_NOT_FOUND; return true; } int csLen = cs.length(); +        int csLast = csLen - 1; int searchLen = searchChars.length; +        int searchLast = searchLen - 1; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { +                    if (Character.isHighSurrogate(ch)) { +                        if (j == searchLast) { // missing low surrogate, fine, like String.indexOf(String) +                            return false; +                        } +                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { +                            return false; +                        } +                    } else { // ch is in the Basic Multilingual Plane return false; +                    } } } }"
1,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { -            return result; -        } +        setPlot(plot); int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { 
1,"private static int greatestCommonDivisor(int u, int v) { // From Commons Math: //if either operand is abs 1, return 1: -        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) { +        if (Math.abs(u) <= 1 && Math.abs(v) <= 1) { return 1; } // keep u and v negative, as negative integers range down to "
1,double oldFac = hsig ? 0 : ccov1 * cc * (2. - cc); -            oldFac += 1. - ccov1 - ccovmu; +            if (org.apache.commons.math3.optimization.direct.CMAESOptimizer.this.inputSigma!=null) { +                oldFac += 1. - ccov1 - ccovmu; +            } if (isActiveCMA) { 
0,"public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); +        if ((isNaN) || (rhs.isNaN)) {    return org.apache.commons.math.complex.Complex.NaN;} return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); } //-----------------------------------------------------------------------"
0,"index 58d5289..075683d 100644 */ public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) { -        super(paint, stroke, paint, stroke, alpha); +        super(paint, stroke, outlinePaint, outlineStroke, alpha); this.value = value; } "
1,"if (end < start) { -            throw new IllegalArgumentException(""Requires start <= end.""); +            if (org.jfree.data.time.TimeSeries.DEFAULT_RANGE_DESCRIPTION.length() == org.jfree.data.time.TimeSeries.this.data.size()) { +                throw new IllegalArgumentException(""Requires start <= end.""); +            } } "
0,"* can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ -      if (NodeUtil.hasFinally(n)) { +      if (NodeUtil.hasFinally(n)&&allCatchNodes == tryBlock) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); }"
0,"index 3f39c07..d53a8f8 100644  @Override public void process(Node externs, Node root) { -    (new NodeTraversal(compiler, this)).traverse(root); +    (new NodeTraversal(compiler, this)).traverseRoots(externs, root); }  @Override index 589f673..1487af3 100644 private static class Definition { final Node node; final Set<Var> depends = Sets.newHashSet(); +    private boolean unknownDependencies = false;  Definition(Node node) { this.node = node; new AbstractCfgNodeTraversalCallback() { @Override public void visit(NodeTraversal t, Node n, Node parent) { -        if (n.isName() && jsScope.isDeclared(n.getString(), true)) { +        if (n.isName()) { Var dep = jsScope.getVar(n.getString()); +          if (dep == null) { +            def.unknownDependencies = true; +          } else { def.depends.add(dep); +          } } } }); GraphNode<Node, Branch> n = getCfg().getNode(useNode); FlowState<MustDef> state = n.getAnnotation(); Definition def = state.getIn().reachingDef.get(jsScope.getVar(name)); +    if (def.unknownDependencies) { +      return true; +    }  for (Var s : def.depends) { if (s.scope != jsScope) {"
1,"int startValue = start.get(field); if (endValue < startValue) { int newdiff = startValue - endValue; -            end.add( field, newdiff ); +            end.add( newdiff, newdiff ); return newdiff; } else { return 0; "
1,"* can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ -      if (NodeUtil.hasFinally(n)) { +      if (!NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } "
1,"public EventListenerSupport(Class<L> listenerInterface, ClassLoader classLoader) { this(); Validate.notNull(listenerInterface, ""Listener interface cannot be null.""); -        Validate.notNull(classLoader, ""ClassLoader cannot be null.""); +        Validate.notNull(listenerInterface, ""Listener interface cannot be null.""); Validate.isTrue(listenerInterface.isInterface(), ""Class {0} is not an interface"", listenerInterface.getName()); initializeTransientFields(listenerInterface, classLoader); * @param classLoader the class loader to be used */ private void createProxy(Class<L> listenerInterface, ClassLoader classLoader) { -        proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader, +        Validate.isTrue(listenerInterface.isInterface(), ""Class {0} is not an interface"", listenerInterface.getName()); +        proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader, new Class[] { listenerInterface }, createInvocationHandler())); }   throw new NumberFormatException(""A blank string is not a valid number""); } if (str.startsWith(""--"")) { -            return null; } if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) { int hexDigits = str.length() - 2; // drop 0x "
1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(namespace,'.'); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"
1, // checkSuspiciousCode needs to be enabled for CheckGlobalThis to get run. options.checkSuspiciousCode = true; -    options.checkGlobalThisLevel = CheckLevel.WARNING; options.checkSymbols = true; options.checkMissingReturn = CheckLevel.WARNING; 
0,index ce94573..6e3294b 100644 */ private String getRemainingJSDocLine() { String result = stream.getRemainingJSDocLine(); +    unreadToken = NO_UNREAD_TOKEN; return result; } 
0,"index a7b95b0..0fc5ae8 100644 } else { recordDepScope(nameNode, ns); } -        } else { +        } else if (!(parent.isCall() && parent.getFirstChild() == n)) { // The rhs of the assignment is the caller, so it's used by the // context. Don't associate it w/ the lhs. // FYI: this fixes only the specific case where the assignment is the"
1,int increase = 0;  // count the replacement text elements that are larger than their corresponding text being replaced +        if(repeat) for (int i = 0; i < searchList.length; i++) { int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) {
0,"throw new NumberFormatException(""A blank string is not a valid number""); } if (str.startsWith(""--"")) { -            return null; +if (str.startsWith(""--"")==true){throw new NumberFormatException();}            return null; } if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) { int hexDigits = str.length() - 2; // drop 0xS "
0," // return the first endpoint if it is good enough double yMin = f.value(min); +        // start of generated patch +        if(Math.abs(yMin)<=functionValueAccuracy){ +          setResult(min,0); +          return result; +        } +        // end of generated patch +        /* start of original code if (Math.abs(yMin) <= functionValueAccuracy) { setResult(yMin, 0); return result; } +        end of original code*/  // reduce interval if min and initial bracket the root if (yInitial * yMin < 0) { "
0,index 20196bf..a8e92fc 100644 return true; }  +        if (n.isDelProp()) { +          return true; +        }  for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {
0,"index e6398f6..bf3e4bf 100644 } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if (fa * fb > 0.0 ) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return org.apache.commons.math.util.MathUtils.equals(x, y, 1) || x == y; }  /**"
0,"index 855cad0..5d89e34 100644 // Backwards compatibility with TimeZone. map = new HashMap<String, String>(); map.put(""GMT"", ""UTC""); +            map.put(""WET"", ""WET""); +            map.put(""CET"", ""CET""); +            map.put(""MET"", ""CET""); +            map.put(""ECT"", ""CET""); +            map.put(""EET"", ""EET""); map.put(""MIT"", ""Pacific/Apia""); map.put(""HST"", ""Pacific/Honolulu"");  // JDK 1.1 compatible map.put(""AST"", ""America/Anchorage""); map.put(""PNT"", ""America/Phoenix""); map.put(""CST"", ""America/Chicago""); map.put(""EST"", ""America/New_York"");  // JDK 1.1 compatible -            map.put(""IET"", ""America/Indianapolis""); +            map.put(""IET"", ""America/Indiana/Indianapolis""); map.put(""PRT"", ""America/Puerto_Rico""); map.put(""CNT"", ""America/St_Johns""); -            map.put(""AGT"", ""America/Buenos_Aires""); +            map.put(""AGT"", ""America/Argentina/Buenos_Aires""); map.put(""BET"", ""America/Sao_Paulo""); -            map.put(""WET"", ""Europe/London""); -            map.put(""ECT"", ""Europe/Paris""); map.put(""ART"", ""Africa/Cairo""); map.put(""CAT"", ""Africa/Harare""); -            map.put(""EET"", ""Europe/Bucharest""); map.put(""EAT"", ""Africa/Addis_Ababa""); -            map.put(""MET"", ""Asia/Tehran""); map.put(""NET"", ""Asia/Yerevan""); map.put(""PLT"", ""Asia/Karachi""); -            map.put(""IST"", ""Asia/Calcutta""); +            map.put(""IST"", ""Asia/Kolkata""); map.put(""BST"", ""Asia/Dhaka""); -            map.put(""VST"", ""Asia/Saigon""); +            map.put(""VST"", ""Asia/Ho_Chi_Minh""); map.put(""CTT"", ""Asia/Shanghai""); map.put(""JST"", ""Asia/Tokyo""); map.put(""ACT"", ""Australia/Darwin"");"
1,"private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j = 4 * this.pingPong - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; "
0,Index: source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java =================================================================== } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if (dataset == null) { return result; } int seriesCount = dataset.getRowCount();
0,"index 167e2cb..26a56a7 100644 } break; } +                  }  token = eatTokensUntilEOL(); -                  } continue retry; } } } }  +    restoreLookAhead(token); return reportGenericTypeSyntaxWarning(); }  // NOTE(nicksantos): We're not implementing generics at the moment, so // just throw out TypeParameters. if (token != JsDocToken.LP) { +      restoreLookAhead(token); return reportTypeSyntaxWarning(""msg.jsdoc.missing.lp""); } "
1,"if (x <= 0.0) { ret = 0.0; } else { -            double n = getNumeratorDegreesOfFreedom(); +            setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom); +            setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom); +            setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom); +            double n = getNumeratorDegreesOfFreedom(); double m = getDenominatorDegreesOfFreedom();  ret = Beta.regularizedBeta((n * x) / (m + n * x), double d = getDenominatorDegreesOfFreedom(); // use mean ret = d / (d - 2.0); -        return ret; +        return p; }  /**   (""bad value for maximumIterations: "" + maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { -            throw new IllegalArgumentException -            (""Invalid endpoint parameters:  lowerBound="" + lowerBound + -              "" initial="" + initial + "" upperBound="" + upperBound); +            int i = 0; +            throw new IllegalArgumentException(""Function is not polynomial.""); } double a = initial; double b = initial; "
1,} } } +                if (minRatioPositions.isEmpty()) { return minRow; } +        } return minRatioPositions.get(0); } 
1,"* @param notify  notify listeners? */ public void add(TimeSeriesDataItem item, boolean notify) { -        if (item == null) { -            throw new IllegalArgumentException(""Null 'item' argument.""); -        } +        updateBoundsForRemovedItem(item); item = (TimeSeriesDataItem) item.clone(); Class c = item.getPeriod().getClass(); if (this.timePeriodClass == null) { "
0,"index 6e0237f..f24f87c 100644 final double[] eventY = interpolator.getInterpolatedState().clone();  // advance all event states to current time -                currentEvent.stepAccepted(eventT, eventY); -                isLastStep = currentEvent.stop(); +                for (final EventState state : eventsStates) { +                    state.stepAccepted(eventT, eventY); +                    isLastStep = isLastStep || state.stop(); +                }  // handle the first part of the step, up to the event for (final StepHandler handler : stepHandlers) { if (isLastStep) { // the event asked to stop integration System.arraycopy(eventY, 0, y, 0, y.length); -                    for (final EventState remaining : occuringEvents) { -                        remaining.stepAccepted(eventT, eventY); -                    } return eventT; }  -                boolean needReset = currentEvent.reset(eventT, eventY); +                boolean needReset = false; +                for (final EventState state : eventsStates) { +                    needReset =  needReset || state.reset(eventT, eventY); +                } if (needReset) { // some event handler has triggered changes that // invalidate the derivatives, we need to recompute them System.arraycopy(eventY, 0, y, 0, y.length); computeDerivatives(eventT, y, yDot); resetOccurred = true; -                    for (final EventState remaining : occuringEvents) { -                        remaining.stepAccepted(eventT, eventY); -                    } return eventT; } "
1,} res = n.checkTreeEqualsImpl(n2); if (res != null) { -        return res; +        if (true) +            return null; +        return res; } } return res; 
0,"this.dataset = dataset; PiePlot piePlot = new PiePlot(null); this.pieChart = new JFreeChart(piePlot); -        this.pieChart.removeLegend(); +        setDataset(dataset); +        this.pieChart.removeLegend(); this.dataExtractOrder = TableOrder.BY_COLUMN; this.pieChart.setBackgroundPaint(null); TextTitle seriesTitle = new TextTitle(""Series Title"", "
0,index e0466ea..f2d36f5 100644 Var var = s.getVar(lhs.getString()); return var != null && var.getScope() == s +          && !isNamedParameter(var) && !blacklistedVars.contains(var); } }  +  private boolean isNamedParameter(Var v) { +    return v.getParentNode().isParamList(); +  }  private void applyCollapses() { for (Collapse collapse : collapses) {
1,case 'l' : case 'L' : if (dec == null -                        && exp == null -                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { +                        && exp == null || (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { 
0,*/ public boolean contains(char ch) { char[] thisBuf = buffer; +    // start of generated patch +        for(int i=0;i<size;i++){ +          if(thisBuf[i]==ch){ +            return true; +          } +        } +    // end of generated patch +    /* start of original code for (int i = 0; i < thisBuf.length; i++) { if (thisBuf[i] == ch) { return true; } } +    end of original code*/ return false; } 
1,"} mant = str.substring(0, decPos); } else { -            if (expPos > -1) { +            if (expPos<-1) { mant = str.substring(0, expPos); } else { mant = str; "
0,"index 13ebfd2..5db4884 100644 public OpenMapRealVector ebeDivide(RealVector v) { checkVectorDimensions(v.getDimension()); OpenMapRealVector res = new OpenMapRealVector(this); -        Iterator iter = res.entries.iterator(); +        Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key())); public OpenMapRealVector ebeDivide(double[] v) { checkVectorDimensions(v.length); OpenMapRealVector res = new OpenMapRealVector(this); -        Iterator iter = res.entries.iterator(); +        Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() / v[iter.key()]); public OpenMapRealVector ebeMultiply(RealVector v) { checkVectorDimensions(v.getDimension()); OpenMapRealVector res = new OpenMapRealVector(this); -        Iterator iter = res.entries.iterator(); +        Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key())); public OpenMapRealVector ebeMultiply(double[] v) { checkVectorDimensions(v.length); OpenMapRealVector res = new OpenMapRealVector(this); -        Iterator iter = res.entries.iterator(); +        Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() * v[iter.key()]);"
1,"private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j = 4 * 2 * (pingPong) - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];"
1,"if (basicRow != null) { for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) { if (tableau.getEntry(basicRow, j) == 1) { +                         if (org.apache.commons.math.optimization.linear.SimplexTableau.this.constraints.size() < org.apache.commons.math.optimization.linear.SimplexTableau.this.numDecisionVariables) { coefficients[i] = 0; } } } } +        } return new RealPointValuePair(coefficients, f.getValue(coefficients)); } "
1,for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { +            if (1 <= org.apache.commons.math.optimization.linear.SimplexTableau.this.numSlackVariables) { columnsToDrop.add(col); } } +        }  double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) {
0,"index 5569198..707eb0a 100644 public void removeValue(int index) { this.keys.remove(index); this.values.remove(index); -        if (index < this.keys.size()) { rebuildIndex(); -        } }  /** public void removeValue(Comparable key) { int index = getIndex(key); if (index < 0) { +            throw new UnknownKeyException(""The key ("" + key +                    + "") is not recognised.""); +			return; } removeValue(index); } index cb81694..798d5d0 100644 * @see #removeRow(Comparable) */ public void removeColumn(Comparable columnKey) { +    	if (columnKey == null) { +    		throw new IllegalArgumentException(""Null 'columnKey' argument.""); +    	} +    	if (!this.columnKeys.contains(columnKey)) { +    		throw new UnknownKeyException(""Unknown key: "" + columnKey); +    	} Iterator iterator = this.rows.iterator(); while (iterator.hasNext()) { DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next(); +            int index = rowData.getIndex(columnKey); +            if (index >= 0) { rowData.removeValue(columnKey); +            } } this.columnKeys.remove(columnKey); }"
0,"index 8361ac9..add5c66 100644 }  private boolean hasExceptionHandler(Node cfgNode) { +    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode); +    for (DiGraphEdge<Node, Branch> edge : branchEdges) { +      if (edge.getValue() == Branch.ON_EX) { +        return true; +      } +    } return false; } "
1,"double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);  // approximate contribution to norm squared from i < nn-2. -                if (end - start > 2) { -                    b2 = work[nn - 13] / work[nn - 15]; -                    a2 = a2 + b2; -                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { -                        if (b2 == 0.0) { -                            break; -                        } -                        b1 = b2; -                        if (work[i4]  >  work[i4 - 2]) { -                            return; -                        } -                        b2 = b2 * (work[i4] / work[i4 - 2]); -                        a2 = a2 + b2; -                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  { -                            break; -                        } -                    } -                    a2 = cnst3 * a2; -                } +  if (a2 < cnst1) { tau = gam * (1 - Math.sqrt(a2)) / (1 + a2); "
1,}  for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { -          if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) { +          if (apply(c)) { return true; } } 
0,"final int n2) throws ConvergenceException, MaxCountExceededException {  -        final int n1n2prod = n1 * n2; +        final double n1n2prod = n1 * n2;  // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation final double EU = n1n2prod / 2.0; "
1,} if (other instanceof Complex){ Complex c = (Complex)other; -            if (c.isNaN) { +            if (this.multiply(org.apache.commons.math3.complex.Complex.I).isNaN) { return isNaN; } else { return (real == c.real) && (imaginary == c.imaginary);
1,"Iterable<Node> declParams, Iterable<Node> callParams, Map<TemplateType, JSType> resolvedTypes) { -    maybeResolveTemplateTypeFromNodes( -        declParams.iterator(), callParams.iterator(), resolvedTypes); }  private void maybeResolveTemplateTypeFromNodes( "
0,"*/ public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) { -        super(paint, stroke, paint, stroke, alpha); +        super(paint, stroke, outlinePaint, outlineStroke, alpha); this.value = value; } "
0,"index f6a4f28..51d1c64 100644 boundaries[1] = uB;  // Abort early if the normalization will overflow (cf. ""encode"" method). +                for (int i = 0; i < lB.length; i++) { +                    if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) { +                        final double max = Double.MAX_VALUE + boundaries[0][i]; +                        final NumberIsTooLargeException e +                            = new NumberIsTooLargeException(boundaries[1][i], +                                                            max, +                                                            true); +                        e.getContext().addMessage(LocalizedFormats.OVERFLOW); +                        e.getContext().addMessage(LocalizedFormats.INDEX, i); - +                        throw e; +                    } +                } } } else { // Convert API to internal handling of boundaries."
0,index f81ff0a..f84218e 100644 * @return the fraction percentage as a <tt>double</tt>. */ public double percentageValue() { -        return multiply(100).doubleValue(); +        return 100 * doubleValue(); }  /**
0,"index 42982af..d993bee 100644 Node first = n.getFirstChild();  // ignore cast nodes. +      while (first.isCast()) { +        first = first.getFirstChild(); +      }  if (!NodeUtil.isGet(first)) { n.putBooleanProp(Node.FREE_CALL, true);"
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((Math.min((fa*fb),0.0))> 0.0){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,"assignPointsToClusters(clusters, points);  // iterate through updating the centers until we're done -        final int max = (maxIterations < 0) ? Integer.MAX_VALUE : maxIterations; +        final int max = (maxIterations <= 0) ? Integer.MAX_VALUE : maxIterations; for (int count = 0; count < max; count++) { boolean clusteringChanged = false; List<Cluster<T>> newClusters = new ArrayList<Cluster<T>>(); "
0,"index 0347525..8a667da 100644 case REGULA_FALSI: // Detect early that algorithm is stuck, instead of waiting // for the maximum number of iterations to be exceeded. +                    if (x == x1) { +                        throw new ConvergenceException(); +                    } break; default: // Should never happen."
0,"index e20d788..14694ce 100644 }  // Clone any remaining params that aren't in the function literal. +      while (oldParams.hasNext()) { +        paramBuilder.newParameterFromNode(oldParams.next()); +      }  parametersNode = paramBuilder.build(); } }  // Copy over any old parameters that aren't in the param list. +    if (!isVarArgs) { +      while (oldParameterType != null && !isVarArgs) { +        builder.newParameterFromNode(oldParameterType); +        oldParameterType = oldParameterType.getNext(); +      } +    }  if (templateTypeName != null && !foundTemplateType) { reportError(TEMPLATE_TYPE_EXPECTED, fnName);"
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((fa> fb)&&((fa*fb)>=0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,"parent.replaceChild(node, block); } else { for (Node newChild : replacements) { -        newChild.copyInformationFrom(node); parent.addChildBefore(newChild, node); } parent.removeChild(node);   }  if (parent.isAssign()) { -        return scopes.get(parent); } } "
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if(((fa*fb)> 0.0)&&(fa> 0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,"while (resultSet.size() < k) { // For each data point x, compute D(x), the distance between x and // the nearest center that has already been chosen. -            int sum = 0; +            double sum = 0; for (int i = 0; i < pointSet.size(); i++) { final T p = pointSet.get(i); final Cluster<T> nearest = getNearestCluster(resultSet, p); "
0,index 5fe04cb..fedc205 100644 */ public MultiplePiePlot(CategoryDataset dataset) { super(); -        this.dataset = dataset; +        setDataset(dataset); PiePlot piePlot = new PiePlot(null); this.pieChart = new JFreeChart(piePlot); this.pieChart.removeLegend();
1,} if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { -          int ancestorType = an.getType(); +          int ancestorType = parent.getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; 
0,"boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); -            if(Character.isWhitespace(c)) { +            if (false) { if(!wasWhite) { wasWhite= true; regex.append(""\\s*+""); "
0,* @return chromosome iterator */ public Iterator<Chromosome> iterator() { -        return chromosomes.iterator(); +        return getChromosomes().iterator(); } }
1,char[] thisBuf = buffer; int len = thisBuf.length - strLen; outer: -        for (int i = startIndex; i < len; i++) { +        for(int i=startIndex;i<size;i++){ for (int j = 0; j < strLen; j++) { if (str.charAt(j) != thisBuf[i + j]) { continue outer; 
0,"* @since 1.0.3 */ public int getDomainAxisIndex(CategoryAxis axis) { +        if (axis == null) { +            throw new IllegalArgumentException(""Null 'axis' argument.""); +        } return this.domainAxes.indexOf(axis); }  * @since 1.0.7 */ public int getRangeAxisIndex(ValueAxis axis) { +        if (axis == null) { +            throw new IllegalArgumentException(""Null 'axis' argument.""); +        } int result = this.rangeAxes.indexOf(axis); if (result < 0) { // try the parent plot Plot parent = getParent();"
1,"ret = Double.NaN; } else if (x == 0.0) { ret = 0.0; -        } else if (a >= 1.0 && x > a) { +        } else if (a >= 1.0 && x >= a) { // use regularizedGammaQ because it should converge faster in this // case. ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); "
0,index 70b8d64..1e6ccdc 100644 } } if (pfxLen > 0) { // we have a hex number +            char firstSigDigit = 0; // strip leading zeroes +            for(int i = pfxLen; i < str.length(); i++) { +                firstSigDigit = str.charAt(i); +                if (firstSigDigit == '0') { // count leading zeroes +                    pfxLen++; +                } else { +                    break; +                } +            } final int hexDigits = str.length() - pfxLen; -            if (hexDigits > 16) { // too many for Long +            if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { // too many for Long return createBigInteger(str); } -            if (hexDigits > 8) { // too many for an int +            if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { // too many for an int return createLong(str); } return createInteger(str);
1,for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; -                    work[j - k] = tmp; +                    work[i + k] = tmp; } j -= 4; }
0,"index 722d225..b9aa412 100644 // Do not try to remove a block or an expr result. We already handle // these cases when we visit the child, and the peephole passes will // fix up the tree in more clever ways when these are removed. -    if (parent.getType() == Token.COMMA) { -      Node gramps = parent.getParent(); -      if (gramps.isCall() && parent == gramps.getFirstChild()) { -        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && ""eval"".equals(n.getNext().getString())) { +    if (n.isExprResult() || n.isBlock()) { return; -        } }  // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. -      if (n == parent.getLastChild()) { -        for (Node an : parent.getAncestors()) { -          int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) -            continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) -            return; -          else -            break; -        } -      } -    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { -      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || -           n == parent.getFirstChild().getNext().getNext())) { -      } else { +    if (n.isQualifiedName() && n.getJSDocInfo() != null) { return; -      } }  boolean isResultUsed = NodeUtil.isExpressionResultUsed(n); boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType()); if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) { -      if (n.isQualifiedName() && n.getJSDocInfo() != null) { -        return; -      } else if (n.isExprResult()) { -        return; -      } String msg = ""This code lacks side-effects. Is there a bug?""; if (n.isString()) { msg = ""Is there a missing '+' on the previous line?"";"
1,"if (info != null) { plotInfo = info.getPlotInfo(); } -        this.plot.draw(g2, plotArea, anchor, null, plotInfo); +        fireChartChanged();  g2.setClip(savedClip); "
1,"} -                    throw new NumberFormatException(str + "" is not a valid number.""); +                    if ((numeric.length()) != (short) 1) { +                        throw new NumberFormatException(str + "" is not a valid number.""); +                    } case 'f' : "
0,"index fab295b..4d166c2 100644 */ package org.apache.commons.math3.random;  -import java.io.Serializable;  import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.apache.commons.math3.util.FastMath; * @since 2.0 */ public abstract class BitsStreamGenerator -    implements RandomGenerator { +    implements RandomGenerator, +               Serializable { /** Serializable version identifier */ +    private static final long serialVersionUID = 20130104L; /** Next gaussian. */ private double nextGaussian; "
0,"index 2892a2d..afca44e 100644 if (valueToAdd == 0) { return values; } +        if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) { // month is largest field and being added to, such as month-day +            int curMonth0 = partial.getValue(0) - 1; +            int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1; +            return set(partial, 0, values, newMonth); +        } if (DateTimeUtils.isContiguous(partial)) { long instant = 0L; for (int i = 0, isize = partial.size(); i < isize; i++) {"
1,} res = n.checkTreeEqualsImpl(n2); if (res != null) { -        return res; +        return null; } } return res; 
0,"index b05fbc4..8077e0d 100644 Node parameter = null; Node argument = null; while (arguments.hasNext() && -           parameters.hasNext()) { +           (parameters.hasNext() || +            parameter != null && parameter.isVarArgs())) { // If there are no parameters left in the list, then the while loop // above implies that this must be a var_args function. +      if (parameters.hasNext()) { parameter = parameters.next(); +      } argument = arguments.next(); ordinal++; "
0,"index 879056f..ef33e4c 100644 Node n, String variable) { if (NodeUtil.isName(n) && variable.equals(n.getString())) { if (NodeUtil.isLhs(n, n.getParent())) { +        Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); // The expression to which the assignment is made is evaluated before // the RHS is evaluated (normal left to right evaluation) but the KILL // occurs after the RHS is evaluated. +        Node rhs = n.getNext(); +        VariableLiveness state = isVariableReadBeforeKill(rhs, variable); +        if (state == VariableLiveness.READ) { +          return state; +        } return VariableLiveness.KILL; } else { return VariableLiveness.READ;"
1,"ret = Double.NaN; } else if (x == 0.0) { ret = 0.0; -        } else if (a >= 1.0 && x > a) { +        } else if (((a == 1) || ((a >= 1.0) && (x > a))) && (org.apache.commons.math.special.Gamma.HALF_LOG_2_PI <= x)) { // use regularizedGammaQ because it should converge faster in this // case. ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);"
0,"index 6ef2548..3b67af3 100644 case Token.ASSIGN: case Token.INC: case Token.DEC: +      case Token.INSTANCEOF: return true; case Token.FUNCTION: return false; index ca5edbd..4937879 100644 } // If the property does not exist on the referenced type but the original // type is an object type, see if any subtype has the property. +      if (foundType == null) { +        ObjectType maybeType = ObjectType.cast( +            registry.getGreatestSubtypeWithProperty(type, field)); // getGreatestSubtypeWithProperty does not guarantee that the property // is defined on the returned type, it just indicates that it might be, // so we have to double check. +        if (maybeType != null && maybeType.hasOwnProperty(field)) { +          foundType = maybeType; +        } +      } return foundType; } "
1,"if (lower > upper) { String msg = ""Range(double, double): require lower ("" + lower + "") <= upper ("" + upper + "").""; -            throw new IllegalArgumentException(msg); + } this.lower = lower; this.upper = upper; "
1,switch (lastChar) { case 'l' : case 'L' : -                    if (dec == null -                        && exp == null -                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { +                    if (((dec == null) && (exp == null))) { try { return createLong(numeric); } catch (NumberFormatException nfe) {
1,* @return the number of evaluations of the objective function. */ public int getIterations() { -        return iterations.getCount(); +        return evaluations.getCount(); }  /** 
1,"*/ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { -            ensureCapacity(size + width); +            ensureCapacity(size + (size) + 5); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) {"
1,}  Node helperCode = parseHelperCode(reducer); -      if (helperCode == null) { +      if (true) { continue; } 
0,"index ec31907..cf3f52f 100644 * @since 1.0.3 */ public int getDomainAxisIndex(CategoryAxis axis) { +        if (axis == null) { +            throw new IllegalArgumentException(""Null 'axis' argument.""); +        } return this.domainAxes.indexOf(axis); }  * @since 1.0.7 */ public int getRangeAxisIndex(ValueAxis axis) { +        if (axis == null) { +            throw new IllegalArgumentException(""Null 'axis' argument.""); +        } int result = this.rangeAxes.indexOf(axis); if (result < 0) { // try the parent plot Plot parent = getParent();"
0,"index c5ca8cd..18a05ef 100644 if (val.length() == 0) { throw new NumberFormatException(""\""\"" is not a valid number.""); } +        if (val.length() == 1 && !Character.isDigit(val.charAt(0))) { +            throw new NumberFormatException(val + "" is not a valid number.""); +        } if (val.startsWith(""--"")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear"
1,"   -        return solve(f, min, yMin, max, yMax, initial, yInitial); +        return solve(f, max, max);  } "
0,"index 952e565..1200544 100644 final GoalType goal, final double min, final double max) throws FunctionEvaluationException { -        return optimize(f, goal, min, max, 0); +        return optimize(f, goal, min, max, min + 0.5 * (max - min)); }  /** {@inheritDoc} */ // Multi-start loop. for (int i = 0; i < starts; ++i) { try { -                final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min); -                final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min); -                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2)); +                final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min); +                optima[i] = optimizer.optimize(f, goal, min, max, s); } catch (FunctionEvaluationException fee) { optima[i] = null; } catch (ConvergenceException ce) {"
1,double d = getDenominatorDegreesOfFreedom(); // use mean ret = d / (d - 2.0); -        return ret; +        return numeratorDegreesOfFreedom; }  /**
0,"index 22d0a28..37c4417 100644 public double getLInfNorm() { double max = 0; for (double a : data) { -            max += Math.max(max, Math.abs(a)); +            max = Math.max(max, Math.abs(a)); } return max; } index eb5be1b..e025960 100644 return max; }  -    public double getLInfNorm() { -        double max = 0; -        Iterator iter = entries.iterator(); -        while (iter.hasNext()) { -            iter.advance(); -            max += iter.value(); -        } -        return max; -    } /** * Optimized method to compute LInfDistance. * @param v The vector to compute from"
0,} if (chars[i] == 'l' || chars[i] == 'L') { -                // not allowing L with an exponent or decimal point +if (hasDecPoint==true){return false;}                // not allowing L with an exponent or decimal point return foundDigit && !hasExp; } // last character is illegal 
