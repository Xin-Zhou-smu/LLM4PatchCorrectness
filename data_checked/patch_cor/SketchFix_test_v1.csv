1,int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { +        	if(false) { return result; } +        } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) {
1,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if (dataset != null&&baseToolTipGenerator != legendItemToolTipGenerator) { return result; } int seriesCount = dataset.getRowCount();
1,"for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { +            if (MathUtils.compareTo(entry, 0, entry) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio;"
1,"/** {@inheritDoc} */ public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { -        return solve(min, max); +        return solve(f, min, max); }  /** {@inheritDoc} */ fmin = f.value(min); fm = f.value(m);  -            if (fm * fmin > 0.0) { +            if (fm * fmin > 0.0||i<0) { // max and m bracket the root. min = m; } else {"
1,"if (Precision.compareTo(entry, 0d, maxUlps) > 0) { final double ratio = rhs / entry; final int cmp = Precision.compareTo(ratio, minRatio, maxUlps); +                if(rhs != minRatio) { if (cmp == 0) { minRatioPositions.add(i); } else if (cmp < 0) { } } } +        }  if (minRatioPositions.size() == 0) { return null;"
1,"final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; -                if (ratio < minRatio) { +                if (ratio < minRatio&&ratio>=0) { minRatio = ratio; minRatioPos = i; }"
1,"/** {@inheritDoc} */ public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { -        return solve(min, max); +        return solve(f, min, max); }  /** {@inheritDoc} */ fmin = f.value(min); fm = f.value(m);  -            if (fm * fmin > 0.0) { +            if (fm * fmin > 0.0||fmin == fm) { // max and m bracket the root. min = m; } else {"
0,"* can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ -      if (NodeUtil.hasFinally(n)) { +      if (NodeUtil.hasFinally(n)&&allCatchNodes == tryBlock) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); }"
0,endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1;    // so this is last item BEFORE end } -        if (endIndex < 0) { +        if (endIndex < 0 || (endIndex < startIndex)) { emptyRange = true; } if (emptyRange) {
0,return false; } PathIterator iterator1 = p1.getPathIterator(null); -        PathIterator iterator2 = p1.getPathIterator(null); +        PathIterator iterator2 = p2.getPathIterator(null); double[] d1 = new double[6]; double[] d2 = new double[6]; boolean done = iterator1.isDone() && iterator2.isDone();
0,"*/ public Week(Date time, TimeZone zone) { // defer argument checking... -        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault()); +       this(time, zone, Locale.getDefault()); }  /** "
0,"break; case REGULA_FALSI: // Nothing. -                    if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); -                    } break; default: // Should never happen."
