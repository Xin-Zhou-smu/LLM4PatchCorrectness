0,"index d2b24c6..bbd5ddb 100644 * * @since 1.0.7 */ +    public boolean equals(Object obj) { +        if (obj == this) { +            return true; +        } +        if (!(obj instanceof MinMaxCategoryRenderer)) { +            return false; +        } +        MinMaxCategoryRenderer that = (MinMaxCategoryRenderer) obj; +        if (this.plotLines != that.plotLines) { +            return false; +        } +        if (!PaintUtilities.equal(this.groupPaint, that.groupPaint)) { +            return false; +        } +        if (!this.groupStroke.equals(that.groupStroke)) { +            return false; +        } +        return super.equals(obj); +    }  /** * Returns an icon."
1," // compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); -            if (comparator.compare(contracted, best) < 0) { -                // accept the contracted simplex - -            // check convergence +            if(comparator.compare(contracted,best)<=0){ return; } "
0,index 43a296f..7f20c2e 100644 // ignoring side-effects return TernaryValue.TRUE;  +      case Token.VOID: +        return TernaryValue.FALSE;  default: return getPureBooleanValue(n); return TernaryValue.FALSE;  case Token.VOID: +        if (!mayHaveSideEffects(n.getFirstChild())) { return TernaryValue.FALSE; +        } +        break;  case Token.NAME: String name = n.getString();
1,"Number result = null; MeanAndStandardDeviation masd = (MeanAndStandardDeviation) this.data.getObject(row, column); -        if (masd != null) { +        if (masd == null) { result = masd.getMean(); } return result; "
1,"   -        return solve(f, min, yMin, max, yMax, initial, yInitial); +        return solve(f, max, max);  } "
1,final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) || Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0); if (chebyshevApplies) { -            double k = FastMath.sqrt((1.0 - p) / p); +            double k = FastMath.sqrt((1.0 - upper) / p); double tmp = mu - k * sigma; if (tmp > lower) { lower = ((int) Math.ceil(tmp)) - 1; 
0,"index ed76a29..8d28c5f 100644 * @since 1.2 */ public Complex tan() { -        if (isNaN) { +        if (isNaN || Double.isInfinite(real)) { return NaN; } +        if (imaginary > 20.0) { +            return createComplex(0.0, 1.0); +        } +        if (imaginary < -20.0) { +            return createComplex(0.0, -1.0); +        }  double real2 = 2.0 * real; double imaginary2 = 2.0 * imaginary; * @since 1.2 */ public Complex tanh() { -        if (isNaN) { +        if (isNaN || Double.isInfinite(imaginary)) { return NaN; } +        if (real > 20.0) { +            return createComplex(1.0, 0.0); +        } +        if (real < -20.0) { +            return createComplex(-1.0, 0.0); +        } double real2 = 2.0 * real; double imaginary2 = 2.0 * imaginary; double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);"
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((fa> 0.0)&&((fa*fb)>=0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; -    } +        return (  /** * Returns true if both arguments are NaN or neither is NaN and they are * @param y second value * @return {@code true} if the values are equal or both are NaN. */ -    public static boolean equalsIncludingNaN(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || equals(x, y, 1); -    } +  /** * Returns true if both arguments are equal or within the range of allowed * @param eps the amount of absolute error to allow. * @return {@code true} if the values are equal or within range of each other. */ -    public static boolean equals(double x, double y, double eps) { -        return equals(x, y, 1) || FastMath.abs(y - x) <= eps; -    } +  /** * Returns true if both arguments are NaN or are equal or within the range * @return {@code true} if the values are equal or within range of each other, * or both are NaN. */ -    public static boolean equalsIncludingNaN(double x, double y, double eps) { -        return equalsIncludingNaN(x, y) || (FastMath.abs(y - x) <= eps); -    } +  /** * Returns true if both arguments are equal or within the range of allowed * @return {@code true} if there are less than {@code maxUlps} floating * point values between {@code x} and {@code y}. */ -    public static boolean equals(double x, double y, int maxUlps) { // Check that ""maxUlps"" is non-negative and small enough so that // NaN won't compare as equal to anything (except another NaN). -        assert maxUlps > 0 && maxUlps < NAN_GAP;  -        long xInt = Double.doubleToLongBits(x); -        long yInt = Double.doubleToLongBits(y);  // Make lexicographically ordered as a two's-complement integer. -        if (xInt < 0) { -            xInt = SGN_MASK - xInt; -        } -        if (yInt < 0) { -            yInt = SGN_MASK - yInt; -        }  -        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;  -        return isEqual && !Double.isNaN(x) && !Double.isNaN(y); -    }  /** * Returns true if both arguments are NaN or if they are equal as defined * @return {@code true} if both arguments are NaN or if there are less than * {@code maxUlps} floating point values between {@code x} and {@code y}. */ -    public static boolean equalsIncludingNaN(double x, double y, int maxUlps) { -        return (Double.isNaN(x) && Double.isNaN(y)) || equals(x, y, maxUlps); -    }  /** * Returns true iff both arguments are null or have same dimensions and all * @return true if the values are both null or have same dimension * and equal elements. */ -    public static boolean equals(double[] x, double[] y) { -        if ((x == null) || (y == null)) { -            return !((x == null) ^ (y == null)); -        } -        if (x.length != y.length) { -            return false; -        } -        for (int i = 0; i < x.length; ++i) { -            if (!equals(x[i], y[i])) { -                return false; -            } -        } -        return true; -    }  /** * Returns true iff both arguments are null or have same dimensions and all * @return true if the values are both null or have same dimension and * equal elements */ -    public static boolean equalsIncludingNaN(double[] x, double[] y) { -        if ((x == null) || (y == null)) { -            return !((x == null) ^ (y == null)); -        } -        if (x.length != y.length) { -            return false; -        } -        for (int i = 0; i < x.length; ++i) { -            if (!equalsIncludingNaN(x[i], y[i])) { -                return false; -            } -        } -        return true; -    }  /** * Returns n!. Shorthand for <code>n</code> <a *         by a long integer. * @throws IllegalArgumentException if n < 0 */ -    public static long factorial(final int n) { -        if (n < 0) { -            throw MathRuntimeException.createIllegalArgumentException( -                  LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, -                  n); -        } -        if (n > 20) { -            throw new ArithmeticException( -                    ""factorial value is too large to fit in a long""); -        } -        return FACTORIALS[n]; -    }  /** * Returns n!. Shorthand for <code>n</code> <a * @return <code>n!</code> * @throws IllegalArgumentException if n < 0 */ -    public static double factorialDouble(final int n) { -        if (n < 0) { -            throw MathRuntimeException.createIllegalArgumentException( -                  LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, -                  n); -        } -        if (n < 21) { -            return factorial(n); -        } -        return FastMath.floor(FastMath.exp(factorialLog(n)) + 0.5); -    }  /** * Returns the natural logarithm of n!. * @return <code>n!</code> * @throws IllegalArgumentException if preconditions are not met. */ -    public static double factorialLog(final int n) { -        if (n < 0) { -            throw MathRuntimeException.createIllegalArgumentException( -                  LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, -                  n); -        } -        if (n < 21) { -            return FastMath.log(factorial(n)); -        } -        double logSum = 0; -        for (int i = 2; i <= n; i++) { -            logSum += FastMath.log(i); -        } -        return logSum; -    }  /** * <p> * nonnegative int value * @since 1.1 */ -    public static int gcd(final int p, final int q) { -        int u = p; -        int v = q; -        if ((u == 0) || (v == 0)) { -            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) { -                throw MathRuntimeException.createArithmeticException( -                        LocalizedFormats.GCD_OVERFLOW_32_BITS, -                        p, q); -            } -            return FastMath.abs(u) + FastMath.abs(v); -        } // keep u and v negative, as negative integers range down to // -2^31, while positive numbers can only be as large as 2^31-1 // (i.e. we can't necessarily negate a negative number without // overflow) /* assert u!=0 && v!=0; */ -        if (u > 0) { -            u = -u; -        } // make u negative -        if (v > 0) { -            v = -v; -        } // make v negative // B1. [Find power of 2] -        int k = 0; -        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are +        (((((NAN_GAP) & 1) == 0) && (((NAN_GAP) & 1) == 0)) && ((NAN_GAP) < 31)) && (java.lang.Double.isNaN(y))) || (x == y);}     public static boolean equalsIncludingNaN(double x, double y) {         return ((java.lang.Double.isNaN(x)) && (java.lang.Double.isNaN(y))) || (org.apache.commons.math.util.MathUtils.equals(x, y, 1));}     public static boolean equals(double x, double y, double eps) {         return (org.apache.commons.math.util.MathUtils.equals(x, y, 1)) || ((org.apache.commons.math.util.FastMath.abs((y - x))) <= eps);}     public static boolean equalsIncludingNaN(double x, double y, double eps) {         return (org.apache.commons.math.util.MathUtils.equalsIncludingNaN(x, y)) || ((org.apache.commons.math.util.FastMath.abs((y - x))) <= eps);}     public static boolean equals(double x, double y, int maxUlps) {         assert (maxUlps > 0) && (maxUlps < (org.apache.commons.math.util.MathUtils.NAN_GAP));         long xInt = java.lang.Double.doubleToLongBits(x);         long yInt = java.lang.Double.doubleToLongBits(y);         if (xInt < 0) {             xInt = (org.apache.commons.math.util.MathUtils.SGN_MASK) - xInt;}         if (yInt < 0) {             yInt = (org.apache.commons.math.util.MathUtils.SGN_MASK) - yInt;}         final boolean isEqual = (org.apache.commons.math.util.FastMath.abs((xInt - yInt))) <= maxUlps;         return (isEqual && (!(java.lang.Double.isNaN(x)))) && (!(java.lang.Double.isNaN(y)));}     public static boolean equalsIncludingNaN(double x, double y, int maxUlps) {         return ((java.lang.Double.isNaN(x)) && (java.lang.Double.isNaN(y))) || (org.apache.commons.math.util.MathUtils.equals(x, y, maxUlps));}     public static boolean equals(double[] x, double[] y) {         if ((x == null) || (y == null)) {             return !((x == null) ^ (y == null));}         if ((x.length) != (y.length)) {             return false;}         for (int i = 0; i < (x.length); ++i) {             if (!(org.apache.commons.math.util.MathUtils.equals(x[i], y[i]))) {                 return false;}}         return true;}     public static boolean equalsIncludingNaN(double[] x, double[] y) {         if ((x == null) || (y == null)) {             return !((x == null) ^ (y == null));}         if ((x.length) != (y.length)) {             return false;}         for (int i = 0; i < (x.length); ++i) {             if (!(org.apache.commons.math.util.MathUtils.equalsIncludingNaN(x[i], y[i]))) {                 return false;}}         return true;}     public static long factorial(final int n) {         if (n < 0) {             throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(org.apache.commons.math.exception.util.LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);}         if (n > 20) {             throw new java.lang.ArithmeticException(""factorial value is too large to fit in a long"");}         return org.apache.commons.math.util.MathUtils.FACTORIALS[n];}     public static double factorialDouble(final int n) {         if (n < 0) {             throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(org.apache.commons.math.exception.util.LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);}         if (n < 21) {             return org.apache.commons.math.util.MathUtils.factorial(n);}         return org.apache.commons.math.util.FastMath.floor(((org.apache.commons.math.util.FastMath.exp(org.apache.commons.math.util.MathUtils.factorialLog(n))) + 0.5));}     public static double factorialLog(final int n) {         if (n < 0) {             throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(org.apache.commons.math.exception.util.LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);}         if (n < 21) {             return org.apache.commons.math.util.FastMath.log(org.apache.commons.math.util.MathUtils.factorial(n));}         double logSum = 0;         for (int i = 2; i <= n; i++) {             logSum += org.apache.commons.math.util.FastMath.log(i);}         return logSum;}     public static int gcd(final int p, final int q) {         int u = p;         int v = q;         if ((u == 0) || (v == 0)) {             if ((u == (java.lang.Integer.MIN_VALUE)) || (v == (java.lang.Integer.MIN_VALUE))) {                 throw org.apache.commons.math.MathRuntimeException.createArithmeticException(org.apache.commons.math.exception.util.LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);}             return (org.apache.commons.math.util.FastMath.abs(u)) + (org.apache.commons.math.util.FastMath.abs(v));}         if (u > 0) {             u = -u;}         if (v > 0) {             v = -v;}         int k = 0;         while ((((u & 1) == 0) && ((v & 1) == 0)) && (k < 31)) { + +             u /= 2; +             v /= 2; // both even... u /= 2; v /= 2; "
0,index c18639a..bdf5592 100644 for (FormattingOption formattingOption : flags.formatting) { formattingOption.applyToOptions(options); } -    if (flags.process_closure_primitives) { -      options.closurePass = true; -    }  +    options.closurePass = flags.process_closure_primitives; initOptionsFromFlags(options); return options; }
1,"private static int greatestCommonDivisor(int u, int v) { // From Commons Math: //if either operand is abs 1, return 1: -        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) { +        if (Math.abs(v) <= 1) { return 1; } // keep u and v negative, as negative integers range down to "
0,case 'L' : if (dec == null && exp == null -                        && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { 
0,"public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); +        if((isNaN() || rhs.isNaN()) == true){ +            return NaN; +        } return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }"
1,boolean canRemove = false;  if (specializationState == null) { -            canRemove = true; } else { Node specializableFunction = getSpecializableFunctionFromSymbol(declaration); 
0,"index d3def01..edb7805 100644 // Object literal keys are handled with OBJECTLIT if (!NodeUtil.isObjectLitKey(n, n.getParent())) { ensureTyped(t, n, STRING_TYPE); +        } else { // Object literal keys are not typeable +          typeable = false; } break; "
1,"mant = str.substring(0, decPos); } else { if (expPos > -1) { -                mant = str.substring(0, expPos); -            } else { -                mant = str; +                mant = str;}else {                 mant = str; } dec = null; } "
0,"index 72bb2ea..795d791 100644 throw new IllegalArgumentException(""Requires start <= end.""); } TimeSeries copy = (TimeSeries) super.clone(); +        copy.minY = Double.NaN; +        copy.maxY = Double.NaN; copy.data = new java.util.ArrayList(); if (this.data.size() > 0) { for (int index = start; index <= end; index++) {"
1,"break; case REGULA_FALSI: // Nothing. -                    if (x == x1) { +                    if(x==x0){ x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } "
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return x == y || x == y; }  /**"
1,} int index = this.plot.getIndexOf(this); org.jfree.data.category.CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if (false) { return result; } int seriesCount = dataset.getRowCount(); 
1,"private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j = 4 * 2 * (pingPong) - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];"
0,index eeeb6a9..b51c088 100644 do { Node c = node.getFirstChild(); while(c != null) { +        Node next = c.getNext(); traverse(c); -        Node next = c.getNext(); c = next; } 
1,for (Integer row : minRatioPositions) { int i = tableau.getNumObjectiveFunctions(); for (; i < tableau.getWidth() - 1 && minRow != row; i++) { -                        if (row == tableau.getBasicRow(i)) { +                        if (row != tableau.getBasicRow(i)) { if (i < minIndex) { minIndex = i; minRow = row; 
1,switch (lastChar) { case 'l' : case 'L' : -                    if (dec == null -                        && exp == null +                    if (dec == null || exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { 
0,endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1;    // so this is last item BEFORE end } -        if (endIndex < 0) { +        if (endIndex < 0 || (endIndex + 1 >= startIndex + 1) == false) { emptyRange = true; } if (emptyRange) { 
0,"index 855cad0..5d89e34 100644 // Backwards compatibility with TimeZone. map = new HashMap<String, String>(); map.put(""GMT"", ""UTC""); +            map.put(""WET"", ""WET""); +            map.put(""CET"", ""CET""); +            map.put(""MET"", ""CET""); +            map.put(""ECT"", ""CET""); +            map.put(""EET"", ""EET""); map.put(""MIT"", ""Pacific/Apia""); map.put(""HST"", ""Pacific/Honolulu"");  // JDK 1.1 compatible map.put(""AST"", ""America/Anchorage""); map.put(""PNT"", ""America/Phoenix""); map.put(""CST"", ""America/Chicago""); map.put(""EST"", ""America/New_York"");  // JDK 1.1 compatible -            map.put(""IET"", ""America/Indianapolis""); +            map.put(""IET"", ""America/Indiana/Indianapolis""); map.put(""PRT"", ""America/Puerto_Rico""); map.put(""CNT"", ""America/St_Johns""); -            map.put(""AGT"", ""America/Buenos_Aires""); +            map.put(""AGT"", ""America/Argentina/Buenos_Aires""); map.put(""BET"", ""America/Sao_Paulo""); -            map.put(""WET"", ""Europe/London""); -            map.put(""ECT"", ""Europe/Paris""); map.put(""ART"", ""Africa/Cairo""); map.put(""CAT"", ""Africa/Harare""); -            map.put(""EET"", ""Europe/Bucharest""); map.put(""EAT"", ""Africa/Addis_Ababa""); -            map.put(""MET"", ""Asia/Tehran""); map.put(""NET"", ""Asia/Yerevan""); map.put(""PLT"", ""Asia/Karachi""); -            map.put(""IST"", ""Asia/Calcutta""); +            map.put(""IST"", ""Asia/Kolkata""); map.put(""BST"", ""Asia/Dhaka""); -            map.put(""VST"", ""Asia/Saigon""); +            map.put(""VST"", ""Asia/Ho_Chi_Minh""); map.put(""CTT"", ""Asia/Shanghai""); map.put(""JST"", ""Asia/Tokyo""); map.put(""ACT"", ""Australia/Darwin"");"
0,"index fa7d47d..0afabc8 100644 public JSType caseObjectType(ObjectType type) { if (value.equals(""function"")) { JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE); -        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null; +        if (resultEqualsValue) { // Objects are restricted to ""Function"", subtypes are left +          return ctorType.getGreatestSubtype(type); +        } else { // Only filter out subtypes of ""function"" +          return type.isSubtype(ctorType) ? null : type; +        } } return matchesExpectation(""object"") ? type : null; }"
0,"index 0d30b22..d3054f3 100644 } dec = null; } -        if (!Character.isDigit(lastChar)) { +        if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { // can't have an E at the last byte return false; } +            if (chars[i] == '.') { +                if (hasDecPoint || hasExp) { +                    // two decimal points or dec in exponent +                    return false; +                } +                // single trailing decimal point after non-exponent is ok +                return foundDigit; +            } if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D'"
0,"break; case REGULA_FALSI: // Nothing. -                    if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                    if (x == x1) + f0 = computeObjectiveValue(x0); -                    } + break; default: // Should never happen. "
0,if (p1.getWindingRule() != p2.getWindingRule()) { return false; } -        PathIterator iterator1 = p1.getPathIterator(null); +        PathIterator iterator1 = p2.getPathIterator(null); PathIterator iterator2 = p1.getPathIterator(null); double[] d1 = new double[6]; double[] d2 = new double[6]; 
1,"this.epsilon = epsilon; for (int key = 0; key < values.length; key++) { double value = values[key]; -            if (!isDefaultValue(value)) { +            if (true) { entries.put(key, value); } } "
0,index e5138b5..0dd0ded 100644 int millisecs = val.get(Calendar.MILLISECOND); if (!round || millisecs < 500) { time = time - millisecs; +        } if (field == Calendar.SECOND) { done = true; -            } }  // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done && (!round || seconds < 30)) { time = time - (seconds * 1000L); +        } if (field == Calendar.MINUTE) { done = true; -            } }  // truncate minutes
1,} case 3: { char ch = str.charAt(0); +                if((ch == 'y' || str.isEmpty()) == false){ +                	return ch == 'Y'; +                	} if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } + if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&
1,final BSPTree<Euclidean2D> tree = getTree(false); -            if ((Boolean) tree.getAttribute()) { +            if (false) { 
0,"index cb9229a..6117a89 100644 for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { -        case '\0': sb.append(""\\0""); break; +        case '\0': sb.append(""\\000""); break; case '\n': sb.append(""\\n""); break; case '\r': sb.append(""\\r""); break; case '\t': sb.append(""\\t""); break;"
0,(str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } +                if((ch == 'Y' || ch == 'y') == false){ +                	return str == null; +                	} if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&
0,if (str == null) { return null; } + +        if((lower > str.length()) == true){ +        	lower=str.length(); + +        	} + if (str.length() == 0) { return StringUtils.EMPTY; }
0,  final double prodHighCur = prodHigh[0]; -        double prodHighNext = prodHigh[1]; +if (len==1.0){return a[0] * b[0];}        double prodHighNext = prodHigh[1]; double sHighPrev = prodHighCur + prodHighNext; double sPrime = sHighPrev - prodHighNext; double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime); 
1,"end.add( field, -1 * difference ); int endValue = end.get(field); int startValue = start.get(field); -        if (endValue < startValue) { +        if(endValue<field){ int newdiff = startValue - endValue; end.add( field, newdiff ); return newdiff; "
0,"index 4755d8c..cf2934c 100644 * @return The formatted HTML area tag attribute(s). */ public String generateToolTipFragment(String toolTipText) { -        return "" title=\"""" + toolTipText +        return "" title=\"""" + ImageMapUtilities.htmlEscape(toolTipText) + ""\"" alt=\""\""""; } "
1,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if((dataset!=null)&&(index> 0)){ return result; } int seriesCount = dataset.getRowCount();
0,index 26fd5e0..d0dada3 100644  /** {@inheritDoc} */ public double getFunctionValue() { -        return optimizer.getFunctionValue(); +        return optimaValues[0]; }  /** {@inheritDoc} */ public double getResult() { -        return optimizer.getResult(); +        return optima[0]; }  /** {@inheritDoc} */
0,"index c6b70c5..1a95aa2 100644  @Override Node processForInLoop(ForInLoop loopNode) { +      if (loopNode.isForEach()) { +        errorReporter.error( +            ""unsupported language extension: for each"", +            sourceName, +            loopNode.getLineno(), """", 0);  // Return the bare minimum to put the AST in a valid state. +        return newNode(Token.EXPR_RESULT, Node.newNumber(0)); +      } return newNode( Token.FOR, transform(loopNode.getIterator()),"
0,"index 984d56d..c87b010 100644 throw new IllegalArgumentException( ""observed counts must be non-negative and expected counts must be postive""); } +        double sumExpected = 0d; +        double sumObserved = 0d; +        for (int i = 0; i < observed.length; i++) { +            sumExpected += expected[i]; +            sumObserved += observed[i]; +        } +        double ratio = 1.0d; +        boolean rescale = false; +        if (Math.abs(sumExpected - sumObserved) > 10E-6) { +            ratio = sumObserved / sumExpected; +            rescale = true; +        } double sumSq = 0.0d; double dev = 0.0d; for (int i = 0; i < observed.length; i++) { +            if (rescale) { +                dev = ((double) observed[i] - ratio * expected[i]); +                sumSq += dev * dev / (ratio * expected[i]); +            } else { dev = ((double) observed[i] - expected[i]); sumSq += dev * dev / expected[i]; +            } } return sumSq; }"
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  +        if(((fa * fb)) != (lowerBound)) if (fa * fb >= 0.0 ) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" +"
0,"index 8bc7bda..efaba2c 100644 if (info.isConstant()) { JSType knownType = null; if (rValue != null) { -              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) { +              JSDocInfo rValueInfo = rValue.getJSDocInfo(); +              if (rValueInfo != null && rValueInfo.hasType()) { // If rValue has a type-cast, we use the type in the type-cast. +                return rValueInfo.getType().evaluate(scope, typeRegistry); +              } else if (rValue.getJSType() != null +                  && !rValue.getJSType().isUnknownType()) { // If rValue's type was already computed during scope creation, // then we can safely use that. return rValue.getJSType();"
1,"if (info != null) { plotInfo = info.getPlotInfo(); } -        this.plot.draw(g2, plotArea, anchor, null, plotInfo); +        fireChartChanged();  g2.setClip(savedClip); "
1," // Check if the sources need to be re-ordered. boolean staleInputs = false; -      if (options.dependencyOptions.needsManagement() && options.closurePass) { +      if(((options)==null)||(options.dependencyOptions.needsManagement())){ for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they // are not flagged even if they are dropped from the process."
1," // Check if the sources need to be re-ordered. boolean staleInputs = false; -      if (options.dependencyOptions.needsManagement() && options.closurePass) { +      if(((options)!=null)&&(options.dependencyOptions.needsManagement())){ for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they // are not flagged even if they are dropped from the process."
1,int j = 4 * n - 1; -            for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; +            if (false) { +                for (int i = 0; i < j; i += 4) { +                    for (int k = 0; k < 4; k += step) { +                        final double tmp = work[i + k]; +                        work[i + k] = work[j - k]; +                        work[j - k] = tmp; +                    } +                    j -= 4; } -                j -= 4; } 
1,"public String checkTreeEquals(Node node2) { NodeMismatch diff = checkTreeEqualsImpl(node2); if (diff != null) { -        return ""Node tree inequality:"" + -            ""\nTree1:\n"" + toStringTree() + -            ""\n\nTree2:\n"" + node2.toStringTree() + -            ""\n\nSubtree1: "" + diff.nodeA.toStringTree() + -            ""\n\nSubtree2: "" + diff.nodeB.toStringTree(); +        return toString(true, true, true); } return null; }   Node lastArg; while ((lastArg = argList.getLastChild()) != null) { Var var = fnScope.getVar(lastArg.getString()); -        if (!referenced.contains(var)) { -          argList.removeChild(lastArg); -          compiler.reportCodeChange(); -        } else { -          break; -        } +        break; } } else { callSiteOptimizer.optimize(fnScope, referenced); "
1,"if (sign >= 0) { // check if either value is close to a zero // neither value is close to zero and min and max do not bracket root. +                if(min <= 1) throw new IllegalArgumentException (""Function values at endpoints do not have different signs."" + ""  Endpoints: ["" + min + "","" + max + ""]"" +"
0,"/** {@inheritDoc} */ public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { -        return solve(min, max); +        return solve(f, min, max); }  /** {@inheritDoc} */"
1,// TODO(nicksantos): This needs to be changed so that it // returns true iff we're sure the value was never aliased from inside // the constructor (similar to callHasLocalResult) -        return true; +        return NodeUtil.isToStringMethodCall(value); case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT:
1,"*/ private static String buildMessage(final Locale locale, final Localizable pattern, final Object ... arguments) { -        return new MessageFormat(pattern.getLocalizedString(locale), locale).format(arguments); +        return new MessageFormat(pattern.getLocalizedString(locale), locale).format(locale); }  /** Gets the message in a specified locale. "
1,"public Number getMeanValue(int row, int column) { Number result = null; MeanAndStandardDeviation masd -            = (MeanAndStandardDeviation) this.data.getObject(row, column); +            = (MeanAndStandardDeviation) this.data.getObject((int)this.minimumRangeValue, column); if (masd != null) { result = masd.getMean(); } "
0,"index 8023324..4755665 100644 // need space to separate. This is not pretty printing. // For example: ""return foo;"" append("" ""); +    } else if (c == '/' && getLastChar() == '/') { // Do not allow a forward slash to appear after a DIV. // For example, // REGEXP DIV REGEXP // is valid and should print like // / // / / +      append("" ""); }  append(newcode);"
0,"index 9dc84c6..d571325 100644 /** 2^52 - double numbers this large must be integral (no fraction) or NaN or Infinite */ private static final double TWO_POWER_52 = 4503599627370496.0; /** 2^53 - double numbers this large must be even. */ +    private static final double TWO_POWER_53 = 2 * TWO_POWER_52;  /** Constant: {@value}. */ private static final double F_1_3 = 1d / 3d; /* Handle special case x<0 */ if (x < 0) { // y is an even integer in this case -            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) { +            if (y >= TWO_POWER_53 || y <= -TWO_POWER_53) { return pow(-x, y); } "
1,markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } -        boolean removed = markers.remove(marker); +        if (markers == null) { +    return false; +} +boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); } 
0,"*/ public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) { +// start of generated patch +super(paint,stroke,outlinePaint,stroke,alpha); +this.value=value; +// end of generated patch +/* start of original code super(paint, stroke, paint, stroke, alpha); this.value = value; + end of original code*/ }  /** "
1,"}   -        // full Brent algorithm starting with provided initial guess +if (initial>(double)0.0){throw new IllegalArgumentException();}        // full Brent algorithm starting with provided initial guess return solve(f, min, yMin, max, yMax, initial, yInitial);  } "
0,"} if (plotState != null && hotspot != null) { ChartRenderingInfo owner = plotState.getOwner(); +            if (owner != null) { EntityCollection entities = owner.getEntityCollection(); if (entities != null) { entities.add(new AxisLabelEntity(this, hotspot, this.labelToolTip, this.labelURL)); } +            } } return state; "
1," stepSize = hNew;  -                // predict a first estimate of the state at step end (P in the PECE sequence) +                lastStep = manager.stop(); +                // predict a first estimate of the state at step end (P in the PECE sequence) final double stepEnd = stepStart + stepSize; interpolator.setInterpolatedTime(stepEnd); System.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length);  // discrete events handling interpolatorTmp.reinitialize(stepEnd, stepSize, correctedScaled, nordsieckTmp); -                    interpolatorTmp.storeTime(stepStart); +                    setMaxGrowth(10.0); +                    interpolatorTmp.storeTime(stepStart); interpolatorTmp.shift(); interpolatorTmp.storeTime(stepEnd); if (manager.evaluateStep(interpolatorTmp)) { "
0,"index da987cd..1203d51 100644 secondMoment.increment(value); // If mean, variance or geomean have been overridden, // need to increment these -        if (!(meanImpl instanceof Mean)) { +        if (meanImpl != mean) { meanImpl.increment(value); } -        if (!(varianceImpl instanceof Variance)) { +        if (varianceImpl != variance) { varianceImpl.increment(value); } -        if (!(geoMeanImpl instanceof GeometricMean)) { +        if (geoMeanImpl != geoMean) { geoMeanImpl.increment(value); } n++;"
1,"case REGULA_FALSI: // Nothing. if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        x0 = 0.5 * ((int)x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break;"
0,"index 1db94e2..4aa4555 100644 @Override public void process(Node externs, Node root) { NodeTraversal.traverse(compiler, root, this); +    removeDuplicateDeclarations(root); if (MAKE_LOCAL_NAMES_UNIQUE) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(); NodeTraversal t = new NodeTraversal(compiler, renamer); t.traverseRoots(externs, root); } -    removeDuplicateDeclarations(root); new PropogateConstantAnnotations(compiler, assertOnChange) .process(externs, root); }"
1,"System.arraycopy(iTypes, 0, newTypes, 0, i); System.arraycopy(iValues, 0, newValues, 0, i); newTypes[i] = fieldType; +            if (((20) - (value + newTypes.length) < value) || ((2) != (org.joda.time.Partial.this.iTypes.length))) { newValues[i] = value; +            } System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); // use public constructor to ensure full validation"
0,int start = pos.getIndex(); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { +            next(pos); return appendTo == null ? null : appendTo.append(QUOTE); } int lastHold = start; for (int i = pos.getIndex(); i < pattern.length(); i++) {
1,"} k = 1.0 / k; tmp = mu + k * sigma; -            if (tmp < upper) { -                upper = ((int) Math.ceil(tmp)) - 1; -            } }  return solveInverseCumulativeProbability(p, lower, upper);"
0, // compute the intersection on infinite line Vector3D v1D = line.intersection(subLine.line); +        if (v1D == null) { +            return null; +        }  // check location of point with respect to first sub-line Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));    // compute the intersection on infinite line Vector2D v2D = line1.intersection(line2); +        if (v2D == null) { +            return null; +        }  // check location of point with respect to first sub-line Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D)); 
0,index 886d424..c7cbfb3 100644 */ public boolean contains(char ch) { char[] thisBuf = buffer; -        for (int i = 0; i < thisBuf.length; i++) { +        for (int i = 0; i < this.size; i++) { if (thisBuf[i] == ch) { return true; } return -1; } char[] thisBuf = buffer; -        for (int i = startIndex; i < thisBuf.length; i++) { +        for (int i = startIndex; i < size; i++) { if (thisBuf[i] == ch) { return i; }
0,"index 6901c8e..a783b35 100644 } Class lhsClass = lhs.getClass(); if (!lhsClass.isArray()) { +            if (lhs instanceof java.math.BigDecimal) { +                isEquals = (((java.math.BigDecimal)lhs).compareTo(rhs) == 0); +            } else { // The simple case, not an array, just test the element isEquals = lhs.equals(rhs); +            } } else if (lhs.getClass() != rhs.getClass()) { // Here when we compare different dimensions, for example: a boolean[][] to a boolean[] this.setEquals(false);"
1," // Verify bracketing double sign = yMin * yMax; -        if (sign >= 0) { -            // check if either value is close to a zero +if (sign >= 0&&!(sign<=(double)0.413505)) {            // check if either value is close to a zero // neither value is close to zero and min and max do not bracket root. throw new IllegalArgumentException (""Function values at endpoints do not have different signs."" + "
0,@Override public void matchConstraint(ObjectType constraintObj) { // We only want to match contraints on anonymous types. +	  if((hasReferenceName() && constraintObj.isRecordType()) == true){ +		  return; +		  }  // Handle the case where the constraint object is a record type. //
1," // evaluate 3 hours before and after to work out if anything is happening long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR); -        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR); +        long instantAfter = getOffset(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR); if (instantBefore == instantAfter) { return instant;  // not an overlap (less than is a gap, equal is normal case) } "
0,"// Collections.binarySearch() and tells us where to insert the // new item...otherwise it will be just -1 and we should just // append the value to the list... -            if (this.autoSort) { +            if (!(org.jfree.data.xy.XYSeries.this.allowDuplicateXValues)) { this.data.add(-index - 1, new XYDataItem(x, y)); } else {"
0, } if (plotState != null && hotspot != null) { +        	if((null == plotState.getOwner()) == true){ +        		return state; +        		} ChartRenderingInfo owner = plotState.getOwner(); EntityCollection entities = owner.getEntityCollection(); if (entities != null) {  
0,"index e2f0538..26fb230 100644  private class AliasedTypeNode implements AliasUsage { private final Node typeReference; +    private final Node aliasDefinition; private final String aliasName;  -    AliasedTypeNode(Node typeReference, +    AliasedTypeNode(Node typeReference, Node aliasDefinition, String aliasName) { this.typeReference = typeReference; +      this.aliasDefinition = aliasDefinition; this.aliasName = aliasName; }  @Override public void applyAlias() { -      typeReference.setString(aliasName); +      String typeName = typeReference.getString(); +      String aliasExpanded = +          Preconditions.checkNotNull(aliasDefinition.getQualifiedName()); +      Preconditions.checkState(typeName.startsWith(aliasName)); +      typeReference.setString(typeName.replaceFirst(aliasName, aliasExpanded)); } }  Var aliasVar = aliases.get(baseName); if (aliasVar != null) { Node aliasedNode = aliasVar.getInitialValue(); -          aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex))); +          aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode, baseName)); } } "
1,long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { -                this.minEndIndex = index; +                this.data.remove(index); +                this.minEndIndex = index; } } else { 
1,"locale = Locale.getDefault(); } try { +                if(locale!=null){ +                    key=new Pair(key,locale); +                } SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale); String pattern = formatter.toPattern(); "
0,*/ public boolean contains(char ch) { char[] thisBuf = buffer; +    // start of generated patch +        for(int i=0;i<size;i++){ +          if(thisBuf[i]==ch){ +            return true; +          } +        } +    // end of generated patch +    /* start of original code for (int i = 0; i < thisBuf.length; i++) { if (thisBuf[i] == ch) { return true; } } +    end of original code*/ return false; } 
0,"index accf4c5..c3fc14b 100644  Node block = fnNode.getLastChild();  +    boolean hasSideEffects = false;  // empty function case +    if (block.hasChildren()) { +      Preconditions.checkState(block.hasOneChild()); +      Node stmt = block.getFirstChild(); +      if (stmt.isReturn()) { +        hasSideEffects = NodeUtil.mayHaveSideEffects( +            stmt.getFirstChild(), compiler); +      } +    }  // CALL NODE: [ NAME, ARG1, ARG2, ... ] Node cArg = callNode.getFirstChild().getNext(); // For each named parameter check if a mutable argument use more than one. if (fnParam != null) { if (cArg != null) { +          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { +            return CanInlineResult.NO; +          }  // Check for arguments that are evaluated more than once. // Note: Unlike block inlining, there it is not possible that a"
1,for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; -                    work[j - k] = tmp; +                    work[i + k] = tmp; } j -= 4; }
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((fa*maximumIterations)> 0.0){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,"index 9d1b797..3fc328d 100644 private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j = 4 * (n - 1); for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];"
0,"index b418dbd..7289803 100755 propertyNode); }  -  @Override -  public JSType getLeastSupertype(JSType that) { -    if (!that.isRecordType()) { -      return super.getLeastSupertype(that); -    } -    RecordTypeBuilder builder = new RecordTypeBuilder(registry); -    for (String property : properties.keySet()) { -      if (that.toMaybeRecordType().hasProperty(property) && -          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( -              getPropertyType(property))) { -        builder.addProperty(property, getPropertyType(property), -            getPropertyNode(property)); -      } -    } -    return builder.build(); -  } JSType getGreatestSubtypeHelper(JSType that) { if (that.isRecordType()) { RecordType thatRecord = that.toMaybeRecordType();"
1,"double rhs = tableau.getEntry(i, tableau.getWidth() - 1); if (MathUtils.compareTo(tableau.getEntry(i, col), 0, epsilon) >= 0) { double ratio = rhs / tableau.getEntry(i, col); -                if (ratio < minRatio) { +                if(ratio<=minRatio){ minRatio = ratio; minRatioPos = i; } "
1,outEdges.get(0).getValue() == Branch.UNCOND); Node fallThrough = computeFollowing(n); Node nextCfgNode = outEdges.get(0).getDestination().getValue(); -            if (nextCfgNode == fallThrough) { +            if (false) { removeNode(n); } } 
0,"index 54aabc4..73f1ea3 100644 // Zero or sub-normal if (x == 0) { // make sure 0 has the right sign +                if ((bits & 0x8000000000000000L) != 0) { +                    sign = -1; +                } return; }   Dfp y = this; boolean negate = false; -        if (lessThan(getZero())) { +        int cmp0 = compare(this, getZero()); +        if (cmp0 == 0) { +            return sign < 0 ? -0.0 : +0.0; +        } else if (cmp0 < 0) { y = negate(); negate = true; }"
1,"double minValue = 0; Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { -            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { +            if (MathUtils.compareTo(tableau.getEntry(0, i), this.epsilon, epsilon) < 0) { minValue = tableau.getEntry(0, i); minPos = i; } "
1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(""JSC_NULL_ARGUMENT_ERROR""); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"
1,// Fall back to bisection. -                    delta = 0.5 * dx; +                    if (y0 < 1) { +                        delta = 0.5 * dx; +                    } oldDelta = delta; 
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if (fa * fb >= 0.0 && (fa * fb >= 0.0) != true) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,"index bf15a49..b36a156 100644 */ private static int greatestCommonDivisor(int u, int v) { // From Commons Math: +        if ((u == 0) || (v == 0)) { +            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) { +                throw new ArithmeticException(""overflow: gcd is 2^31""); +            } +            return Math.abs(u) + Math.abs(v); +        } //if either operand is abs 1, return 1: -        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) { +        if (Math.abs(u) == 1 || Math.abs(v) == 1) { return 1; } // keep u and v negative, as negative integers range down to"
1,"public EventListenerSupport(Class<L> listenerInterface, ClassLoader classLoader) { this(); Validate.notNull(listenerInterface, ""Listener interface cannot be null.""); -        Validate.notNull(classLoader, ""ClassLoader cannot be null.""); +        Validate.notNull(listenerInterface, ""Listener interface cannot be null.""); Validate.isTrue(listenerInterface.isInterface(), ""Class {0} is not an interface"", listenerInterface.getName()); initializeTransientFields(listenerInterface, classLoader); * @param classLoader the class loader to be used */ private void createProxy(Class<L> listenerInterface, ClassLoader classLoader) { -        proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader, +        Validate.isTrue(listenerInterface.isInterface(), ""Class {0} is not an interface"", listenerInterface.getName()); +        proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader, new Class[] { listenerInterface }, createInvocationHandler())); }   throw new NumberFormatException(""A blank string is not a valid number""); } if (str.startsWith(""--"")) { -            return null; } if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) { int hexDigits = str.length() - 2; // drop 0x "
1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(""JSC_BASE_CLASS_ERROR""); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"
0,"index 3fc328d..2d0d72f 100644 lowerSpectra = Math.min(lowerSpectra, lower); final double upper = dCurrent + eCurrent; work[upperStart + m - 1] = upper; +        upperSpectra = Math.max(upperSpectra, upper); minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);  } diagMax    = work[4 * i0]; offDiagMin = work[4 * i0 + 2]; double previousEMin = work[4 * i0 + 3]; -                    for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) { -                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) && +                    for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) { +                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) || (work[i + 2] <= TOLERANCE_2 * sigma)) { // insert a split work[i + 2]  = -sigma; double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);  // approximate contribution to norm squared from i < nn-2. -                if (end - start > 2) { +                if (end - start > 3) { b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {"
1,* @return a number between 0.0 and 100.0 */ double getTypedPercent() { -    int total = nullCount + unknownCount + typedCount; +    int total = this.noTypeCheckSection + unknownCount + typedCount; if (total == 0) { return 0.0; } else { 
1," if (!collapses.isEmpty()) { applyCollapses(); -      compiler.reportCodeChange(); } }    private void applyCollapses() { -    for (Collapse collapse : collapses) { - -      Node var = new Node(Token.VAR); -      var.copyInformationFrom(collapse.startNode); -      collapse.parent.addChildBefore(var, collapse.startNode); - -      boolean redeclaration = false; -      for (Node n = collapse.startNode; n != collapse.endNode;) { -        Node next = n.getNext(); - -        Preconditions.checkState(var.getNext() == n); -        collapse.parent.removeChildAfter(var); - -        if (n.isVar()) { -          while(n.hasChildren()) { -            var.addChildToBack(n.removeFirstChild()); -          } -        } else { -          Node assign = n.getFirstChild(); -          Node lhs = assign.getFirstChild(); -          Preconditions.checkState(lhs.isName()); -          Node rhs = assign.getLastChild(); -          lhs.addChildToBack(rhs.detachFromParent()); -          var.addChildToBack(lhs.detachFromParent()); -          redeclaration = true; -        } -        n = next; -      } - -      if (redeclaration) { -        JSDocInfo info = new JSDocInfo(); -        info.addSuppression(""duplicate""); -        var.setJSDocInfo(info); -      } -    } } } "
0,"index e6d4320..c2150b1 100644 return n; }  -    if (n.getParent() == null) { -      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges(); -      if (outEdges.size() == 1) { -        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue()); -      } -    } switch (n.getType()) { -      case Token.BLOCK: -        if (n.hasChildren()) { -          Node first = n.getFirstChild(); -          return tryRemoveUnconditionalBranching(first); -        } else { -          return tryRemoveUnconditionalBranching(ControlFlowAnalysis.computeFollowNode(n)); -        } case Token.RETURN: if (n.hasChildren()) { break; (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {  Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND); -          Node fallThrough = tryRemoveUnconditionalBranching(computeFollowing(n)); +          Node fallThrough = computeFollowing(n); Node nextCfgNode = outEdges.get(0).getDestination().getValue(); if (nextCfgNode == fallThrough) { removeDeadExprStatementSafely(n);  private Node computeFollowing(Node n) { Node next = ControlFlowAnalysis.computeFollowNode(n); +    while (next != null && next.getType() == Token.BLOCK) { +      if (next.hasChildren()) { +        next = next.getFirstChild(); +      } else { +        next = computeFollowing(next); +      } +    } return next; } "
0,"index c86b9d7..3868531 100644 if (calendar == null) { throw new IllegalArgumentException(""The calendar must not be null""); } +        int era = calendar.get(Calendar.ERA); int yearOfEra = calendar.get(Calendar.YEAR); return new LocalDate( -            yearOfEra, +            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH) ); if (date == null) { throw new IllegalArgumentException(""The date must not be null""); } +        if (date.getTime() < 0) { // handle years in era BC +            GregorianCalendar cal = new GregorianCalendar(); +            cal.setTime(date); +            return fromCalendarFields(cal); +        } return new LocalDate( date.getYear() + 1900, date.getMonth() + 1, index e75deca..f37db3e 100644 if (calendar == null) { throw new IllegalArgumentException(""The calendar must not be null""); } +        int era = calendar.get(Calendar.ERA); int yearOfEra = calendar.get(Calendar.YEAR); return new LocalDateTime( -            yearOfEra, +            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH), calendar.get(Calendar.HOUR_OF_DAY), if (date == null) { throw new IllegalArgumentException(""The date must not be null""); } +        if (date.getTime() < 0) { // handle years in era BC +            GregorianCalendar cal = new GregorianCalendar(); +            cal.setTime(date); +            return fromCalendarFields(cal); +        } return new LocalDateTime( date.getYear() + 1900, date.getMonth() + 1,"
0,"index 002acd6..081f01f 100644 return block; }  +  private static Node blockUnchecked(Node stmt) { +    return new Node(Token.BLOCK, stmt); +  }  public static Node script(Node ... stmts) { // TODO(johnlenz): finish setting up the SCRIPT node }  public static Node tryFinally(Node tryBody, Node finallyBody) { -    Preconditions.checkState(tryBody.isLabelName()); -    Preconditions.checkState(finallyBody.isLabelName()); +    Preconditions.checkState(tryBody.isBlock()); +    Preconditions.checkState(finallyBody.isBlock()); Node catchBody = block().copyInformationFrom(tryBody); return new Node(Token.TRY, tryBody, catchBody, finallyBody); } public static Node tryCatch(Node tryBody, Node catchNode) { Preconditions.checkState(tryBody.isBlock()); Preconditions.checkState(catchNode.isCatch()); -    Node catchBody = block(catchNode).copyInformationFrom(catchNode); +    Node catchBody = blockUnchecked(catchNode).copyInformationFrom(catchNode); return new Node(Token.TRY, tryBody, catchBody); } "
1,"* @param notify  notify listeners? */ public void add(TimeSeriesDataItem item, boolean notify) { -        if (item == null) { -            throw new IllegalArgumentException(""Null 'item' argument.""); -        } +        updateBoundsForRemovedItem(item); item = (TimeSeriesDataItem) item.clone(); Class c = item.getPeriod().getClass(); if (this.timePeriodClass == null) { "
1,"// x--4 (which is a syntax error). char prev = getLastChar(); boolean negativeZero = isNegativeZero(x); -    if (x < 0 && prev == '-') { +    if (prev == '-') { add("" ""); } "
0,"index c97e091..7a882de 100644 }  static Double getStringNumberValue(String rawJsString) { +    if (rawJsString.contains(""\u000b"")) { // vertical tab is not always whitespace +      return null; +    }  String s = trimJsWhiteSpace(rawJsString); // return ScriptRuntime.toNumber(s); static TernaryValue isStrWhiteSpaceChar(int c) { switch (c) { case '\u000B': // <VT> -        return TernaryValue.TRUE; +        return TernaryValue.UNKNOWN;  // IE says ""no"", EcmaScript says ""yes"" case ' ': // <SP> case '\n': // <LF> case '\r': // <CR>"
1,} -            if (max(diagD) > 1e14 * min(diagD)) { +            if (this.dimension == 1) { double tfac = max(diagD) / 1e14 - min(diagD); 
0,"index 6ff5e36..ab65ba3 100644  // BAR X Number meanValue = dataset.getMeanValue(row, column); +        if (meanValue == null) { +            return; +        }  double value = meanValue.doubleValue(); double base = 0.0; }  // standard deviation lines -            double valueDelta = dataset.getStdDevValue(row, column).doubleValue(); +        Number n = dataset.getStdDevValue(row, column); +        if (n != null) { +            double valueDelta = n.doubleValue(); double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() + valueDelta, dataArea, yAxisLocation); double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25, lowVal, rectY + rectHeight * 0.75); g2.draw(line); +        }  CategoryItemLabelGenerator generator = getItemLabelGenerator(row, column);  // BAR Y Number meanValue = dataset.getMeanValue(row, column); +        if (meanValue == null) { +            return; +        }  double value = meanValue.doubleValue(); double base = 0.0; }  // standard deviation lines -            double valueDelta = dataset.getStdDevValue(row, column).doubleValue(); +        Number n = dataset.getStdDevValue(row, column); +        if (n != null) { +            double valueDelta = n.doubleValue(); double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() + valueDelta, dataArea, yAxisLocation); double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, lowVal, rectX + rectWidth / 2.0d + 5.0d, lowVal); g2.draw(line); +        }  CategoryItemLabelGenerator generator = getItemLabelGenerator(row, column);"
1,"// the guessed root is either not strictly inside the interval or it // is a NaN (which occurs when some sampling points share the same y) // we try again with a lower interpolation order -                    if (signChangeIndex - start >= end - signChangeIndex) { +                    if ((signChangeIndex - start >= end - signChangeIndex) || (y[0] * y[1] < 0)) { // we have more points before the sign change, drop the lowest point ++start; } else { "
0,"index c998d1e..d6c194a 100644 // JavaScript handles zero shifts on signed numbers differently than // Java as an Java int can not represent the unsigned 32-bit number // where JavaScript can so use a long here. -          result = lvalInt >>> rvalInt; +          long lvalLong = lvalInt & 0xffffffffL; +          result = lvalLong >>> rvalInt; break; default: throw new AssertionError(""Unknown shift operator: "" +"
1,if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); -            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() +            long e = getDataItem(this.maxStartIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { 
0,"index 0f0786a..8f39421 100644 if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(""Stopwatch is not running. ""); } +        if(this.runningState == STATE_RUNNING) { stopTime = System.currentTimeMillis(); +        } this.runningState = STATE_STOPPED; } "
1,"// if the plot area is too small, just return... boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW); boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW); -        if (b1 || b2) { +        if (b1 || (getRenderer() != null)) { return; } "
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((fa> 0.0)&&((fa*fb)> 0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,"// contract with translators is that they have to understand codepoints // and they just took care of a surrogate pair for (int pt = 0; pt < consumed; pt++) { -                pos += Character.charCount(Character.codePointAt(input, pos)); +                pos += Character.charCount(Character.codePointAt(input, pt)); } } } "
