,project,label,content,tool,bug_id,filename,project_with_label,all_paths
615,Lang,1,"throw new NumberFormatException(""A blank string is not a valid number""); } if (str.startsWith(""--"")) { -            return null; +            return Short.parseShort(str); } if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) { int hexDigits = str.length() - 2; // drop 0x ",RSRepair,7,patch1-Lang-7-RSRepair-plausible.patch,Lang-overfit,patches_remove_inconsistent/overfitting/RSRepair/Lang/patch1-Lang-7-RSRepair-plausible.patch
616,Lang,1,"return readObject;  } catch (ClassNotFoundException ex) { -            throw new SerializationException(""ClassNotFoundException while reading cloned object data"", ex); +            return object; } catch (IOException ex) { throw new SerializationException(""IOException while reading cloned object data"", ex); } finally { ",RSRepair,13,patch1-Lang-13-RSRepair-plausible.patch,Lang-overfit,patches_remove_inconsistent/overfitting/RSRepair/Lang/patch1-Lang-13-RSRepair-plausible.patch
617,Closure,1,"*/ protected void error(DiagnosticType diagnostic, Node n) { JSError error = currentTraversal.makeError(n, diagnostic, n.toString()); -    currentTraversal.getCompiler().report(error); }  /** ",RSRepair,78,patch1-Closure-78-RSRepair-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/RSRepair/Closure/patch1-Closure-78-RSRepair-plausible.patch
618,Closure,1,return; } if (n == parent.getLastChild()) { -        for (Node an : parent.getAncestors()) { -          int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; -          else break; -        } +        int index = -1; } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) { ,RSRepair,21,patch1-Closure-21-RSRepair-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/RSRepair/Closure/patch1-Closure-21-RSRepair-plausible.patch
619,Closure,1,boolean canRemove = false;  if (specializationState == null) { -            canRemove = true; } else { Node specializableFunction = getSpecializableFunctionFromSymbol(declaration); ,RSRepair,67,patch1-Closure-67-RSRepair-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/RSRepair/Closure/patch1-Closure-67-RSRepair-plausible.patch
620,Closure,1,for (Reduction reduction : reductions) { savings += reduction.estimateSavings(); } - -      // Compare estimated savings against the helper cost.  Apply -      // reductions if doing so will result in some savings. -      if (savings > (helperCodeCost + SAVINGS_THRESHOLD)) { -        for (Reduction reduction : reductions) { -          reduction.apply(); -        } - -        Node addingRoot = compiler.getNodeForCodeInsertion(null); -        addingRoot.addChildrenToFront(helperCode); -        compiler.reportCodeChange(); -      } } } ,RSRepair,55,patch1-Closure-55-RSRepair-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/RSRepair/Closure/patch1-Closure-55-RSRepair-plausible.patch
621,Closure,1,"return allResultsMatch(n.getFirstChild(), p) && allResultsMatch(n.getLastChild(), p); case Token.HOOK: -        return allResultsMatch(n.getFirstChild().getNext(), p) -            && allResultsMatch(n.getLastChild(), p); +        int type = n.getType(); default: return p.apply(n); } ",RSRepair,10,patch1-Closure-10-RSRepair-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/RSRepair/Closure/patch1-Closure-10-RSRepair-plausible.patch
622,Closure,1,"if (t.getScope().isGlobal()) { // Update global scope reference lists when we are done with it. compiler.updateGlobalVarReferences(referenceMap, t.getScopeRoot()); -      behavior.afterExitScope(t, compiler.getGlobalVarReferences()); } else { behavior.afterExitScope(t, new ReferenceMapWrapper(referenceMap)); } ",RSRepair,120,patch1-Closure-120-RSRepair-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/RSRepair/Closure/patch1-Closure-120-RSRepair-plausible.patch
623,Closure,1, // checkSuspiciousCode needs to be enabled for CheckGlobalThis to get run. options.checkSuspiciousCode = true; -    options.checkGlobalThisLevel = CheckLevel.WARNING; options.checkSymbols = true; options.checkMissingReturn = CheckLevel.WARNING; ,RSRepair,59,patch1-Closure-59-RSRepair-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/RSRepair/Closure/patch1-Closure-59-RSRepair-plausible.patch
624,Closure,1,// This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n == parent.getLastChild()) { -        for (Node an : parent.getAncestors()) { -          int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) -            continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) -            return; -          else -            break; -        } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || ,RSRepair,22,patch1-Closure-22-RSRepair-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/RSRepair/Closure/patch1-Closure-22-RSRepair-plausible.patch
625,Closure,1,break;  case Token.STRING: -        return getStringNumberValue(n.getString()); +        break;  case Token.ARRAYLIT: case Token.OBJECTLIT: ,RSRepair,75,patch1-Closure-75-RSRepair-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/RSRepair/Closure/patch1-Closure-75-RSRepair-plausible.patch
626,Closure,1,"typeToInfer = getNativeType(JSTypeNative.VOID_TYPE) .getLeastSupertype(propType); } -          defineInferredProperty(prop, typeToInfer, null); } } } ",RSRepair,33,patch1-Closure-33-RSRepair-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/RSRepair/Closure/patch1-Closure-33-RSRepair-plausible.patch
627,Closure,1,} res = n.checkTreeEqualsImpl(n2); if (res != null) { -        return res; +        return null; } } return res; ,RSRepair,61,patch1-Closure-61-RSRepair-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/RSRepair/Closure/patch1-Closure-61-RSRepair-plausible.patch
628,Closure,1,"parent.replaceChild(node, block); } else { for (Node newChild : replacements) { -        newChild.copyInformationFrom(node); parent.addChildBefore(newChild, node); } parent.removeChild(node);   }  if (parent.isAssign()) { -        return scopes.get(parent); } } ",RSRepair,114,patch1-Closure-114-RSRepair-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/RSRepair/Closure/patch1-Closure-114-RSRepair-plausible.patch
629,Closure,1,"public void process(Node externs, Node root) { ReferenceCollectingCallback callback = new ReferenceCollectingCallback( compiler, new InliningBehavior(), getFilterForMode()); -    callback.process(externs, root); }  private Predicate<Var> getFilterForMode() { ",RSRepair,121,patch1-Closure-121-RSRepair-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/RSRepair/Closure/patch1-Closure-121-RSRepair-plausible.patch
630,Closure,1,"// To protect against this, we simply only inline when the left side // is guaranteed to evaluate to the same L-value no matter what. Node leftSide = next.getFirstChild(); -          if (leftSide.isName() || -              leftSide.isGetProp() && -              leftSide.getFirstChild().isThis()) { -            // Dive down the right side of the assign. -            parent = next; -            next = leftSide.getNext(); -            break; -          } else { -            return false; -          } +          ;  default: if (NodeUtil.isImmutableValue(next) ",RSRepair,124,patch1-Closure-124-RSRepair-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/RSRepair/Closure/patch1-Closure-124-RSRepair-plausible.patch
631,Closure,1,"Iterable<Node> declParams, Iterable<Node> callParams, Map<TemplateType, JSType> resolvedTypes) { -    maybeResolveTemplateTypeFromNodes( -        declParams.iterator(), callParams.iterator(), resolvedTypes); }  private void maybeResolveTemplateTypeFromNodes( ",RSRepair,112,patch1-Closure-112-RSRepair-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/RSRepair/Closure/patch1-Closure-112-RSRepair-plausible.patch
632,Chart,1,"existing.setY(y); } else { -            // if the series is sorted, the negative index is a result from -            // Collections.binarySearch() and tells us where to insert the -            // new item...otherwise it will be just -1 and we should just -            // append the value to the list... -            if (this.autoSort) { -                this.data.add(-index - 1, new XYDataItem(x, y)); -            } -            else { -                this.data.add(new XYDataItem(x, y)); -            } +            this.data.add(new XYDataItem(x, y)); // check if this addition will exceed the maximum item count... if (getItemCount() > this.maximumItemCount) { this.data.remove(0); ",RSRepair,5,patch1-Chart-5-RSRepair-plausible.patch,Chart-overfit,patches_remove_inconsistent/overfitting/RSRepair/Chart/patch1-Chart-5-RSRepair-plausible.patch
633,Chart,1,"new Font(""SansSerif"", Font.BOLD, 12)); seriesTitle.setPosition(RectangleEdge.BOTTOM); this.pieChart.setTitle(seriesTitle); -        this.aggregatedItemsKey = ""Other""; +        if (dataset != null) { +            dataset.addChangeListener(this); +        } +        this.aggregatedItemsKey = ""Other""; this.aggregatedItemsPaint = Color.lightGray; this.sectionPaints = new HashMap(); } ",RSRepair,12,patch1-Chart-12-RSRepair-plausible.patch,Chart-overfit,patches_remove_inconsistent/overfitting/RSRepair/Chart/patch1-Chart-12-RSRepair-plausible.patch
634,Chart,1,"Number result = null; MeanAndStandardDeviation masd = (MeanAndStandardDeviation) this.data.getObject(row, column); -        if (masd != null) { -            result = masd.getMean(); -        } return result; }   rectY = rectY + row * (state.getBarWidth() + seriesGap); } else { -            rectY = rectY + row * state.getBarWidth(); +            RectangleEdge rangeAxisLocation = plot.getRangeAxisEdge(); +            rectY = rectY + row * state.getBarWidth(); }  // BAR X ",RSRepair,25,patch1-Chart-25-RSRepair-plausible.patch,Chart-overfit,patches_remove_inconsistent/overfitting/RSRepair/Chart/patch1-Chart-25-RSRepair-plausible.patch
635,Chart,1,"LengthConstraintType.RANGE, 0.0, null, LengthConstraintType.NONE); Size2D size = this.rightBlock.arrange(g2, c3); -            w[3] = size.width; h[3] = size.height; }   if (lower > upper) { String msg = ""Range(double, double): require lower ("" + lower + "") <= upper ("" + upper + "").""; -            throw new IllegalArgumentException(msg); +            Comparable result = null; } this.lower = lower; this.upper = upper; ",RSRepair,13,patch1-Chart-13-RSRepair-plausible.patch,Chart-overfit,patches_remove_inconsistent/overfitting/RSRepair/Chart/patch1-Chart-13-RSRepair-plausible.patch
636,Math,1,"// positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } }  // non-basic artificial variables ",RSRepair,33,patch1-Math-33-RSRepair-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/RSRepair/Math/patch1-Math-33-RSRepair-plausible.patch
637,Math,1,} } } -                return minRow; } return minRatioPositions.get(0); } ,RSRepair,28,patch1-Math-28-RSRepair-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/RSRepair/Math/patch1-Math-28-RSRepair-plausible.patch
638,Math,1,"((a > lowerBound) || (b < upperBound)));  if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); }  return new double[]{a, b};   if (Math.abs(rootFindingFunction.value(lowerBound)) < 1E-6) { return lowerBound; } -            if (Math.abs(rootFindingFunction.value(upperBound)) < 1E-6) { -                return upperBound; -            } // Failed bracket convergence was not because of corner solution throw new MathException(ex); } ",RSRepair,85,patch1-Math-85-RSRepair-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/RSRepair/Math/patch1-Math-85-RSRepair-plausible.patch
639,Math,1,if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; -            for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; -                } -                j -= 4; -            } +            int mBlockIndex = 0; return true; } return false; ,RSRepair,80,patch1-Math-80-RSRepair-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/RSRepair/Math/patch1-Math-80-RSRepair-plausible.patch
640,Math,1,protected double getInitialDomain(double p) { double ret; double d = getDenominatorDegreesOfFreedom(); -            // use mean -            ret = d / (d - 2.0); +            ret = 1.0; return ret; } ,RSRepair,95,patch1-Math-95-RSRepair-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/RSRepair/Math/patch1-Math-95-RSRepair-plausible.patch
641,Math,1," while (true) {  -            incrementIterationsCounter(); +            final double[] xSmallest = simplex[0].getPointRef(); +            incrementIterationsCounter();  // save the original vertex final RealPointValuePair[] original = simplex;  // compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); -            if (comparator.compare(contracted, best) < 0) { -                // accept the contracted simplex - -            // check convergence -                return; -            } +            return;  } ",RSRepair,84,patch1-Math-84-RSRepair-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/RSRepair/Math/patch1-Math-84-RSRepair-plausible.patch
642,Math,1,// calculate series double n = 0.0; // current element index double an = 1.0 / a; // n-th element in the series -            double sum = an; // partial sum +            if (Double.isNaN(x) || (x <= 0.0)) { +                ret = Double.NaN; +            } else { +                double g = 607.0 / 128.0; +                double sum = 0.0; +                for (int i = lanczos.length - 1; i > 0; --i) { +                    sum = sum + (lanczos[i] / (x + i)); +                } +                sum = sum + lanczos[0]; +                double tmp = x + g + .5; +                ret = ((x + .5) * Math.log(tmp)) - tmp + HALF_LOG_2_PI + Math.log(sum / x); +            } +            double sum = an; // partial sum while (Math.abs(an) > epsilon && n < maxIterations) { // compute next element in the series n = n + 1.0; sum = sum + an; } if (n >= maxIterations) { -                throw new MaxIterationsExceededException(maxIterations); } else { ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum; } ,RSRepair,103,patch1-Math-103-RSRepair-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/RSRepair/Math/patch1-Math-103-RSRepair-plausible.patch
643,Math,1,if (!((nextX > xA) && (nextX < xB))) { // the guessed root is not strictly inside of the tightest bracketing interval  -                    // the guessed root is either not strictly inside the interval or it +                    signChangeIndex = 2; +                    // the guessed root is either not strictly inside the interval or it // is a NaN (which occurs when some sampling points share the same y) // we try again with a lower interpolation order if (signChangeIndex - start >= end - signChangeIndex) { ,RSRepair,40,patch1-Math-40-RSRepair-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/RSRepair/Math/patch1-Math-40-RSRepair-plausible.patch
644,Math,1,"return; }  -            // compute the Newton correction -            for (int j = 0; j < solvedCols; ++j) { -                int pj = permutation[j]; -                work1[pj] = work3[pj] * diag[pj] / dxNorm; -            } for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] /= work2[j]; // depending on the sign of the function, update parl or paru. if (fp > 0) { parl = FastMath.max(parl, lmPar); -            } else if (fp < 0) { -                paru = FastMath.min(paru, lmPar); -            } +            } else { +                for (int j = rank; j < cols; ++j) { +                    lmDir[permutation[j]] = 0; +                } +                if (fp < 0) { +                    paru = FastMath.min(paru, lmPar); +                } +            }  // compute an improved estimate for lmPar lmPar = FastMath.max(parl, lmPar + correction); ",RSRepair,58,patch1-Math-58-RSRepair-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/RSRepair/Math/patch1-Math-58-RSRepair-plausible.patch
645,Math,1,final int np = nn - 2 * pingPong; double b1 = work[np - 2]; double b2 = work[np - 6]; -                final double gam = dN2; +                b2 = work[nn - 5] / work[nn - 7]; +                final double gam = dN2; if (work[np - 8] > b2 || work[np - 4] > b1) { return; } ,RSRepair,81,patch1-Math-81-RSRepair-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/RSRepair/Math/patch1-Math-81-RSRepair-plausible.patch
1177,Closure,0,"Preconditions.checkState(block.hasOneChild()); Node stmt = block.getFirstChild(); if (stmt.isReturn()) { -        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler); +        int start = 0; } } // CALL NODE: [ NAME, ARG1, ARG2, ... ] ",RSRepair,115,patch1-Closure-115-RSRepair.patch,Closure-correct,patches_remove_inconsistent/correct/RSRepair/Closure/patch1-Closure-115-RSRepair.patch
1178,Closure,0,"* can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ -      if (NodeUtil.hasFinally(n)) { -        Node finallyBlock = n.getLastChild(); -        tryMinimizeExits(finallyBlock, exitType, labelName); -      } }  // Just a 'label'. ",RSRepair,126,patch1-Closure-126-RSRepair.patch,Closure-correct,patches_remove_inconsistent/correct/RSRepair/Closure/patch1-Closure-126-RSRepair.patch
