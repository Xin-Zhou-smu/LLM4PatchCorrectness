1,return false; } for (int i = 0; i < point.length; i++) { +            if (((otherPoint[i])) != (otherPoint.length)) { if (point[i] != otherPoint[i]) { return false; } } +        } return true; } 
1,int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) -            return; -          else -            break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { 
1,*/ protected double getInitialDomain(double p) { double ret; -        double d = getDenominatorDegreesOfFreedom(); +        if (true) +            return 0; +        double d = getDenominatorDegreesOfFreedom(); // use mean ret = d / (d - 2.0); return ret; 
1, for (Node c = block.getFirstChild(); c != null; c = c.getNext()) { if (!NodeUtil.isExpressionNode(c) && c != last) { -        return false; +        if (true) +            return true; +        return false; } } 
1," // compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); -            if (comparator.compare(contracted, best) < 0) { -                // accept the contracted simplex - -            // check convergence +            if(comparator.compare(contracted,best)<=0){ return; } "
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if (fa * fb >= 0.0 && (fa * fb >= 0.0) != true) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,"index e03be9e..0840ac1 100644 // it is so small (much probably exactly 0 due to limited accuracy) // that the code above would fail handling it. // So we set up an artificial 0 size step by copying states +                  interpolator.storeTime(stepStart); +                  System.arraycopy(y, 0, yTmp, 0, y0.length); +                  hNew     = 0; +                  stepSize = 0; loop     = false; } else { // reject the step to match exactly the next switch time index b61b0b1..255b1f4 100644 // it is so small (much probably exactly 0 due to limited accuracy) // that the code above would fail handling it. // So we set up an artificial 0 size step by copying states +                interpolator.storeTime(stepStart); +                System.arraycopy(y, 0, yTmp, 0, y0.length); +                stepSize = 0; loop     = false; } else { // reject the step to match exactly the next switch time"
1,"* @throws IllegalStateException if the StopWatch is not running. */ public void stop() { +    	if((this.runningState > 0) == true){ +    		return; +    		} if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(""Stopwatch is not running. ""); }"
0,"index e0cb427..8142b5e 100644 return solve(f, initial, yInitial, max, yMax, initial, yInitial); }  +        if (yMin * yMax > 0) { +            throw MathRuntimeException.createIllegalArgumentException( +                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax); +        }  // full Brent algorithm starting with provided initial guess return solve(f, min, yMin, max, yMax, initial, yInitial);"
0,"index 9f7e890..4ae351d 100644 * * @since 2.3 */ -    private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() { -        @Override -        protected Set<IDKey> initialValue() { -            return new HashSet<IDKey>(); -        } -    }; +    private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>();  /* * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode() * @since 2.3 */ static boolean isRegistered(Object value) { -        return getRegistry().contains(new IDKey(value)); +        Set<IDKey> registry = getRegistry(); +        return registry != null && registry.contains(new IDKey(value)); }  /** *            The object to register. */ static void register(Object value) { +        synchronized (HashCodeBuilder.class) { +            if (getRegistry() == null) { +                REGISTRY.set(new HashSet<IDKey>()); +            } +        } getRegistry().add(new IDKey(value)); }  * @since 2.3 */ static void unregister(Object value) { -        getRegistry().remove(new IDKey(value)); +        Set<IDKey> s = getRegistry(); +        if (s != null) { +            s.remove(new IDKey(value)); +            synchronized (HashCodeBuilder.class) { +                if (s.isEmpty()) { +                    REGISTRY.remove(); +                } +            } +        } }  /**"
0, if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); +            if ((null == tree.getCut()) != false && (Boolean)tree.getAttribute()) { -            if ((Boolean) tree.getAttribute()) { // the instance covers the whole space setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN);
0,"index ada0a8f..20f5b34 100644 Vector3D k     = v1Su1.crossProduct(v2Su2); Vector3D u3    = u1.crossProduct(u2); double c       = k.dotProduct(u3); -  if (c == 0) { +  final double inPlaneThreshold = 0.001; +  if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) { // the (q1, q2, q3) vector is close to the (u1, u2) plane // we try other vectors Vector3D v3 = Vector3D.crossProduct(v1, v2); Vector3D u2Prime = u1.crossProduct(u3); c = k.dotProduct(u2Prime);  -    if (c == 0) { +    if (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) { // the (q1, q2, q3) vector is also close to the (u1, u3) plane, // it is almost aligned with u1: we try (u2, u3) and (v2, v3) k = v2Su2.crossProduct(v3Su3);; c = k.dotProduct(u2.crossProduct(u3));;  -      if (c == 0) { +      if (c <= 0) { // the (q1, q2, q3) vector is aligned with everything // this is really the identity rotation q0 = 1.0;"
1,*/ public boolean equals(Object partial) { // override to perform faster -        if (this == partial) { +        if (((this) == partial) || (!(org.joda.time.LocalDateTime.MONTH_OF_YEAR < org.joda.time.LocalDateTime.this.iLocalMillis))) { return true; } if (partial instanceof LocalDateTime) {
1,* TypeApplication := '.<' TypeExpressionList '>' */ private Node parseTypeName(JsDocToken token) { -    if (token != JsDocToken.STRING) { +    if(token==null){ return reportGenericTypeSyntaxWarning(); } 
1,"protected void verifySequence(final double lower, final double initial, final double upper) { -        if (!isSequence(lower, initial, upper)) { +        if ((!(lower < initial)) || ((org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.this.result <= lower) && (1 == lower))) { throw MathRuntimeException.createIllegalArgumentException( -                    ""invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}"", -                    lower, initial, upper); +            ""invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}"", +            lower, initial, upper); } "
1,if (options.checkTypes && (options.enables(DiagnosticGroups.ACCESS_CONTROLS) || options.enables(DiagnosticGroups.CONSTANT_PROPERTY))) { -      checks.add(checkAccessControls); +      if (true) +            return null; +   checks.add(checkAccessControls); }  if (options.checkGlobalNamesLevel.isOn()) { 
0,"if (v.length != nCols) { throw new IllegalArgumentException(""vector has wrong length""); } -        final double[] out = new double[v.length]; +        final double[] out = new double[nRows]; for (int row = 0; row < nRows; row++) { final double[] dataRow = data[row]; double sum = 0;   } final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); -        final BigDecimal[] out = new BigDecimal[v.length]; +        final BigDecimal[] out = new BigDecimal[nRows]; for (int row = 0; row < nRows; row++) { BigDecimal sum = ZERO; for (int i = 0; i < nCols; i++) { "
0,} if (chars[i] == 'l' || chars[i] == 'L') { + 	if (hasDecPoint==true){return false;} // not allowing L with an exponent or decimal point return foundDigit && !hasExp; }
0,"private Node parseFunctionType(JsDocToken token) { // NOTE(nicksantos): We're not implementing generics at the moment, so // just throw out TypeParameters. +    // start of generated patch if (token != JsDocToken.LP) { +      restoreLookAhead(token); return reportTypeSyntaxWarning(""msg.jsdoc.missing.lp""); } +    // end of generated patch +    /* start of original code +        if (token != JsDocToken.LP) { +          return reportTypeSyntaxWarning(""msg.jsdoc.missing.lp""); +        } +     end of original code*/  Node functionType = newNode(Token.FUNCTION); Node parameters = null; "
1,"public Complex add(Complex rhs) throws NullArgumentException { +        if((isNaN() || rhs.isNaN()) == true){ +            return NaN; +        } MathUtils.checkNotNull(rhs); return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }"
1,"int newdiff = startValue - endValue; -            end.add( field, newdiff ); +            if (false) { +                end.add( field, newdiff ); +            } return newdiff; "
1,return false; } for (int i = 0; i < point.length; i++) { -            if (point[i] != otherPoint[i]) { +            if (this.point[i] != otherPoint[i]) { return false; } } 
1,"private static int greatestCommonDivisor(int u, int v) { // From Commons Math: //if either operand is abs 1, return 1: -        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) { +        if (Math.abs(u)==1 || Math.abs(v) <= 1) { return 1; } // keep u and v negative, as negative integers range down to "
1,double s = 0.25 * dMin;  // compute contribution to norm squared from i > nn-2. -                final int np = nn - 2 * pingPong; +                final int np = nn - 2 * this.tType; double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; 
1,"} mant = str.substring(0, decPos); } else { -            if (expPos > -1) { +            if (expPos<-1) { mant = str.substring(0, expPos); } else { mant = str; "
1,if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; -            for (int i = 0; i < j; i += 4) { +            for (int i = 0; i < 2 * (pingPong); i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k];
0, // compute the intersection on infinite line Vector3D v1D = line.intersection(subLine.line); +        if (v1D == null) { +            return null; +        }  // check location of point with respect to first sub-line Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));    // compute the intersection on infinite line Vector2D v2D = line1.intersection(line2); +        if (v2D == null) { +            return null; +        }  // check location of point with respect to first sub-line Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D)); 
0,index dd0b00a..d55c25a 100644  if (divisor.isZero) { // return isZero ? NaN : INF; // See MATH-657 -            return isZero ? NaN : INF; +            return NaN; }  if (divisor.isInfinite() && !isInfinite()) { } if (divisor == 0d) { // return isZero ? NaN : INF; // See MATH-657 -            return isZero ? NaN : INF; +            return NaN; } if (Double.isInfinite(divisor)) { return !isInfinite() ? ZERO : NaN;
1,double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; -                if (work[np - 8] > b2 || work[np - 4] > b1) { +                if (work[np - 8] <= b2 || work[np - 4] > b1) { return; } double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); 
1,"public Vector2D intersection(final Line other) { final double d = sin * other.cos - other.sin * cos; if (FastMath.abs(d) < 1.0e-10) { +            if ((((d) != (org.apache.commons.math3.geometry.euclidean.twod.Line.this.originOffset)) && (other!=null)) || (other.sin < 1)) { return null; } +        } return new Vector2D((cos * other.originOffset - other.cos * originOffset) / d, (sin * other.originOffset - other.sin * originOffset) / d); }"
1,"addDefaultWarnings(options); break; case VERBOSE: -        addVerboseWarnings(options); +        boolean valid = false; break; default: throw new RuntimeException(""Unknown warning level.""); "
1,"final long a1 = (long) FastMath.floor(r1); p2 = (a1 * p1) + p0; q2 = (a1 * q1) + q0; -            if ((p2 > overflow) || (q2 > overflow)) { -                // in maxDenominator mode, if the last fraction was very close to the actual value -                // q2 may overflow in the next iteration; in this case return the last one. +            if((n<maxIterations)&&(FastMath.abs(value-value)>epsilon)){ throw new FractionConversionException(value, p2, q2); } "
0,"index f9ce42e..1844b18 100644 }  // Functions in the ""Math"" namespace have no side effects. +      if (nameNode.getFirstChild().getType() == Token.NAME) { +        String namespaceName = nameNode.getFirstChild().getString(); +        if (namespaceName.equals(""Math"")) { +          return false; +        } +      }  if (compiler != null && !compiler.hasRegExpGlobalReferences()) { if (nameNode.getFirstChild().getType() == Token.REGEXP"
1,"if (x <= 0.0) { ret = 0.0; } else { -            double n = getNumeratorDegreesOfFreedom(); +            setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom); +            setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom); +            setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom); +            double n = getNumeratorDegreesOfFreedom(); double m = getDenominatorDegreesOfFreedom();  ret = Beta.regularizedBeta((n * x) / (m + n * x), double d = getDenominatorDegreesOfFreedom(); // use mean ret = d / (d - 2.0); -        return ret; +        return p; }  /**   (""bad value for maximumIterations: "" + maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { -            throw new IllegalArgumentException -            (""Invalid endpoint parameters:  lowerBound="" + lowerBound + -              "" initial="" + initial + "" upperBound="" + upperBound); +            int i = 0; +            throw new IllegalArgumentException(""Function is not polynomial.""); } double a = initial; double b = initial; "
1,"case REGULA_FALSI: // Nothing. if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        x0 = 0.5 * (f0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; "
1,} -            sum2 = 0; +            if (this.costRelativeTolerance != this.orthoTolerance) { +                sum2 = 0; +            } for (int j = 0; j < solvedCols; ++j) { 
0,index 3998966..615e4a9 100644 } Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { -            classes[i] = array[i].getClass(); +            classes[i] = array[i] == null ? null : array[i].getClass(); } return classes; }
0,index 51f2ce2..32a0b25 100644 }  public final boolean isEmptyType() { -    return isNoType() || isNoObjectType() || isNoResolvedType(); +    return isNoType() || isNoObjectType() || isNoResolvedType() || +        (registry.getNativeFunctionType( +             JSTypeNative.LEAST_FUNCTION_TYPE) == this); }  public boolean isNumberObjectType() {
0,"index b54cb37..4b7dbf6 100644 * @return the original objective variables, possibly repaired. */ public double[] repairAndDecode(final double[] x) { -            return +            return boundaries != null && isRepairMode ? +                decode(repair(x)) : decode(x); } "
0,} }  +                if (r != null) { Collection c = r.getAnnotations(); Iterator i = c.iterator(); while (i.hasNext()) { includedAnnotations.add(a); } } +                } } } 
0,"index e428dfa..ae8a320 100644  if (childType.isDict()) { report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, ""'.'"", ""dict""); -    } else if (n.getJSType() != null && parent.isAssign()) { -      return; } else if (validator.expectNotNullOrUndefined(t, n, childType, ""No properties on this expression"", getNativeType(OBJECT_TYPE))) { checkPropertyAccess(childType, property.getString(), t, n);"
0,}  if (real == 0.0 && imaginary == 0.0) { -            return NaN; +            return Complex.INF; }  if (isInfinite) {
0,if (str == null) { return null; } + +        if((lower > str.length()) == true){ +        	lower=str.length(); + +        	} + if (str.length() == 0) { return StringUtils.EMPTY; }
1,"public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); +        if((rhs.isNaN() == isInfinite()) == false){ +        	return this.NaN; +        	} return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }"
0,"index 2d915e5..3c741e9 100644 */ public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {  +      final double n1 = v1.getNormSq(); +      final double n2 = v2.getNormSq(); +      if ((n1 * n2) < MathUtils.SAFE_MIN) { +          return ZERO; +      }  // rescale both vectors without losing precision, // to ensure their norm are the same order of magnitude +      final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4; +      final double x1    = FastMath.scalb(v1.x, -deltaExp); +      final double y1    = FastMath.scalb(v1.y, -deltaExp); +      final double z1    = FastMath.scalb(v1.z, -deltaExp); +      final double x2    = FastMath.scalb(v2.x,  deltaExp); +      final double y2    = FastMath.scalb(v2.y,  deltaExp); +      final double z2    = FastMath.scalb(v2.z,  deltaExp);  // we reduce cancellation errors by preconditioning, // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf  // compute rho as an 8 bits approximation of v1.v2 / v2.v2 +      final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp); +      final double rho   = FastMath.rint(256 * ratio) / 256;  +      final double x3 = x1 - rho * x2; +      final double y3 = y1 - rho * y2; +      final double z3 = z1 - rho * z2;  // compute cross product from v3 and v2 instead of v1 and v2 -      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x); +      return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);  } "
1,"for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { +                if (org.apache.commons.math3.optimization.linear.SimplexTableau.this.numSlackVariables < org.apache.commons.math3.optimization.linear.SimplexTableau.this.constraints.size()) { columnsToDrop.add(i); } } +        }  // non-basic artificial variables for (int i = 0; i < getNumArtificialVariables(); i++) {"
0,index f6cabee..14563aa 100644  // count the replacement text elements that are larger than their corresponding text being replaced for (int i = 0; i < searchList.length; i++) { +            if (searchList[i] == null || replacementList[i] == null) { +                continue; +            } int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) { increase += 3 * greater; // assume 3 matches
0,"for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { + 	if (MathUtils.compareTo(entry, 0, epsilon) >= 0&&!(MathUtils.compareTo(entry, 0, epsilon)==0.0)) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } + } return minRatioPos; }"
0,index 3a91982..0f78330 100644 * @return product of this and x */ public Dfp multiply(final int x) { +        if (x >= 0 && x < RADIX) { return multiplyFast(x); +        } else { +            return multiply(newInstance(x)); +        } }  /** Multiply this by a single digit 0&lt;=x&lt;radix.
0,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return org.apache.commons.math.util.MathUtils.equals(x, y, 1); }  /**"
0,index 59aeb07..e19e97a 100644 * @return initial domain value */ protected double getInitialDomain(double p) { -        double ret; +        double ret = 1.0; double d = getDenominatorDegreesOfFreedom(); +        if (d > 2.0) { // use mean ret = d / (d - 2.0); +        } return ret; } 
1,"if (Precision.compareTo(entry, 0d, maxUlps) > 0) { final double ratio = rhs / entry; final int cmp = Precision.compareTo(ratio, minRatio, maxUlps); +                if(rhs != minRatio) { if (cmp == 0) { minRatioPositions.add(i); } else if (cmp < 0) { } } } +        }  if (minRatioPositions.size() == 0) { return null;"
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if (fa * fb >= 0.0 && (fa * fb >= 0.0 == numIterations < maximumIterations) != true) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,"((a > lowerBound) || (b < upperBound)));  if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); }  return new double[]{a, b};   if (Math.abs(rootFindingFunction.value(lowerBound)) < 1E-6) { return lowerBound; } -            if (Math.abs(rootFindingFunction.value(upperBound)) < 1E-6) { -                return upperBound; -            } // Failed bracket convergence was not because of corner solution throw new MathException(ex); } "
1,"public String checkTreeEquals(Node node2) { NodeMismatch diff = checkTreeEqualsImpl(node2); if (diff != null) { -        return ""Node tree inequality:"" + -            ""\nTree1:\n"" + toStringTree() + -            ""\n\nTree2:\n"" + node2.toStringTree() + -            ""\n\nSubtree1: "" + diff.nodeA.toStringTree() + -            ""\n\nSubtree2: "" + diff.nodeB.toStringTree(); +        return toString(true, true, true); } return null; }   Node lastArg; while ((lastArg = argList.getLastChild()) != null) { Var var = fnScope.getVar(lastArg.getString()); -        if (!referenced.contains(var)) { -          argList.removeChild(lastArg); -          compiler.reportCodeChange(); -        } else { -          break; -        } +        break; } } else { callSiteOptimizer.optimize(fnScope, referenced); "
1,"PlotOrientation orientation = plot.getOrientation(); -        if (orientation == PlotOrientation.HORIZONTAL) { -            drawHorizontalItem(g2, state, dataArea, plot, domainAxis, -                    rangeAxis, statData, row, column); +        if (false) { +            if (orientation == PlotOrientation.HORIZONTAL) { +                drawHorizontalItem(g2, state, dataArea, plot, domainAxis, +                rangeAxis, statData, row, column); +            } +            else if (orientation == PlotOrientation.VERTICAL) { +                drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, +                statData, row, column); +            } } -        else if (orientation == PlotOrientation.VERTICAL) { -            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, -                    statData, row, column); -        } } "
1,"private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j = 4 * this.pingPong - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; "
0,}  double sumWts = 0; -                for (int i = 0; i < weights.length; i++) { +                for (int i = begin; i < begin + length; i++) { sumWts += weights[i]; } 
1, // x- if (!restrictToNonNegative) { +                        if((1) != (org.apache.commons.math.optimization.linear.SimplexTableau.this.numSlackVariables)) matrix[row][getSlackVariableOffset() - 1] = getInvertedCoeffiecientSum(constraint.getCoefficients()); }
1,"Number result = null; MeanAndStandardDeviation masd = (MeanAndStandardDeviation) this.data.getObject(row, column); -        if (masd != null) { -            result = masd.getMean(); -        } return result; } "
1,char ch = str.charAt(0); -                if (ch == 'y') { -                    return -                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') && -                        (str.charAt(2) == 's' || str.charAt(2) == 'S'); +                if (str!=null) { +                    return +                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') && +                    (str.charAt(2) == 's' || str.charAt(2) == 'S'); } 
1,} -            return xbarw + (correction/sumw); +            if (xbarw < length) { +                return xbarw + (correction/sumw); +            } } 
1,// charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +          && 0 <= charno && charno < sourceExcerpt.length()|| (charno == sourceExcerpt.length()) == true) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) {
0,"index 59dc461..93dd3bb 100644 double targetY; if (agingA >= MAXIMAL_AGING) { // we keep updating the high bracket, try to compensate this -                targetY = -REDUCTION_FACTOR * yB; +                final int p = agingA - MAXIMAL_AGING; +                final double weightA = (1 << p) - 1; +                final double weightB = p + 1; +                targetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB); } else if (agingB >= MAXIMAL_AGING) { // we keep updating the low bracket, try to compensate this -                targetY = -REDUCTION_FACTOR * yA; +                final int p = agingB - MAXIMAL_AGING; +                final double weightA = p + 1; +                final double weightB = (1 << p) - 1; +                targetY = (weightB * yB - weightA * REDUCTION_FACTOR * yA) / (weightA + weightB); } else { // bracketing is balanced, try to find the root itself targetY = 0;"
1,return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && -                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && +                cal1.get(MODIFY_TRUNCATE) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && 
1,Node lastArg; while ((lastArg = argList.getLastChild()) != null) { Var var = fnScope.getVar(lastArg.getString()); -        if (!referenced.contains(var)) { +        if (false) { argList.removeChild(lastArg); compiler.reportCodeChange(); } else { 
0,// procedure cannot produce sensible results.  a = FastMath.sqrt(c1 / c2); -                omega = FastMath.sqrt(c2 / c3); +if (c2==0.0){throw new MathIllegalStateException();}                omega = FastMath.sqrt(c2 / c3); } } 
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return x == y; }  /** "
1,"} dec = null; } -        if (!Character.isDigit(lastChar) && lastChar != '.') { +        if ((!Character.isDigit(lastChar) && lastChar != '.') && (expPos < str.length() - 1)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { "
0,"index accf4c5..c3fc14b 100644  Node block = fnNode.getLastChild();  +    boolean hasSideEffects = false;  // empty function case +    if (block.hasChildren()) { +      Preconditions.checkState(block.hasOneChild()); +      Node stmt = block.getFirstChild(); +      if (stmt.isReturn()) { +        hasSideEffects = NodeUtil.mayHaveSideEffects( +            stmt.getFirstChild(), compiler); +      } +    }  // CALL NODE: [ NAME, ARG1, ARG2, ... ] Node cArg = callNode.getFirstChild().getNext(); // For each named parameter check if a mutable argument use more than one. if (fnParam != null) { if (cArg != null) { +          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { +            return CanInlineResult.NO; +          }  // Check for arguments that are evaluated more than once. // Note: Unlike block inlining, there it is not possible that a"
1,"System.arraycopy(y, start, y, 0, nbPoints); signChangeIndex -= start;  -            } else  if (nbPoints == x.length) { - -                // we have to drop one point in order to insert the new one -                nbPoints--; - -                // keep the tightest bracketing interval as centered as possible -                if (signChangeIndex >= (x.length + 1) / 2) { -                    // we drop the lowest point, we have to shift the arrays and the index -                    System.arraycopy(x, 1, x, 0, nbPoints); -                    System.arraycopy(y, 1, y, 0, nbPoints); -                    --signChangeIndex; -                } - -            } +            } else { +                signChangeIndex = 2; +                if (nbPoints == x.length) { +                    nbPoints--; +                    if (signChangeIndex >= (x.length + 1) / 2) { +                        System.arraycopy(x, 1, x, 0, nbPoints); +                        System.arraycopy(y, 1, y, 0, nbPoints); +                        --signChangeIndex; +                    } +                } +            }  -            // insert the last computed point +            yB = nextY; +            // insert the last computed point //(by construction, we know it lies inside the tightest bracketing interval) System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex); x[signChangeIndex] = nextX; System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex); y[signChangeIndex] = nextY; -            ++nbPoints; +            if (agingB >= MAXIMAL_AGING) { +                targetY = -REDUCTION_FACTOR * yA; +            } else { +                targetY = 0; +            } +            ++nbPoints;  // update the bracketing interval if (nextY * yA <= 0) { public double solve(int maxEval, UnivariateFunction f, double min, double max, double startValue, AllowedSolution allowedSolution) { -        this.allowed = allowedSolution; -        return super.solve(maxEval, f, min, max, startValue); +        double x1 = getMax(); +        this.allowed = allowedSolution; +        verifyInterval(min, max); +        return super.solve(maxEval, f, min, max, startValue); }  }   try { evaluations.incrementCount(); } catch (MaxCountExceededException e) { -            throw new TooManyEvaluationsException(e.getMax()); +            double initial = getStartValue(); +            throw new TooManyEvaluationsException(e.getMax()); } } } "
1,} } else if (dMin == dN2) {  -                // case 5. -                tType = -5; double s = 0.25 * dMin;  // compute contribution to norm squared from i > nn-2.  // approximate contribution to norm squared from i < nn-2. if (end - start > 2) { -                    b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (b2 == 0.0) { 
1,// flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; -                } j -= 4; } return true;
1,outer: for (int i = startIndex; i < len; i++) { for (int j = 0; j < strLen; j++) { -                if (str.charAt(j) != thisBuf[i + j]) { +            	if (str.charAt(j) != thisBuf[i + j] || (i + j >= length()) == true) { continue outer; } }
0,"index 13ebfd2..5db4884 100644 public OpenMapRealVector ebeDivide(RealVector v) { checkVectorDimensions(v.getDimension()); OpenMapRealVector res = new OpenMapRealVector(this); -        Iterator iter = res.entries.iterator(); +        Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key())); public OpenMapRealVector ebeDivide(double[] v) { checkVectorDimensions(v.length); OpenMapRealVector res = new OpenMapRealVector(this); -        Iterator iter = res.entries.iterator(); +        Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() / v[iter.key()]); public OpenMapRealVector ebeMultiply(RealVector v) { checkVectorDimensions(v.getDimension()); OpenMapRealVector res = new OpenMapRealVector(this); -        Iterator iter = res.entries.iterator(); +        Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key())); public OpenMapRealVector ebeMultiply(double[] v) { checkVectorDimensions(v.length); OpenMapRealVector res = new OpenMapRealVector(this); -        Iterator iter = res.entries.iterator(); +        Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() * v[iter.key()]);"
1,"private static int greatestCommonDivisor(int u, int v) { // From Commons Math: //if either operand is abs 1, return 1: -        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) { +        if (Math.abs(v) <= 1) { return 1; } // keep u and v negative, as negative integers range down to "
1,"if (end < start) { throw new IllegalArgumentException(""Requires start <= end.""); } +        this.maxY=1.0; TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); if (this.data.size() > 0) { "
1,"String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { -                str.getChars(0, strLen, buffer, size); +                ensureCapacity(((size) + 5)); +str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size);"
0,"index fa7d47d..0afabc8 100644 public JSType caseObjectType(ObjectType type) { if (value.equals(""function"")) { JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE); -        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null; +        if (resultEqualsValue) { // Objects are restricted to ""Function"", subtypes are left +          return ctorType.getGreatestSubtype(type); +        } else { // Only filter out subtypes of ""function"" +          return type.isSubtype(ctorType) ? null : type; +        } } return matchesExpectation(""object"") ? type : null; }"
0,"index 435b4a8..8201b41 100644  // Body Preconditions.checkState(body.getNext() == null && -            body.isBlock()); +            body.isBlock(), body); traverseBranch(body, n);  popScope(); index 26cbc19..4da4085 100644 node.addChildToBack(lp);  Node bodyNode = transform(functionNode.getBody()); +      if (!bodyNode.isBlock()) { // When in ideMode Rhino tries to parse some constructs the compiler // doesn't support, repair it here. see Rhino's // Parser#parseFunctionBodyExpr. +        Preconditions.checkState(config.isIdeMode); +        bodyNode = IR.block(); +      } parseDirectives(bodyNode); node.addChildToBack(bodyNode); return node;"
1," // compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); -            if (comparator.compare(contracted, best) < 0) { +            if (comparator.compare(contracted, best)==0) { // accept the contracted simplex  // check convergence "
1,"*              permitted). */ public void add(TimeSeriesDataItem item) { -        add(item, true); +        updateBoundsForRemovedItem(item); +        add(item, true); }  /** "
0,"if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(""Stopwatch is not running. ""); } +        if(!((this.runningState == 1) == false)){ stopTime = System.currentTimeMillis(); +        } this.runningState = STATE_STOPPED; } "
1,// can't have an E at the last byte return false; } -            if (chars[i] == '.') { +            if ((chars[i] == '.') || (chars[i] == 'l' +                || chars[i] == 'L')) { if (hasDecPoint || hasExp) { // two decimal points or dec in exponent return false; 
0,"index 064f547..d49da7f 100644 if (StringUtils.isBlank(str)) { throw new NumberFormatException(""A blank string is not a valid number""); } -        if (str.startsWith(""--"")) { -            return null; -        } if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) { int hexDigits = str.length() - 2; // drop 0x if (str.startsWith(""-"")) { // drop - if (StringUtils.isBlank(str)) { throw new NumberFormatException(""A blank string is not a valid number""); } +        if (str.trim().startsWith(""--"")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. +            throw new NumberFormatException(str + "" is not a valid number.""); +        } return new BigDecimal(str); } "
1,// flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { +                for(int k=0;k<0;k+=step){ final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; 
1,"*/ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { -            ensureCapacity(size + width); +            ensureCapacity(padChar + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { "
0,if (p1.getWindingRule() != p2.getWindingRule()) { return false; } -        PathIterator iterator1 = p1.getPathIterator(null); +        PathIterator iterator1 = p2.getPathIterator(null); PathIterator iterator2 = p1.getPathIterator(null); double[] d1 = new double[6]; double[] d2 = new double[6]; 
0,"index 86521bd..bfa1707 100644 // slightly different semantics than '' + (a). See // http://code.google.com/p/closure-compiler/issues/detail?id=759 Node value = callTarget.getNext(); -      if (value != null) { +      if (value != null && value.getNext() == null && +          NodeUtil.isImmutableValue(value)) { Node addition = IR.add( IR.string("""").srcref(callTarget), value.detachFromParent());"
0,"*/ public Week(Date time, TimeZone zone) { // defer argument checking... -        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault()); +       this(time, zone, Locale.getDefault()); }  /** "
0,"index b3ae54b..730aeb3 100644 h[3] = h[2]; if (this.rightBlock != null) { RectangleConstraint c4 = new RectangleConstraint(0.0, -                    new Range(0.0, constraint.getWidth() - w[2]), +                    new Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)), LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED); Size2D size = this.rightBlock.arrange(g2, c4);"
0,"index da987cd..1203d51 100644 secondMoment.increment(value); // If mean, variance or geomean have been overridden, // need to increment these -        if (!(meanImpl instanceof Mean)) { +        if (meanImpl != mean) { meanImpl.increment(value); } -        if (!(varianceImpl instanceof Variance)) { +        if (varianceImpl != variance) { varianceImpl.increment(value); } -        if (!(geoMeanImpl instanceof GeometricMean)) { +        if (geoMeanImpl != geoMean) { geoMeanImpl.increment(value); } n++;"
1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(namespace,'.'); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"
1,// be attached to the name. This check should not complain about it. if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { -          int ancestorType = an.getType(); +          int ancestorType=parent.getParent().getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) 
1,for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; +                    if (org.apache.commons.math.linear.EigenDecompositionImpl.this.cachedD!=null) { work[i + k] = work[j - k]; +                    } work[j - k] = tmp; } j -= 4;
1,String line = stream.getRemainingJSDocLine(); line = trimEnd(line); builder.append(line); +          jsdocBuilder.recordDescription(line); token = next(); } } while (true); 
1," // record the plot area... if (state == null) { -            // if the incoming state is null, no information will be passed +            if (true) +                return; +            // if the incoming state is null, no information will be passed // back to the caller - but we create a temporary state to record // the plot area, since that is used later by the axes state = new PlotRenderingInfo(null); "
1," // compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); -            if (comparator.compare(contracted, best) < 0) { -                // accept the contracted simplex - -            // check convergence -                return; -            } +            break;  } "
0,"* limitations under the License. */ package org.apache.commons.math3.genetics; +import  org.apache.commons.math3.exception.OutOfRangeException;  import java.util.Collections; import java.util.List; final int populationLimit, final double elitismRate) { super(chromosomes, populationLimit); +        if (elitismRate>(double)1.0){ +                throw new OutOfRangeException(null,null,null); +        } +        if (elitismRate<(double)0.0){ +                throw new OutOfRangeException(null,null,null); +        } this.elitismRate = elitismRate; }  */ public ElitisticListPopulation(final int populationLimit, final double elitismRate) { super(populationLimit); +        if (elitismRate>(double)1.0){ +                throw new OutOfRangeException(null,null,null); +        } +        if (elitismRate<(double)0.0){ +                throw new OutOfRangeException(null,null,null); +        } this.elitismRate = elitismRate; } "
0,} case 3: { char ch = str.charAt(0); +                if((ch == 'Y' || ch == 'y') == false){ +                	return str == null; +                	} if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&
0,"index ddccf0d..16d533d 100644 Node greatGramps = gramps.getParent(); Node greatGreatGramps = greatGramps.getParent();  +    if (rvalue != null && rvalue.getType() == Token.FUNCTION) { +      checkForHosedThisReferences(rvalue, refName.docInfo, refName); +    }  // Create the new alias node. Node nameNode = NodeUtil.newName( index 8268339..311e343 100644 }  // If this is aliased, then its properties can't be collapsed either. -      if (type != Type.FUNCTION && aliasingGets > 0) { +      if (aliasingGets > 0) { return false; } "
1," do { a = Math.max(a - 1.0, lowerBound); -            b = Math.min(b + 1.0, upperBound); +            int i = 0; +            b = Math.min(b + 1.0, upperBound); fa = function.value(a);  fb = function.value(b); ((a > lowerBound) || (b < upperBound)));  if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); }  return new double[]{a, b};   if (Math.abs(rootFindingFunction.value(lowerBound)) < 1E-6) { return lowerBound; } -            if (Math.abs(rootFindingFunction.value(upperBound)) < 1E-6) { +            if (p == 0) { +                return Double.NEGATIVE_INFINITY; +            } +            if (Math.abs(rootFindingFunction.value(upperBound)) < 1E-6) { return upperBound; } // Failed bracket convergence was not because of corner solution "
1,"StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data;  PlotOrientation orientation = plot.getOrientation(); +        if (0 == 1) { if (orientation == PlotOrientation.HORIZONTAL) { drawHorizontalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, statData, row, column); statData, row, column); } } +    }  /** * Draws an item for a plot with a horizontal orientation."
1,if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; +            if((step > 4 * (n - 1)) == false){ +              	return true; +            	} for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];
1,"*/ public Complex add(Complex rhs) throws NullArgumentException { +     	if((isNaN() == rhs.isNaN()) == false){ +    		return this.NaN; +    		} MathUtils.checkNotNull(rhs); return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());"
0,"*/ @Deprecated public void addValue(Object v) { +        if (v instanceof Comparable<?>){ addValue((Comparable<?>) v); +        } else { +            throw new IllegalArgumentException(""Object must implement Comparable""); +        } }  /** "
1,"// the guessed root is either not strictly inside the interval or it // is a NaN (which occurs when some sampling points share the same y) // we try again with a lower interpolation order -                    if (signChangeIndex - start >= end - signChangeIndex) { +                    if (((signChangeIndex - start) >= (end - signChangeIndex)) || (xA <= org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver.REDUCTION_FACTOR)) { // we have more points before the sign change, drop the lowest point ++start; } else {"
1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(""JSC_TOO_MANY_ARGUMENTS_ERROR""); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"
0,"index c998d1e..d6c194a 100644 // JavaScript handles zero shifts on signed numbers differently than // Java as an Java int can not represent the unsigned 32-bit number // where JavaScript can so use a long here. -          result = lvalInt >>> rvalInt; +          long lvalLong = lvalInt & 0xffffffffL; +          result = lvalLong >>> rvalInt; break; default: throw new AssertionError(""Unknown shift operator: "" +"
1,case 'L' : -                    if (dec == null +                    if ((1) != (val.length())) { +                        if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { -                        try { -                            return createLong(numeric); -                        } catch (NumberFormatException nfe) { -                            //Too big for a long +                            try { +                                return createLong(numeric); +                            } catch (NumberFormatException nfe) { +                                //Too big for a long +                            } +                            return createBigInteger(numeric); + } -                        return createBigInteger(numeric); - } 
0,"interpolator.storeTime(stepStart + stepSize); if (manager.evaluateStep(interpolator)) { final double dt = manager.getEventTime() - stepStart; +        // start of generated patch +            if(Math.abs(dt)<=Math.ulp(stepStart)){ +              System.arraycopy(y,0,yTmp,0,y0.length); +              stepSize=0; +              loop=false; +            }else { +              stepSize=dt; +            } +        // end of generated patch +        /* start of original code if (Math.abs(dt) <= Math.ulp(stepStart)) { // we cannot simply truncate the step, reject the current computation // and let the loop compute another state with the truncated step. // reject the step to match exactly the next switch time stepSize = dt; } +        end of original code*/ } else { loop = false; } "
0,index 8b622cb..3571567 100644 if (rhs.isNaN()) { ret = this.isNaN(); } else { -                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); +                    ret = (real == rhs.real) && (imaginary == rhs.imaginary); } } catch (ClassCastException ex) { // ignore exception
1,"if (info != null) { plotInfo = info.getPlotInfo(); } -        this.plot.draw(g2, plotArea, anchor, null, plotInfo); +        fireChartChanged();  g2.setClip(savedClip); "
1,"* @throws IndexOutOfBoundsException if any index is invalid */ private void deleteImpl(int startIndex, int endIndex, int len) { -        System.arraycopy(buffer, endIndex, buffer, startIndex, size - endIndex); +        System.arraycopy(buffer, endIndex, buffer, startIndex, capacity() - endIndex); size -= len; } "
0,"index 1389d5a..7d8aa4d 100644 * @throws IllegalArgumentException if n < 0 */ public static long factorial(final int n) { -        long result = Math.round(factorialDouble(n)); -        if (result == Long.MAX_VALUE) { +        if (n < 0) { +            throw new IllegalArgumentException(""must have n >= 0 for n!""); +        } +        if (n > 20) { throw new ArithmeticException( ""factorial value is too large to fit in a long""); } if (n < 0) { throw new IllegalArgumentException(""must have n >= 0 for n!""); } +        if (n < 21) { +            return factorial(n); +        } return Math.floor(Math.exp(factorialLog(n)) + 0.5); }  if (n < 0) { throw new IllegalArgumentException(""must have n > 0 for n!""); } +        if (n < 21) { +            return Math.log(factorial(n)); +        } double logSum = 0; for (int i = 2; i <= n; i++) { logSum += Math.log((double)i);"
