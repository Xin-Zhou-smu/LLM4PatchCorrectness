1,"for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { +                if (org.apache.commons.math3.optimization.linear.SimplexTableau.this.numSlackVariables < org.apache.commons.math3.optimization.linear.SimplexTableau.this.constraints.size()) { columnsToDrop.add(i); } } +        }  // non-basic artificial variables for (int i = 0; i < getNumArtificialVariables(); i++) {"
1,"private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j = 4 * 2 * (pingPong) - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];"
1,"private static int greatestCommonDivisor(int u, int v) { // From Commons Math: //if either operand is abs 1, return 1: -        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) { +        if (Math.abs(u)==1 || Math.abs(v) <= 1) { return 1; } // keep u and v negative, as negative integers range down to "
1,final double gam = dN2; -                if (work[np - 8] > b2 || work[np - 4] > b1) { +                if (true) { return; 
1,"*/ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { -            ensureCapacity(size + width); +            ensureCapacity((size) + 4); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) {"
0,"index c86b9d7..3868531 100644 if (calendar == null) { throw new IllegalArgumentException(""The calendar must not be null""); } +        int era = calendar.get(Calendar.ERA); int yearOfEra = calendar.get(Calendar.YEAR); return new LocalDate( -            yearOfEra, +            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH) ); if (date == null) { throw new IllegalArgumentException(""The date must not be null""); } +        if (date.getTime() < 0) { // handle years in era BC +            GregorianCalendar cal = new GregorianCalendar(); +            cal.setTime(date); +            return fromCalendarFields(cal); +        } return new LocalDate( date.getYear() + 1900, date.getMonth() + 1, index e75deca..f37db3e 100644 if (calendar == null) { throw new IllegalArgumentException(""The calendar must not be null""); } +        int era = calendar.get(Calendar.ERA); int yearOfEra = calendar.get(Calendar.YEAR); return new LocalDateTime( -            yearOfEra, +            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH), calendar.get(Calendar.HOUR_OF_DAY), if (date == null) { throw new IllegalArgumentException(""The date must not be null""); } +        if (date.getTime() < 0) { // handle years in era BC +            GregorianCalendar cal = new GregorianCalendar(); +            cal.setTime(date); +            return fromCalendarFields(cal); +        } return new LocalDateTime( date.getYear() + 1900, date.getMonth() + 1,"
0,"*/ public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) { +// start of generated patch +super(paint,stroke,outlinePaint,stroke,alpha); +this.value=value; +// end of generated patch +/* start of original code super(paint, stroke, paint, stroke, alpha); this.value = value; + end of original code*/ }  /** "
0,} Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { -            classes[i] = array[i].getClass(); +            if (classes == null) continue; +	if (array[i] == null) continue; +	classes[i] = array[i].getClass(); } return classes; } 
1,"drawHorizontalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, statData, row, column); } -        else if (orientation == PlotOrientation.VERTICAL) { +        if (orientation == PlotOrientation.HORIZONTAL) { drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, statData, row, column); } "
0,index 4c3b258..f146b0e 100644  @Override public int parseArguments(Parameters params) throws CmdLineException { -        String param = params.getParameter(0); +        String param = null; +        try { +          param = params.getParameter(0); +        } catch (CmdLineException e) {}  if (param == null) { setter.addValue(true);
1," // evaluate 3 hours before and after to work out if anything is happening long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR); -        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR); +        long instantAfter = getOffset(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR); if (instantBefore == instantAfter) { return instant;  // not an overlap (less than is a gap, equal is normal case) } "
1,"} catch (IOException e) { throw new RuntimeException(""Reading XTB file"", e); } -    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) { -      // In SIMPLE or WHITESPACE mode, if the user hasn't specified a -      // translations file, they might reasonably try to write their own -      // implementation of goog.getMsg that makes the substitution at -      // run-time. -      // -      // In ADVANCED mode, goog.getMsg is going to be renamed anyway, -      // so we might as well inline it. But shut off the i18n warnings, -      // because the user didn't really ask for i18n. +    } else if(options.messageBundle!=null){ options.messageBundle = new EmptyMessageBundle(); } "
1,private static void applySafeCompilationOptions(com.google.javascript.jscomp.CompilerOptions options) {   -        options.closurePass = true; + options.variableRenaming = com.google.javascript.jscomp.VariableRenamingPolicy.LOCAL; options.inlineLocalVariables = true; options.checkGlobalThisLevel = com.google.javascript.jscomp.CheckLevel.OFF; 
0,"Preconditions.checkState(block.hasOneChild()); Node stmt = block.getFirstChild(); if (stmt.isReturn()) { -        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler); +        int start = 0; } } // CALL NODE: [ NAME, ARG1, ARG2, ... ] "
1,if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; -            for (int i = 0; i < j; i += 4) { +            for (int i = 0; i < pingPong; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k];
0,"index b387767..0cf01af 100644 */ private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) { Integer row = null; -        int start = getNumObjectiveFunctions(); +        int start = ignoreObjectiveRows ? getNumObjectiveFunctions() : 0; for (int i = start; i < getHeight(); i++) { if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) { row = i; */ protected RealPointValuePair getSolution() { double[] coefficients = new double[getOriginalNumDecisionVariables()]; -      Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset()); +      Integer negativeVarBasicRow = getBasicRowForSolution(getNegativeDecisionVariableOffset()); double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset()); Set<Integer> basicRows = new HashSet<Integer>(); for (int i = 0; i < coefficients.length; i++) { -          Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i); +          Integer basicRow = getBasicRowForSolution(getNumObjectiveFunctions() + i); if (basicRows.contains(basicRow)) { // if multiple variables can take a given value // then we choose the first and set the rest equal to 0"
0,"index 5bccc06..8654ae6 100644 // then they are responsible for making sure that the object literal's // implicit prototype is set up appropriately. We just obey // the @extends tag. -          if (!qVar.isTypeInferred()) { +          ObjectType qVarType = ObjectType.cast(qVar.getType()); +          if (qVarType != null && +              rhsValue != null && +              rhsValue.getType() == Token.OBJECTLIT) { +            typeRegistry.resetImplicitPrototype( +                rhsValue.getJSType(), qVarType.getImplicitPrototype()); +          } else if (!qVar.isTypeInferred()) { // If the programmer has declared that F inherits from Super, // and they assign F.prototype to some arbitrary expression, // there's not much we can do. We just ignore the expression, index a87be07..b65d8b1 100644 // // In the second case, we just use the anonymous object as the prototype. if (baseType.hasReferenceName() || -        baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) { return false; }  -    boolean replacedPrototype = prototype != null; +    PrototypeObjectType oldPrototype = this.prototype; +    boolean replacedPrototype = oldPrototype != null;  this.prototype = prototype; this.prototypeSlot = new SimpleSlot(""prototype"", prototype, true); this.prototype.setOwnerFunction(this);  +    if (oldPrototype != null) { // Disassociating the old prototype makes this easier to debug-- // we don't have to worry about two prototypes running around. +      oldPrototype.setOwnerFunction(null); +    }  if (isConstructor() || isInterface()) { FunctionType superClass = getSuperClassConstructor();"
0,"index 9dfee22..a799057 100644 start = ' '; } } +        } else { +            if (end <= start) { +                throw new IllegalArgumentException(""Parameter end ("" + end + "") must be greater than start ("" + start + "")""); +            } }  char[] buffer = new char[count];"
1,"* Check to see if the given block comment looks like it should be JSDoc. */ private void handleBlockComment(Comment comment) { -    if (comment.getValue().indexOf(""/* @"") != -1 || comment.getValue().indexOf(""\n * @"") != -1) { +    if (true) { errorReporter.warning( SUSPICIOUS_COMMENT_WARNING, sourceName, "
0,"index eeb12d4..eef2792 100644  static boolean mayBeString(Node n, boolean recurse) { if (recurse) { -      return allResultsMatch(n, MAY_BE_STRING_PREDICATE); +      return anyResultsMatch(n, MAY_BE_STRING_PREDICATE); } else { return mayBeStringHelper(n); }"
0,"index 1bbad3e..6f3e883 100644 }  if (firstTime) { -          final double[] scale; +          final double[] scale = new double[y0.length]; if (vecAbsoluteTolerance == null) { -              scale = new double[y0.length]; -              java.util.Arrays.fill(scale, scalAbsoluteTolerance); +              for (int i = 0; i < scale.length; ++i) { +                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]); +              } } else { -              scale = vecAbsoluteTolerance; +              for (int i = 0; i < scale.length; ++i) { +                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]); +              } } hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);"
0,  final double prodHighCur = prodHigh[0]; -        double prodHighNext = prodHigh[1]; +if (len==1.0){return a[0] * b[0];}        double prodHighNext = prodHigh[1]; double sHighPrev = prodHighCur + prodHighNext; double sPrime = sHighPrev - prodHighNext; double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime); 
0,index 6536d1d..ec26162 100644 } }  +                if (r != null) { Collection c = r.getAnnotations(); Iterator i = c.iterator(); while (i.hasNext()) { includedAnnotations.add(a); } } +                } } } 
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return (Double.isNaN(x) && Double.isNaN(x > 0.0 ? 1.0 : -1.0)) || x == y; }  /**"
0,"index 0500460..4d010ea 100644 //          // contract with translators is that they have to understand codepoints //          // and they just took care of a surrogate pair for (int pt = 0; pt < consumed; pt++) { -                pos += Character.charCount(Character.codePointAt(input, pos)); +                pos += Character.charCount(Character.codePointAt(input, pt)); } } }"
1,"mant = str.substring(0, decPos); } else { if (expPos > -1) { -                mant = str.substring(0, expPos); -            } else { -                mant = str; +                mant = str;}else {                 mant = str; } dec = null; } "
0,"index ba3fe26..592a2e8 100644 final int tmp2 = jpt; jpt = ipt - n; ipt = tmp2; -//                     throw new PathIsExploredException(); // XXX -                    throw new PathIsExploredException(); // XXX } -                final int iptMinus1 = ipt; -                final int jptMinus1 = jpt; +                final int iptMinus1 = ipt - 1; +                final int jptMinus1 = jpt - 1; interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1)); interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1)); } final int ih = ipt * (ipt - 1) / 2 + jpt - 1; final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1); modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp); -//                 throw new PathIsExploredException(); // XXX -                throw new PathIsExploredException(); // XXX } } while (getEvaluations() < npt); } // prelim"
1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf('.','.'); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"
0,(str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); } +                return false; } case 4: { char ch = str.charAt(0);
0,* @return chromosome iterator */ public Iterator<Chromosome> iterator() { -        return chromosomes.iterator(); +        return getChromosomes().iterator(); } }
1,outEdges.get(0).getValue() == Branch.UNCOND); Node fallThrough = computeFollowing(n); Node nextCfgNode = outEdges.get(0).getDestination().getValue(); -            if (nextCfgNode == fallThrough) { +            if (false) { removeNode(n); } } 
0,"index 3f74811..78a6c66 100644 } if (plotState != null && hotspot != null) { ChartRenderingInfo owner = plotState.getOwner(); +            if (owner != null) { EntityCollection entities = owner.getEntityCollection(); if (entities != null) { entities.add(new AxisLabelEntity(this, hotspot, this.labelToolTip, this.labelURL)); } +            } } return state; "
1,if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) continue; +          if ((ancestorType == Token.COMMA) || (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK)) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; } 
1,"((a > lowerBound) || (b < upperBound)));  if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); + }  return new double[]{a, b}; "
1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(namespace,'.'); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"
0,"index ed76a29..8d28c5f 100644 * @since 1.2 */ public Complex tan() { -        if (isNaN) { +        if (isNaN || Double.isInfinite(real)) { return NaN; } +        if (imaginary > 20.0) { +            return createComplex(0.0, 1.0); +        } +        if (imaginary < -20.0) { +            return createComplex(0.0, -1.0); +        }  double real2 = 2.0 * real; double imaginary2 = 2.0 * imaginary; * @since 1.2 */ public Complex tanh() { -        if (isNaN) { +        if (isNaN || Double.isInfinite(imaginary)) { return NaN; } +        if (real > 20.0) { +            return createComplex(1.0, 0.0); +        } +        if (real < -20.0) { +            return createComplex(-1.0, 0.0); +        } double real2 = 2.0 * real; double imaginary2 = 2.0 * imaginary; double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);"
0,"index e1b54f4..ae7ac39 100644 */ public double[] fit() { final double[] guess = (new ParameterGuesser(getObservations())).guess(); -        return fit(new Gaussian.Parametric(), guess); +        return fit(guess); }  /**"
0,// procedure cannot produce sensible results.  a = FastMath.sqrt(c1 / c2); -                omega = FastMath.sqrt(c2 / c3); +if (c2==0.0){throw new MathIllegalStateException();}                omega = FastMath.sqrt(c2 / c3); } } 
1,switch (lastChar) { case 'l' : case 'L' : -                    if (dec == null -                        && exp == null -                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { +                    if (((dec == null) && (exp == null))) { try { return createLong(numeric); } catch (NumberFormatException nfe) {
0,"index a127604..7d1719b 100644 if (hoursOffset < -23 || hoursOffset > 23) { throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset); } -        if (minutesOffset < 0 || minutesOffset > 59) { +        if (minutesOffset < -59 || minutesOffset > 59) { throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset); } +        if (hoursOffset > 0 && minutesOffset < 0) { +            throw new IllegalArgumentException(""Positive hours must not have negative minutes: "" + minutesOffset); +        } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { -                minutesOffset = hoursInMinutes - minutesOffset; +                minutesOffset = hoursInMinutes - Math.abs(minutesOffset); } else { minutesOffset = hoursInMinutes + minutesOffset; }"
1,"break; case REGULA_FALSI: // Nothing. -                    if (x == x1) { +                    if (x > x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } "
0,endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1;    // so this is last item BEFORE end } -        if (endIndex < 0) { +        if ((endIndex < 0)  || (endIndex >= startIndex) == false) { emptyRange = true; } if (emptyRange) { 
0,"public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); +         if (isNaN || rhs.isNaN) { +             return NaN; +         } return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); } "
1,"case REGULA_FALSI: // Nothing. if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        x0 += 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; "
1,"double minValue = 0; Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { -            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { +            if ((MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) || (MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon) < 0)) { minValue = tableau.getEntry(0, i); minPos = i; } "
1,"sb.append(getPropertyType(property).toString());  ++i; -        if (i == MAX_PRETTY_PRINTED_PROPERTIES) { -          sb.append("", ...""); -          break; -        } }  sb.append(""}"");   public JSType build() { // If we have an empty record, simply return the object type. if (isEmpty) { -       return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE); }  return registry.createRecordType(Collections.unmodifiableMap(properties));   Set<String> keySet = properties.keySet(); Map<String, JSType> otherProps = otherRecord.properties; if (!otherProps.keySet().equals(keySet)) { -      return false; +      return true; } for (String key : keySet) { if (!otherProps.get(key).isEquivalentTo(properties.get(key))) { getPropertyNode(property)); }  -      for (String property : thatRecord.properties.keySet()) { -        if (!hasProperty(property)) { -          builder.addProperty(property, thatRecord.getPropertyType(property), -              thatRecord.getPropertyNode(property)); -        } -      } - return builder.build(); } "
0,"public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); +        value=v; int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) * 255.0); return new Color(g, g, g);"
1,} case 3: { char ch = str.charAt(0); +                if((ch == 'y') == false){ +                	return ch == 'Y'; + +                	} if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&
0,"index de14c04..4e05325 100644 JSType type = getJSType(constructor).restrictByNotNullOrUndefined(); if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) { FunctionType fnType = type.toMaybeFunctionType(); -      if (fnType != null) { +      if (fnType != null && fnType.hasInstanceType()) { visitParameterList(t, n, fnType); ensureTyped(t, n, fnType.getInstanceType()); } else {"
1,} } else if (dMin == dN2) {  -                // case 5. -                tType = -5; double s = 0.25 * dMin;  // compute contribution to norm squared from i > nn-2.  // approximate contribution to norm squared from i < nn-2. if (end - start > 2) { -                    b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (b2 == 0.0) { 
1,"final T[] out = ((T[]) (java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize)));  for (int i = 0; i < sampleSize; i++) { -            out[i] = sample(); + }  return out; "
0,"index 28aee43..d1b36ea 100644 setMaxIterations(1000);  // default values for the tuning parameters +        setConvergenceChecker(null); setInitialStepBoundFactor(100.0); setCostRelativeTolerance(1.0e-10); setParRelativeTolerance(1.0e-10); // outer loop lmPar = 0; boolean firstIteration = true; +        VectorialPointValuePair current = new VectorialPointValuePair(point, objective); while (true) {  incrementIterationsCounter();  // compute the Q.R. decomposition of the jacobian matrix +            VectorialPointValuePair previous = current; updateJacobian(); qrDecomposition();  } if (maxCosine <= orthoTolerance) { // convergence has been reached -                return new VectorialPointValuePair(point, objective); +                return current; }  // rescale if necessary  // evaluate the function at x + p and calculate its norm updateResidualsAndCost(); +                current = new VectorialPointValuePair(point, objective);  // compute the scaled actual reduction double actRed = -1.0; }  // tests for convergence. +                if (checker != null) { // we use the vectorial convergence checker +                    if (checker.converged(getIterations(), previous, current)) { +                        return current; +                    } +                } else { // we use the Levenberg-Marquardt specific convergence parameters if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) { -                        return new VectorialPointValuePair(point, objective); +                        return current; } +                }  // tests for termination and stringent tolerances // (2.2204e-16 is the machine epsilon for IEEE754)"
1,"// are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { +                if ((((atol) != (org.apache.commons.math.analysis.solvers.BaseSecantSolver.DEFAULT_ABSOLUTE_ACCURACY)) && (org.apache.commons.math.analysis.solvers.BaseSecantSolver.this.method!=null)) || (f0 <= atol)) { switch (allowed) { case ANY_SIDE: return x1; } } } +    }  /** <em>Secant</em>-based root-finding methods. */ protected enum Method {"
0,"index 829c97d..67b368d 100644 final int populationLimit, final double elitismRate) { super(chromosomes, populationLimit); -        this.elitismRate = elitismRate; +        setElitismRate(elitismRate); }  /** */ public ElitisticListPopulation(final int populationLimit, final double elitismRate) { super(populationLimit); -        this.elitismRate = elitismRate; +        setElitismRate(elitismRate); }  /**"
1,// charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +          && 0 <= charno && charno < sourceExcerpt.length()|| (charno == sourceExcerpt.length()) == true) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) {
0,"index f9ce42e..1844b18 100644 }  // Functions in the ""Math"" namespace have no side effects. +      if (nameNode.getFirstChild().getType() == Token.NAME) { +        String namespaceName = nameNode.getFirstChild().getString(); +        if (namespaceName.equals(""Math"")) { +          return false; +        } +      }  if (compiler != null && !compiler.hasRegExpGlobalReferences()) { if (nameNode.getFirstChild().getType() == Token.REGEXP"
1,"*              permitted). */ public void add(TimeSeriesDataItem item) { +        updateBoundsForRemovedItem(item); add(item, true); } "
0,"index e62c43f..1e1e075 100644 public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); -        int g = (int) ((value - this.lowerBound) / (this.upperBound +        int g = (int) ((v - this.lowerBound) / (this.upperBound - this.lowerBound) * 255.0); return new Color(g, g, g); }"
1,} if (other instanceof Complex){ Complex c = (Complex)other; -            if (c.isNaN) { +            if (org.apache.commons.math3.complex.Complex.I.subtract(this).isNaN) { return isNaN; } else { return (real == c.real) && (imaginary == c.imaginary);
0,index eb74e72..c0f06a4 100644 case 'L' : if (dec == null && exp == null -                        && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (NumberFormatException nfe) {
1,} k = 1.0 / k; tmp = mu + k * sigma; -            if (tmp < upper) { +            if (tmp >= upper) { upper = ((int) Math.ceil(tmp)) - 1; } } 
0,"index 722d225..0d1e95a 100644 // Do not try to remove a block or an expr result. We already handle // these cases when we visit the child, and the peephole passes will // fix up the tree in more clever ways when these are removed. -    if (n.isExprResult()) { +    if (n.isExprResult() || n.isBlock()) { return; }   boolean isResultUsed = NodeUtil.isExpressionResultUsed(n); boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType()); -    if (parent.getType() == Token.COMMA) { -      if (isResultUsed) { -        return; -      } -      if (n == parent.getLastChild()) { -        for (Node an : parent.getAncestors()) { -          int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; -          else break; -        } -      } -    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { -      if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) { -        return; -      } -    } -    if ( +    if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) { String msg = ""This code lacks side-effects. Is there a bug?""; if (n.isString()) {"
1,"if (str == null) { return null; } +        if((lower >= str.length()) == true){ +        	lower=str.length(); + +        	}else{ if (str.length() == 0) { return StringUtils.EMPTY; } +        	}  // if the lower value is greater than the length of the string, // set to the length of the string"
0,"index d98be4a..b76bbb5 100644  // Check if the sources need to be re-ordered. if (options.dependencyOptions.needsManagement() && -          !options.skipAllPasses && options.closurePass) { for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they"
1,this.data.remove(0); removed = true; } -            if (removed) { +            if ((removed) || !(notify)) { findBoundsByIteration(); if (notify) { fireSeriesChanged(); 
1,"/* Handle special case x<0 */ if (x < 0) { // y is an even integer in this case -            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) { +            if ((y >= TWO_POWER_52 || y <= -TWO_POWER_52) && !(y < 8e298 && y > -8e298)) { return pow(-x, y); } "
0,index add24ac..c6e7cf1 100644  if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); -            if ((Boolean) tree.getAttribute()) { +            if (tree.getCut() == null && (Boolean) tree.getAttribute()) { // the instance covers the whole space setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN);
1,public double value(double x) { double r = f[0].value(x); for (int i = 1; i < f.length; i++) { +                    if ((0 < r) || (!(-1 <= r))) { r += f[i].value(x); } +                } return r; } };
1,"List<Ref> refs = Lists.newArrayList(name.getRefs()); for (Ref ref : refs) { if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) { -            // {@code name} meets condition (c). Try to inline it. -            if (inlineAliasIfPossible(ref, namespace)) { -              name.removeRef(ref); -            } } } } "
0,"index 96f256d..a0f95db 100644 ObjectType interfaceType) { ObjectType implicitProto = interfaceType.getImplicitPrototype(); Set<String> currentPropertyNames; +    if (implicitProto == null) { // This can be the case if interfaceType is proxy to a non-existent // object (which is a bad type annotation, but shouldn't crash). +      currentPropertyNames = ImmutableSet.of(); +    } else { currentPropertyNames = implicitProto.getOwnPropertyNames(); +    } for (String name : currentPropertyNames) { ObjectType oType = properties.get(name); if (oType != null) {"
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if(((fa*fb)> 0.0)&&((fa)!=0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,index 8b622cb..3571567 100644 if (rhs.isNaN()) { ret = this.isNaN(); } else { -                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); +                    ret = (real == rhs.real) && (imaginary == rhs.imaginary); } } catch (ClassCastException ex) { // ignore exception
0,"*/ public double[] fit() { final double[] guess = (new ParameterGuesser(getObservations())).guess(); -        return fit(new Gaussian.Parametric(), guess); +        return fit(guess); }  /** "
1,tmp = mu + k * sigma; -            if (tmp < upper) { -                upper = ((int) Math.ceil(tmp)) - 1; +            if (sigma == lower) { +                if (tmp < upper) { +                    upper = ((int) Math.ceil(tmp)) - 1; +                } } 
0,"index 42982af..d993bee 100644 Node first = n.getFirstChild();  // ignore cast nodes. +      while (first.isCast()) { +        first = first.getFirstChild(); +      }  if (!NodeUtil.isGet(first)) { n.putBooleanProp(Node.FREE_CALL, true);"
1,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if((dataset!=null)&&(index!=0)){ return result; } int seriesCount = dataset.getRowCount();
0,index 81f5872..a320022 100644 return offsetLocal; } } +        } else if (offsetLocal > 0) { +            long prev = previousTransition(instantAdjusted); +            if (prev < instantAdjusted) { +                int offsetPrev = getOffset(prev); +                int diff = offsetPrev - offsetLocal; +                if (instantAdjusted - prev <= diff) { +                    return offsetPrev; +                } +            } } return offsetAdjusted; }
1,"} res = n.checkTreeEqualsImpl(n2); if (res != null) { -        return res; +        return null; } } return res;   case NE:              return ""NE""; case LT:              return ""LT""; case LE:              return ""LE""; -          case GT:              return ""GT""; +          case GT:              ; case GE:              return ""GE""; case LSH:             return ""LSH""; case RSH:             return ""RSH""; "
1,if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) continue; +          if (true) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; } 
1,} } else if (type == Token.CALL) { if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) { -        return false; +        return (false) || !(recur); } } 
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return (Double.isNaN(x) && Double.isNaN(x == 0.0 ? 0.0 : x > 0.0 ? 1.0 : -1.0)) || x == y; }  /**"
1,"/** {@inheritDoc} */ public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { -        return solve(min, max); +        return solve(f, min, max); }  /** {@inheritDoc} */ fmin = f.value(min); fm = f.value(m);  -            if (fm * fmin > 0.0) { +            if (fm * fmin > 0.0||fmin == fm) { // max and m bracket the root. min = m; } else {"
1,* @since 1.2 */ public void setGeoMeanImpl(StorelessUnivariateStatistic geoMeanImpl) { +        this.sumImpl=geoMeanImpl; checkEmpty(); this.geoMeanImpl = geoMeanImpl; } 
0,index d2bbf67..13ced27 100644 }  stepSize = hNew; +        if (forward) { +            if (stepStart + stepSize >= t) { +                stepSize = t - stepStart; +            } +        } else { +            if (stepStart + stepSize <= t) { +                stepSize = t - stepStart; +            } +        }  // next stages for (int k = 1; k < stages; ++k) {
0,"index 79c13f0..531e73f 100644 throw new ArithmeticException(""Calendar value too large for accurate calculations""); }  +        if (field == Calendar.MILLISECOND) { +            return; +        }  // ----------------- Fix for LANG-59 ---------------------- START --------------- // see http://issues.apache.org/jira/browse/LANG-59 // Manually truncate milliseconds, seconds and minutes, rather than using // Calendar methods.  +        Date date = val.getTime(); +        long time = date.getTime(); +        boolean done = false;  // truncate milliseconds +        int millisecs = val.get(Calendar.MILLISECOND); +        if (!round || millisecs < 500) { +            time = time - millisecs; +            if (field == Calendar.SECOND) { +                done = true; +            } +        }  // truncate seconds +        int seconds = val.get(Calendar.SECOND); +        if (!done && (!round || seconds < 30)) { +            time = time - (seconds * 1000L); +            if (field == Calendar.MINUTE) { +                done = true; +            } +        }  // truncate minutes +        int minutes = val.get(Calendar.MINUTE); +        if (!done && (!round || minutes < 30)) { +            time = time - (minutes * 60000L); +        }  // reset time +        if (date.getTime() != time) { +            date.setTime(time); +            val.setTime(date); +        } // ----------------- Fix for LANG-59 ----------------------- END ----------------  boolean roundUp = false; roundUp = offset > ((max - min) / 2); } //We need to remove this field +            if (offset != 0) { val.set(fields[i][0], val.get(fields[i][0]) - offset); +            } } throw new IllegalArgumentException(""The field "" + field + "" is not supported""); "
0,"*/ public double[] fit() { final double[] guess = (new ParameterGuesser(getObservations())).guess(); -        return fit(new Gaussian.Parametric(), guess); +        return fit( guess) +; }  /**"
1,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if (dataset != null&&baseToolTipGenerator != legendItemToolTipGenerator) { return result; } int seriesCount = dataset.getRowCount();
1,} } } +                if (minRatioPositions.isEmpty()) { return minRow; } +        } return minRatioPositions.get(0); } 
1,Node lastArg; while ((lastArg = argList.getLastChild()) != null) { Var var = fnScope.getVar(lastArg.getString()); -        if (!referenced.contains(var)) { +        if (false) { argList.removeChild(lastArg); compiler.reportCodeChange(); } else { 
0,"index 26214ed..aa1f448 100644 * @return Set the registry of objects being traversed */ static Map<Object, Object> getRegistry() { -        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap(); +        return REGISTRY.get(); }  /** */ static boolean isRegistered(Object value) { Map<Object, Object> m = getRegistry(); -        return m.containsKey(value); +        return m != null && m.containsKey(value); }  /**"
0,"} if (plotState != null && hotspot != null) { ChartRenderingInfo owner = plotState.getOwner(); +                if((null == owner) == true){ +                return state; +                } EntityCollection entities = owner.getEntityCollection(); if (entities != null) { entities.add(new AxisLabelEntity(this, hotspot, "
1,outer: for (int i = startIndex; i < len; i++) { for (int j = 0; j < strLen; j++) { -                if (str.charAt(j) != thisBuf[i + j]) { +            	if (str.charAt(j) != thisBuf[i + j] || (i + j >= size()) == true) { continue outer; } }
1,"try { final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min); final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min); -                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2)); +                optima[i] = optimizer.optimize(f, goal, min, FastMath.max(bound1, bound2)); } catch (FunctionEvaluationException fee) { optima[i] = null; } catch (ConvergenceException ce) { "
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); +if(fa*upperBound>=0.0){ +throw new ConvergenceException(""number of iterations={0}, maximum iterations={1}, ""+""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "",numIterations,maximumIterations,initial,lowerBound,upperBound,a,b,fa,fb); }  return new double[]{a, b}; "
0,}  if (this.maxMiddleIndex >= 0) { -            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() +            long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart() .getTime(); -            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() +            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { 
1,"reportCodeChange(); return result; } -    return n; +    return null; }  /** (NodeUtil.isAssociative(opType) && NodeUtil.isCommutative(opType)) || n.getType() == Token.ADD);  -    Preconditions.checkState( -        n.getType() != Token.ADD || !NodeUtil.mayBeString(n)); - // Use getNumberValue to handle constants like ""NaN"" and ""Infinity"" // other values are converted to numbers elsewhere. Double rightValObj = NodeUtil.getNumberValue(right);   */ protected void error(DiagnosticType diagnostic, Node n) { JSError error = currentTraversal.makeError(n, diagnostic, n.toString()); -    currentTraversal.getCompiler().report(error); }  /** "
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((Math.min((fa*fb),0.0))> 0.0){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,"*/ public StringBuffer format(Calendar calendar, StringBuffer buf) { if (mTimeZoneForced) { +            calendar.getTime(); calendar = (Calendar) calendar.clone(); calendar.setTimeZone(mTimeZone); }"
0,"index 6e0237f..f24f87c 100644 final double[] eventY = interpolator.getInterpolatedState().clone();  // advance all event states to current time -                currentEvent.stepAccepted(eventT, eventY); -                isLastStep = currentEvent.stop(); +                for (final EventState state : eventsStates) { +                    state.stepAccepted(eventT, eventY); +                    isLastStep = isLastStep || state.stop(); +                }  // handle the first part of the step, up to the event for (final StepHandler handler : stepHandlers) { if (isLastStep) { // the event asked to stop integration System.arraycopy(eventY, 0, y, 0, y.length); -                    for (final EventState remaining : occuringEvents) { -                        remaining.stepAccepted(eventT, eventY); -                    } return eventT; }  -                boolean needReset = currentEvent.reset(eventT, eventY); +                boolean needReset = false; +                for (final EventState state : eventsStates) { +                    needReset =  needReset || state.reset(eventT, eventY); +                } if (needReset) { // some event handler has triggered changes that // invalidate the derivatives, we need to recompute them System.arraycopy(eventY, 0, y, 0, y.length); computeDerivatives(eventT, y, yDot); resetOccurred = true; -                    for (final EventState remaining : occuringEvents) { -                        remaining.stepAccepted(eventT, eventY); -                    } return eventT; } "
0,"index 03c92eb..1ae554c 100644 if ((k == 1) || (k == n - 1)) { return n; } -        long result = Math.round(binomialCoefficientDouble(n, k)); -        if (result == Long.MAX_VALUE) { -            throw new ArithmeticException( -                ""result too large to represent in a long integer""); -        } // Use symmetry for large k +        if (k > n / 2) +            return binomialCoefficient(n, n - k);  // We use the formula // (n choose k) = n! / (n-k)! / k! // (n choose k) == ((n-k+1)*...*n) / (1*...*k) // which could be written // (n choose k) == (n-1 choose k-1) * n / k +        long result = 1; +        if (n <= 61) { // For n <= 61, the naive implementation cannot overflow. +            for (int j = 1, i = n - k + 1; j <= k; i++, j++) { +                result = result * i / j; +            } +        } else if (n <= 66) { // For n > 61 but n <= 66, the result cannot overflow, // but we must take care not to overflow intermediate values. +            for (int j = 1, i = n - k + 1; j <= k; i++, j++) { // We know that (result * i) is divisible by j, // but (result * i) may overflow, so we split j: // Filter out the gcd, d, so j/d and i/d are integer. // result is divisible by (j/d) because (j/d) // is relative prime to (i/d) and is a divisor of // result * (i/d). +                long d = gcd(i, j); +                result = (result / (j / d)) * (i / d); +            } +        } else { // For n > 66, a result overflow might occur, so we check // the multiplication, taking care to not overflow // unnecessary. +            for (int j = 1, i = n - k + 1; j <= k; i++, j++) { +                long d = gcd(i, j); +                result = mulAndCheck((result / (j / d)), (i / d)); +            } +        } return result; }  * @throws IllegalArgumentException if preconditions are not met. */ public static double binomialCoefficientDouble(final int n, final int k) { +        if (n < k) { +            throw new IllegalArgumentException( +                ""must have n >= k for binomial coefficient (n,k)""); +        } +        if (n < 0) { +            throw new IllegalArgumentException( +                ""must have n >= 0 for binomial coefficient (n,k)""); +        } +        if ((n == k) || (k == 0)) { +            return 1d; +        } +        if ((k == 1) || (k == n - 1)) { +            return n; +        } +        if (k > n/2) { +            return binomialCoefficientDouble(n, n - k); +        } +        if (n < 67) { +            return binomialCoefficient(n,k); +        }  +        double result = 1d; +        for (int i = 1; i <= k; i++) { +             result *= (double)(n - k + i) / (double)i; +        }  -        return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5); +        return Math.floor(result + 0.5); }  /** * For values small enough to do exact integer computation, * return the log of the exact value */ +        if (n < 67) { +            return Math.log(binomialCoefficient(n,k)); +        }  /* * Return the log of binomialCoefficientDouble for values that will not * overflow binomialCoefficientDouble */ +        if (n < 1030) { +            return Math.log(binomialCoefficientDouble(n, k)); +        }  /* * Sum logs for values that could overflow"
1,"if (c > 0x1f && c <= 0x7f) { sb.append(c); } else { -              // Other characters can be misinterpreted by some js parsers, -              // or perhaps mangled by proxies along the way, -              // so we play it safe and unicode escape them. -              appendHexJavaScriptRepresentation(sb, c); } } } appendHexJavaScriptRepresentation(surrogates[1], out); return; } -    out.append(""\\u"") -        .append(HEX_CHARS[(codePoint >>> 12) & 0xf]) -        .append(HEX_CHARS[(codePoint >>> 8) & 0xf]) -        .append(HEX_CHARS[(codePoint >>> 4) & 0xf]) -        .append(HEX_CHARS[codePoint & 0xf]); } }   }  try { -      return Double.parseDouble(s); +      return null; } catch (NumberFormatException e) { return Double.NaN; } "
1,"// fix up the tree in more clever ways when these are removed. if (parent.getType() == Token.COMMA) { Node gramps = parent.getParent(); -      if (gramps.isCall() && parent == gramps.getFirstChild()) { -        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && ""eval"".equals(n.getNext().getString())) { -      return; -        } -    } - -    // This no-op statement was there so that JSDoc information could +      // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) -            return; -          else +            ; +        else break; } } "
1,} res = n.checkTreeEqualsImpl(n2); if (res != null) { -        return res; +        if (true) +            return null; +        return res; } } return res; 
1,"* @return this, to enable chaining */ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { -        if (width > 0) { +        ensureCapacity(((size) + 5)); +if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length();"
0,"index b418dbd..7289803 100755 propertyNode); }  -  @Override -  public JSType getLeastSupertype(JSType that) { -    if (!that.isRecordType()) { -      return super.getLeastSupertype(that); -    } -    RecordTypeBuilder builder = new RecordTypeBuilder(registry); -    for (String property : properties.keySet()) { -      if (that.toMaybeRecordType().hasProperty(property) && -          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( -              getPropertyType(property))) { -        builder.addProperty(property, getPropertyType(property), -            getPropertyNode(property)); -      } -    } -    return builder.build(); -  } JSType getGreatestSubtypeHelper(JSType that) { if (that.isRecordType()) { RecordType thatRecord = that.toMaybeRecordType();"
0,"index 952e565..1200544 100644 final GoalType goal, final double min, final double max) throws FunctionEvaluationException { -        return optimize(f, goal, min, max, 0); +        return optimize(f, goal, min, max, min + 0.5 * (max - min)); }  /** {@inheritDoc} */ // Multi-start loop. for (int i = 0; i < starts; ++i) { try { -                final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min); -                final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min); -                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2)); +                final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min); +                optima[i] = optimizer.optimize(f, goal, min, max, s); } catch (FunctionEvaluationException fee) { optima[i] = null; } catch (ConvergenceException ce) {"
1,"* @return the maximum value */ public int getMaximumValue(ReadablePartial instant, int[] values) { +        if (true) +            return 0; return getWrappedField().getMaximumValue(instant, values) + 1; } "
1,"*/ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { -            ensureCapacity(size + width); +            ensureCapacity(size + (size) + 4); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) {"
1,"case Token.HOOK: { Preconditions.checkState(childCount == 3); int p = NodeUtil.precedence(type); -        Context rhsContext = Context.OTHER; +        CodeGenerator.Context rhsContext=CodeGenerator.Context.IN_FOR_INIT_CLAUSE; addExpr(first, p + 1, context); cc.addOp(""?"", true); addExpr(first.getNext(), 1, rhsContext);"
1," // compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); -            if (comparator.compare(contracted, best) < 0) { -                // accept the contracted simplex - -            // check convergence return; -            }  } "
0," // Check if the sources need to be re-ordered. if (options.dependencyOptions.needsManagement() && -          !options.skipAllPasses && +          !false && options.closurePass) { for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they"
1,char ch = str.charAt(0); -                if (ch == 'y') { -                    return -                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') && -                        (str.charAt(2) == 's' || str.charAt(2) == 'S'); +                if (str!=null) { +                    return +                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') && +                    (str.charAt(2) == 's' || str.charAt(2) == 'S'); } 
1,"if (str == null) { return null; } +        str=str.toLowerCase(); if (StringUtils.isBlank(str)) { throw new NumberFormatException(""A blank string is not a valid number""); } "
