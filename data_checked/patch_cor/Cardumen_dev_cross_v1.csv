1,"List<Ref> refs = Lists.newArrayList(name.getRefs()); for (Ref ref : refs) { if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) { -            // {@code name} meets condition (c). Try to inline it. -            if (inlineAliasIfPossible(ref, namespace)) { -              name.removeRef(ref); -            } } } } "
1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(""JSC_LATE_PROVIDE_ERROR""); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"
0,"index 253f3c5..b881bb2 100644  int n = 1; double dPrev = 0.0; -        double p0 = 1.0; -        double q1 = 1.0; double cPrev = hPrev; double hN = hPrev;  final double a = getA(n, x); final double b = getB(n, x);  -            double cN = a * hPrev + b * p0; -            double q2 = a * q1 + b * dPrev; -            if (Double.isInfinite(cN) || Double.isInfinite(q2)) { -                double scaleFactor = 1d; -                double lastScaleFactor = 1d; -                final int maxPower = 5; -                final double scale = FastMath.max(a,b); -                if (scale <= 0) {  // Can't scale -                    throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x); -                } -                for (int i = 0; i < maxPower; i++) { -                    lastScaleFactor = scaleFactor; -                    scaleFactor *= scale; -                    if (a != 0.0 && a > b) { -                        cN = hPrev / lastScaleFactor + (b / scaleFactor * p0); -                        q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev); -                    } else if (b != 0) { -                        cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor; -                        q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor; -                    } -                    if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) { -                        break; -                    } -                } +            double dN = a + b * dPrev; +            if (Precision.equals(dN, 0.0, small)) { +                dN = small; +            } +            double cN = a + b / cPrev; +            if (Precision.equals(cN, 0.0, small)) { +                cN = small; }  -            final double deltaN = cN / q2 / cPrev; -            hN = cPrev * deltaN; +            dN = 1 / dN; +            final double deltaN = cN * dN; +            hN = hPrev * deltaN;  if (Double.isInfinite(hN)) { throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, break; }  -            dPrev = q1; -            cPrev = cN / q2; -            p0 = hPrev; -            hPrev = cN; -            q1 = q2; +            dPrev = dN; +            cPrev = cN; +            hPrev = hN; n++; } "
0,index 52a4436..9a24c00 100644 return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && -                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && +                cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&
0,"index b54cb37..4b7dbf6 100644 * @return the original objective variables, possibly repaired. */ public double[] repairAndDecode(final double[] x) { -            return +            return boundaries != null && isRepairMode ? +                decode(repair(x)) : decode(x); } "
1,"*/ public Complex add(Complex rhs) throws NullArgumentException { +        if ((isNaN) || (rhs.isNaN)) {    return org.apache.commons.math.complex.Complex.NaN;} MathUtils.checkNotNull(rhs); return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }"
0,"index 3b84fdc..b9ec964 100644 DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); -                if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) { +                if (compare < 0) { throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName()); } else if (compare == 0) { if (compare > 0) { break; } else if (compare == 0) { +                            if (fieldType.getRangeDurationType() == null) { +                                break; +                            } DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) { index 7e0ce57..bf44e01 100644 * @return zero always */ public int compareTo(DurationField durationField) { +        if (durationField.isSupported()) { +            return 1; +        } return 0; } "
1,*/ protected double calculateNumericalVariance() { final double N = getPopulationSize(); -        final double m = getNumberOfSuccesses(); -        final double n = getSampleSize(); +        final int m = getNumberOfSuccesses(); +        final int n = getSampleSize(); return (n * m * (N - n) * (N - m)) / (N * N * (N - 1)); } 
1,"reportCodeChange(); return result; } -    return n; +    return null; }  /** (NodeUtil.isAssociative(opType) && NodeUtil.isCommutative(opType)) || n.getType() == Token.ADD);  -    Preconditions.checkState( -        n.getType() != Token.ADD || !NodeUtil.mayBeString(n)); - // Use getNumberValue to handle constants like ""NaN"" and ""Infinity"" // other values are converted to numbers elsewhere. Double rightValObj = NodeUtil.getNumberValue(right);   */ protected void error(DiagnosticType diagnostic, Node n) { JSError error = currentTraversal.makeError(n, diagnostic, n.toString()); -    currentTraversal.getCompiler().report(error); }  /** "
0,"index 2116f7c..0c73f42 100644 * * @return the version, for example 131 for Java 1.3.1 */ -    static float toJavaVersionInt(String version) { +    static int toJavaVersionInt(String version) { return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE)); } "
0,"index 1bbad3e..6f3e883 100644 }  if (firstTime) { -          final double[] scale; +          final double[] scale = new double[y0.length]; if (vecAbsoluteTolerance == null) { -              scale = new double[y0.length]; -              java.util.Arrays.fill(scale, scalAbsoluteTolerance); +              for (int i = 0; i < scale.length; ++i) { +                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]); +              } } else { -              scale = vecAbsoluteTolerance; +              for (int i = 0; i < scale.length; ++i) { +                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]); +              } } hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);"
0,"index d2a4e5d..cca8d9b 100644 @Override Node processAssignment(Assignment assignmentNode) { Node assign = processInfixExpression(assignmentNode); +      Node target = assign.getFirstChild(); +      if (!validAssignmentTarget(target)) { +        errorReporter.error( +          ""invalid assignment target"", +          sourceName, +          target.getLineno(), """", 0); +      } return assign; }  operand.setDouble(-operand.getDouble()); return operand; } else { +        if (type == Token.INC || type == Token.DEC) { +          if (!validAssignmentTarget(operand)) { +            String msg = (type == Token.INC) +                ? ""invalid increment target"" +                : ""invalid decrement target""; +            errorReporter.error( +              msg, +              sourceName, +              operand.getLineno(), """", 0); +          } +        }  Node node = newNode(type, operand); if (exprNode.isPostfix()) { } }  +    private boolean validAssignmentTarget(Node target) { +      switch (target.getType()) { +        case Token.NAME: +        case Token.GETPROP: +        case Token.GETELEM: +          return true; +      } +      return false; +    }  @Override Node processVariableDeclaration(VariableDeclaration declarationNode) {"
1,"compiler.getCodingConvention(), globalName, value, -                v.getJSDocInfo()) +                grandparent.getJSDocInfo()) .useSourceInfoIfMissingFromForTree(n); NodeUtil.setDebugInformation( newDecl.getFirstChild().getFirstChild(), n, name); "
0,"index cfdccbe..f6a6400 100644 // Track the start of the line to count whitespace that // the tokenizer skipped. Because this case is rare, it's easier // to do this here than in the tokenizer. +    int lineStartChar = -1;  do { switch (token) { case STAR: if (ignoreStar) { // Mark the position after the star as the new start of the line. +            lineStartChar = stream.getCharno() + 1; } else { // The star is part of the comment. if (builder.length() > 0) { }  ignoreStar = true; +          lineStartChar = 0; token = next(); continue;  ignoreStar = false; state = State.SEARCHING_ANNOTATION;  +          boolean isEOC = token == JsDocToken.EOC; +          if (!isEOC) { +            if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE) { +              int numSpaces = stream.getCharno() - lineStartChar; +              for (int i = 0; i < numSpaces; i++) { +                builder.append(' '); +              } +              lineStartChar = -1; +            } else if (builder.length() > 0) { // All tokens must be separated by a space. +              builder.append(' '); +            } +          }  if (token == JsDocToken.EOC || token == JsDocToken.EOF || return new ExtractionInfo(multilineText, token); }  -          if (builder.length() > 0) { -            builder.append(' '); -          } builder.append(toString(token));  line = stream.getRemainingJSDocLine();"
1,"if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); +            if (false) { +                throw new ConvergenceException( +                ""number of iterations={0}, maximum iterations={1}, "" + +                ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + +                ""final b value={6}, f(a)={7}, f(b)={8}"", +                numIterations, maximumIterations, initial, +                lowerBound, upperBound, a, b, fa, fb); +            } } "
1,"if (end < start) { -            throw new IllegalArgumentException(""Requires start <= end.""); +            if (org.jfree.data.time.TimeSeries.DEFAULT_RANGE_DESCRIPTION.length() == org.jfree.data.time.TimeSeries.this.data.size()) { +                throw new IllegalArgumentException(""Requires start <= end.""); +            } } "
1,protected double getInitialDomain(double p) { double ret; double d = getDenominatorDegreesOfFreedom(); -            // use mean -            ret = d / (d - 2.0); +            ret = 1.0; return ret; } 
1,if (cls == null) { return StringUtils.EMPTY; } -        return getShortClassName(cls.getName()); +        return getShortCanonicalName(cls.getName()); }  /** 
1,"case REGULA_FALSI: // Nothing. if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        x0 = 0.5 * (f0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; "
1,"throw new IllegalArgumentException(""Requires start >= 0.""); } if (end < start) { +            if (org.jfree.data.time.TimeSeries.this.data.size() == org.jfree.data.time.TimeSeries.this.range.length()) { throw new IllegalArgumentException(""Requires start <= end.""); } +        } TimeSeries copy = (TimeSeries) super.clone();  copy.data = new java.util.ArrayList();"
1,"Vector3D k     = v1Su1.crossProduct(v2Su2); Vector3D u3    = u1.crossProduct(u2); double c       = k.dotProduct(u3); -  if (c == 0) { +  if (c <= 0) { // the (q1, q2, q3) vector is close to the (u1, u2) plane // we try other vectors Vector3D v3 = Vector3D.crossProduct(v1, v2); "
1,double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; -                if (work[np - 8] > b2 || work[np - 4] > b1) { +                if (work[np - 8] <= b2 || work[np - 4] > b1) { return; } double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); 
1,"private static int greatestCommonDivisor(int u, int v) { // From Commons Math: //if either operand is abs 1, return 1: -        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) { +        if (Math.abs(u)==1 || Math.abs(v) <= 1) { return 1; } // keep u and v negative, as negative integers range down to "
1,} k = 1.0 / k; tmp = mu + (k * sigma); -            if (tmp < upper) { +            if (false) { upper = ((int) (java.lang.Math.ceil(tmp))) - 1; } } 
1,"if (lower > upper) { String msg = ""Range(double, double): require lower ("" + lower + "") <= upper ("" + upper + "").""; -            throw new IllegalArgumentException(msg); + } this.lower = lower; this.upper = upper; "
1,"if (this.leftBlock != null) { Size2D size = this.leftBlock.arrange(g2, c2); w[2] = size.width; -            h[2] = size.height; +            this.topBlock = null; +            h[2] = size.height; } if (this.rightBlock != null) { double maxW = Math.max(width - w[2], 0.0); h[0] = size.height; } w[1] = w[0]; -        if (this.bottomBlock != null) { -            RectangleConstraint c2 = new RectangleConstraint(w[0], null, -                    LengthConstraintType.FIXED, 0.0, new Range(0.0, -                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE); -            Size2D size = this.bottomBlock.arrange(g2, c2); -            h[1] = size.height; -        } -        h[2] = constraint.getHeight() - h[1] - h[0]; +        Size2D s1 = arrangeNN(container, g2); +        this.rightBlock = null; +        h[2] = constraint.getHeight() - h[1] - h[0]; if (this.leftBlock != null) { RectangleConstraint c3 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth()), "
0,"index c5ca8cd..18a05ef 100644 if (val.length() == 0) { throw new NumberFormatException(""\""\"" is not a valid number.""); } +        if (val.length() == 1 && !Character.isDigit(val.charAt(0))) { +            throw new NumberFormatException(val + "" is not a valid number.""); +        } if (val.startsWith(""--"")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear"
0,"index ff09646..5006065 100644 if (g0Positive ^ (gb >= 0)) { // there is a sign change: an event is expected during this step  +                    if (ga * gb > 0) { // this is a corner case: // - there was an event near ta, // - there is another event between ta and tb // this implies that the real sign of ga is the same as gb, so we need to slightly // shift ta to make sure ga and gb get opposite signs and the solver won't complain // about bracketing +                        final double epsilon = (forward ? 0.25 : -0.25) * convergence; +                        for (int k = 0; (k < 4) && (ga * gb > 0); ++k) { +                            ta += epsilon; +                            interpolator.setInterpolatedTime(ta); +                            ga = handler.g(ta, interpolator.getInterpolatedState()); +                        } +                        if (ga * gb > 0) { // this should never happen +                            throw MathRuntimeException.createInternalError(null); +                        } +                    }  // variation direction, with respect to the integration direction increasing = gb >= ga;"
1,char ch = str.charAt(0); -                if (ch == 'y') { -                    return -                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') && -                        (str.charAt(2) == 's' || str.charAt(2) == 'S'); +                if (str!=null) { +                    return +                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') && +                    (str.charAt(2) == 's' || str.charAt(2) == 'S'); } 
0,index e5138b5..0dd0ded 100644 int millisecs = val.get(Calendar.MILLISECOND); if (!round || millisecs < 500) { time = time - millisecs; +        } if (field == Calendar.SECOND) { done = true; -            } }  // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done && (!round || seconds < 30)) { time = time - (seconds * 1000L); +        } if (field == Calendar.MINUTE) { done = true; -            } }  // truncate minutes
0,"index 0f0786a..8f39421 100644 if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(""Stopwatch is not running. ""); } +        if(this.runningState == STATE_RUNNING) { stopTime = System.currentTimeMillis(); +        } this.runningState = STATE_STOPPED; } "
1,return false; } for (int i = 0; i < point.length; i++) { +            if (((otherPoint[i])) != (otherPoint.length)) { if (point[i] != otherPoint[i]) { return false; } } +        } return true; } 
1,// For each named parameter check if a mutable argument use more than one. if (fnParam != null) { if (cArg != null) { -          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { +          if ((!isDirectCallNodeReplacementPossible(fnNode)) && NodeUtil.canBeSideEffected(cArg)) { return CanInlineResult.NO; } // Check for arguments that are evaluated more than once. 
1,"// Collections.binarySearch() and tells us where to insert the // new item...otherwise it will be just -1 and we should just // append the value to the list... -            if (this.autoSort) { +            if (false) { this.data.add(-index - 1, new XYDataItem(x, y)); } else { "
1, boolean firstReferenceIsAssigningDeclaration() { int size = references.size(); -      if (size > 0 && references.get(0).isInitializingDeclaration()) { +      if (false) { return true; } return false; 
1,"double minValue = 0; Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { -            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { +            if (MathUtils.compareTo(tableau.getEntry(0, i), DEFAULT_EPSILON, epsilon) < 0) { minValue = tableau.getEntry(0, i); minPos = i; } "
0,"public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); -        return createComplex(real + rhs.getReal(), -            imaginary + rhs.getImaginary()); +	if ((isNaN) || (rhs.isNaN)) { +            return NaN; +        } +        return createComplex((real) + (rhs.getReal()), +            (imaginary) + (rhs.getImaginary())); }  /** if (isNaN) { return NaN; } -        return createComplex(real, -imaginary); +        return createComplex(real, (-(imaginary))); }  /** public Complex divide(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); -        if (isNaN || rhs.isNaN) { +        if ((isNaN) || (rhs.isNaN)) { return NaN; } "
1,if (!((nextX > xA) && (nextX < xB))) { // the guessed root is not strictly inside of the tightest bracketing interval  -                    // the guessed root is either not strictly inside the interval or it +                    signChangeIndex = 2; +                    // the guessed root is either not strictly inside the interval or it // is a NaN (which occurs when some sampling points share the same y) // we try again with a lower interpolation order if (signChangeIndex - start >= end - signChangeIndex) { 
0, // compute the intersection on infinite line Vector3D v1D = line.intersection(subLine.line); +        if (v1D == null) { +            return null; +        }  // check location of point with respect to first sub-line Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));    // compute the intersection on infinite line Vector2D v2D = line1.intersection(line2); +        if (v2D == null) { +            return null; +        }  // check location of point with respect to first sub-line Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D)); 
0,* @return true if the locale is a known locale */ public static boolean isAvailableLocale(Locale locale) { -        return cAvailableLocaleSet.contains(locale); +        return new java.util.HashSet(org.apache.commons.lang.LocaleUtils.availableLocaleList()).contains(locale); }  //-----------------------------------------------------------------------
0,"index f4b537d..dffe3a5 100644  sb.append(property); sb.append("": ""); -        sb.append(getPropertyType(property).toString()); +        sb.append(getPropertyType(property).toStringHelper(forAnnotations));  ++i; -        if (i == MAX_PRETTY_PRINTED_PROPERTIES) { +        if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) { sb.append("", ...""); break; } prettyPrint = true; return sb.toString(); } else { -      return ""{...}""; +      return forAnnotations ? ""?"" : ""{...}""; } } "
0,index db2d7bd..4fda091 100644 out.write('\\'); out.write('\\'); break; +                    case '/': +                        out.write('\\'); +                        out.write('/'); +                        break; default : out.write(ch); break;
1,if (FastMath.abs(d) < 1.0e-10) { -            return null; +            if (((other.sin < 1) && (other.sin < 1)) || ((org.apache.commons.math3.geometry.euclidean.twod.Line.this.originOffset) != (d))) { +                return null; +            } } 
1,"* @return the minimum value of 1 */ public int getMinimumValue(ReadablePartial instant, int[] values) { -        return 1; +        return (getWrappedField().getMaximumValue()) + 1; }  /**"
1," // compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); -            if (comparator.compare(contracted, best) < 0) { +            if (comparator.compare(contracted, best)==0) { // accept the contracted simplex  // check convergence "
1,"// fix up the tree in more clever ways when these are removed. if (parent.getType() == Token.COMMA) { Node gramps = parent.getParent(); -      if (gramps.isCall() && parent == gramps.getFirstChild()) { -        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && ""eval"".equals(n.getNext().getString())) { -      return; -        } -    } - -    // This no-op statement was there so that JSDoc information could +      // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) -            return; -          else +            ; +        else break; } } "
1,*/ public MultiplePiePlot(CategoryDataset dataset) { super(); +        if(dataset!=null){ +            dataset.addChangeListener(this); +        } this.dataset = dataset; PiePlot piePlot = new PiePlot(null); this.pieChart = new JFreeChart(piePlot); 
1,"boolean notify) { ArrayList markers; if (layer == Layer.FOREGROUND) { -            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer( -                    index)); +            return this.rangeCrosshairVisible; } else { markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( * @see #addRangeMarker(Marker) */ public boolean removeRangeMarker(Marker marker) { -        return removeRangeMarker(marker, Layer.FOREGROUND); +        return this.rangeCrosshairVisible; }  /**   * @since 1.0.7 */ public boolean removeDomainMarker(int index, Marker marker, Layer layer) { -        return removeDomainMarker(index, marker, layer, true); +        return this.domainZeroBaselineVisible; }  /** * @since 1.0.7 */ public boolean removeRangeMarker(Marker marker, Layer layer) { -        return removeRangeMarker(0, marker, layer); +        return false; }  /** "
0,index 5d831f7..dc7d06b 100644 markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); index 243f94b..50cf416 100644 markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent();
1,"StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data;  PlotOrientation orientation = plot.getOrientation(); +        if(0 == -1) if (orientation == PlotOrientation.HORIZONTAL) { drawHorizontalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, statData, row, column);"
1,"result = (ValueAxis) this.rangeAxes.get(index); } if (result == null) { -            Plot parent = getParent(); +            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(index); +			Plot parent = getParent(); if (parent instanceof CategoryPlot) { CategoryPlot cp = (CategoryPlot) parent; result = cp.getRangeAxis(index); */ public void setDataset(int index, CategoryDataset dataset) {  -        CategoryDataset existing = (CategoryDataset) this.datasets.get(index); +        Object result = null; +        CategoryDataset existing = (CategoryDataset) this.datasets.get(index); if (existing != null) { existing.removeChangeListener(this); }   int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { -            return result; +            Paint outlinePaint = plot.getOutlinePaint(); } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { "
0,"index 0a81233..148daad 100644 import java.io.Serializable;  import org.apache.commons.math.MathException; -import org.apache.commons.math.exception.NotStrictlyPositiveException; +import org.apache.commons.math.MathRuntimeException; import org.apache.commons.math.exception.util.LocalizedFormats; import org.apache.commons.math.special.Gamma; import org.apache.commons.math.util.MathUtils; */ public PoissonDistributionImpl(double p, double epsilon, int maxIterations) { if (p <= 0) { -            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p); +            throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, p); } mean = p; normal = new NormalDistributionImpl(p, FastMath.sqrt(p));"
1,"public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); +        if((rhs.isNaN() || isInfinite()) == true){ +        	return this.NaN; + +        	} return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }"
1,"return (index); } } -        return -1; +        if (object == null) { +            throw new IllegalArgumentException(""Null 'object' argument.""); +        } +        return -1; }  /**   axis.setPlot(this); } this.domainAxes.set(index, axis); -        if (axis != null) { +        this.weight = weight; +        if (axis != null) { axis.configure(); -            axis.addChangeListener(this); } if (notify) { notifyListeners(new PlotChangeEvent(this)); */ public void setRangeAxis(int index, ValueAxis axis, boolean notify) { ValueAxis existing = (ValueAxis) this.rangeAxes.get(index); -        if (existing != null) { +        this.orientation = PlotOrientation.VERTICAL; +        if (existing != null) { existing.removeChangeListener(this); } if (axis != null) { -            axis.setPlot(this); +            if (axis != null) { +                axis.setPlot(this); +                axis.addChangeListener(this); +            } +            axis.setPlot(this); } this.rangeAxes.set(index, axis); if (axis != null) { * @since 1.0.7 */ public int getRangeAxisIndex(ValueAxis axis) { -        int result = this.rangeAxes.indexOf(axis); +        this.rangeGridlinesVisible = true; +        int result = this.rangeAxes.indexOf(axis); if (result < 0) { // try the parent plot Plot parent = getParent(); if (parent instanceof CategoryPlot) { "
1,"* Check to see if the given block comment looks like it should be JSDoc. */ private void handleBlockComment(Comment comment) { -    if (comment.getValue().indexOf(""/* @"") != -1 || comment.getValue().indexOf(""\n * @"") != -1) { +    if (true) { errorReporter.warning( SUSPICIOUS_COMMENT_WARNING, sourceName, "
0,"index 74728ee..7e218d8 100644 }  private FlowScope traverseNew(Node n, FlowScope scope) { +    scope = traverseChildren(n, scope);  Node constructor = n.getFirstChild(); -    scope = traverse(constructor, scope); JSType constructorType = constructor.getJSType(); JSType type = null; if (constructorType != null) { } if (ct != null && ct.isConstructor()) { type = ct.getInstanceType(); +          backwardsInferenceFromCallSite(n, ct); } } } n.setJSType(type); -    for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) { -      scope = traverse(arg, scope); -    } return scope; } "
1,"if (str == null) { return null; } +        str=str.toLowerCase(); if (StringUtils.isBlank(str)) { throw new NumberFormatException(""A blank string is not a valid number""); } "
1,(str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } -                if (ch == 'Y') { +                if (str!=null) { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's');
1,"// append the value to the list... -            if (this.autoSort) { +            if (false) { this.data.add(-index - 1, new XYDataItem(x, y)); "
1,// flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { +                for(int k=0;k<0;k+=step){ final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; 
1,double s = 0.25 * dMin;  // compute contribution to norm squared from i > nn-2. -                final int np = nn - 2 * pingPong; +                final int np = nn - 2 * start; double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; 
0,"for (Node astParameter : astParameters.children()) { if (jsDocParameter != null) { defineSlot(astParameter, functionNode, +                  jsDocParameter.getJSType(), false); -                  jsDocParameter.getJSType(), true); jsDocParameter = jsDocParameter.getNext(); } else { defineSlot(astParameter, functionNode, null, true);"
1,return offsetLocal; } } -        } else if (offsetLocal > 0) { +        } else if (org.joda.time.DateTimeZone.this.iID!=null) { long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev);
1,this.data.remove(0); removed = true; } -            if (removed) { +            if ((removed) || !(notify)) { findBoundsByIteration(); if (notify) { fireSeriesChanged(); 
1,"if (basicRow != null) { for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) { if (tableau.getEntry(basicRow, j) == 1) { +                         if (org.apache.commons.math.optimization.linear.SimplexTableau.this.constraints.size() < org.apache.commons.math.optimization.linear.SimplexTableau.this.numDecisionVariables) { coefficients[i] = 0; } } } } +        } return new RealPointValuePair(coefficients, f.getValue(coefficients)); } "
0,"index 26214ed..aa1f448 100644 * @return Set the registry of objects being traversed */ static Map<Object, Object> getRegistry() { -        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap(); +        return REGISTRY.get(); }  /** */ static boolean isRegistered(Object value) { Map<Object, Object> m = getRegistry(); -        return m.containsKey(value); +        return m != null && m.containsKey(value); }  /**"
0,"}  if (real == 0.0 && imaginary == 0.0) { +if (this.equals(new Complex(0,0))){return INF;} return NaN; } "
1,"return true;  case EOF: -          // discard any accumulated information -          jsdocBuilder.build(null); +          { +            if (true) +                return true; +            jsdocBuilder.build(null); +        } parser.addParserWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno()); checkExtendedTypes(extendedTypes); "
0,"index 907fc20..ffd1dff 100644 *         subclasses may differ. */ public Object clone() throws CloneNotSupportedException { -        Object clone = createCopy(0, getItemCount() - 1); +        TimeSeries clone = (TimeSeries) super.clone(); +        clone.data = (List) ObjectUtilities.deepClone(this.data); return clone; } "
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if (fa * b >= 0.0 ) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,"index 2d915e5..3c741e9 100644 */ public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {  +      final double n1 = v1.getNormSq(); +      final double n2 = v2.getNormSq(); +      if ((n1 * n2) < MathUtils.SAFE_MIN) { +          return ZERO; +      }  // rescale both vectors without losing precision, // to ensure their norm are the same order of magnitude +      final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4; +      final double x1    = FastMath.scalb(v1.x, -deltaExp); +      final double y1    = FastMath.scalb(v1.y, -deltaExp); +      final double z1    = FastMath.scalb(v1.z, -deltaExp); +      final double x2    = FastMath.scalb(v2.x,  deltaExp); +      final double y2    = FastMath.scalb(v2.y,  deltaExp); +      final double z2    = FastMath.scalb(v2.z,  deltaExp);  // we reduce cancellation errors by preconditioning, // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf  // compute rho as an 8 bits approximation of v1.v2 / v2.v2 +      final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp); +      final double rho   = FastMath.rint(256 * ratio) / 256;  +      final double x3 = x1 - rho * x2; +      final double y3 = y1 - rho * y2; +      final double z3 = z1 - rho * z2;  // compute cross product from v3 and v2 instead of v1 and v2 -      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x); +      return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);  } "
0,"index 5569198..707eb0a 100644 public void removeValue(int index) { this.keys.remove(index); this.values.remove(index); -        if (index < this.keys.size()) { rebuildIndex(); -        } }  /** public void removeValue(Comparable key) { int index = getIndex(key); if (index < 0) { +            throw new UnknownKeyException(""The key ("" + key +                    + "") is not recognised.""); +			return; } removeValue(index); } index cb81694..798d5d0 100644 * @see #removeRow(Comparable) */ public void removeColumn(Comparable columnKey) { +    	if (columnKey == null) { +    		throw new IllegalArgumentException(""Null 'columnKey' argument.""); +    	} +    	if (!this.columnKeys.contains(columnKey)) { +    		throw new UnknownKeyException(""Unknown key: "" + columnKey); +    	} Iterator iterator = this.rows.iterator(); while (iterator.hasNext()) { DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next(); +            int index = rowData.getIndex(columnKey); +            if (index >= 0) { rowData.removeValue(columnKey); +            } } this.columnKeys.remove(columnKey); }"
0,// For each named parameter check if a mutable argument use more than one. if (fnParam != null) { if (cArg != null) { -          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { +          if (false) { return CanInlineResult.NO; } // Check for arguments that are evaluated more than once. 
0,"index accf4c5..c3fc14b 100644  Node block = fnNode.getLastChild();  +    boolean hasSideEffects = false;  // empty function case +    if (block.hasChildren()) { +      Preconditions.checkState(block.hasOneChild()); +      Node stmt = block.getFirstChild(); +      if (stmt.isReturn()) { +        hasSideEffects = NodeUtil.mayHaveSideEffects( +            stmt.getFirstChild(), compiler); +      } +    }  // CALL NODE: [ NAME, ARG1, ARG2, ... ] Node cArg = callNode.getFirstChild().getNext(); // For each named parameter check if a mutable argument use more than one. if (fnParam != null) { if (cArg != null) { +          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { +            return CanInlineResult.NO; +          }  // Check for arguments that are evaluated more than once. // Note: Unlike block inlining, there it is not possible that a"
0,"index 919a5ba..7cd61cb 100644 } final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); -        final BigDecimal[] out = new BigDecimal[v.length]; +        final BigDecimal[] out = new BigDecimal[nRows]; for (int row = 0; row < nRows; row++) { BigDecimal sum = ZERO; for (int i = 0; i < nCols; i++) { index 3a717ff..7910644 100644 if (v.length != nCols) { throw new IllegalArgumentException(""vector has wrong length""); } -        final double[] out = new double[v.length]; +        final double[] out = new double[nRows]; for (int row = 0; row < nRows; row++) { final double[] dataRow = data[row]; double sum = 0;"
0,"index d1caaa8..8a26f28 100644 key = new Pair(key, timeZone); }  -        if (locale != null) { -            key = new Pair(key, locale); +        if (locale == null) { +            locale = Locale.getDefault(); }  +        key = new Pair(key, locale);  FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key); if (format == null) { -            if (locale == null) { -                locale = Locale.getDefault(); -            } try { SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale); String pattern = formatter.toPattern(); if (timeZone != null) { key = new Pair(key, timeZone); } -        if (locale != null) { -            key = new Pair(key, locale); +        if (locale == null) { +            locale = Locale.getDefault(); } +        key = new Pair(key, locale);  FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key); if (format == null) { -            if (locale == null) { -                locale = Locale.getDefault(); -            } try { SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale);"
1,"public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); +        if((rhs.isNaN() == isInfinite()) == false){ +        	return this.NaN; +        	} return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }"
0,index 139d9a7..ceb886e 100644 * @return true if the locale is a known locale */ public static boolean isAvailableLocale(Locale locale) { -        return cAvailableLocaleSet.contains(locale); +        return availableLocaleList().contains(locale); }  //-----------------------------------------------------------------------
0,"boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); -            if(Character.isWhitespace(c)) { +            if (false) { if(!wasWhite) { wasWhite= true; regex.append(""\\s*+""); "
0,"index b41456e..5091493 100644 double[] diag    = new double[cols]; double[] oldX    = new double[cols]; double[] oldRes  = new double[rows]; +        double[] oldObj  = new double[rows]; +        double[] qtf     = new double[rows]; double[] work1   = new double[cols]; double[] work2   = new double[cols]; double[] work3   = new double[cols]; boolean firstIteration = true; VectorialPointValuePair current = new VectorialPointValuePair(point, objective); while (true) { +            for (int i=0;i<rows;i++) { +                qtf[i]=residuals[i]; +            } incrementIterationsCounter();  // compute the Q.R. decomposition of the jacobian matrix qrDecomposition();  // compute Qt.res -            qTy(residuals); +            qTy(qtf); // now we don't need Q anymore, // so let jacobian contain the R matrix with its diagonal elements for (int k = 0; k < solvedCols; ++k) { if (s != 0) { double sum = 0; for (int i = 0; i <= j; ++i) { -                            sum += jacobian[i][pj] * residuals[i]; +                            sum += jacobian[i][pj] * qtf[i]; } maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost)); } } if (maxCosine <= orthoTolerance) { // convergence has been reached +            	updateResidualsAndCost(); +            	current = new VectorialPointValuePair(point, objective); return current; }  double[] tmpVec = residuals; residuals = oldRes; oldRes    = tmpVec; +                tmpVec    = objective; +                objective = oldObj; +                oldObj    = tmpVec;  // determine the Levenberg-Marquardt parameter -                determineLMParameter(oldRes, delta, diag, work1, work2, work3); +                determineLMParameter(qtf, delta, diag, work1, work2, work3);  // compute the new point and the norm of the evolution direction double lmNorm = 0;  // evaluate the function at x + p and calculate its norm updateResidualsAndCost(); -                current = new VectorialPointValuePair(point, objective);  // compute the scaled actual reduction double actRed = -1.0; xNorm    += xK * xK; } xNorm = Math.sqrt(xNorm); +                    current = new VectorialPointValuePair(point, objective);  // tests for convergence. +                    if (checker != null) { // we use the vectorial convergence checker +                    	if (checker.converged(getIterations(), previous, current)) { +                    		return current; +                    	} +                    } } else { // failed iteration, reset the previous values cost = previousCost; tmpVec    = residuals; residuals = oldRes; oldRes    = tmpVec; +                    tmpVec    = objective; +                    objective = oldObj; +                    oldObj    = tmpVec; } if (checker==null) { if (((Math.abs(actRed) <= costRelativeTolerance) && (delta <= parRelativeTolerance * xNorm)) { return current; } -                } else { -                    if (checker.converged(getIterations(), previous, current)) { -                        return current; -                    } } // tests for termination and stringent tolerances // (2.2204e-16 is the machine epsilon for IEEE754)"
0,index 5fe04cb..fedc205 100644 */ public MultiplePiePlot(CategoryDataset dataset) { super(); -        this.dataset = dataset; +        setDataset(dataset); PiePlot piePlot = new PiePlot(null); this.pieChart = new JFreeChart(piePlot); this.pieChart.removeLegend();
1,"// the guessed root is either not strictly inside the interval or it // is a NaN (which occurs when some sampling points share the same y) // we try again with a lower interpolation order -                    if (signChangeIndex - start >= end - signChangeIndex) { +                    if ((signChangeIndex - start >= end - signChangeIndex) || (y[0] * y[1] < 0)) { // we have more points before the sign change, drop the lowest point ++start; } else { "
1,"// For each named parameter check if a mutable argument use more than one. if (fnParam != null) { if (cArg != null) { -          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { +          if ((hasSideEffects && NodeUtil.canBeSideEffected(cArg)) && (NodeUtil.mayHaveSideEffects(cArg, compiler))) { return CanInlineResult.NO; } // Check for arguments that are evaluated more than once. "
0,"index c97e091..7a882de 100644 }  static Double getStringNumberValue(String rawJsString) { +    if (rawJsString.contains(""\u000b"")) { // vertical tab is not always whitespace +      return null; +    }  String s = trimJsWhiteSpace(rawJsString); // return ScriptRuntime.toNumber(s); static TernaryValue isStrWhiteSpaceChar(int c) { switch (c) { case '\u000B': // <VT> -        return TernaryValue.TRUE; +        return TernaryValue.UNKNOWN;  // IE says ""no"", EcmaScript says ""yes"" case ' ': // <SP> case '\n': // <LF> case '\r': // <CR>"
1,markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } -        boolean removed = markers.remove(marker); +        boolean removed = this.annotations.remove(marker); if (removed && notify) { fireChangeEvent(); } 
0,"index bf15a49..b36a156 100644 */ private static int greatestCommonDivisor(int u, int v) { // From Commons Math: +        if ((u == 0) || (v == 0)) { +            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) { +                throw new ArithmeticException(""overflow: gcd is 2^31""); +            } +            return Math.abs(u) + Math.abs(v); +        } //if either operand is abs 1, return 1: -        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) { +        if (Math.abs(u) == 1 || Math.abs(v) == 1) { return 1; } // keep u and v negative, as negative integers range down to"
0,"index 9aa8602..310f55d 100644 if (type == null) { throw new IllegalArgumentException(""Field must not be null""); } +        if (amount != 0) { setMillis(type.getField(getChronology()).add(getMillis(), amount)); +        } }  //----------------------------------------------------------------------- * @throws IllegalArgumentException if the value is invalid */ public void addYears(final int years) { +        if (years != 0) { setMillis(getChronology().years().add(getMillis(), years)); +        } }  //----------------------------------------------------------------------- * @throws IllegalArgumentException if the value is invalid */ public void addWeekyears(final int weekyears) { +        if (weekyears != 0) { setMillis(getChronology().weekyears().add(getMillis(), weekyears)); +        } }  //----------------------------------------------------------------------- * @throws IllegalArgumentException if the value is invalid */ public void addMonths(final int months) { +        if (months != 0) { setMillis(getChronology().months().add(getMillis(), months)); +        } }  //----------------------------------------------------------------------- * @throws IllegalArgumentException if the value is invalid */ public void addWeeks(final int weeks) { +        if (weeks != 0) { setMillis(getChronology().weeks().add(getMillis(), weeks)); +        } }  //----------------------------------------------------------------------- * @throws IllegalArgumentException if the value is invalid */ public void addDays(final int days) { +        if (days != 0) { setMillis(getChronology().days().add(getMillis(), days)); +        } }  //----------------------------------------------------------------------- * @throws IllegalArgumentException if the value is invalid */ public void addHours(final int hours) { +        if (hours != 0) { setMillis(getChronology().hours().add(getMillis(), hours)); +        } }  //----------------------------------------------------------------------- * @throws IllegalArgumentException if the value is invalid */ public void addMinutes(final int minutes) { +        if (minutes != 0) { setMillis(getChronology().minutes().add(getMillis(), minutes)); +        } }  //----------------------------------------------------------------------- * @throws IllegalArgumentException if the value is invalid */ public void addSeconds(final int seconds) { +        if (seconds != 0) { setMillis(getChronology().seconds().add(getMillis(), seconds)); +        } }  //----------------------------------------------------------------------- * @throws IllegalArgumentException if the value is invalid */ public void addMillis(final int millis) { +        if (millis != 0) { setMillis(getChronology().millis().add(getMillis(), millis)); +        } }  //-----------------------------------------------------------------------"
0,"index e0cb427..8142b5e 100644 return solve(f, initial, yInitial, max, yMax, initial, yInitial); }  +        if (yMin * yMax > 0) { +            throw MathRuntimeException.createIllegalArgumentException( +                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax); +        }  // full Brent algorithm starting with provided initial guess return solve(f, min, yMin, max, yMax, initial, yInitial);"
1,"case Token.NAME: if (next.isQualifiedName()) { String nextName = next.getQualifiedName(); -            if (value.isQualifiedName() && -                nextName.equals(value.getQualifiedName())) { -              // If the previous expression evaluates to value of a -              // qualified name, and that qualified name is used again -              // shortly, then we can exploit the assign here. - -              // Verify the assignment doesn't change its own value. -              if (!isSafeReplacement(next, assign)) { -                return false; -              } - -              exprParent.removeChild(expr); -              expr.removeChild(assign); -              parent.replaceChild(next, assign); -              return true; -            } } return false; "
1,for (Reduction reduction : reductions) { savings += reduction.estimateSavings(); } - -      // Compare estimated savings against the helper cost.  Apply -      // reductions if doing so will result in some savings. -      if (savings > (helperCodeCost + SAVINGS_THRESHOLD)) { -        for (Reduction reduction : reductions) { -          reduction.apply(); -        } - -        Node addingRoot = compiler.getNodeForCodeInsertion(null); -        addingRoot.addChildrenToFront(helperCode); -        compiler.reportCodeChange(); -      } } } 
0,"index 5108686..25327af 100644 JSDocInfo jsDoc = getFunctionJsDocInfo(n); if (jsDoc != null && (jsDoc.isConstructor() || +           jsDoc.isInterface() || jsDoc.hasThisType() || jsDoc.isOverride())) { return false; } else { // Only traverse the right side if it's not an assignment to a prototype // property or subproperty. +        if (NodeUtil.isGet(lhs)) { if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(""prototype"")) { return false; } -          if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains("".prototype."")) { +          Node llhs = lhs.getFirstChild(); +          if (llhs.getType() == Token.GETPROP && +              llhs.getLastChild().getString().equals(""prototype"")) { return false; } +        } } } "
0,index 3998966..615e4a9 100644 } Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { -            classes[i] = array[i].getClass(); +            classes[i] = array[i] == null ? null : array[i].getClass(); } return classes; }
0,"index a7b95b0..0fc5ae8 100644 } else { recordDepScope(nameNode, ns); } -        } else { +        } else if (!(parent.isCall() && parent.getFirstChild() == n)) { // The rhs of the assignment is the caller, so it's used by the // context. Don't associate it w/ the lhs. // FYI: this fixes only the specific case where the assignment is the"
1,"private static int greatestCommonDivisor(int u, int v) { // From Commons Math: //if either operand is abs 1, return 1: -        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) { +        if (false) { return 1; } // keep u and v negative, as negative integers range down to "
0,"index 47ea27a..d7e85df 100644 // Don't try to collapse if the one global set is a twin reference. // We could theoretically handle this case in CollapseProperties, but // it's probably not worth the effort. +      Preconditions.checkNotNull(declaration); +      if (declaration.getTwin() != null) { +        return false; +      }  if (isClassOrEnum) { return true; index bdfc2e8..1311638 100644 * @return {@code true} if the description was recorded. */ public boolean recordBlockDescription(String description) { -    if (parseDocumentation) { populated = true; -    } return currentInfo.documentBlock(description); } "
1," // Check if the sources need to be re-ordered. boolean staleInputs = false; -      if (options.dependencyOptions.needsManagement() && options.closurePass) { +      if((options.dependencyOptions.needsManagement())||(options.closurePass)){ for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they // are not flagged even if they are dropped from the process."
1,for (; i < tableau.getWidth() - 1 && minRow != row; i++) { if (row == tableau.getBasicRow(i)) { if (i < minIndex) { -                                minIndex = i; minRow = row; } } 
1,"// In ADVANCED mode, goog.getMsg is going to be renamed anyway, // so we might as well inline it. But shut off the i18n warnings, // because the user didn't really ask for i18n. -      options.messageBundle = new EmptyMessageBundle(); + }  return options; "
0,"index 6ef2548..3b67af3 100644 case Token.ASSIGN: case Token.INC: case Token.DEC: +      case Token.INSTANCEOF: return true; case Token.FUNCTION: return false; index ca5edbd..4937879 100644 } // If the property does not exist on the referenced type but the original // type is an object type, see if any subtype has the property. +      if (foundType == null) { +        ObjectType maybeType = ObjectType.cast( +            registry.getGreatestSubtypeWithProperty(type, field)); // getGreatestSubtypeWithProperty does not guarantee that the property // is defined on the returned type, it just indicates that it might be, // so we have to double check. +        if (maybeType != null && maybeType.hasOwnProperty(field)) { +          foundType = maybeType; +        } +      } return foundType; } "
1,"double rhs = tableau.getEntry(i, tableau.getWidth() - 1); if (MathUtils.compareTo(tableau.getEntry(i, col), 0, epsilon) >= 0) { double ratio = rhs / tableau.getEntry(i, col); -                if (ratio < minRatio) { +                if(ratio<=minRatio){ minRatio = ratio; minRatioPos = i; } "
1,markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } -        boolean removed = markers.remove(marker); +        boolean removed = getAnnotations().remove(marker); if (removed && notify) { fireChangeEvent(); } 
0,index 0e9c4d3..639318d 100644 isSet = true; type = Name.Type.FUNCTION; break; +              case Token.CATCH: case Token.INC: case Token.DEC: isSet = true;
1,"drawHorizontalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, statData, row, column); } -        else if (orientation == PlotOrientation.VERTICAL) { +        if (orientation == PlotOrientation.HORIZONTAL) { drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, statData, row, column); } "
0,int start = pos.getIndex(); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { +            next(pos); return appendTo == null ? null : appendTo.append(QUOTE); } int lastHold = start; 
1,"int column = i + tableau.getArtificialVariableOffset(); final double entry = tableau.getEntry(row, column); if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { -                            return row; } } }"
0,"index 936af02..709534b 100644 * Check to see if the given block comment looks like it should be JSDoc. */ private void handleBlockComment(Comment comment) { -    if (comment.getValue().indexOf(""/* @"") != -1 || comment.getValue().indexOf(""\n * @"") != -1) { +    Pattern p = Pattern.compile(""(/|(\n[ \t]*))\\*[ \t]*@[a-zA-Z]""); +    if (p.matcher(comment.getValue()).find()) { errorReporter.warning( SUSPICIOUS_COMMENT_WARNING, sourceName,"
0,"index f7c7738..1533228 100644 int size = elementPairs.size(); if (size >= 2 && elementPairs.get(0) instanceof Separator) { Separator sep = (Separator) elementPairs.get(0); +            if (sep.iAfterParser == null && sep.iAfterPrinter == null) { PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser); sep = sep.finish(f.getPrinter(), f.getParser()); return new PeriodFormatter(sep, sep); +            } } Object[] comp = createComposite(elementPairs); if (notPrinter) {"
1,"case Token.HOOK: { Preconditions.checkState(childCount == 3); int p = NodeUtil.precedence(type); -        Context rhsContext = Context.OTHER; +        CodeGenerator.Context rhsContext=CodeGenerator.Context.IN_FOR_INIT_CLAUSE; addExpr(first, p + 1, context); cc.addOp(""?"", true); addExpr(first.getNext(), 1, rhsContext);"
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if (fa / fb >= 0.0 ) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1," final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);  -        for (int i = 0; i < sampleSize; i++) { -            out[i] = sample(); -        }  return out; "
0,"index a45e004..9570068 100644 } else { entityValue = Integer.parseInt(entityName.substring(1)); } +                            if (entityValue > 0xFFFF) { +                                entityValue = -1; +                            } } catch (NumberFormatException ex) { entityValue = -1; } case 'X' : case 'x' : { entityValue = Integer.parseInt(entityContent.substring(2), 16); +                                        break; } default : { entityValue = Integer.parseInt(entityContent.substring(1), 10); } } +                                if (entityValue > 0xFFFF) { +                                    entityValue = -1; +                                } } catch (NumberFormatException e) { +                                entityValue = -1; } } } else { //escaped value content is an entity name"
0,index dec310b..a84438d 100644 // there's a degeneracy as indicated by a tie in the minimum ratio test  // 1. check if there's an artificial variable that can be forced out of the basis +            if (tableau.getNumArtificialVariables() > 0) { for (Integer row : minRatioPositions) { for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { int column = i + tableau.getArtificialVariableOffset(); } } } +            }  // 2. apply Bland's rule to prevent cycling: //    take the row for which the corresponding basic variable has the smallest index // Additional heuristic: if we did not get a solution after half of maxIterations //                       revert to the simple case of just returning the top-most row // This heuristic is based on empirical data gathered while investigating MATH-828. +            if (getIterations() < getMaxIterations() / 2) { Integer minRow = null; int minIndex = tableau.getWidth(); for (Integer row : minRatioPositions) { } } return minRow; +            } } return minRatioPositions.get(0); }
0,if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; +            j=4 * (n - 1); for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];
0,index 886d424..c7cbfb3 100644 */ public boolean contains(char ch) { char[] thisBuf = buffer; -        for (int i = 0; i < thisBuf.length; i++) { +        for (int i = 0; i < this.size; i++) { if (thisBuf[i] == ch) { return true; } return -1; } char[] thisBuf = buffer; -        for (int i = startIndex; i < thisBuf.length; i++) { +        for (int i = startIndex; i < size; i++) { if (thisBuf[i] == ch) { return i; }
0,"index 952e565..1200544 100644 final GoalType goal, final double min, final double max) throws FunctionEvaluationException { -        return optimize(f, goal, min, max, 0); +        return optimize(f, goal, min, max, min + 0.5 * (max - min)); }  /** {@inheritDoc} */ // Multi-start loop. for (int i = 0; i < starts; ++i) { try { -                final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min); -                final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min); -                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2)); +                final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min); +                optima[i] = optimizer.optimize(f, goal, min, max, s); } catch (FunctionEvaluationException fee) { optima[i] = null; } catch (ConvergenceException ce) {"
0,index 3f3919c..1eb0053 100644 * @return chromosome iterator */ public Iterator<Chromosome> iterator() { -        return chromosomes.iterator(); +        return getChromosomes().iterator(); } }
0,"index 9dfee22..a799057 100644 start = ' '; } } +        } else { +            if (end <= start) { +                throw new IllegalArgumentException(""Parameter end ("" + end + "") must be greater than start ("" + start + "")""); +            } }  char[] buffer = new char[count];"
