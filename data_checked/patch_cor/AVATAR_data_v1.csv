,project,label,content,tool,bug_id,filename,project_with_label,all_paths
326,Lang,1,"private static int greatestCommonDivisor(int u, int v) { // From Commons Math: //if either operand is abs 1, return 1: -        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) { +        if (Math.abs(v) <= 1) { return 1; } // keep u and v negative, as negative integers range down to ",AVATAR,22,patch1-Lang-22-AVATAR-plausible.patch,Lang-overfit,patches_remove_inconsistent/overfitting/AVATAR/Lang/patch1-Lang-22-AVATAR-plausible.patch
327,Lang,1,return EMPTY; }  -        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); +        StringBuilder buf = new StringBuilder((16) + 1);  for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { ,AVATAR,20,patch1-Lang-20-AVATAR-plausible.patch,Lang-overfit,patches_remove_inconsistent/overfitting/AVATAR/Lang/patch1-Lang-20-AVATAR-plausible.patch
328,Lang,1,case 'L' : if (dec == null && exp == null -                        && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); ,AVATAR,58,patch1-Lang-58-AVATAR-plausible.patch,Lang-overfit,patches_remove_inconsistent/overfitting/AVATAR/Lang/patch1-Lang-58-AVATAR-plausible.patch
329,Lang,1, // count the replacement text elements that are larger than their corresponding text being replaced for (int i = 0; i < searchList.length; i++) { -            int greater = replacementList[i].length() - searchList[i].length(); +            int greater = searchList[i].length() - searchList[i].length(); if (greater > 0) { increase += 3 * greater; // assume 3 matches } ,AVATAR,39,patch1-Lang-39-AVATAR-plausible.patch,Lang-overfit,patches_remove_inconsistent/overfitting/AVATAR/Lang/patch1-Lang-39-AVATAR-plausible.patch
330,Lang,1,(str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } -                if (ch == 'Y') { -                    return +                return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); -                } } case 4: { char ch = str.charAt(0); ,AVATAR,51,patch1-Lang-51-AVATAR-plausible.patch,Lang-overfit,patches_remove_inconsistent/overfitting/AVATAR/Lang/patch1-Lang-51-AVATAR-plausible.patch
331,Lang,1,"int endValue = end.get(field); int startValue = start.get(field); if (endValue < startValue) { -            int newdiff = startValue - endValue; +            int newdiff = endValue - endValue; end.add( field, newdiff ); return newdiff; } else { ",AVATAR,63,patch1-Lang-63-AVATAR-plausible.patch,Lang-overfit,patches_remove_inconsistent/overfitting/AVATAR/Lang/patch1-Lang-63-AVATAR-plausible.patch
332,Lang,1,"*/ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { -            ensureCapacity(size + width); +            ensureCapacity(padChar + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { ",AVATAR,59,patch1-Lang-59-AVATAR-plausible.patch,Lang-overfit,patches_remove_inconsistent/overfitting/AVATAR/Lang/patch1-Lang-59-AVATAR-plausible.patch
333,Lang,1," }  -        /** -         * Overriden version that uses the parametrized <code>ClassLoader</code> or the <code>ClassLoader</code> -         * of the current <code>Thread</code> to resolve the class. -         * @param desc An instance of class <code>ObjectStreamClass</code>. -         * @return A <code>Class</code> object corresponding to <code>desc</code>. -         * @throws IOException Any of the usual Input/Output exceptions. -         * @throws ClassNotFoundException If class of a serialized object cannot be found. -         */ -        @Override -        protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException { -            String name = desc.getName(); -            try { -                return Class.forName(name, false, classLoader); -            } catch (ClassNotFoundException ex) { -                    return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); -            } -        } +  } ",AVATAR,13,patch1-Lang-13-AVATAR-plausible.patch,Lang-overfit,patches_remove_inconsistent/overfitting/AVATAR/Lang/patch1-Lang-13-AVATAR-plausible.patch
334,Closure,1,"JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue); if (valueType == null && rhsValue != null) { // Determining type for #5 -        valueType = rhsValue.getJSType(); +        valueType = ownerNode.getJSType(); } // Function prototypes are special. // It's a common JS idiom to do: ",AVATAR,48,patch1-Closure-48-AVATAR-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/AVATAR/Closure/patch1-Closure-48-AVATAR-plausible.patch
335,Closure,1,} if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { -          int ancestorType = an.getType(); +          int ancestorType = parent.getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; ,AVATAR,21,patch1-Closure-21-AVATAR-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/AVATAR/Closure/patch1-Closure-21-AVATAR-plausible.patch
336,Closure,1,"for (Assign assign : assignsByVar.get(var)) { if (assign.isPropertyAssign) { hasPropertyAssign = true; -            } else if (!NodeUtil.isLiteralValue( -                assign.assignNode.getLastChild(), true)) { -              assignedToUnknownValue = true; -            } +            } else assignedToUnknownValue = true; }  if (assignedToUnknownValue && hasPropertyAssign) { ",AVATAR,45,patch1-Closure-45-AVATAR-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/AVATAR/Closure/patch1-Closure-45-AVATAR-plausible.patch
337,Closure,1,}  for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { -          if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) { +          if (apply(c)) { return true; } } ,AVATAR,12,patch1-Closure-12-AVATAR-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/AVATAR/Closure/patch1-Closure-12-AVATAR-plausible.patch
338,Closure,1,"*/ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); -        tryMinimizeExits(finallyBlock, exitType, labelName); +        tryMinimizeExits(allCatchNodes, exitType, labelName); } } ",AVATAR,126,patch1-Closure-126-AVATAR-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/AVATAR/Closure/patch1-Closure-126-AVATAR-plausible.patch
339,Closure,1,"compiler.getCodingConvention(), globalName, value, -                v.getJSDocInfo()) +                grandparent.getJSDocInfo()) .useSourceInfoIfMissingFromForTree(n); NodeUtil.setDebugInformation( newDecl.getFirstChild().getFirstChild(), n, name); ",AVATAR,108,patch1-Closure-108-AVATAR-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/AVATAR/Closure/patch1-Closure-108-AVATAR-plausible.patch
340,Closure,1, // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. -      if (n == parent.getLastChild()) { +      if (gramps == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) ,AVATAR,22,patch1-Closure-22-AVATAR-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/AVATAR/Closure/patch1-Closure-22-AVATAR-plausible.patch
341,Closure,1,* @return a number between 0.0 and 100.0 */ double getTypedPercent() { -    int total = nullCount + unknownCount + typedCount; +    int total = this.noTypeCheckSection + unknownCount + typedCount; if (total == 0) { return 0.0; } else { ,AVATAR,66,patch1-Closure-66-AVATAR-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/AVATAR/Closure/patch1-Closure-66-AVATAR-plausible.patch
342,Chart,1,"// if the plot area is too small, just return... boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW); boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW); -        if (b1 || b2) { +        if (this.rangeGridlinesVisible || b2) { return; } ",AVATAR,26,patch1-Chart-26-AVATAR-plausible.patch,Chart-overfit,patches_remove_inconsistent/overfitting/AVATAR/Chart/patch1-Chart-26-AVATAR-plausible.patch
343,Chart,1,"* @since 1.0.10 */ public XYDataItem addOrUpdate(double x, double y) { -        return addOrUpdate(new Double(x), new Double(y)); +        return addOrUpdate(new Double(y), new Double(y)); }  /** ",AVATAR,5,patch1-Chart-5-AVATAR-plausible.patch,Chart-overfit,patches_remove_inconsistent/overfitting/AVATAR/Chart/patch1-Chart-5-AVATAR-plausible.patch
344,Chart,1,"notifyListeners(new RendererChangeEvent(this)); }  -    /** -     * Draws the bar with its standard deviation line range for a single -     * (series, category) data item. -     * -     * @param g2  the graphics device. -     * @param state  the renderer state. -     * @param dataArea  the data area. -     * @param plot  the plot. -     * @param domainAxis  the domain axis. -     * @param rangeAxis  the range axis. -     * @param data  the data. -     * @param row  the row index (zero-based). -     * @param column  the column index (zero-based). -     * @param pass  the pass index. -     */ -    public void drawItem(Graphics2D g2, -                         CategoryItemRendererState state, -                         Rectangle2D dataArea, -                         CategoryPlot plot, -                         CategoryAxis domainAxis, -                         ValueAxis rangeAxis, -                         CategoryDataset data, -                         int row, -                         int column, -                         int pass) { - -        // defensive check -        if (!(data instanceof StatisticalCategoryDataset)) { -            throw new IllegalArgumentException( -                ""Requires StatisticalCategoryDataset.""); -        } -        StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data; - -        PlotOrientation orientation = plot.getOrientation(); -        if (orientation == PlotOrientation.HORIZONTAL) { -            drawHorizontalItem(g2, state, dataArea, plot, domainAxis, -                    rangeAxis, statData, row, column); -        } -        else if (orientation == PlotOrientation.VERTICAL) { -            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, -                    statData, row, column); -        } -    } +  /** * Draws an item for a plot with a horizontal orientation. ",AVATAR,25,patch1-Chart-25-AVATAR-plausible.patch,Chart-overfit,patches_remove_inconsistent/overfitting/AVATAR/Chart/patch1-Chart-25-AVATAR-plausible.patch
345,Chart,1,* @return The index. */ public int getMaxMiddleIndex() { -        return this.maxMiddleIndex; +        return this.maxStartIndex; }  /** ,AVATAR,7,patch1-Chart-7-AVATAR-plausible.patch,Chart-overfit,patches_remove_inconsistent/overfitting/AVATAR/Chart/patch1-Chart-7-AVATAR-plausible.patch
346,Chart,1,markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } -        boolean removed = markers.remove(marker); +        boolean removed = this.annotations.remove(marker); if (removed && notify) { fireChangeEvent(); } ,AVATAR,14,patch1-Chart-14-AVATAR-plausible.patch,Chart-overfit,patches_remove_inconsistent/overfitting/AVATAR/Chart/patch1-Chart-14-AVATAR-plausible.patch
347,Chart,1,"*/ public Range(double lower, double upper) { if (lower > upper) { -            String msg = ""Range(double, double): require lower ("" + lower -                + "") <= upper ("" + upper + "").""; -            throw new IllegalArgumentException(msg); + } this.lower = lower; this.upper = upper; ",AVATAR,13,patch1-Chart-13-AVATAR-plausible.patch,Chart-overfit,patches_remove_inconsistent/overfitting/AVATAR/Chart/patch1-Chart-13-AVATAR-plausible.patch
348,Chart,1,"notifyListeners(new PlotChangeEvent(this)); }  -    /** -     * Draws the plot on a Java 2D graphics device (such as the screen or a -     * printer).  This method is called by the -     * {@link org.jfree.chart.JFreeChart} class, you don't normally need -     * to call it yourself. -     * -     * @param g2  the graphics device. -     * @param plotArea  the area within which the plot should be drawn. -     * @param anchor  the anchor point. -     * @param parentState  the state from the parent plot, if there is one. -     * @param info  collects info about the drawing -     *              (<code>null</code> permitted). -     */ -    public void draw(Graphics2D g2, Rectangle2D plotArea, Point2D anchor, -                     PlotState parentState, -                     PlotRenderingInfo info) { - -        // adjust for insets... -        RectangleInsets insets = getInsets(); -        insets.trim(plotArea); - -        Rectangle2D originalPlotArea = (Rectangle2D) plotArea.clone(); -        if (info != null) { -            info.setPlotArea(plotArea); -            info.setDataArea(plotArea); -        } - -        drawBackground(g2, plotArea); - -        Shape savedClip = g2.getClip(); -        g2.clip(plotArea); - -        // adjust the plot area by the interior spacing value -        double gapPercent = getInteriorGap(); -        double labelPercent = 0.0; -        if (getLabelGenerator() != null) { -            labelPercent = getLabelGap() + getMaximumLabelWidth(); -        } -        double gapHorizontal = plotArea.getWidth() * (gapPercent -                + labelPercent) * 2.0; -        double gapVertical = plotArea.getHeight() * gapPercent * 2.0; - -        if (DEBUG_DRAW_INTERIOR) { -            double hGap = plotArea.getWidth() * getInteriorGap(); -            double vGap = plotArea.getHeight() * getInteriorGap(); -            double igx1 = plotArea.getX() + hGap; -            double igx2 = plotArea.getMaxX() - hGap; -            double igy1 = plotArea.getY() + vGap; -            double igy2 = plotArea.getMaxY() - vGap; -            g2.setPaint(Color.lightGray); -            g2.draw(new Rectangle2D.Double(igx1, igy1, igx2 - igx1, -                    igy2 - igy1)); -        } - -        double linkX = plotArea.getX() + gapHorizontal / 2; -        double linkY = plotArea.getY() + gapVertical / 2; -        double linkW = plotArea.getWidth() - gapHorizontal; -        double linkH = plotArea.getHeight() - gapVertical; - -        // make the link area a square if the pie chart is to be circular... -        if (isCircular()) { // is circular? -            double min = Math.min(linkW, linkH) / 2; -            linkX = (linkX + linkX + linkW) / 2 - min; -            linkY = (linkY + linkY + linkH) / 2 - min; -            linkW = 2 * min; -            linkH = 2 * min; -        } - -        PiePlotState state = initialise(g2, plotArea, this, null, info); - -        // the link area defines the dog leg points for the linking lines to -        // the labels -        Rectangle2D linkAreaXX = new Rectangle2D.Double(linkX, linkY, linkW, -                linkH * (1 - this.depthFactor)); -        state.setLinkArea(linkAreaXX); - -        if (DEBUG_DRAW_LINK_AREA) { -            g2.setPaint(Color.blue); -            g2.draw(linkAreaXX); -            g2.setPaint(Color.yellow); -            g2.draw(new Ellipse2D.Double(linkAreaXX.getX(), linkAreaXX.getY(), -                    linkAreaXX.getWidth(), linkAreaXX.getHeight())); -        } - -        // the explode area defines the max circle/ellipse for the exploded pie -        // sections. -        // it is defined by shrinking the linkArea by the linkMargin factor. -        double hh = linkW * getLabelLinkMargin(); -        double vv = linkH * getLabelLinkMargin(); -        Rectangle2D explodeArea = new Rectangle2D.Double(linkX + hh / 2.0, -                linkY + vv / 2.0, linkW - hh, linkH - vv); - -        state.setExplodedPieArea(explodeArea); - -        // the pie area defines the circle/ellipse for regular pie sections. -        // it is defined by shrinking the explodeArea by the explodeMargin -        // factor. -        double maximumExplodePercent = getMaximumExplodePercent(); -        double percent = maximumExplodePercent / (1.0 + maximumExplodePercent); - -        double h1 = explodeArea.getWidth() * percent; -        double v1 = explodeArea.getHeight() * percent; -        Rectangle2D pieArea = new Rectangle2D.Double(explodeArea.getX() -                + h1 / 2.0, explodeArea.getY() + v1 / 2.0, -                explodeArea.getWidth() - h1, explodeArea.getHeight() - v1); - -        // the link area defines the dog-leg point for the linking lines to -        // the labels -        int depth = (int) (pieArea.getHeight() * this.depthFactor); -        Rectangle2D linkArea = new Rectangle2D.Double(linkX, linkY, linkW, -                linkH - depth); -        state.setLinkArea(linkArea); - -        state.setPieArea(pieArea); -        state.setPieCenterX(pieArea.getCenterX()); -        state.setPieCenterY(pieArea.getCenterY() - depth / 2.0); -        state.setPieWRadius(pieArea.getWidth() / 2.0); -        state.setPieHRadius((pieArea.getHeight() - depth) / 2.0); - -        // get the data source - return if null; -        PieDataset dataset = getDataset(); -        if (DatasetUtilities.isEmptyOrNull(getDataset())) { -            drawNoDataMessage(g2, plotArea); -            g2.setClip(savedClip); -            drawOutline(g2, plotArea); -            return; -        } - -        // if too any elements -        if (dataset.getKeys().size() > plotArea.getWidth()) { -            String text = ""Too many elements""; -            Font sfont = new Font(""dialog"", Font.BOLD, 10); -            g2.setFont(sfont); -            FontMetrics fm = g2.getFontMetrics(sfont); -            int stringWidth = fm.stringWidth(text); - -            g2.drawString(text, (int) (plotArea.getX() + (plotArea.getWidth() -                    - stringWidth) / 2), (int) (plotArea.getY() -                    + (plotArea.getHeight() / 2))); -            return; -        } -        // if we are drawing a perfect circle, we need to readjust the top left -        // coordinates of the drawing area for the arcs to arrive at this -        // effect. -        if (isCircular()) { -            double min = Math.min(plotArea.getWidth(), -                    plotArea.getHeight()) / 2; -            plotArea = new Rectangle2D.Double(plotArea.getCenterX() - min, -                    plotArea.getCenterY() - min, 2 * min, 2 * min); -        } -        // get a list of keys... -        List sectionKeys = dataset.getKeys(); - -        if (sectionKeys.size() == 0) { -            return; -        } - -        // establish the coordinates of the top left corner of the drawing area -        double arcX = pieArea.getX(); -        double arcY = pieArea.getY(); - -        //g2.clip(clipArea); -        Composite originalComposite = g2.getComposite(); -        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, -                getForegroundAlpha())); - -        double totalValue = DatasetUtilities.calculatePieDatasetTotal(dataset); -        double runningTotal = 0; -        if (depth < 0) { -            return;  // if depth is negative don't draw anything -        } - -        ArrayList arcList = new ArrayList(); -        Arc2D.Double arc; -        Paint paint; -        Paint outlinePaint; -        Stroke outlineStroke; - -        Iterator iterator = sectionKeys.iterator(); -        while (iterator.hasNext()) { - -            Comparable currentKey = (Comparable) iterator.next(); -            Number dataValue = dataset.getValue(currentKey); -            if (dataValue == null) { -                arcList.add(null); -                continue; -            } -            double value = dataValue.doubleValue(); -            if (value <= 0) { -                arcList.add(null); -                continue; -            } -            double startAngle = getStartAngle(); -            double direction = getDirection().getFactor(); -            double angle1 = startAngle + (direction * (runningTotal * 360)) -                    / totalValue; -            double angle2 = startAngle + (direction * (runningTotal + value) -                    * 360) / totalValue; -            if (Math.abs(angle2 - angle1) > getMinimumArcAngleToDraw()) { -                arcList.add(new Arc2D.Double(arcX, arcY + depth, -                        pieArea.getWidth(), pieArea.getHeight() - depth, -                        angle1, angle2 - angle1, Arc2D.PIE)); -            } -            else { -                arcList.add(null); -            } -            runningTotal += value; -        } - -        Shape oldClip = g2.getClip(); - -        Ellipse2D top = new Ellipse2D.Double(pieArea.getX(), pieArea.getY(), -                pieArea.getWidth(), pieArea.getHeight() - depth); - -        Ellipse2D bottom = new Ellipse2D.Double(pieArea.getX(), pieArea.getY() -                + depth, pieArea.getWidth(), pieArea.getHeight() - depth); - -        Rectangle2D lower = new Rectangle2D.Double(top.getX(), -                top.getCenterY(), pieArea.getWidth(), bottom.getMaxY() -                - top.getCenterY()); - -        Rectangle2D upper = new Rectangle2D.Double(pieArea.getX(), top.getY(), -                pieArea.getWidth(), bottom.getCenterY() - top.getY()); - -        Area a = new Area(top); -        a.add(new Area(lower)); -        Area b = new Area(bottom); -        b.add(new Area(upper)); -        Area pie = new Area(a); -        pie.intersect(b); - -        Area front = new Area(pie); -        front.subtract(new Area(top)); - -        Area back = new Area(pie); -        back.subtract(new Area(bottom)); - -        // draw the bottom circle -        int[] xs; -        int[] ys; -        arc = new Arc2D.Double(arcX, arcY + depth, pieArea.getWidth(), -                pieArea.getHeight() - depth, 0, 360, Arc2D.PIE); - -        int categoryCount = arcList.size(); -        for (int categoryIndex = 0; categoryIndex < categoryCount; -                 categoryIndex++) { -            arc = (Arc2D.Double) arcList.get(categoryIndex); -            if (arc == null) { -                continue; -            } -            Comparable key = getSectionKey(categoryIndex); -            paint = lookupSectionPaint(key, true); -            outlinePaint = lookupSectionOutlinePaint(key); -            outlineStroke = lookupSectionOutlineStroke(key); -            g2.setPaint(paint); -            g2.fill(arc); -            g2.setPaint(outlinePaint); -            g2.setStroke(outlineStroke); -            g2.draw(arc); -            g2.setPaint(paint); - -            Point2D p1 = arc.getStartPoint(); - -            // draw the height -            xs = new int[] {(int) arc.getCenterX(), (int) arc.getCenterX(), -                    (int) p1.getX(), (int) p1.getX()}; -            ys = new int[] {(int) arc.getCenterY(), (int) arc.getCenterY() -                    - depth, (int) p1.getY() - depth, (int) p1.getY()}; -            Polygon polygon = new Polygon(xs, ys, 4); -            g2.setPaint(java.awt.Color.lightGray); -            g2.fill(polygon); -            g2.setPaint(outlinePaint); -            g2.setStroke(outlineStroke); -            g2.draw(polygon); -            g2.setPaint(paint); - -        } - -        g2.setPaint(Color.gray); -        g2.fill(back); -        g2.fill(front); - -        // cycle through once drawing only the sides at the back... -        int cat = 0; -        iterator = arcList.iterator(); -        while (iterator.hasNext()) { -            Arc2D segment = (Arc2D) iterator.next(); -            if (segment != null) { -                Comparable key = getSectionKey(cat); -                paint = lookupSectionPaint(key, true); -                outlinePaint = lookupSectionOutlinePaint(key); -                outlineStroke = lookupSectionOutlineStroke(key); -                drawSide(g2, pieArea, segment, front, back, paint, -                        outlinePaint, outlineStroke, false, true); -            } -            cat++; -        } - -        // cycle through again drawing only the sides at the front... -        cat = 0; -        iterator = arcList.iterator(); -        while (iterator.hasNext()) { -            Arc2D segment = (Arc2D) iterator.next(); -            if (segment != null) { -                Comparable key = getSectionKey(cat); -                paint = lookupSectionPaint(key); -                outlinePaint = lookupSectionOutlinePaint(key); -                outlineStroke = lookupSectionOutlineStroke(key); -                drawSide(g2, pieArea, segment, front, back, paint, -                        outlinePaint, outlineStroke, true, false); -            } -            cat++; -        } - -        g2.setClip(oldClip); - -        // draw the sections at the top of the pie (and set up tooltips)... -        Arc2D upperArc; -        for (int sectionIndex = 0; sectionIndex < categoryCount; -                 sectionIndex++) { -            arc = (Arc2D.Double) arcList.get(sectionIndex); -            if (arc == null) { -                continue; -            } -            upperArc = new Arc2D.Double(arcX, arcY, pieArea.getWidth(), -                    pieArea.getHeight() - depth, arc.getAngleStart(), -                    arc.getAngleExtent(), Arc2D.PIE); - -            Comparable currentKey = (Comparable) sectionKeys.get(sectionIndex); -            paint = lookupSectionPaint(currentKey, true); -            outlinePaint = lookupSectionOutlinePaint(currentKey); -            outlineStroke = lookupSectionOutlineStroke(currentKey); -            g2.setPaint(paint); -            g2.fill(upperArc); -            g2.setStroke(outlineStroke); -            g2.setPaint(outlinePaint); -            g2.draw(upperArc); - -           // add a tooltip for the section... -            if (info != null) { -                EntityCollection entities -                        = info.getOwner().getEntityCollection(); -                if (entities != null) { -                    String tip = null; -                    PieToolTipGenerator tipster = getToolTipGenerator(); -                    if (tipster != null) { -                        // @mgs: using the method's return value was missing -                        tip = tipster.generateToolTip(dataset, currentKey); -                    } -                    String url = null; -                    if (getURLGenerator() != null) { -                        url = getURLGenerator().generateURL(dataset, currentKey, -                                getPieIndex()); -                    } -                    PieSectionEntity entity = new PieSectionEntity( -                            upperArc, dataset, getPieIndex(), sectionIndex, -                            currentKey, tip, url); -                    entities.add(entity); -                } -            } -            List keys = dataset.getKeys(); -            Rectangle2D adjustedPlotArea = new Rectangle2D.Double( -                    originalPlotArea.getX(), originalPlotArea.getY(), -                    originalPlotArea.getWidth(), originalPlotArea.getHeight() -                    - depth); -            if (getSimpleLabels()) { -                drawSimpleLabels(g2, keys, totalValue, adjustedPlotArea, -                        linkArea, state); -            } -            else { -                drawLabels(g2, keys, totalValue, adjustedPlotArea, linkArea, -                        state); -            } -        } - -        g2.setClip(savedClip); -        g2.setComposite(originalComposite); -        drawOutline(g2, originalPlotArea); - -    } +  /** * Draws the side of a pie section. ",AVATAR,15,patch1-Chart-15-AVATAR-plausible.patch,Chart-overfit,patches_remove_inconsistent/overfitting/AVATAR/Chart/patch1-Chart-15-AVATAR-plausible.patch
349,Math,1,"case REGULA_FALSI: // Nothing. if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        x0 = 0.5 * (f0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; ",AVATAR,50,patch1-Math-50-AVATAR-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/AVATAR/Math/patch1-Math-50-AVATAR-plausible.patch
350,Math,1,"ret = Double.NaN; } else if (x == 0.0) { ret = 0.0; -        } else if (a >= 1.0 && x > a) { +        } else if (a >= 1.0 && x >= a) { // use regularizedGammaQ because it should converge faster in this // case. ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); ",AVATAR,104,patch1-Math-104-AVATAR-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/AVATAR/Math/patch1-Math-104-AVATAR-plausible.patch
351,Math,1,"(restrictToNonNegative ? 0 : mostNegative); if (basicRow != null) { for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) { -                    if (tableau.getEntry(basicRow, j) == 1) { +                    if (tableau.getEntry(basicRow, i) == 1) { coefficients[i] = 0; } } ",AVATAR,88,patch1-Math-88-AVATAR-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/AVATAR/Math/patch1-Math-88-AVATAR-plausible.patch
352,Math,1,"assignPointsToClusters(clusters, points);  // iterate through updating the centers until we're done -        final int max = (maxIterations < 0) ? Integer.MAX_VALUE : maxIterations; +        final int max = (maxIterations <= 0) ? Integer.MAX_VALUE : maxIterations; for (int count = 0; count < max; count++) { boolean clusteringChanged = false; List<Cluster<T>> newClusters = new ArrayList<Cluster<T>>(); ",AVATAR,57,patch1-Math-57-AVATAR-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/AVATAR/Math/patch1-Math-57-AVATAR-plausible.patch
353,Math,1," // compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); -            if (comparator.compare(contracted, best) < 0) { +            if (comparator.compare(contracted, best) <= 0) { // accept the contracted simplex  // check convergence ",AVATAR,84,patch1-Math-84-AVATAR-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/AVATAR/Math/patch1-Math-84-AVATAR-plausible.patch
354,Math,1,double d = getDenominatorDegreesOfFreedom(); // use mean ret = d / (d - 2.0); -        return ret; +        return d; }  /** ,AVATAR,95,patch1-Math-95-AVATAR-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/AVATAR/Math/patch1-Math-95-AVATAR-plausible.patch
355,Math,1,"double minValue = 0; Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { -            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { +            if (MathUtils.compareTo(tableau.getEntry(0, i), this.epsilon, epsilon) < 0) { minValue = tableau.getEntry(0, i); minPos = i; } ",AVATAR,82,patch1-Math-82-AVATAR-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/AVATAR/Math/patch1-Math-82-AVATAR-plausible.patch
356,Math,1,* @return the number of evaluations of the objective function. */ public int getIterations() { -        return iterations.getCount(); +        return this.evaluations.getCount(); }  /** ,AVATAR,6,patch1-Math-6-AVATAR-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/AVATAR/Math/patch1-Math-6-AVATAR-plausible.patch
357,Math,1,double s = 0.25 * dMin;  // compute contribution to norm squared from i > nn-2. -                final int np = nn - 2 * pingPong; +                final int np = nn - 2 * start; double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; ,AVATAR,81,patch1-Math-81-AVATAR-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/AVATAR/Math/patch1-Math-81-AVATAR-plausible.patch
358,Math,1,final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) || Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0); if (chebyshevApplies) { -            double k = FastMath.sqrt((1.0 - p) / p); +            double k = FastMath.sqrt((1.0 - upper) / p); double tmp = mu - k * sigma; if (tmp > lower) { lower = ((int) Math.ceil(tmp)) - 1; ,AVATAR,2,patch1-Math-2-AVATAR-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/AVATAR/Math/patch1-Math-2-AVATAR-plausible.patch
359,Math,1,"private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j = 4 * this.pingPong - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; ",AVATAR,80,patch1-Math-80-AVATAR-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/AVATAR/Math/patch1-Math-80-AVATAR-plausible.patch
360,Math,1,"try { final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min); final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min); -                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2)); +                optima[i] = optimizer.optimize(f, goal, FastMath.min(min, bound2), FastMath.max(bound1, bound2)); } catch (FunctionEvaluationException fee) { optima[i] = null; } catch (ConvergenceException ce) { ",AVATAR,62,patch1-Math-62-AVATAR-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/AVATAR/Math/patch1-Math-62-AVATAR-plausible.patch
361,Math,1,// Inverse quadratic interpolation. double r1 = y0 / y2; double r2 = y1 / y2; -                    p = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0)); +                    p = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r1 - 1.0)); p1 = (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0); } if (p > 0.0) { ,AVATAR,78,patch1-Math-78-AVATAR-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/AVATAR/Math/patch1-Math-78-AVATAR-plausible.patch
362,Math,1,"*/ private static String buildMessage(final Locale locale, final Localizable pattern, final Object ... arguments) { -        return new MessageFormat(pattern.getLocalizedString(locale), locale).format(arguments); +        return new MessageFormat(pattern.getLocalizedString(locale), locale).format(locale); }  /** Gets the message in a specified locale. ",AVATAR,49,patch1-Math-49-AVATAR-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/AVATAR/Math/patch1-Math-49-AVATAR-plausible.patch
768,Lang,0,"// contract with translators is that they have to understand codepoints // and they just took care of a surrogate pair for (int pt = 0; pt < consumed; pt++) { -                pos += Character.charCount(Character.codePointAt(input, pos)); +                pos += Character.charCount(Character.codePointAt(input, pt)); } } } ",AVATAR,6,patch1-Lang-6-AVATAR.patch,Lang-correct,patches_remove_inconsistent/correct/AVATAR/Lang/patch1-Lang-6-AVATAR.patch
769,Lang,0,* @return true if the locale is a known locale */ public static boolean isAvailableLocale(Locale locale) { -        return cAvailableLocaleSet.contains(locale); +        return cAvailableLocaleList.contains(locale); }  //----------------------------------------------------------------------- ,AVATAR,57,patch1-Lang-57-AVATAR.patch,Lang-correct,patches_remove_inconsistent/correct/AVATAR/Lang/patch1-Lang-57-AVATAR.patch
770,Lang,0,"boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); -            if(Character.isWhitespace(c)) { -                if(!wasWhite) { -                    wasWhite= true; -                    regex.append(""\\s*+""); -                } -                continue; -            } + wasWhite= false; switch(c) { case '\'': ",AVATAR,10,patch1-Lang-10-AVATAR.patch,Lang-correct,patches_remove_inconsistent/correct/AVATAR/Lang/patch1-Lang-10-AVATAR.patch
771,Lang,0,"if (StringUtils.isBlank(str)) { throw new NumberFormatException(""A blank string is not a valid number""); } -        if (str.startsWith(""--"")) { -            return null; -        } if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) { int hexDigits = str.length() - 2; // drop 0x if (str.startsWith(""-"")) { // drop - if (StringUtils.isBlank(str)) { throw new NumberFormatException(""A blank string is not a valid number""); } +        if (str.trim().startsWith(""--"")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. +            throw new NumberFormatException(str + "" is not a valid number.""); +        } return new BigDecimal(str); } ",AVATAR,7,patch1-Lang-7-AVATAR.patch,Lang-correct,patches_remove_inconsistent/correct/AVATAR/Lang/patch1-Lang-7-AVATAR.patch
772,Closure,0,"Set<String> currentPropertyNames; // This can be the case if interfaceType is proxy to a non-existent // object (which is a bad type annotation, but shouldn't crash). -      currentPropertyNames = implicitProto.getOwnPropertyNames(); +      if (implicitProto != null) { +	currentPropertyNames = implicitProto.getOwnPropertyNames(); for (String name : currentPropertyNames) { ObjectType oType = properties.get(name); if (oType != null) { } currentProperties.put(name, interfaceType); } +} + for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) { checkInterfaceConflictProperties(t, n, functionName, properties, currentProperties, iType); ",AVATAR,2,patch1-Closure-2-AVATAR.patch,Closure-correct,patches_remove_inconsistent/correct/AVATAR/Closure/patch1-Closure-2-AVATAR.patch
773,Closure,0,"propertyNode); }  -  @Override -  public JSType getLeastSupertype(JSType that) { -    if (!that.isRecordType()) { -      return super.getLeastSupertype(that); -    } -    RecordTypeBuilder builder = new RecordTypeBuilder(registry); -    for (String property : properties.keySet()) { -      if (that.toMaybeRecordType().hasProperty(property) && -          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( -              getPropertyType(property))) { -        builder.addProperty(property, getPropertyType(property), -            getPropertyNode(property)); -      } -    } -    return builder.build(); -  } JSType getGreatestSubtypeHelper(JSType that) { if (that.isRecordType()) { RecordType thatRecord = that.toMaybeRecordType(); ",AVATAR,46,patch1-Closure-46-AVATAR.patch,Closure-correct,patches_remove_inconsistent/correct/AVATAR/Closure/patch1-Closure-46-AVATAR.patch
774,Closure,0,// charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +          && 0 <= charno && charno <= sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { ,AVATAR,62,patch1-Closure-62-AVATAR.patch,Closure-correct,patches_remove_inconsistent/correct/AVATAR/Closure/patch1-Closure-62-AVATAR.patch
775,Closure,0,"// For each named parameter check if a mutable argument use more than one. if (fnParam != null) { if (cArg != null) { -          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { -            return CanInlineResult.NO; -          } + // Check for arguments that are evaluated more than once. // Note: Unlike block inlining, there it is not possible that a // parameter reference will be in a loop. ",AVATAR,115,patch1-Closure-115-AVATAR.patch,Closure-correct,patches_remove_inconsistent/correct/AVATAR/Closure/patch1-Closure-115-AVATAR.patch
776,Closure,0,"// No charsetEncoder provided - pass straight latin characters // through, and escape the rest.  Doing the explicit character // check is measurably faster than using the CharsetEncoder. -            if (c > 0x1f && c <= 0x7f) { +            if (c > 0x1f && c < 0x7f) { sb.append(c); } else { // Other characters can be misinterpreted by some js parsers, ",AVATAR,73,patch1-Closure-73-AVATAR.patch,Closure-correct,patches_remove_inconsistent/correct/AVATAR/Closure/patch1-Closure-73-AVATAR.patch
777,Closure,0,"// x--4 (which is a syntax error). char prev = getLastChar(); boolean negativeZero = isNegativeZero(x); -    if (x < 0 && prev == '-') { +    if (x <= 0 && prev == '-') { add("" ""); } ",AVATAR,38,patch1-Closure-38-AVATAR.patch,Closure-correct,patches_remove_inconsistent/correct/AVATAR/Closure/patch1-Closure-38-AVATAR.patch
778,Chart,0,} }  +                if (r != null) { Collection c = r.getAnnotations(); Iterator i = c.iterator(); while (i.hasNext()) { includedAnnotations.add(a); } } +                } } } ,AVATAR,4,patch1-Chart-4-AVATAR.patch,Chart-correct,patches_remove_inconsistent/correct/AVATAR/Chart/patch1-Chart-4-AVATAR.patch
779,Chart,0,if (p1.getWindingRule() != p2.getWindingRule()) { return false; } -        PathIterator iterator1 = p1.getPathIterator(null); +        PathIterator iterator1 = p2.getPathIterator(null); PathIterator iterator2 = p1.getPathIterator(null); double[] d1 = new double[6]; double[] d2 = new double[6]; ,AVATAR,11,patch1-Chart-11-AVATAR.patch,Chart-correct,patches_remove_inconsistent/correct/AVATAR/Chart/patch1-Chart-11-AVATAR.patch
780,Chart,0,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if (dataset == null) { return result; } int seriesCount = dataset.getRowCount(); ,AVATAR,1,patch1-Chart-1-AVATAR.patch,Chart-correct,patches_remove_inconsistent/correct/AVATAR/Chart/patch1-Chart-1-AVATAR.patch
781,Chart,0,"public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); -        int g = (int) ((value - this.lowerBound) / (this.upperBound +        int g = (int) ((v - this.lowerBound) / (this.upperBound - this.lowerBound) * 255.0); return new Color(g, g, g); } ",AVATAR,24,patch1-Chart-24-AVATAR.patch,Chart-correct,patches_remove_inconsistent/correct/AVATAR/Chart/patch1-Chart-24-AVATAR.patch
782,Math,0,"* @return b if a is lesser or equal to b, a otherwise */ public static float max(final float a, final float b) { -        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b); +        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a); }  /** Compute the maximum of two values ",AVATAR,59,patch1-Math-59-AVATAR.patch,Math-correct,patches_remove_inconsistent/correct/AVATAR/Math/patch1-Math-59-AVATAR.patch
783,Math,0,"*/ @Deprecated public void addValue(Object v) { +        if (v instanceof Comparable<?>){ addValue((Comparable<?>) v); +        } else { +            throw new IllegalArgumentException(""Object must implement Comparable""); +        } }  /** ",AVATAR,89,patch1-Math-89-AVATAR.patch,Math-correct,patches_remove_inconsistent/correct/AVATAR/Math/patch1-Math-89-AVATAR.patch
784,Math,0, // compute the intersection on infinite line Vector3D v1D = line.intersection(subLine.line); +        if (v1D == null) { +            return null; +        }  // check location of point with respect to first sub-line Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));    // compute the intersection on infinite line Vector2D v2D = line1.intersection(line2); +        if (v2D == null) { +            return null; +        }  // check location of point with respect to first sub-line Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D)); ,AVATAR,4,patch1-Math-4-AVATAR.patch,Math-correct,patches_remove_inconsistent/correct/AVATAR/Math/patch1-Math-4-AVATAR.patch
