,project,label,content,tool,bug_id,filename,project_with_label,all_paths
122,Lang,1,* @return true if the locale is a known locale */ public static boolean isAvailableLocale(Locale locale) { -        return cAvailableLocaleSet.contains(locale); +        if (cAvailableLocaleSet == null) { +    return false; +} +return cAvailableLocaleSet.contains(locale); }  //----------------------------------------------------------------------- ,FixMiner,57,patch1-Lang-57-FixMiner-plausible.patch,Lang-overfit,patches_remove_inconsistent/overfitting/FixMiner/Lang/patch1-Lang-57-FixMiner-plausible.patch
123,Lang,1,"int startValue = start.get(field); if (endValue < startValue) { int newdiff = startValue - endValue; -            end.add( field, newdiff ); +            end.add( newdiff, newdiff ); return newdiff; } else { return 0; ",FixMiner,63,patch1-Lang-63-FixMiner-plausible.patch,Lang-overfit,patches_remove_inconsistent/overfitting/FixMiner/Lang/patch1-Lang-63-FixMiner-plausible.patch
124,Closure,1,} } else if (type == Token.CALL) { if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) { -        return false; +        return (false) || !(recur); } } ,FixMiner,129,patch1-Closure-129-FixMiner-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/FixMiner/Closure/patch1-Closure-129-FixMiner-plausible.patch
125,Closure,1,"// ""this"" references aren't currently modeled in the CFG.  default: -        throw new IllegalArgumentException(""Node cannot be refined. \n"" + -            node.toStringTree()); + } } ",FixMiner,19,patch1-Closure-19-FixMiner-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/FixMiner/Closure/patch1-Closure-19-FixMiner-plausible.patch
126,Chart,1,"h[1] = size.height; } h[2] = constraint.getHeight() - h[1] - h[0]; -        if (this.leftBlock != null) { +        if ((this.leftBlock != null) && !(this.rightBlock != null)) { RectangleConstraint c3 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth()), LengthConstraintType.RANGE, h[2], null, ",FixMiner,13,patch1-Chart-13-FixMiner-plausible.patch,Chart-overfit,patches_remove_inconsistent/overfitting/FixMiner/Chart/patch1-Chart-13-FixMiner-plausible.patch
127,Chart,1,if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); -            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() +            long e = getDataItem(this.maxStartIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { ,FixMiner,7,patch1-Chart-7-FixMiner-plausible.patch,Chart-overfit,patches_remove_inconsistent/overfitting/FixMiner/Chart/patch1-Chart-7-FixMiner-plausible.patch
128,Chart,1,markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } -        boolean removed = markers.remove(marker); +        if (markers == null) { +    return false; +} +boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); } ,FixMiner,14,patch1-Chart-14-FixMiner-plausible.patch,Chart-overfit,patches_remove_inconsistent/overfitting/FixMiner/Chart/patch1-Chart-14-FixMiner-plausible.patch
129,Chart,1,"linkH = 2 * min; }  -        PiePlotState state = initialise(g2, plotArea, this, null, info); +        if (info == null) { +    return; +} +PiePlotState state = initialise(g2, plotArea, this, null, info);  // the link area defines the dog leg points for the linking lines to // the labels ",FixMiner,15,patch1-Chart-15-FixMiner-plausible.patch,Chart-overfit,patches_remove_inconsistent/overfitting/FixMiner/Chart/patch1-Chart-15-FixMiner-plausible.patch
130,Chart,1,"// if the plot area is too small, just return... boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW); boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW); -        if (b1 || b2) { +        if (b1 || (getRenderer() != null)) { return; } ",FixMiner,26,patch1-Chart-26-FixMiner-plausible.patch,Chart-overfit,patches_remove_inconsistent/overfitting/FixMiner/Chart/patch1-Chart-26-FixMiner-plausible.patch
131,Chart,1,"public Number getMeanValue(int row, int column) { Number result = null; MeanAndStandardDeviation masd -            = (MeanAndStandardDeviation) this.data.getObject(row, column); +            = (MeanAndStandardDeviation) this.data.getObject((int)this.minimumRangeValue, column); if (masd != null) { result = masd.getMean(); } ",FixMiner,25,patch1-Chart-25-FixMiner-plausible.patch,Chart-overfit,patches_remove_inconsistent/overfitting/FixMiner/Chart/patch1-Chart-25-FixMiner-plausible.patch
132,Chart,1,this.data.remove(0); removed = true; } -            if (removed) { +            if ((removed) || !(notify)) { findBoundsByIteration(); if (notify) { fireSeriesChanged(); ,FixMiner,3,patch1-Chart-3-FixMiner-plausible.patch,Chart-overfit,patches_remove_inconsistent/overfitting/FixMiner/Chart/patch1-Chart-3-FixMiner-plausible.patch
133,Chart,1,"if (start < 0) { throw new IllegalArgumentException(""Requires start >= 0.""); } -        if (end < start) { +        if ((end < start) && (this.data.size() > 0)) { throw new IllegalArgumentException(""Requires start <= end.""); } TimeSeries copy = (TimeSeries) super.clone(); ",FixMiner,17,patch1-Chart-17-FixMiner-plausible.patch,Chart-overfit,patches_remove_inconsistent/overfitting/FixMiner/Chart/patch1-Chart-17-FixMiner-plausible.patch
134,Math,1,"case REGULA_FALSI: // Nothing. if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), fx)); f0 = computeObjectiveValue(x0); } break; ",FixMiner,50,patch1-Math-50-FixMiner-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/FixMiner/Math/patch1-Math-50-FixMiner-plausible.patch
135,Math,1,double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; -                if (work[np - 8] > b2 || work[np - 4] > b1) { +                if (work[np - 8] <= b2 || work[np - 4] > b1) { return; } double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); ,FixMiner,81,patch1-Math-81-FixMiner-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/FixMiner/Math/patch1-Math-81-FixMiner-plausible.patch
136,Math,1,"}  // initial checks for splits (see Parlett & Marques section 3.3) -        flipIfWarranted(n, 2); +        goodStep(n, 2);  // two iterations with Li's test for initial splits initialSplits(n); ",FixMiner,80,patch1-Math-80-FixMiner-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/FixMiner/Math/patch1-Math-80-FixMiner-plausible.patch
137,Math,1,"((a > lowerBound) || (b < upperBound)));  if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); + }  return new double[]{a, b}; ",FixMiner,85,patch1-Math-85-FixMiner-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/FixMiner/Math/patch1-Math-85-FixMiner-plausible.patch
138,Math,1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return x == y; }  /** ",FixMiner,63,patch1-Math-63-FixMiner-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/FixMiner/Math/patch1-Math-63-FixMiner-plausible.patch
139,Math,1,"* Default constructor, uses default parameters */ public CMAESOptimizer() { -        this(0); + }  /** ",FixMiner,20,patch1-Math-20-FixMiner-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/FixMiner/Math/patch1-Math-20-FixMiner-plausible.patch
140,Time,1,* @return true to log verbosely */ public static boolean verbose() { -        return cVerbose.get(); +        return cVerbose != null || cVerbose.get(); }  //----------------------------------------------------------------------- ,FixMiner,11,patch1-Time-11-FixMiner-plausible.patch,Time-overfit,patches_remove_inconsistent/overfitting/FixMiner/Time/patch1-Time-11-FixMiner-plausible.patch
693,Chart,0,"*/ public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); -        v = Math.min(v, this.upperBound); +        value = Math.min(v, this.upperBound); int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) * 255.0); return new Color(g, g, g); ",FixMiner,24,patch1-Chart-24-FixMiner.patch,Chart-correct,patches_remove_inconsistent/correct/FixMiner/Chart/patch1-Chart-24-FixMiner.patch
694,Math,0, /** {@inheritDoc} */ public boolean isSupportLowerBoundInclusive() { -        return true; +        return false; }  /** {@inheritDoc} */ ,FixMiner,22,patch1-Math-22-FixMiner.patch,Math-correct,patches_remove_inconsistent/correct/FixMiner/Math/patch1-Math-22-FixMiner.patch
695,Math,0,"final int n2) throws ConvergenceException, MaxCountExceededException {  -        final int n1n2prod = n1 * n2; +        final double n1n2prod = n1 * n2;  // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation final double EU = n1n2prod / 2.0; ",FixMiner,30,patch1-Math-30-FixMiner.patch,Math-correct,patches_remove_inconsistent/correct/FixMiner/Math/patch1-Math-30-FixMiner.patch
696,Math,0,"while (resultSet.size() < k) { // For each data point x, compute D(x), the distance between x and // the nearest center that has already been chosen. -            int sum = 0; +            double sum = 0; for (int i = 0; i < pointSet.size(); i++) { final T p = pointSet.get(i); final Cluster<T> nearest = getNearestCluster(resultSet, p); ",FixMiner,57,patch1-Math-57-FixMiner.patch,Math-correct,patches_remove_inconsistent/correct/FixMiner/Math/patch1-Math-57-FixMiner.patch
697,Math,0,"* @return the L<sub>2</sub> distance between the two points */ public static double distance(int[] p1, int[] p2) { -      int sum = 0; +      double sum=0; for (int i = 0; i < p1.length; i++) { -          final int dp = p1[i] - p2[i]; +          final double dp=p1[i]-p2[i]; sum += dp * dp; } return Math.sqrt(sum);",FixMiner,79,patch1-Math-79-FixMiner.patch,Math-correct,patches_remove_inconsistent/correct/FixMiner/Math/patch1-Math-79-FixMiner.patch
698,Math,0,*/ @Deprecated public double getPct(Object v) { -        return getCumPct((Comparable<?>) v); +        return getPct((Comparable<?>) v); }  /** ,FixMiner,75,patch1-Math-75-FixMiner.patch,Math-correct,patches_remove_inconsistent/correct/FixMiner/Math/patch1-Math-75-FixMiner.patch
