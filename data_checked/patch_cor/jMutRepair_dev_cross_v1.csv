0,"index 1afb7a8..c5ef4b0 100644 break; case Token.MOD: if (rval == 0) { -          error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right); return null; } result = lval % rval; break; case Token.DIV: if (rval == 0) { -          error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right); return null; } result = lval / rval;"
0,"index 8c5d125..a31b17a 100644 return true;  // Binary operators are only valid if both children are valid. +      case Token.ADD: case Token.BITAND: case Token.BITNOT: case Token.BITOR: case Token.BITXOR: +      case Token.DIV: +      case Token.EQ: +      case Token.GE: +      case Token.GT: +      case Token.LE: +      case Token.LSH: +      case Token.LT: +      case Token.MOD: +      case Token.MUL: +      case Token.NE: +      case Token.RSH: +      case Token.SHEQ: +      case Token.SHNE: +      case Token.SUB: +      case Token.URSH: +        return isValidDefineValue(val.getFirstChild(), defines) +            && isValidDefineValue(val.getLastChild(), defines);  // Uniary operators are valid if the child is valid. case Token.NOT: case Token.NEG: +      case Token.POS: return isValidDefineValue(val.getFirstChild(), defines);  // Names are valid if and only if they are defines themselves."
0,"index 38857c7..8df302f 100644 currentFormatField= nextFormatField; currentStrategy= nextStrategy; } +        if (patternMatcher.regionStart() != patternMatcher.regionEnd()) { +            throw new IllegalArgumentException(""Failed to parse \""""+pattern+""\"" ; gave up at index ""+patternMatcher.regionStart()); +        } if(currentStrategy.addRegex(this, regex)) { collector.add(currentStrategy); }"
0,} Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { -            classes[i] = array[i].getClass(); +            classes[i] = array[i] == null ? null : array[i].getClass(); } return classes; } 
1,"DurationField first = savedFields[0].iField.getDurationField(); if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) { saveField(DateTimeFieldType.year(), iDefaultYear); +                if (resetFields) { return computeMillis(resetFields, text); } } +        }  long millis = iMillis; try {"
0,double chiSquare = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; -            chiSquare += residual * residual / residualsWeights[i]; +            chiSquare += ((residualsWeights[i]) * residual) * residual; } return chiSquare; }
1,"for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { +                if (org.apache.commons.math3.optimization.linear.SimplexTableau.this.numSlackVariables < org.apache.commons.math3.optimization.linear.SimplexTableau.this.constraints.size()) { columnsToDrop.add(i); } } +        }  // non-basic artificial variables for (int i = 0; i < getNumArtificialVariables(); i++) {"
1,} } else if (type == Token.CALL) { if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) { -        return false; +        return (false) || !(recur); } } 
1,* @return the number of evaluations of the objective function. */ public int getIterations() { -        return iterations.getCount(); +        return evaluations.getCount(); }  /** 
1,"// In ADVANCED mode, goog.getMsg is going to be renamed anyway, // so we might as well inline it. But shut off the i18n warnings, // because the user didn't really ask for i18n. -      options.messageBundle = new EmptyMessageBundle(); + }  return options; "
0,"public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); +        if((isNaN() || rhs.isNaN()) == true){ +            return NaN; +        } return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }"
0,"index 8228589..3cc4138 100644 */ public Week(Date time, TimeZone zone) { // defer argument checking... -        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault()); +        this(time, zone, Locale.getDefault()); }  /**"
0,"index 73ece1c..85f1c81 100644 if (!(obj instanceof ShapeList)) { return false; } -        return super.equals(obj); +        ShapeList that = (ShapeList) obj; +        int listSize = size(); +        for (int i = 0; i < listSize; i++) { +           if (!ShapeUtilities.equal((Shape) get(i), (Shape) that.get(i))) { +               return false; +           } +        } +        return true;  } "
1,"w[4] = size.width; h[4] = size.height; } -        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4])); +        this.rightBlock = null; +        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4])); return arrange(container, g2, new RectangleConstraint(width, height)); } "
1,"public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); -        int g = (int) ((value - this.lowerBound) / (this.upperBound +        int g = (int) ((java.lang.Math.min(v, upperBound)) / (this.upperBound - this.lowerBound) * 255.0); return new Color(g, g, g); } "
1,return false; } for (int i = 0; i < point.length; i++) { +            if (((otherPoint[i])) != (otherPoint.length)) { if (point[i] != otherPoint[i]) { return false; } } +        } return true; } 
0,index 1dc33b7..2270c17 100644  static boolean isSimpleNumber(String s) { int len = s.length(); +    if (len == 0) { +      return false; +    } for (int index = 0; index < len; index++) { char c = s.charAt(index); if (c < '0' || c > '9') { return false; } } -    return len > 0 && s.charAt(0) != '0'; +    return len == 1 || s.charAt(0) != '0'; }  static double getSimpleNumber(String s) {
0,"index ec31907..cf3f52f 100644 * @since 1.0.3 */ public int getDomainAxisIndex(CategoryAxis axis) { +        if (axis == null) { +            throw new IllegalArgumentException(""Null 'axis' argument.""); +        } return this.domainAxes.indexOf(axis); }  * @since 1.0.7 */ public int getRangeAxisIndex(ValueAxis axis) { +        if (axis == null) { +            throw new IllegalArgumentException(""Null 'axis' argument.""); +        } int result = this.rangeAxes.indexOf(axis); if (result < 0) { // try the parent plot Plot parent = getParent();"
1,"locale = Locale.getDefault(); } try { +                if(locale!=null){ +                    key=new Pair(key,locale); +                } SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale); String pattern = formatter.toPattern(); "
0,"index b3ae54b..730aeb3 100644 h[3] = h[2]; if (this.rightBlock != null) { RectangleConstraint c4 = new RectangleConstraint(0.0, -                    new Range(0.0, constraint.getWidth() - w[2]), +                    new Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)), LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED); Size2D size = this.rightBlock.arrange(g2, c4);"
1,"drawHorizontalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, statData, row, column); } -        else if (orientation == PlotOrientation.VERTICAL) { +        if (orientation == PlotOrientation.HORIZONTAL) { drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, statData, row, column); } "
1,final double gam = dN2; -                if (work[np - 8] > b2 || work[np - 4] > b1) { +                if (true) { return; 
1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(""JSC_BASE_CLASS_ERROR""); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"
1," // Check if the sources need to be re-ordered. boolean staleInputs = false; -      if (options.dependencyOptions.needsManagement() && options.closurePass) { +      if(((options.dependencyOptions)!=null)&&(options.dependencyOptions.needsManagement())){ for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they // are not flagged even if they are dropped from the process."
1,"*/ public void removeRow(Comparable rowKey) { int index = getRowIndex(rowKey); +        if(index<0){ +            throw new UnknownKeyException(""The key (""+rowKey.toString()); +        } removeRow(index); } "
0,} Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { -            classes[i] = array[i].getClass(); +            if (classes == null) continue; +	if (array[i] == null) continue; +	classes[i] = array[i].getClass(); } return classes; } 
1,} }  -          if (canRemove) { +          if (false) { declaration.remove(); changed = true; } 
0,"index ed76a29..8d28c5f 100644 * @since 1.2 */ public Complex tan() { -        if (isNaN) { +        if (isNaN || Double.isInfinite(real)) { return NaN; } +        if (imaginary > 20.0) { +            return createComplex(0.0, 1.0); +        } +        if (imaginary < -20.0) { +            return createComplex(0.0, -1.0); +        }  double real2 = 2.0 * real; double imaginary2 = 2.0 * imaginary; * @since 1.2 */ public Complex tanh() { -        if (isNaN) { +        if (isNaN || Double.isInfinite(imaginary)) { return NaN; } +        if (real > 20.0) { +            return createComplex(1.0, 0.0); +        } +        if (real < -20.0) { +            return createComplex(-1.0, 0.0); +        } double real2 = 2.0 * real; double imaginary2 = 2.0 * imaginary; double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);"
0,"index 927e17f..75c9757 100644 this.checker = checker;  evaluations = new Incrementor(0, new MaxEvalCallback()); -        iterations = new Incrementor(0, new MaxIterCallback()); +        iterations = new Incrementor(Integer.MAX_VALUE, new MaxIterCallback()); }  /** index bd12b54..e010781 100644 }  PointValuePair current = null; -        int iter = 0; int maxEval = getMaxEvaluations(); while (true) { -            ++iter; +            incrementIterationCount();  final double objective = computeObjectiveValue(point); PointValuePair previous = current; current = new PointValuePair(point, objective); if (previous != null) { -                if (checker.converged(iter, previous, current)) { +                if (checker.converged(getIterations(), previous, current)) { // We have found an optimum. return current; } steepestDescent = newSteepestDescent;  // Compute conjugate search direction. -            if (iter % n == 0 || +            if (getIterations() % n == 0 || beta < 0) { // Break conjugation: reset search direction. searchDirection = steepestDescent.clone(); index fed67b1..0303041 100644  generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) { +            incrementIterationCount();  // Generate and evaluate lambda offspring final RealMatrix arz = randn1(dimension, lambda); index afe8d2f..9572820 100644 double[] x = guess; double fVal = computeObjectiveValue(x); double[] x1 = x.clone(); -        int iter = 0; while (true) { -            ++iter; +            incrementIterationCount();  double fX = fVal; double fX2 = 0; final PointValuePair current = new PointValuePair(x, fVal); if (!stop) { // User-defined stopping criteria. if (checker != null) { -                    stop = checker.converged(iter, previous, current); +                    stop = checker.converged(getIterations(), previous, current); } } if (stop) { index 0dd644e..9ea2324 100644 int iteration = 0; final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker(); while (true) { -            if (iteration > 0) { +            if (getIterations() > 0) { boolean converged = true; for (int i = 0; i < simplex.getSize(); i++) { PointValuePair prev = previous[i]; previous = simplex.getPoints(); simplex.iterate(evalFunc, comparator);  +            incrementIterationCount(); +			++iteration; } }  index 844ed22..a2834f2 100644  // iterate until convergence is reached PointVectorValuePair current = null; -        int iter = 0; for (boolean converged = false; !converged;) { -            ++iter; +            incrementIterationCount();  // evaluate the objective function and its jacobian PointVectorValuePair previous = current;  // Check convergence. if (previous != null) { -                converged = checker.converged(iter, previous, current); +                converged = checker.converged(getIterations(), previous, current); if (converged) { setCost(computeCost(currentResiduals)); return current; index 4016131..ca2d138 100644 // Outer loop. lmPar = 0; boolean firstIteration = true; -        int iter = 0; final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); while (true) { +            incrementIterationCount(); - -            ++iter; final PointVectorValuePair previous = current;  // QR decomposition of the jacobian matrix // tests for convergence. if (checker != null) { // we use the vectorial convergence checker -                        if (checker.converged(iter, previous, current)) { +                        if (checker.converged(getIterations(), previous, current)) { setCost(currentCost); return current; }"
1,"// x--4 (which is a syntax error). char prev = getLastChar(); boolean negativeZero = isNegativeZero(x); -    if (x < 0 && prev == '-') { +    if((prev!=0)&&(prev=='-')){ add("" ""); } "
0,index 139d9a7..ceb886e 100644 * @return true if the locale is a known locale */ public static boolean isAvailableLocale(Locale locale) { -        return cAvailableLocaleSet.contains(locale); +        return availableLocaleList().contains(locale); }  //-----------------------------------------------------------------------
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((Math.min((fa*fb),0.0))> 0.0){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,index d2bbf67..13ced27 100644 }  stepSize = hNew; +        if (forward) { +            if (stepStart + stepSize >= t) { +                stepSize = t - stepStart; +            } +        } else { +            if (stepStart + stepSize <= t) { +                stepSize = t - stepStart; +            } +        }  // next stages for (int k = 1; k < stages; ++k) {
0,"index 2d915e5..3c741e9 100644 */ public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {  +      final double n1 = v1.getNormSq(); +      final double n2 = v2.getNormSq(); +      if ((n1 * n2) < MathUtils.SAFE_MIN) { +          return ZERO; +      }  // rescale both vectors without losing precision, // to ensure their norm are the same order of magnitude +      final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4; +      final double x1    = FastMath.scalb(v1.x, -deltaExp); +      final double y1    = FastMath.scalb(v1.y, -deltaExp); +      final double z1    = FastMath.scalb(v1.z, -deltaExp); +      final double x2    = FastMath.scalb(v2.x,  deltaExp); +      final double y2    = FastMath.scalb(v2.y,  deltaExp); +      final double z2    = FastMath.scalb(v2.z,  deltaExp);  // we reduce cancellation errors by preconditioning, // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf  // compute rho as an 8 bits approximation of v1.v2 / v2.v2 +      final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp); +      final double rho   = FastMath.rint(256 * ratio) / 256;  +      final double x3 = x1 - rho * x2; +      final double y3 = y1 - rho * y2; +      final double z3 = z1 - rho * z2;  // compute cross product from v3 and v2 instead of v1 and v2 -      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x); +      return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);  } "
0,"index b41456e..5091493 100644 double[] diag    = new double[cols]; double[] oldX    = new double[cols]; double[] oldRes  = new double[rows]; +        double[] oldObj  = new double[rows]; +        double[] qtf     = new double[rows]; double[] work1   = new double[cols]; double[] work2   = new double[cols]; double[] work3   = new double[cols]; boolean firstIteration = true; VectorialPointValuePair current = new VectorialPointValuePair(point, objective); while (true) { +            for (int i=0;i<rows;i++) { +                qtf[i]=residuals[i]; +            } incrementIterationsCounter();  // compute the Q.R. decomposition of the jacobian matrix qrDecomposition();  // compute Qt.res -            qTy(residuals); +            qTy(qtf); // now we don't need Q anymore, // so let jacobian contain the R matrix with its diagonal elements for (int k = 0; k < solvedCols; ++k) { if (s != 0) { double sum = 0; for (int i = 0; i <= j; ++i) { -                            sum += jacobian[i][pj] * residuals[i]; +                            sum += jacobian[i][pj] * qtf[i]; } maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost)); } } if (maxCosine <= orthoTolerance) { // convergence has been reached +            	updateResidualsAndCost(); +            	current = new VectorialPointValuePair(point, objective); return current; }  double[] tmpVec = residuals; residuals = oldRes; oldRes    = tmpVec; +                tmpVec    = objective; +                objective = oldObj; +                oldObj    = tmpVec;  // determine the Levenberg-Marquardt parameter -                determineLMParameter(oldRes, delta, diag, work1, work2, work3); +                determineLMParameter(qtf, delta, diag, work1, work2, work3);  // compute the new point and the norm of the evolution direction double lmNorm = 0;  // evaluate the function at x + p and calculate its norm updateResidualsAndCost(); -                current = new VectorialPointValuePair(point, objective);  // compute the scaled actual reduction double actRed = -1.0; xNorm    += xK * xK; } xNorm = Math.sqrt(xNorm); +                    current = new VectorialPointValuePair(point, objective);  // tests for convergence. +                    if (checker != null) { // we use the vectorial convergence checker +                    	if (checker.converged(getIterations(), previous, current)) { +                    		return current; +                    	} +                    } } else { // failed iteration, reset the previous values cost = previousCost; tmpVec    = residuals; residuals = oldRes; oldRes    = tmpVec; +                    tmpVec    = objective; +                    objective = oldObj; +                    oldObj    = tmpVec; } if (checker==null) { if (((Math.abs(actRed) <= costRelativeTolerance) && (delta <= parRelativeTolerance * xNorm)) { return current; } -                } else { -                    if (checker.converged(getIterations(), previous, current)) { -                        return current; -                    } } // tests for termination and stringent tolerances // (2.2204e-16 is the machine epsilon for IEEE754)"
0,}  double sumWts = 0; -                for (int i = 0; i < weights.length; i++) { +                for (int i = begin; i < begin + length; i++) { sumWts += weights[i]; } 
0,"index 1bbad3e..6f3e883 100644 }  if (firstTime) { -          final double[] scale; +          final double[] scale = new double[y0.length]; if (vecAbsoluteTolerance == null) { -              scale = new double[y0.length]; -              java.util.Arrays.fill(scale, scalAbsoluteTolerance); +              for (int i = 0; i < scale.length; ++i) { +                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]); +              } } else { -              scale = vecAbsoluteTolerance; +              for (int i = 0; i < scale.length; ++i) { +                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]); +              } } hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);"
0,"index 06988ab..70142c4 100644 // makes more sense. Now, resolution via registry is first in order to // avoid triggering the warnings built into the resolution via properties. boolean resolved = resolveViaRegistry(t, enclosing); -    if (detectImplicitPrototypeCycle()) { +    if (detectInheritanceCycle()) { handleTypeCycle(t); }  }  resolveViaProperties(t, enclosing); -    if (detectImplicitPrototypeCycle()) { +    if (detectInheritanceCycle()) { handleTypeCycle(t); } "
1,"if (objectType != null && (objectType.getConstructor() != null || objectType.isFunctionPrototypeType())) { -          return objectType.toString() + ""."" + propName; } } } "
1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(0,'.'); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"
1," // Verify bracketing double sign = yMin * yMax; -        if (sign >= 0) { -            // check if either value is close to a zero +if (sign >= 0&&!(sign<=(double)0.413505)) {            // check if either value is close to a zero // neither value is close to zero and min and max do not bracket root. throw new IllegalArgumentException (""Function values at endpoints do not have different signs."" + "
0,index 4c3b258..f146b0e 100644  @Override public int parseArguments(Parameters params) throws CmdLineException { -        String param = params.getParameter(0); +        String param = null; +        try { +          param = params.getParameter(0); +        } catch (CmdLineException e) {}  if (param == null) { setter.addValue(true);
0,"index 752e04f..0345c85 100644 scope.inferQualifiedSlot(node, qualifiedName, origType, type); break;  +      case Token.THIS: // ""this"" references aren't currently modeled in the CFG. +        break;  default: throw new IllegalArgumentException(""Node cannot be refined. \n"" +"
1,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if((dataset!=null)&&(index!=0)){ return result; } int seriesCount = dataset.getRowCount();
1,"child.getLastChild()); break; case Token.GETPROP: -              maybeCollectMember(child, child, null); +              { +                if (true) +                    return; +                maybeCollectMember(child, child, null); +            } break; } } "
1,"public Complex add(Complex rhs) throws NullArgumentException { +        if((isNaN() || rhs.isNaN()) == true){ +            return NaN; +        } MathUtils.checkNotNull(rhs); return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }"
1,// padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line -      if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +      if (excerpt.equals(LINE) || 0 <= charno && charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { 
1," // Check if the sources need to be re-ordered. boolean staleInputs = false; -      if (options.dependencyOptions.needsManagement() && options.closurePass) { +      if((options.dependencyOptions.needsManagement())||(options.closurePass)){ for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they // are not flagged even if they are dropped from the process."
1,"*/ public Complex add(Complex rhs) throws NullArgumentException { +        if ((isNaN) || (rhs.isNaN)) {    return org.apache.commons.math.complex.Complex.NaN;} MathUtils.checkNotNull(rhs); return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }"
1,for (int i = begin; i < begin + length; i++) { correction += weights[i] * (values[i] - xbarw); } +            if (xbarw < length) { return xbarw + (correction/sumw); } +        } return Double.NaN; } 
0,"index 03c92eb..1ae554c 100644 if ((k == 1) || (k == n - 1)) { return n; } -        long result = Math.round(binomialCoefficientDouble(n, k)); -        if (result == Long.MAX_VALUE) { -            throw new ArithmeticException( -                ""result too large to represent in a long integer""); -        } // Use symmetry for large k +        if (k > n / 2) +            return binomialCoefficient(n, n - k);  // We use the formula // (n choose k) = n! / (n-k)! / k! // (n choose k) == ((n-k+1)*...*n) / (1*...*k) // which could be written // (n choose k) == (n-1 choose k-1) * n / k +        long result = 1; +        if (n <= 61) { // For n <= 61, the naive implementation cannot overflow. +            for (int j = 1, i = n - k + 1; j <= k; i++, j++) { +                result = result * i / j; +            } +        } else if (n <= 66) { // For n > 61 but n <= 66, the result cannot overflow, // but we must take care not to overflow intermediate values. +            for (int j = 1, i = n - k + 1; j <= k; i++, j++) { // We know that (result * i) is divisible by j, // but (result * i) may overflow, so we split j: // Filter out the gcd, d, so j/d and i/d are integer. // result is divisible by (j/d) because (j/d) // is relative prime to (i/d) and is a divisor of // result * (i/d). +                long d = gcd(i, j); +                result = (result / (j / d)) * (i / d); +            } +        } else { // For n > 66, a result overflow might occur, so we check // the multiplication, taking care to not overflow // unnecessary. +            for (int j = 1, i = n - k + 1; j <= k; i++, j++) { +                long d = gcd(i, j); +                result = mulAndCheck((result / (j / d)), (i / d)); +            } +        } return result; }  * @throws IllegalArgumentException if preconditions are not met. */ public static double binomialCoefficientDouble(final int n, final int k) { +        if (n < k) { +            throw new IllegalArgumentException( +                ""must have n >= k for binomial coefficient (n,k)""); +        } +        if (n < 0) { +            throw new IllegalArgumentException( +                ""must have n >= 0 for binomial coefficient (n,k)""); +        } +        if ((n == k) || (k == 0)) { +            return 1d; +        } +        if ((k == 1) || (k == n - 1)) { +            return n; +        } +        if (k > n/2) { +            return binomialCoefficientDouble(n, n - k); +        } +        if (n < 67) { +            return binomialCoefficient(n,k); +        }  +        double result = 1d; +        for (int i = 1; i <= k; i++) { +             result *= (double)(n - k + i) / (double)i; +        }  -        return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5); +        return Math.floor(result + 0.5); }  /** * For values small enough to do exact integer computation, * return the log of the exact value */ +        if (n < 67) { +            return Math.log(binomialCoefficient(n,k)); +        }  /* * Return the log of binomialCoefficientDouble for values that will not * overflow binomialCoefficientDouble */ +        if (n < 1030) { +            return Math.log(binomialCoefficientDouble(n, k)); +        }  /* * Sum logs for values that could overflow"
1,"double r = p2 / q2;  if (Double.isNaN(r)) { -                throw new ConvergenceException( -                  LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, +                throw new MaxIterationsExceededException(maxIterations, +                LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, x); } relativeError = FastMath.abs(r / c - 1.0); "
1,"}  if (tailZone != null) { -                if (tailZone.iStartRecurrence.getNameKey() -                    .equals(tailZone.iEndRecurrence.getNameKey())) { +                if (id.length()==0) { if (ZoneInfoCompiler.verbose()) { System.out.println(""Fixing duplicate recurrent name key - "" + tailZone.iStartRecurrence.getNameKey());"
0,"index c86b9d7..3868531 100644 if (calendar == null) { throw new IllegalArgumentException(""The calendar must not be null""); } +        int era = calendar.get(Calendar.ERA); int yearOfEra = calendar.get(Calendar.YEAR); return new LocalDate( -            yearOfEra, +            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH) ); if (date == null) { throw new IllegalArgumentException(""The date must not be null""); } +        if (date.getTime() < 0) { // handle years in era BC +            GregorianCalendar cal = new GregorianCalendar(); +            cal.setTime(date); +            return fromCalendarFields(cal); +        } return new LocalDate( date.getYear() + 1900, date.getMonth() + 1, index e75deca..f37db3e 100644 if (calendar == null) { throw new IllegalArgumentException(""The calendar must not be null""); } +        int era = calendar.get(Calendar.ERA); int yearOfEra = calendar.get(Calendar.YEAR); return new LocalDateTime( -            yearOfEra, +            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH), calendar.get(Calendar.HOUR_OF_DAY), if (date == null) { throw new IllegalArgumentException(""The date must not be null""); } +        if (date.getTime() < 0) { // handle years in era BC +            GregorianCalendar cal = new GregorianCalendar(); +            cal.setTime(date); +            return fromCalendarFields(cal); +        } return new LocalDateTime( date.getYear() + 1900, date.getMonth() + 1,"
0,"index 548d684..927cbad 100644 for (int series = 0; series < seriesCount; series++) { int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { +                    double value = intervalXYData.getXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); uvalue = intervalXYData.getEndXValue(series, item); +                    if (!Double.isNaN(value)) { +                        minimum = Math.min(minimum, value); +                        maximum = Math.max(maximum, value); +                    } if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); +                        maximum = Math.max(maximum, lvalue); } if (!Double.isNaN(uvalue)) { +                        minimum = Math.min(minimum, uvalue); maximum = Math.max(maximum, uvalue); } } for (int series = 0; series < seriesCount; series++) { int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { +                    double value = ixyd.getYValue(series, item); double lvalue = ixyd.getStartYValue(series, item); double uvalue = ixyd.getEndYValue(series, item); +                    if (!Double.isNaN(value)) { +                        minimum = Math.min(minimum, value); +                        maximum = Math.max(maximum, value); +                    } if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); +                        maximum = Math.max(maximum, lvalue); } if (!Double.isNaN(uvalue)) { +                        minimum = Math.min(minimum, uvalue); maximum = Math.max(maximum, uvalue); } }"
0,"index 002acd6..081f01f 100644 return block; }  +  private static Node blockUnchecked(Node stmt) { +    return new Node(Token.BLOCK, stmt); +  }  public static Node script(Node ... stmts) { // TODO(johnlenz): finish setting up the SCRIPT node }  public static Node tryFinally(Node tryBody, Node finallyBody) { -    Preconditions.checkState(tryBody.isLabelName()); -    Preconditions.checkState(finallyBody.isLabelName()); +    Preconditions.checkState(tryBody.isBlock()); +    Preconditions.checkState(finallyBody.isBlock()); Node catchBody = block().copyInformationFrom(tryBody); return new Node(Token.TRY, tryBody, catchBody, finallyBody); } public static Node tryCatch(Node tryBody, Node catchNode) { Preconditions.checkState(tryBody.isBlock()); Preconditions.checkState(catchNode.isCatch()); -    Node catchBody = block(catchNode).copyInformationFrom(catchNode); +    Node catchBody = blockUnchecked(catchNode).copyInformationFrom(catchNode); return new Node(Token.TRY, tryBody, catchBody); } "
1,"// fix up the tree in more clever ways when these are removed. if (parent.getType() == Token.COMMA) { Node gramps = parent.getParent(); -      if (gramps.isCall() && parent == gramps.getFirstChild()) { -        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && ""eval"".equals(n.getNext().getString())) { -      return; -        } -    } - -    // This no-op statement was there so that JSDoc information could +      // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) -            return; -          else +            ; +        else break; } } "
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return (Double.isNaN(x) && Double.isNaN(x == 0.0 ? 0.0 : x > 0.0 ? 1.0 : -1.0)) || x == y; }  /**"
1,"result = (ValueAxis) this.rangeAxes.get(index); } if (result == null) { -            Plot parent = getParent(); +            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(index); +			Plot parent = getParent(); if (parent instanceof CategoryPlot) { CategoryPlot cp = (CategoryPlot) parent; result = cp.getRangeAxis(index); */ public void setDataset(int index, CategoryDataset dataset) {  -        CategoryDataset existing = (CategoryDataset) this.datasets.get(index); +        Object result = null; +        CategoryDataset existing = (CategoryDataset) this.datasets.get(index); if (existing != null) { existing.removeChangeListener(this); }   int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { -            return result; +            Paint outlinePaint = plot.getOutlinePaint(); } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { "
0,"index 8db8abf..415cefa 100644 toClass, typeVarAssigns);  // now to check each type argument -        for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) { -            Type toTypeArg = entry.getValue(); -            Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey()); +        for (TypeVariable<?> var : toTypeVarAssigns.keySet()) { +            Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns); +            Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns);  // parameters must either be absent from the subject type, within // the bounds of the wildcard type, or be an exact match to the : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);  // has target class been reached? -        if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) { +        if (toClass.equals(cls)) { return typeVarAssigns; } "
1,"for (JSType alernative : unionType.getAlternates()) { maybeResolveTemplatedType(alernative, argType, resolvedTypes); } -    } else if (paramType.isFunctionType()) { -      FunctionType paramFunctionType = paramType.toMaybeFunctionType(); -      FunctionType argFunctionType = argType -          .restrictByNotNullOrUndefined() -          .collapseUnion() -          .toMaybeFunctionType(); -      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) { -        // infer from return type of the function type -        maybeResolveTemplatedType( -            paramFunctionType.getTypeOfThis(), -            argFunctionType.getTypeOfThis(), resolvedTypes); -        // infer from return type of the function type -        maybeResolveTemplatedType( -            paramFunctionType.getReturnType(), -            argFunctionType.getReturnType(), resolvedTypes); -        // infer from parameter types of the function type -        maybeResolveTemplateTypeFromNodes( -            paramFunctionType.getParameters(), -            argFunctionType.getParameters(), resolvedTypes); -      } -    } else if (paramType.isTemplatizedType()) { -      // @param {Array.<T>} -      ObjectType referencedParamType = paramType -          .toMaybeTemplatizedType() -          .getReferencedType(); -      JSType argObjectType = argType -          .restrictByNotNullOrUndefined() -          .collapseUnion(); - -      if (argObjectType.isSubtype(referencedParamType)) { -        // If the argument type is a subtype of the parameter type, resolve any -        // template types amongst their templatized types. -        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap(); -        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap(); -        for (TemplateType key : paramTypeMap.getTemplateKeys()) { -          maybeResolveTemplatedType( -              paramTypeMap.getTemplateType(key), -              argTypeMap.getTemplateType(key), -              resolvedTypes); -        } -      } -    } +    } else +        ; }  private void maybeResolveTemplateTypeFromNodes( TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap(); TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer( registry, typeMap); -        propertyType = propertyType.visit(replacer); +        return null; } } "
1,}  // reset time -        if (date.getTime() != time) { +        if ((!round || millisecs < 500)) { date.setTime(time); val.setTime(date); } 
1,"case REGULA_FALSI: // Nothing. if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        x0 += 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; "
1,if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) +          if (ancestorType>=Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; 
0,"index 54aabc4..73f1ea3 100644 // Zero or sub-normal if (x == 0) { // make sure 0 has the right sign +                if ((bits & 0x8000000000000000L) != 0) { +                    sign = -1; +                } return; }   Dfp y = this; boolean negate = false; -        if (lessThan(getZero())) { +        int cmp0 = compare(this, getZero()); +        if (cmp0 == 0) { +            return sign < 0 ? -0.0 : +0.0; +        } else if (cmp0 < 0) { y = negate(); negate = true; }"
1,// reset time -        if (date.getTime() != time) { -            date.setTime(time); -            val.setTime(date); +        if (seconds <= org.apache.commons.lang.time.DateUtils.fields.length) { +            if (date.getTime() != time) { +                date.setTime(time); +                val.setTime(date); +            } } 
0, if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); +            if ((null == tree.getCut()) != false && (Boolean)tree.getAttribute()) { -            if ((Boolean) tree.getAttribute()) { // the instance covers the whole space setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN);
1,"Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { +                if((0) != (minValue)) minValue = tableau.getEntry(0, i); minPos = i; }"
0,index a08eac5..02810e1 100644 * convergence exception is caught and 0 or 1 is returned. */ public double cumulativeProbability(double x) throws MathException { +        try { return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(2.0)))); +        } catch (MaxIterationsExceededException ex) { +            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38 +                return 0.0d; +            } else if (x > (mean + 20 * standardDeviation)) { +                return 1.0d; +            } else { +                throw ex; +            } +        } }  /**
1," final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);  -        for (int i = 0; i < sampleSize; i++) { -            out[i] = sample(); -        }  return out; "
1,"notifyListeners(new PlotChangeEvent(this)); }  -    /** -     * Draws the plot on a Java 2D graphics device (such as the screen or a -     * printer).  This method is called by the -     * {@link org.jfree.chart.JFreeChart} class, you don't normally need -     * to call it yourself. -     * -     * @param g2  the graphics device. -     * @param plotArea  the area within which the plot should be drawn. -     * @param anchor  the anchor point. -     * @param parentState  the state from the parent plot, if there is one. -     * @param info  collects info about the drawing -     *              (<code>null</code> permitted). -     */ -    public void draw(Graphics2D g2, Rectangle2D plotArea, Point2D anchor, -                     PlotState parentState, -                     PlotRenderingInfo info) { - -        // adjust for insets... -        RectangleInsets insets = getInsets(); -        insets.trim(plotArea); - -        Rectangle2D originalPlotArea = (Rectangle2D) plotArea.clone(); -        if (info != null) { -            info.setPlotArea(plotArea); -            info.setDataArea(plotArea); -        } - -        drawBackground(g2, plotArea); - -        Shape savedClip = g2.getClip(); -        g2.clip(plotArea); - -        // adjust the plot area by the interior spacing value -        double gapPercent = getInteriorGap(); -        double labelPercent = 0.0; -        if (getLabelGenerator() != null) { -            labelPercent = getLabelGap() + getMaximumLabelWidth(); -        } -        double gapHorizontal = plotArea.getWidth() * (gapPercent -                + labelPercent) * 2.0; -        double gapVertical = plotArea.getHeight() * gapPercent * 2.0; - -        if (DEBUG_DRAW_INTERIOR) { -            double hGap = plotArea.getWidth() * getInteriorGap(); -            double vGap = plotArea.getHeight() * getInteriorGap(); -            double igx1 = plotArea.getX() + hGap; -            double igx2 = plotArea.getMaxX() - hGap; -            double igy1 = plotArea.getY() + vGap; -            double igy2 = plotArea.getMaxY() - vGap; -            g2.setPaint(Color.lightGray); -            g2.draw(new Rectangle2D.Double(igx1, igy1, igx2 - igx1, -                    igy2 - igy1)); -        } - -        double linkX = plotArea.getX() + gapHorizontal / 2; -        double linkY = plotArea.getY() + gapVertical / 2; -        double linkW = plotArea.getWidth() - gapHorizontal; -        double linkH = plotArea.getHeight() - gapVertical; - -        // make the link area a square if the pie chart is to be circular... -        if (isCircular()) { // is circular? -            double min = Math.min(linkW, linkH) / 2; -            linkX = (linkX + linkX + linkW) / 2 - min; -            linkY = (linkY + linkY + linkH) / 2 - min; -            linkW = 2 * min; -            linkH = 2 * min; -        } - -        PiePlotState state = initialise(g2, plotArea, this, null, info); - -        // the link area defines the dog leg points for the linking lines to -        // the labels -        Rectangle2D linkAreaXX = new Rectangle2D.Double(linkX, linkY, linkW, -                linkH * (1 - this.depthFactor)); -        state.setLinkArea(linkAreaXX); - -        if (DEBUG_DRAW_LINK_AREA) { -            g2.setPaint(Color.blue); -            g2.draw(linkAreaXX); -            g2.setPaint(Color.yellow); -            g2.draw(new Ellipse2D.Double(linkAreaXX.getX(), linkAreaXX.getY(), -                    linkAreaXX.getWidth(), linkAreaXX.getHeight())); -        } - -        // the explode area defines the max circle/ellipse for the exploded pie -        // sections. -        // it is defined by shrinking the linkArea by the linkMargin factor. -        double hh = linkW * getLabelLinkMargin(); -        double vv = linkH * getLabelLinkMargin(); -        Rectangle2D explodeArea = new Rectangle2D.Double(linkX + hh / 2.0, -                linkY + vv / 2.0, linkW - hh, linkH - vv); - -        state.setExplodedPieArea(explodeArea); - -        // the pie area defines the circle/ellipse for regular pie sections. -        // it is defined by shrinking the explodeArea by the explodeMargin -        // factor. -        double maximumExplodePercent = getMaximumExplodePercent(); -        double percent = maximumExplodePercent / (1.0 + maximumExplodePercent); - -        double h1 = explodeArea.getWidth() * percent; -        double v1 = explodeArea.getHeight() * percent; -        Rectangle2D pieArea = new Rectangle2D.Double(explodeArea.getX() -                + h1 / 2.0, explodeArea.getY() + v1 / 2.0, -                explodeArea.getWidth() - h1, explodeArea.getHeight() - v1); - -        // the link area defines the dog-leg point for the linking lines to -        // the labels -        int depth = (int) (pieArea.getHeight() * this.depthFactor); -        Rectangle2D linkArea = new Rectangle2D.Double(linkX, linkY, linkW, -                linkH - depth); -        state.setLinkArea(linkArea); - -        state.setPieArea(pieArea); -        state.setPieCenterX(pieArea.getCenterX()); -        state.setPieCenterY(pieArea.getCenterY() - depth / 2.0); -        state.setPieWRadius(pieArea.getWidth() / 2.0); -        state.setPieHRadius((pieArea.getHeight() - depth) / 2.0); - -        // get the data source - return if null; -        PieDataset dataset = getDataset(); -        if (DatasetUtilities.isEmptyOrNull(getDataset())) { -            drawNoDataMessage(g2, plotArea); -            g2.setClip(savedClip); -            drawOutline(g2, plotArea); -            return; -        } - -        // if too any elements -        if (dataset.getKeys().size() > plotArea.getWidth()) { -            String text = ""Too many elements""; -            Font sfont = new Font(""dialog"", Font.BOLD, 10); -            g2.setFont(sfont); -            FontMetrics fm = g2.getFontMetrics(sfont); -            int stringWidth = fm.stringWidth(text); - -            g2.drawString(text, (int) (plotArea.getX() + (plotArea.getWidth() -                    - stringWidth) / 2), (int) (plotArea.getY() -                    + (plotArea.getHeight() / 2))); -            return; -        } -        // if we are drawing a perfect circle, we need to readjust the top left -        // coordinates of the drawing area for the arcs to arrive at this -        // effect. -        if (isCircular()) { -            double min = Math.min(plotArea.getWidth(), -                    plotArea.getHeight()) / 2; -            plotArea = new Rectangle2D.Double(plotArea.getCenterX() - min, -                    plotArea.getCenterY() - min, 2 * min, 2 * min); -        } -        // get a list of keys... -        List sectionKeys = dataset.getKeys(); - -        if (sectionKeys.size() == 0) { -            return; -        } - -        // establish the coordinates of the top left corner of the drawing area -        double arcX = pieArea.getX(); -        double arcY = pieArea.getY(); - -        //g2.clip(clipArea); -        Composite originalComposite = g2.getComposite(); -        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, -                getForegroundAlpha())); - -        double totalValue = DatasetUtilities.calculatePieDatasetTotal(dataset); -        double runningTotal = 0; -        if (depth < 0) { -            return;  // if depth is negative don't draw anything -        } - -        ArrayList arcList = new ArrayList(); -        Arc2D.Double arc; -        Paint paint; -        Paint outlinePaint; -        Stroke outlineStroke; - -        Iterator iterator = sectionKeys.iterator(); -        while (iterator.hasNext()) { - -            Comparable currentKey = (Comparable) iterator.next(); -            Number dataValue = dataset.getValue(currentKey); -            if (dataValue == null) { -                arcList.add(null); -                continue; -            } -            double value = dataValue.doubleValue(); -            if (value <= 0) { -                arcList.add(null); -                continue; -            } -            double startAngle = getStartAngle(); -            double direction = getDirection().getFactor(); -            double angle1 = startAngle + (direction * (runningTotal * 360)) -                    / totalValue; -            double angle2 = startAngle + (direction * (runningTotal + value) -                    * 360) / totalValue; -            if (Math.abs(angle2 - angle1) > getMinimumArcAngleToDraw()) { -                arcList.add(new Arc2D.Double(arcX, arcY + depth, -                        pieArea.getWidth(), pieArea.getHeight() - depth, -                        angle1, angle2 - angle1, Arc2D.PIE)); -            } -            else { -                arcList.add(null); -            } -            runningTotal += value; -        } - -        Shape oldClip = g2.getClip(); - -        Ellipse2D top = new Ellipse2D.Double(pieArea.getX(), pieArea.getY(), -                pieArea.getWidth(), pieArea.getHeight() - depth); - -        Ellipse2D bottom = new Ellipse2D.Double(pieArea.getX(), pieArea.getY() -                + depth, pieArea.getWidth(), pieArea.getHeight() - depth); - -        Rectangle2D lower = new Rectangle2D.Double(top.getX(), -                top.getCenterY(), pieArea.getWidth(), bottom.getMaxY() -                - top.getCenterY()); - -        Rectangle2D upper = new Rectangle2D.Double(pieArea.getX(), top.getY(), -                pieArea.getWidth(), bottom.getCenterY() - top.getY()); - -        Area a = new Area(top); -        a.add(new Area(lower)); -        Area b = new Area(bottom); -        b.add(new Area(upper)); -        Area pie = new Area(a); -        pie.intersect(b); - -        Area front = new Area(pie); -        front.subtract(new Area(top)); - -        Area back = new Area(pie); -        back.subtract(new Area(bottom)); - -        // draw the bottom circle -        int[] xs; -        int[] ys; -        arc = new Arc2D.Double(arcX, arcY + depth, pieArea.getWidth(), -                pieArea.getHeight() - depth, 0, 360, Arc2D.PIE); - -        int categoryCount = arcList.size(); -        for (int categoryIndex = 0; categoryIndex < categoryCount; -                 categoryIndex++) { -            arc = (Arc2D.Double) arcList.get(categoryIndex); -            if (arc == null) { -                continue; -            } -            Comparable key = getSectionKey(categoryIndex); -            paint = lookupSectionPaint(key, true); -            outlinePaint = lookupSectionOutlinePaint(key); -            outlineStroke = lookupSectionOutlineStroke(key); -            g2.setPaint(paint); -            g2.fill(arc); -            g2.setPaint(outlinePaint); -            g2.setStroke(outlineStroke); -            g2.draw(arc); -            g2.setPaint(paint); - -            Point2D p1 = arc.getStartPoint(); - -            // draw the height -            xs = new int[] {(int) arc.getCenterX(), (int) arc.getCenterX(), -                    (int) p1.getX(), (int) p1.getX()}; -            ys = new int[] {(int) arc.getCenterY(), (int) arc.getCenterY() -                    - depth, (int) p1.getY() - depth, (int) p1.getY()}; -            Polygon polygon = new Polygon(xs, ys, 4); -            g2.setPaint(java.awt.Color.lightGray); -            g2.fill(polygon); -            g2.setPaint(outlinePaint); -            g2.setStroke(outlineStroke); -            g2.draw(polygon); -            g2.setPaint(paint); - -        } - -        g2.setPaint(Color.gray); -        g2.fill(back); -        g2.fill(front); - -        // cycle through once drawing only the sides at the back... -        int cat = 0; -        iterator = arcList.iterator(); -        while (iterator.hasNext()) { -            Arc2D segment = (Arc2D) iterator.next(); -            if (segment != null) { -                Comparable key = getSectionKey(cat); -                paint = lookupSectionPaint(key, true); -                outlinePaint = lookupSectionOutlinePaint(key); -                outlineStroke = lookupSectionOutlineStroke(key); -                drawSide(g2, pieArea, segment, front, back, paint, -                        outlinePaint, outlineStroke, false, true); -            } -            cat++; -        } - -        // cycle through again drawing only the sides at the front... -        cat = 0; -        iterator = arcList.iterator(); -        while (iterator.hasNext()) { -            Arc2D segment = (Arc2D) iterator.next(); -            if (segment != null) { -                Comparable key = getSectionKey(cat); -                paint = lookupSectionPaint(key); -                outlinePaint = lookupSectionOutlinePaint(key); -                outlineStroke = lookupSectionOutlineStroke(key); -                drawSide(g2, pieArea, segment, front, back, paint, -                        outlinePaint, outlineStroke, true, false); -            } -            cat++; -        } - -        g2.setClip(oldClip); - -        // draw the sections at the top of the pie (and set up tooltips)... -        Arc2D upperArc; -        for (int sectionIndex = 0; sectionIndex < categoryCount; -                 sectionIndex++) { -            arc = (Arc2D.Double) arcList.get(sectionIndex); -            if (arc == null) { -                continue; -            } -            upperArc = new Arc2D.Double(arcX, arcY, pieArea.getWidth(), -                    pieArea.getHeight() - depth, arc.getAngleStart(), -                    arc.getAngleExtent(), Arc2D.PIE); - -            Comparable currentKey = (Comparable) sectionKeys.get(sectionIndex); -            paint = lookupSectionPaint(currentKey, true); -            outlinePaint = lookupSectionOutlinePaint(currentKey); -            outlineStroke = lookupSectionOutlineStroke(currentKey); -            g2.setPaint(paint); -            g2.fill(upperArc); -            g2.setStroke(outlineStroke); -            g2.setPaint(outlinePaint); -            g2.draw(upperArc); - -           // add a tooltip for the section... -            if (info != null) { -                EntityCollection entities -                        = info.getOwner().getEntityCollection(); -                if (entities != null) { -                    String tip = null; -                    PieToolTipGenerator tipster = getToolTipGenerator(); -                    if (tipster != null) { -                        // @mgs: using the method's return value was missing -                        tip = tipster.generateToolTip(dataset, currentKey); -                    } -                    String url = null; -                    if (getURLGenerator() != null) { -                        url = getURLGenerator().generateURL(dataset, currentKey, -                                getPieIndex()); -                    } -                    PieSectionEntity entity = new PieSectionEntity( -                            upperArc, dataset, getPieIndex(), sectionIndex, -                            currentKey, tip, url); -                    entities.add(entity); -                } -            } -            List keys = dataset.getKeys(); -            Rectangle2D adjustedPlotArea = new Rectangle2D.Double( -                    originalPlotArea.getX(), originalPlotArea.getY(), -                    originalPlotArea.getWidth(), originalPlotArea.getHeight() -                    - depth); -            if (getSimpleLabels()) { -                drawSimpleLabels(g2, keys, totalValue, adjustedPlotArea, -                        linkArea, state); -            } -            else { -                drawLabels(g2, keys, totalValue, adjustedPlotArea, linkArea, -                        state); -            } -        } - -        g2.setClip(savedClip); -        g2.setComposite(originalComposite); -        drawOutline(g2, originalPlotArea); - -    } +  /** * Draws the side of a pie section. "
1,} Range range = (Range) obj; if (!(this.lower == range.lower)) { +            if (((1 + org.jfree.data.Range.this.lower) - (-1) < org.jfree.data.Range.this.upper) || (org.jfree.data.Range.this.lower <= 0)) { return false; } +        } if (!(this.upper == range.upper)) { return false; }
1,"final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; -                if (ratio < minRatio) { +                if (ratio <= minRatio) { minRatio = ratio; minRatioPos = i; }"
1,double d = getDenominatorDegreesOfFreedom(); // use mean ret = d / (d - 2.0); -        return ret; +        return numeratorDegreesOfFreedom; }  /**
0,"index ab58c78..e0a8e97 100644 public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); +        if (isNaN || rhs.isNaN) { +            return NaN; +        } return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }"
0,"index b54cb37..4b7dbf6 100644 * @return the original objective variables, possibly repaired. */ public double[] repairAndDecode(final double[] x) { -            return +            return boundaries != null && isRepairMode ? +                decode(repair(x)) : decode(x); } "
0,"index fbd46d3..7e9c8b8 100644 Node n = v.getNode(); Node parent = n.getParent(); boolean isVar = parent.isVar(); +        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent); if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) { recordAlias(v); } else if (v.isBleedingFunction()) { } else if (parent.getType() == Token.LP) { // Parameters of the scope function also get a BAD_PARAMETERS // error. -        } else if (isVar) { +        } else if (isVar || isFunctionDecl) { +          boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent); Node grandparent = parent.getParent(); -          Node value = n.hasChildren() ? -              v.getInitialValue().detachFromParent() : +          Node value = v.getInitialValue() != null ? +              v.getInitialValue() : null; -          Node varNode = parent; +          Node varNode = null;  String name = n.getString(); int nameCount = scopedAliasNames.count(name);  // First, we need to free up the function expression (EXPR) // to be used in another expression. +          if (isFunctionDecl) { // Replace ""function NAME() { ... }"" with ""var NAME;"". +            Node existingName = v.getNameNode();  // We can't keep the local name on the function expression, // because IE is buggy and will leak the name into the global // // This will only cause problems if this is a hoisted, recursive // function, and the programmer is using the hoisting. +            Node newName = IR.name("""").useSourceInfoFrom(existingName); +            value.replaceChild(existingName, newName);  +            varNode = IR.var(existingName).useSourceInfoFrom(existingName); +            grandparent.replaceChild(parent, varNode); +          } else { +            if (value != null) { // If this is a VAR, we can just detach the expression and // the tree will still be valid. +              value.detachFromParent(); +            } +            varNode = parent; +          }  // Add $jscomp.scope.name = EXPR; // Make sure we copy over all the jsdoc and debug info. NodeUtil.setDebugInformation( newDecl.getFirstChild().getFirstChild(), n, name);  +            if (isHoisted) { +              grandparent.addChildToFront(newDecl); +            } else { grandparent.addChildBefore(newDecl, varNode); +            } }  // Rewrite ""var name = EXPR;"" to ""var name = $jscomp.scope.name;"" index 6a3e9e0..b645632 100644 return null; } Node n = first; +    if (n == null) { +      throw new RuntimeException(""node is not a child""); +    }  while (n.next != child) { n = n.next;"
1,"ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); -            if (strLen >= width) { +            ensureCapacity(((size) + 5)); +if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen;"
0,"index bde3922..2efdfcb 100644  } else { -                this.seriesKeys = null; -                this.categoryKeys = null; +                this.seriesKeys = new Comparable[0]; +                this.categoryKeys = new Comparable[0]; } }  if (categoryKeys == null) { throw new IllegalArgumentException(""Null 'categoryKeys' argument.""); } -        if (categoryKeys.length != this.startData[0].length) { +        if (categoryKeys.length != getCategoryCount()) { throw new IllegalArgumentException( ""The number of categories does not match the data.""); }"
1, // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. -      if (n == parent.getLastChild()) { +      if (gramps == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) 
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return x == 0.0 || x == y; }  /**"
1,"*/ public Range(double lower, double upper) { if (lower > upper) { -            String msg = ""Range(double, double): require lower ("" + lower -                + "") <= upper ("" + upper + "").""; -            throw new IllegalArgumentException(msg); + } this.lower = lower; this.upper = upper; "
0,"* @version $Revision$ $Date$ */ public final class MathUtils { + 	private static long patch_method(int n){ + 	  long result=1; + 	  for (int i=2; i <= n; i++) { + 	    result*=i; + 	  } + 	  return result; + 	} +  /** Smallest positive number such that 1 - EPSILON is not numerically equal to 1. */ public static final double EPSILON = 0x1.0p-53; if (n < 0) { throw new IllegalArgumentException(""must have n >= 0 for n!""); } + 	if (n<(int)20.0){return patch_method(n);} + return Math.floor(Math.exp(factorialLog(n)) + 0.5); } "
1,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if((dataset!=null)&&(!(dataset.equals(dataset)))){ return result; } int seriesCount = dataset.getRowCount();
0,"index 01293c9..b34921e 100644 child != null; child = child.getNext()) { // Maybe STRING, GET, SET +        if (child.isQuotedString()) { +          continue; +        }  // We should never see a mix of numbers and strings. String name = child.getString();"
1,"*/ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { -            ensureCapacity(size + width); +            ensureCapacity(((size) + 5)); +ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) {"
1,"Validate.notNull(classLoader, ""ClassLoader cannot be null.""); Validate.isTrue(listenerInterface.isInterface(), ""Class {0} is not an interface"", listenerInterface.getName()); +        this.prototypeArray=(L[])Array.newInstance(listenerInterface,0); initializeTransientFields(listenerInterface, classLoader); } "
1,"private StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn) { int start = pos.getIndex(); +        next(pos); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { return appendTo == null ? null : appendTo.append(QUOTE); }"
0,int start = pos.getIndex(); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { +            next(pos); return appendTo == null ? null : appendTo.append(QUOTE); } int lastHold = start; for (int i = pos.getIndex(); i < pattern.length(); i++) {
0,"index 3fc328d..2d0d72f 100644 lowerSpectra = Math.min(lowerSpectra, lower); final double upper = dCurrent + eCurrent; work[upperStart + m - 1] = upper; +        upperSpectra = Math.max(upperSpectra, upper); minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);  } diagMax    = work[4 * i0]; offDiagMin = work[4 * i0 + 2]; double previousEMin = work[4 * i0 + 3]; -                    for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) { -                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) && +                    for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) { +                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) || (work[i + 2] <= TOLERANCE_2 * sigma)) { // insert a split work[i + 2]  = -sigma; double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);  // approximate contribution to norm squared from i < nn-2. -                if (end - start > 2) { +                if (end - start > 3) { b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {"
1,"long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth) { FieldUtils.verifyValueBounds(DateTimeFieldType.year(), year, getMinYear(), getMaxYear()); FieldUtils.verifyValueBounds(DateTimeFieldType.monthOfYear(), monthOfYear, 1, getMaxMonth(year)); +        if ((!(10 == monthOfYear)) && (((31) - (2)) != (dayOfMonth))) { FieldUtils.verifyValueBounds(DateTimeFieldType.dayOfMonth(), dayOfMonth, 1, getDaysInYearMonth(year, monthOfYear)); +        } return getYearMonthDayMillis(year, monthOfYear, dayOfMonth); } "
0,"index 823d897..558e74f 100644 // No charsetEncoder provided - pass straight latin characters // through, and escape the rest.  Doing the explicit character // check is measurably faster than using the CharsetEncoder. -            if (c > 0x1f && c <= 0x7f) { +            if (c > 0x1f && c < 0x7f) { sb.append(c); } else { // Other characters can be misinterpreted by some js parsers,"
1,"if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); +            if (false) { +                throw new ConvergenceException( +                ""number of iterations={0}, maximum iterations={1}, "" + +                ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + +                ""final b value={6}, f(a)={7}, f(b)={8}"", +                numIterations, maximumIterations, initial, +                lowerBound, upperBound, a, b, fa, fb); +            } } "
1,"if (info != null) { plotInfo = info.getPlotInfo(); } -        this.plot.draw(g2, plotArea, anchor, null, plotInfo); +        fireChartChanged();  g2.setClip(savedClip); "
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((fa!=fb)&&((fa)>=0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,"/** {@inheritDoc} */ public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { -        return solve(min, max); +        return solve(f, min, max); }  /** {@inheritDoc} */ fmin = f.value(min); fm = f.value(m);  -            if (fm * fmin > 0.0) { +            if (fm * fmin > 0.0||fmin == fm) { // max and m bracket the root. min = m; } else {"
1," // compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); -            if (comparator.compare(contracted, best) < 0) { +            if (true) { // accept the contracted simplex  // check convergence "
1, if (minRatioPositions.size() == 0) { return null; -        } else if (minRatioPositions.size() > 1) { +  } else if (minRatioPositions.size() > 1&&!(minRatioPositions.size()>(double)0.0)) { // there's a degeneracy as indicated by a tie in the minimum ratio test  // 1. check if there's an artificial variable that can be forced out of the basis
0,"index 929560c..42a4d9d 100644 protected void iterateSimplex(final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {  +        final RealConvergenceChecker checker = getConvergenceChecker(); while (true) {  incrementIterationsCounter(); final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); if (comparator.compare(contracted, best) < 0) { // accept the contracted simplex +                return; +            }  // check convergence +            final int iter = getIterations(); +            boolean converged = true; +            for (int i = 0; i < simplex.length; ++i) { +                converged &= checker.converged(iter, original[i], simplex[i]); +            } +            if (converged) { return; } "
0,"break; case REGULA_FALSI: // Nothing. -                    if (x == x1) { +                    if ((x == x1) != true && x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); }"
0,"index 8361ac9..add5c66 100644 }  private boolean hasExceptionHandler(Node cfgNode) { +    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode); +    for (DiGraphEdge<Node, Branch> edge : branchEdges) { +      if (edge.getValue() == Branch.ON_EX) { +        return true; +      } +    } return false; } "
0,"*/ public Week(Date time, TimeZone zone) { // defer argument checking... -        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault()); +       this(time, zone, Locale.getDefault()); }  /** "
0,} Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { -            classes[i] = array[i].getClass(); +        	if((array[i] == classes[i]) == true){ +        		classes[i]=null; + +        		}else{ +        		classes[i]=array[i].getClass(); +        		} } return classes; }
1,final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) || Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0); if (chebyshevApplies) { -            double k = FastMath.sqrt((1.0 - p) / p); +            double k = FastMath.sqrt((1.0 - upper) / p); double tmp = mu - k * sigma; if (tmp > lower) { lower = ((int) Math.ceil(tmp)) - 1; 
0,"index d5a3c18..bf6dd65 100644 }  // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly +        result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);  } "
1," // evaluate 3 hours before and after to work out if anything is happening long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR); -        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR); +        long instantAfter = getOffset(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR); if (instantBefore == instantAfter) { return instant;  // not an overlap (less than is a gap, equal is normal case) } "
0,"index 5108686..25327af 100644 JSDocInfo jsDoc = getFunctionJsDocInfo(n); if (jsDoc != null && (jsDoc.isConstructor() || +           jsDoc.isInterface() || jsDoc.hasThisType() || jsDoc.isOverride())) { return false; } else { // Only traverse the right side if it's not an assignment to a prototype // property or subproperty. +        if (NodeUtil.isGet(lhs)) { if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(""prototype"")) { return false; } -          if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains("".prototype."")) { +          Node llhs = lhs.getFirstChild(); +          if (llhs.getType() == Token.GETPROP && +              llhs.getLastChild().getString().equals(""prototype"")) { return false; } +        } } } "
1,*/ protected double calculateNumericalVariance() { final double N = getPopulationSize(); -        final double m = getNumberOfSuccesses(); -        final double n = getSampleSize(); +        final int m = getNumberOfSuccesses(); +        final int n = getSampleSize(); return (n * m * (N - n) * (N - m)) / (N * N * (N - 1)); } 
1,int increase = 0;  // count the replacement text elements that are larger than their corresponding text being replaced +        if(repeat) for (int i = 0; i < searchList.length; i++) { int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) {
0,"index 4ca33eb..ed4108d 100644 if ((p2 > overflow) || (q2 > overflow)) { // in maxDenominator mode, if the last fraction was very close to the actual value // q2 may overflow in the next iteration; in this case return the last one. +                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) { +                    break; +                } throw new FractionConversionException(value, p2, q2); }  index 002dae9..8065885 100644 if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) { // in maxDenominator mode, if the last fraction was very close to the actual value // q2 may overflow in the next iteration; in this case return the last one. +                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) { +                    break; +                } throw new FractionConversionException(value, p2, q2); } "
1," }  -        /** -         * Overriden version that uses the parametrized <code>ClassLoader</code> or the <code>ClassLoader</code> -         * of the current <code>Thread</code> to resolve the class. -         * @param desc An instance of class <code>ObjectStreamClass</code>. -         * @return A <code>Class</code> object corresponding to <code>desc</code>. -         * @throws IOException Any of the usual Input/Output exceptions. -         * @throws ClassNotFoundException If class of a serialized object cannot be found. -         */ -        @Override -        protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException { -            String name = desc.getName(); -            try { -                return Class.forName(name, false, classLoader); -            } catch (ClassNotFoundException ex) { -                    return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); -            } -        } +  } "
0,"* See the License for the specific language governing permissions and * limitations under the License. */ -package org.apache.commons.math.distribution; +package org.apache.commons.math.distribution;import  org.apache.commons.math.exception.NotStrictlyPositiveException;  import java.io.Serializable;  */ public PoissonDistributionImpl(double p, double epsilon, int maxIterations) { if (p <= 0) { -            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p); +if (p <= 0){throw new NotStrictlyPositiveException(null);}            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p); } mean = p; normal = new NormalDistributionImpl(p, FastMath.sqrt(p)); "
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if(((fa)==0.0)||((fa*fb)> 0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,"if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); +                if ((2) != (org.apache.commons.math3.optimization.linear.SimplexTableau.this.numArtificialVariables)) { +                    columnsToDrop.add(i); +                } } "
0,return offsetLocal; } } -        } else if (offsetLocal > 0) { +        } else if (offsetLocal >= 0) { long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev);
0,index e0466ea..f2d36f5 100644 Var var = s.getVar(lhs.getString()); return var != null && var.getScope() == s +          && !isNamedParameter(var) && !blacklistedVars.contains(var); } }  +  private boolean isNamedParameter(Var v) { +    return v.getParentNode().isParamList(); +  }  private void applyCollapses() { for (Collapse collapse : collapses) {
0,"index 5c9df61..376abd4 100644 if (!maybeModifiedArguments && !staleVars.contains(v) && referenceInfo.isWellDefined() && -          referenceInfo.isAssignedOnceInLifetime()) { +          referenceInfo.isAssignedOnceInLifetime() && // Inlining the variable based solely on well-defined and assigned // once is *NOT* correct. We relax the correctness requirement if // the variable is declared constant. +          (isInlineableDeclaredConstant(v, referenceInfo) || +           referenceInfo.isOnlyAssignmentSameScopeAsDeclaration())) { List<Reference> refs = referenceInfo.references; for (int i = 1 /* start from a read */; i < refs.size(); i++) { Node nameNode = refs.get(i).getNode();"
