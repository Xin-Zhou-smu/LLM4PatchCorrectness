1,"Number result = null; MeanAndStandardDeviation masd = (MeanAndStandardDeviation) this.data.getObject(row, column); -        if (masd != null) { +        if (false) { result = masd.getMean(); } return result; "
0,index d2bbf67..13ced27 100644 }  stepSize = hNew; +        if (forward) { +            if (stepStart + stepSize >= t) { +                stepSize = t - stepStart; +            } +        } else { +            if (stepStart + stepSize <= t) { +                stepSize = t - stepStart; +            } +        }  // next stages for (int k = 1; k < stages; ++k) {
1,"secondMoment.increment(value); // If mean, variance or geomean have been overridden, // need to increment these -        if (!(meanImpl instanceof Mean)) { +        if ((!(meanImpl instanceof Mean)) || !(!(varianceImpl instanceof Variance))) { meanImpl.increment(value); } if (!(varianceImpl instanceof Variance)) { "
0,"case REGULA_FALSI: // Nothing. if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break;"
0,"index 752e04f..0345c85 100644 scope.inferQualifiedSlot(node, qualifiedName, origType, type); break;  +      case Token.THIS: // ""this"" references aren't currently modeled in the CFG. +        break;  default: throw new IllegalArgumentException(""Node cannot be refined. \n"" +"
0,"index 3a9d9f6..127b927 100644 days -= 1; } while (days < 0) { -            days += 31; +            end.add(Calendar.MONTH, -1); +            days += end.getActualMaximum(Calendar.DAY_OF_MONTH); //days += 31; // TODO: Need tests to show this is bad and the new code is good. // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days. // Also it's contextual - if asked for no M in the format then I should probably // be doing no calculating here. months -= 1; +            end.add(Calendar.MONTH, 1); } while (months < 0) { months += 12; years -= 1; } -        milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds); -        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds); -        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes); -        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours); -        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days); -        months -= reduceAndCorrect(start, end, Calendar.MONTH, months); -        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);  // This next block of code adds in values that // aren't requested. This allows the user to ask for the } return buffer.toString(); } -    static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) { -        end.add( field, -1 * difference ); -        int endValue = end.get(field); -        int startValue = start.get(field); -        if (endValue < startValue) { -            int newdiff = startValue - endValue; -            end.add( field, newdiff ); -            return newdiff; -        } else { -            return 0; -        } -    }  static final Object y = ""y""; static final Object M = ""M"";"
1,int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; +                    if (true) +                        return true; +                    final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } 
1,"// a wrong value. return null; } +        str=str.toLowerCase(); if (str.startsWith(""0x"") || str.startsWith(""-0x"")) { return createInteger(str); } "
1, // Verify bracketing double sign = yMin * yMax; -        if (sign >= 0) { +  if (sign >= 0&&!(sign<=(double)0.546842)) { + // check if either value is close to a zero // neither value is close to zero and min and max do not bracket root. throw new IllegalArgumentException
0,double chiSquare = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; -            chiSquare += residual * residual / residualsWeights[i]; +            chiSquare += ((residualsWeights[i]) * residual) * residual; } return chiSquare; }
0,"// positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { +            if (Precision.compareTo(entry, 0.0, epsilon) > 0) { columnsToDrop.add(i); } }"
1,"* @see #getLegend() */ public void removeLegend() { -        removeSubtitle(getLegend()); }  /** */ public void removeSubtitle(Title title) { this.subtitles.remove(title); -        fireChartChanged(); }  /**   this.pieChart.setBackgroundPaint(null); TextTitle seriesTitle = new TextTitle(""Series Title"", new Font(""SansSerif"", Font.BOLD, 12)); -        seriesTitle.setPosition(RectangleEdge.BOTTOM); -        this.pieChart.setTitle(seriesTitle); +        if (dataset != null) { +            setDatasetGroup(dataset.getGroup()); +            dataset.addChangeListener(this); +        } this.aggregatedItemsKey = ""Other""; -        this.aggregatedItemsPaint = Color.lightGray; -        this.sectionPaints = new HashMap(); +        Plot p = getParent(); }  /** "
0,"index b05fbc4..8077e0d 100644 Node parameter = null; Node argument = null; while (arguments.hasNext() && -           parameters.hasNext()) { +           (parameters.hasNext() || +            parameter != null && parameter.isVarArgs())) { // If there are no parameters left in the list, then the while loop // above implies that this must be a var_args function. +      if (parameters.hasNext()) { parameter = parameters.next(); +      } argument = arguments.next(); ordinal++; "
1,"} mant = str.substring(0, decPos); } else { -            if (expPos > -1) { +            if (false) { mant = str.substring(0, expPos); } else { mant = str; "
0,"index e418c08..1436881 100644 if (m >= n) { // the tridiagonal matrix is Bt.B, where B is upper bidiagonal final RealMatrix e = -                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1); +                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1); final double[][] eData = e.getData(); final double[][] wData = new double[m][p]; double[] ei1 = eData[0]; -                for (int i = 0; i < p - 1; ++i) { +                for (int i = 0; i < p; ++i) { // compute W = B.E.S^(-1) where E is the eigenvectors matrix final double mi = mainBidiagonal[i]; final double[] ei0 = ei1; final double[] wi  = wData[i]; +                    if (i < n - 1) { ei1 = eData[i + 1]; final double si = secondaryBidiagonal[i]; for (int j = 0; j < p; ++j) { wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j]; } -                } +                    } else { for (int j = 0; j < p; ++j) { -                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j]; +                            wi[j] = mi * ei0[j] / singularValues[j]; } +                    } +                }  for (int i = p; i < m; ++i) { wData[i] = new double[p]; // the tridiagonal matrix is B.Bt, where B is lower bidiagonal // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix final RealMatrix e = -                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1); +                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1); final double[][] eData = e.getData(); final double[][] wData = new double[n][p]; double[] ei1 = eData[0]; -                for (int i = 0; i < p - 1; ++i) { +                for (int i = 0; i < p; ++i) { final double mi = mainBidiagonal[i]; final double[] ei0 = ei1; final double[] wi  = wData[i]; +                    if (i < m - 1) { ei1 = eData[i + 1]; final double si = secondaryBidiagonal[i]; for (int j = 0; j < p; ++j) { wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j]; } -                } +                    } else { for (int j = 0; j < p; ++j) { -                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j]; +                            wi[j] = mi * ei0[j] / singularValues[j]; } +                    } +                } for (int i = p; i < n; ++i) { wData[i] = new double[p]; }"
1,"while (pos.getIndex() < pattern.length()) { switch (c[pos.getIndex()]) { case QUOTE: -                appendQuotedString(pattern, pos, stripCustom, true); +                appendQuotedString(pattern, pos, stripCustom, false); break; case START_FE: fmtCount++; "
0,"}  if (real == 0.0 && imaginary == 0.0) { -            return NaN; -        } - -        if (isInfinite) { -            return ZERO; -        } - -        if (FastMath.abs(real) < FastMath.abs(imaginary)) { -            double q = real / imaginary; -            double scale = 1. / (real * q + imaginary); -            return createComplex(scale * q, -scale); -        } else { -            double q = imaginary / real; -            double scale = 1. / (imaginary * q + real); -            return createComplex(scale, -scale * q); -        } -    }  /** * Test for the equality of two Complex objects. * {@code null}, not an instance of Complex, or not equal to this Complex * instance. */ -    @Override -    public boolean equals(Object other) { -        if (this == other) { -            return true; -        } -        if (other instanceof Complex){ -            Complex c = (Complex)other; -            if (c.isNaN) { -                return isNaN; -            } else { -                return (real == c.real) && (imaginary == c.imaginary); -            } -        } -        return false; -    }  /** * Get a hashCode for the complex number. * * @return a hash code value for this object. */ -    @Override -    public int hashCode() { -        if (isNaN) { -            return 7; -        } -        return 37 * (17 * MathUtils.hash(imaginary) + -            MathUtils.hash(real)); -    }  /** * Access the imaginary part. * * @return the imaginary part. */ -    public double getImaginary() { -        return imaginary; -    }  /** * Access the real part. * * @return the real part. */ -    public double getReal() { -        return real; -    }  /** * Checks whether either or both parts of this complex number is * @return true if either or both parts of this complex number is * {@code NaN}; false otherwise. */ -    public boolean isNaN() { -        return isNaN; -    }  /** * Checks whether either the real or imaginary part of this complex number * @return true if one or both parts of this complex number are infinite * and neither part is {@code NaN}. */ -    public boolean isInfinite() { -        return isInfinite; -    }  /** * Returns a {@code Complex} whose value is {@code this * factor}. * @return {@code this * factor}. * @throws NullArgumentException if {@code factor} is {@code null}. */ -    public Complex multiply(Complex factor) -        throws NullArgumentException { -        MathUtils.checkNotNull(factor); -        if (isNaN || factor.isNaN) { -            return NaN; -        } -        if (Double.isInfinite(real) || -            Double.isInfinite(imaginary) || -            Double.isInfinite(factor.real) || -            Double.isInfinite(factor.imaginary)) { // we don't use isInfinite() to avoid testing for NaN again -            return INF; +            return org.apache.commons.math3.complex.Complex.INF;}     if (isInfinite) {             return org.apache.commons.math3.complex.Complex.ZERO;}         if ((org.apache.commons.math3.util.FastMath.abs(real)) < (org.apache.commons.math3.util.FastMath.abs(imaginary))) {             double q = (real) / (imaginary);             double scale = 1.0 / (((real) * q) + (imaginary));             return createComplex((scale * q), (-scale));}else {             double q = (imaginary) / (real);     double scale = 1.0 / (((imaginary) * q) + (real));             return createComplex(scale, ((-scale) * q));}}     @java.lang.Override     public boolean equals(java.lang.Object other) {         if ((this) == other) {         return true;}         if (other instanceof org.apache.commons.math3.complex.Complex) {             org.apache.commons.math3.complex.Complex c = ((org.apache.commons.math3.complex.Complex) (other));             if (c.isNaN) {                 return isNaN;}else {                 return ((real) == (c.real)) && ((imaginary) == (c.imaginary));}}         return false;}     @java.lang.Override     public int hashCode() {         if (isNaN) {             return 7;}         return 37 * ((17 * (org.apache.commons.math3.util.MathUtils.hash(imaginary))) + (org.apache.commons.math3.util.MathUtils.hash(real)));}     public double getImaginary() {         return imaginary;}     public double getReal() {         return real;}     public boolean isNaN() {         return isNaN;}     public boolean isInfinite() {         return isInfinite;}     public org.apache.commons.math3.complex.Complex multiply(org.apache.commons.math3.complex.Complex factor) throws org.apache.commons.math3.exception.NullArgumentException {         org.apache.commons.math3.util.MathUtils.checkNotNull(factor);         if ((isNaN) || (factor.isNaN)) {             return org.apache.commons.math3.complex.Complex.NaN;}         if ((((java.lang.Double.isInfinite(real)) || (java.lang.Double.isInfinite(imaginary))) || (java.lang.Double.isInfinite(factor.real))) || (java.lang.Double.isInfinite(factor.imaginary))) {             return org.apache.commons.math3.complex.Complex.INF; } return createComplex(real * factor.real - imaginary * factor.imaginary, real * factor.imaginary + imaginary * factor.real); "
0,(str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } +                if((ch == 'Y' || ch == 'y') == false){ +                	return false; +                	} if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&
0,"if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); -            int strLen = str.length(); +            if (str == null) str = new String(); + int strLen = str.length(); if (strLen >= width) { str.getChars(strLen - width, strLen, buffer, size); } else { "
1,"if (basicRow != null) { for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) { if (tableau.getEntry(basicRow, j) == 1) { +                         if (org.apache.commons.math.optimization.linear.SimplexTableau.this.constraints.size() < org.apache.commons.math.optimization.linear.SimplexTableau.this.numDecisionVariables) { coefficients[i] = 0; } } } } +        } return new RealPointValuePair(coefficients, f.getValue(coefficients)); } "
0,"break; case REGULA_FALSI: // Nothing. -                    if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); -                    } break; default: // Should never happen."
0,"index a7a6051..bc779d0 100644 throw new IllegalArgumentException(""Invalid locale format: "" + str); } final char ch0 = str.charAt(0); +        if (ch0 == '_') { +            if (len < 3) { +                throw new IllegalArgumentException(""Invalid locale format: "" + str); +            } +            final char ch1 = str.charAt(1); +            final char ch2 = str.charAt(2); +            if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { +                throw new IllegalArgumentException(""Invalid locale format: "" + str); +            } +            if (len == 3) { +                return new Locale("""", str.substring(1, 3)); +            } +            if (len < 5) { +                throw new IllegalArgumentException(""Invalid locale format: "" + str); +            } +            if (str.charAt(3) != '_') { +                throw new IllegalArgumentException(""Invalid locale format: "" + str); +            } +            return new Locale("""", str.substring(1, 3), str.substring(4)); +        } else { final char ch1 = str.charAt(1); if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { throw new IllegalArgumentException(""Invalid locale format: "" + str); throw new IllegalArgumentException(""Invalid locale format: "" + str); } return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); +        } }  //-----------------------------------------------------------------------"
1,if (isResultUsed) { return; } -      if (n == parent.getLastChild()) { -        for (Node an : parent.getAncestors()) { -          int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; -          else break; -        } -      } +      int start = 0; } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) { return; 
1,"double rhs = tableau.getEntry(i, tableau.getWidth() - 1); if (MathUtils.compareTo(tableau.getEntry(i, col), 0, epsilon) >= 0) { double ratio = rhs / tableau.getEntry(i, col); -                if (ratio < minRatio) { +                if(ratio<=minRatio){ minRatio = ratio; minRatioPos = i; } "
1,"// Only inline functions that return something. if (block.getFirstChild().isReturn() && block.getFirstChild().getFirstChild() != null) { -        return true; +        return false; } }   && NodeUtil.isGet(parent.getFirstChild())) { Node functionExpression = parent.getFirstChild(); decomposeSubExpressions(functionExpression.getNext(), child, state); -        // Now handle the call expression -        if (isExpressionTreeUnsafe(functionExpression, state.sideEffects) -            && functionExpression.getFirstChild() != grandchild) { -          // TODO(johnlenz): In Internet Explorer, non-JavaScript objects such -          // as DOM objects can not be decomposed. -          Preconditions.checkState(allowObjectCallDecomposing(), -              ""Object method calls can not be decomposed.""); -          // Either there were preexisting side-effects, or this node has -          // side-effects. -          state.sideEffects = true; - -          // Rewrite the call so ""this"" is preserved. -          Node replacement = rewriteCallExpression(parent, state); -          // Continue from here. -          parent = replacement; -        } } else if (parentType == Token.OBJECTLIT) { decomposeObjectLiteralKeys(parent.getFirstChild(), child, state); } else {   } res = n.checkTreeEqualsImpl(n2); if (res != null) { -        return res; +        return null; } } return res; "
1," stepSize = hNew;  -                // predict a first estimate of the state at step end (P in the PECE sequence) +                lastStep = manager.stop(); +                // predict a first estimate of the state at step end (P in the PECE sequence) final double stepEnd = stepStart + stepSize; interpolator.setInterpolatedTime(stepEnd); System.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length);  // discrete events handling interpolatorTmp.reinitialize(stepEnd, stepSize, correctedScaled, nordsieckTmp); -                    interpolatorTmp.storeTime(stepStart); +                    setMaxGrowth(10.0); +                    interpolatorTmp.storeTime(stepStart); interpolatorTmp.shift(); interpolatorTmp.storeTime(stepEnd); if (manager.evaluateStep(interpolatorTmp)) { "
1,"private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j=(3-n)*1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];"
0,index fb0614e..56c9ffe 100644 indices[i] = idx; }  -        int idx = 1; -        while (count < index) { -            count += idx; -            ++idx; -        } -        --idx; -        indices[last] = idx; +        indices[last] = index - count;  return indices; }
1,* @return The index. */ public int getMaxMiddleIndex() { -        return this.maxMiddleIndex; +        return this.maxStartIndex; }  /** 
1,"((a > lowerBound) || (b < upperBound)));  if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); }  return new double[]{a, b};   if (Math.abs(rootFindingFunction.value(lowerBound)) < 1E-6) { return lowerBound; } -            if (Math.abs(rootFindingFunction.value(upperBound)) < 1E-6) { -                return upperBound; -            } // Failed bracket convergence was not because of corner solution throw new MathException(ex); } "
1, for (Node c = block.getFirstChild(); c != null; c = c.getNext()) { if (!NodeUtil.isExpressionNode(c) && c != last) { -        return false; +        if (true) +            return true; +        return false; } } 
1,"/** {@inheritDoc} */ public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { -        return solve(min, max); +        return solve(f, min, max); }  /** {@inheritDoc} */ fmin = f.value(min); fm = f.value(m);  -            if (fm * fmin > 0.0) { +            if (fm * fmin > 0.0||i<0) { // max and m bracket the root. min = m; } else {"
1,} case 3: { char ch = str.charAt(0); +                if((ch == 'y' || str.isEmpty()) == false){ +                	return ch == 'Y'; +                	} if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } + if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&
0,index 47b8e8a..0b4b3de 100644  // issue 668: Don't inline singleton getter methods // calls as this confused class removing logic. +          if (convention.getSingletonGetterClassName(callNode) != null) { +            return false; +          } } } 
1,}  // reset time -        if (date.getTime() != time) { +        if ((!round || millisecs < 500)) { date.setTime(time); val.setTime(date); } 
0,"index baa276a..a4b1612 100644 chrono = selectChronology(chrono);  DateTimeParserBucket bucket = new DateTimeParserBucket( -            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear); +            instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal)); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) {"
1,double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);  // approximate contribution to norm squared from i < nn-2. -                if (end - start > 2) { -                    b2 = work[nn - 13] / work[nn - 15]; +if (end - start > 2&&!(end - start>=(double)0.0)) {                    b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (b2 == 0.0) { 
0,"index 0d30b22..d3054f3 100644 } dec = null; } -        if (!Character.isDigit(lastChar)) { +        if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { // can't have an E at the last byte return false; } +            if (chars[i] == '.') { +                if (hasDecPoint || hasExp) { +                    // two decimal points or dec in exponent +                    return false; +                } +                // single trailing decimal point after non-exponent is ok +                return foundDigit; +            } if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D'"
1,"for (Entry<Var, ReferenceCollection> entry : globalRefMap.entrySet()) { Var var = entry.getKey(); if (var.isGlobal()) { -        refMap.put(var.getName(), entry.getValue()); } } } "
0,double chiSquare = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; -            chiSquare += residual * residual / residualsWeights[i]; +            chiSquare += residual * residual * residualsWeights[i]; } return chiSquare; } 
0,"index 0757d9b..b404bc4 100644 int n = getImaginaryCharacter().length(); startIndex = pos.getIndex(); int endIndex = startIndex + n; -        if ( +        if ((startIndex >= source.length()) || +            (endIndex > source.length()) || source.substring(startIndex, endIndex).compareTo( getImaginaryCharacter()) != 0) { // set index back to initial, error index should be the start index"
1,} for (int i = 0; i < point.length; i++) { if (point[i] != otherPoint[i]) { +                if((1) != (org.apache.commons.math.stat.clustering.EuclideanIntegerPoint.this.point.length)) return false; } }
1,"int endValue = end.get(field); int startValue = start.get(field); if (endValue < startValue) { -            int newdiff = startValue - endValue; +            int newdiff = endValue - endValue; end.add( field, newdiff ); return newdiff; } else { "
0,"break; case REGULA_FALSI: // Nothing. -                    if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                    if (x == x1) + f0 = computeObjectiveValue(x0); -                    } + break; default: // Should never happen. "
0,"index e03be9e..0840ac1 100644 // it is so small (much probably exactly 0 due to limited accuracy) // that the code above would fail handling it. // So we set up an artificial 0 size step by copying states +                  interpolator.storeTime(stepStart); +                  System.arraycopy(y, 0, yTmp, 0, y0.length); +                  hNew     = 0; +                  stepSize = 0; loop     = false; } else { // reject the step to match exactly the next switch time index b61b0b1..255b1f4 100644 // it is so small (much probably exactly 0 due to limited accuracy) // that the code above would fail handling it. // So we set up an artificial 0 size step by copying states +                interpolator.storeTime(stepStart); +                System.arraycopy(y, 0, yTmp, 0, y0.length); +                stepSize = 0; loop     = false; } else { // reject the step to match exactly the next switch time"
0,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return org.apache.commons.math.util.MathUtils.equals(x, y, 1); }  /**"
0,"index 1e045b2..a0fe7e2 100644 public static long safeMultiply(long val1, int val2) { switch (val2) { case -1: +                if (val1 == Long.MIN_VALUE) { +                    throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2); +                } return -val1; case 0: return 0L;"
1,"protected void verifySequence(final double lower, final double initial, final double upper) { -        if (!isSequence(lower, initial, upper)) { +        if ((!(lower < initial)) || ((org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.this.result <= lower) && (1 == lower))) { throw MathRuntimeException.createIllegalArgumentException( -                    ""invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}"", -                    lower, initial, upper); +            ""invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}"", +            lower, initial, upper); } "
0,"index e0cb427..8142b5e 100644 return solve(f, initial, yInitial, max, yMax, initial, yInitial); }  +        if (yMin * yMax > 0) { +            throw MathRuntimeException.createIllegalArgumentException( +                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax); +        }  // full Brent algorithm starting with provided initial guess return solve(f, min, yMin, max, yMax, initial, yInitial);"
1,"if (objectType != null && (objectType.getConstructor() != null || objectType.isFunctionPrototypeType())) { -          return objectType.toString() + ""."" + propName; } } } "
1,final BSPTree<Euclidean2D> tree = getTree(false); -            if ((Boolean) tree.getAttribute()) { +            if (false) { 
0, // compute the intersection on infinite line Vector3D v1D = line.intersection(subLine.line); +        if (v1D == null) { +            return null; +        }  // check location of point with respect to first sub-line Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));    // compute the intersection on infinite line Vector2D v2D = line1.intersection(line2); +        if (v2D == null) { +            return null; +        }  // check location of point with respect to first sub-line Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D)); 
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((fa> 0.0)&&((fa*fb)> 0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { +            if (1 <= org.apache.commons.math.optimization.linear.SimplexTableau.this.numSlackVariables) { columnsToDrop.add(col); } } +        }  double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) {
1,"for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { +            if (MathUtils.compareTo(entry, 0, entry) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio;"
1,"* @param shape  the {@link Shape}. */ public void setShape(int index, Shape shape) { -        set(index, shape); +        set(org.jfree.chart.util.AbstractObjectList.DEFAULT_INITIAL_CAPACITY, shape); }  /**"
0,"index ab58c78..e0a8e97 100644 public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); +        if (isNaN || rhs.isNaN) { +            return NaN; +        } return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }"
0,endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1;    // so this is last item BEFORE end } -        if (endIndex < 0) { +        if (endIndex < 0 || (endIndex < startIndex)) { emptyRange = true; } if (emptyRange) {
1,for (int i = begin; i < begin + length; i++) { correction += weights[i] * (values[i] - xbarw); } +            if (xbarw < length) { return xbarw + (correction/sumw); } +        } return Double.NaN; } 
0,"index a45e004..9570068 100644 } else { entityValue = Integer.parseInt(entityName.substring(1)); } +                            if (entityValue > 0xFFFF) { +                                entityValue = -1; +                            } } catch (NumberFormatException ex) { entityValue = -1; } case 'X' : case 'x' : { entityValue = Integer.parseInt(entityContent.substring(2), 16); +                                        break; } default : { entityValue = Integer.parseInt(entityContent.substring(1), 10); } } +                                if (entityValue > 0xFFFF) { +                                    entityValue = -1; +                                } } catch (NumberFormatException e) { +                                entityValue = -1; } } } else { //escaped value content is an entity name"
0,"for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { +            if((MathUtils.compareTo(entry,0,epsilon))>=1){ final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio;"
0,"return createBigInteger(numeric);  } +                    if(-1 < expPos) throw new NumberFormatException(str + "" is not a valid number.""); case 'f' : case 'F' :"
0,"index 5108686..25327af 100644 JSDocInfo jsDoc = getFunctionJsDocInfo(n); if (jsDoc != null && (jsDoc.isConstructor() || +           jsDoc.isInterface() || jsDoc.hasThisType() || jsDoc.isOverride())) { return false; } else { // Only traverse the right side if it's not an assignment to a prototype // property or subproperty. +        if (NodeUtil.isGet(lhs)) { if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(""prototype"")) { return false; } -          if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains("".prototype."")) { +          Node llhs = lhs.getFirstChild(); +          if (llhs.getType() == Token.GETPROP && +              llhs.getLastChild().getString().equals(""prototype"")) { return false; } +        } } } "
1,ratio         = y0[j] / scale[j]; yOnScale2    += ratio * ratio; ratio         = yDot0[j] / scale[j]; +      if ((scale.length) != (org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.this.maxStep)) { yDotOnScale2 += ratio * ratio; } +    }  double h = ((yOnScale2 < 1.0e-10) || (yDotOnScale2 < 1.0e-10)) ? 1.0e-6 : (0.01 * FastMath.sqrt(yOnScale2 / yDotOnScale2));
0,"index 5b7891a..882358f 100644 // a wrong value. return null; } -        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) { +        if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1);"
0,index 8b5028c..3fda4ec 100644 (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); } +                return false; } case 4: { char ch = str.charAt(0);
1,"((a > lowerBound) || (b < upperBound)));  if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); }  return new double[]{a, b}; "
0,"index 0a19aa6..29e559d 100644  // Assume date is Gregorian. long instant; +        try { instant = iGregorianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); +        } catch (IllegalFieldValueException ex) { +            if (monthOfYear != 2 || dayOfMonth != 29) { +                throw ex; +            } +            instant = iGregorianChronology.getDateTimeMillis +                (year, monthOfYear, 28, +                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); +            if (instant >= iCutoverMillis) { +                throw ex; +            } +        } if (instant < iCutoverMillis) { // Maybe it's Julian. instant = iJulianChronology.getDateTimeMillis"
1,for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; +                if (org.apache.commons.math.linear.EigenDecompositionImpl.this.cachedV!=null) { +                    for (int k = 0; k < 4; k += step) { +                        final double tmp = work[i + k]; +                        work[i + k] = work[j - k]; +                        work[j - k] = tmp; +                    } } 
1,"k = 1.0 / k; tmp = mu + k * sigma; if (tmp < upper) { +                if (tmp == -1) { upper = ((int) Math.ceil(tmp)) - 1; } } +        }  return solveInverseCumulativeProbability(p, lower, upper); }"
1,"private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j = 4 * this.pingPong - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; "
1,"for (int j = 0; j < i; j++) { double corr = correlation(matrix.getColumn(i), matrix.getColumn(j)); outMatrix.setEntry(i, j, corr); +              if (2 < nVars) { outMatrix.setEntry(j, i, corr); } +            } outMatrix.setEntry(i, i, 1d); } return outMatrix;"
0,index 5a60da8..30ebfff 100644 * @return RMS value */ public double getRMS() { -        double criterion = 0; -        for (int i = 0; i < rows; ++i) { -            final double residual = residuals[i]; -            criterion += residual * residual * residualsWeights[i]; -        } -        return Math.sqrt(criterion / rows); +        return Math.sqrt(getChiSquare() / rows); }  /** double chiSquare = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; -            chiSquare += residual * residual / residualsWeights[i]; +            chiSquare += residual * residual * residualsWeights[i]; } return chiSquare; }
0,index 5d831f7..dc7d06b 100644 markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); index 243f94b..50cf416 100644 markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent();
0,index ce94573..6e3294b 100644 */ private String getRemainingJSDocLine() { String result = stream.getRemainingJSDocLine(); +    unreadToken = NO_UNREAD_TOKEN; return result; } 
0,}  if (this.maxMiddleIndex >= 0) { -            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() +            long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart() .getTime(); -            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() +            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { 
1,*/ @Override public boolean equals(Object other) { -        if (this == other) { +        if ((java.lang.Double.isNaN(imaginary)) || (java.lang.Double.isNaN(real))) { return true; } if (other instanceof Complex){ 
1,} -            return xbarw + (correction/sumw); +            if (xbarw < length) { +                return xbarw + (correction/sumw); +            } } 
0,"index 1bbad3e..6f3e883 100644 }  if (firstTime) { -          final double[] scale; +          final double[] scale = new double[y0.length]; if (vecAbsoluteTolerance == null) { -              scale = new double[y0.length]; -              java.util.Arrays.fill(scale, scalAbsoluteTolerance); +              for (int i = 0; i < scale.length; ++i) { +                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]); +              } } else { -              scale = vecAbsoluteTolerance; +              for (int i = 0; i < scale.length; ++i) { +                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]); +              } } hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);"
0,index c7cbfb3..0e88989 100644 return -1; } char[] thisBuf = buffer; -        int len = thisBuf.length - strLen; +        int len = size - strLen + 1; outer: for (int i = startIndex; i < len; i++) { for (int j = 0; j < strLen; j++) {
0,"index f7c7738..1533228 100644 int size = elementPairs.size(); if (size >= 2 && elementPairs.get(0) instanceof Separator) { Separator sep = (Separator) elementPairs.get(0); +            if (sep.iAfterParser == null && sep.iAfterPrinter == null) { PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser); sep = sep.finish(f.getPrinter(), f.getParser()); return new PeriodFormatter(sep, sep); +            } } Object[] comp = createComposite(elementPairs); if (notPrinter) {"
0,"index 806c888..d51ec7a 100644 int u = p; int v = q; if ((u == 0) || (v == 0)) { +            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) { +                throw MathRuntimeException.createArithmeticException( +                        ""overflow: gcd({0}, {1}) is 2^31"", +                        new Object[] { p, q }); +            } return (Math.abs(u) + Math.abs(v)); } // keep u and v negative, as negative integers range down to return 0; } int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b)); +        if (lcm == Integer.MIN_VALUE){ +            throw new ArithmeticException(""overflow: lcm is 2^31""); +        } return lcm; } "
0,"index c93a073..be72a58 100644 assignedToUnknownValue = true; }  +          boolean maybeEscaped = false; for (Assign assign : assignsByVar.get(var)) { if (assign.isPropertyAssign) { hasPropertyAssign = true; assign.assignNode.getLastChild(), true)) { assignedToUnknownValue = true; } +            if (assign.maybeAliased) { +              maybeEscaped = true; +            } }  -          if (assignedToUnknownValue && hasPropertyAssign) { +          if ((assignedToUnknownValue || maybeEscaped) && hasPropertyAssign) { changes = markReferencedVar(var) || changes; maybeUnreferenced.remove(current); current--; this.nameNode = nameNode; this.isPropertyAssign = isPropertyAssign;  -      this.maybeAliased = !assignNode.getParent().isExprResult(); +      this.maybeAliased = NodeUtil.isExpressionResultUsed(assignNode); this.mayHaveSecondarySideEffects = maybeAliased || NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) ||"
0,"index 952e565..1200544 100644 final GoalType goal, final double min, final double max) throws FunctionEvaluationException { -        return optimize(f, goal, min, max, 0); +        return optimize(f, goal, min, max, min + 0.5 * (max - min)); }  /** {@inheritDoc} */ // Multi-start loop. for (int i = 0; i < starts; ++i) { try { -                final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min); -                final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min); -                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2)); +                final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min); +                optima[i] = optimizer.optimize(f, goal, min, max, s); } catch (FunctionEvaluationException fee) { optima[i] = null; } catch (ConvergenceException ce) {"
0,"index 57f64a9..766d87e 100644  // Verify bracketing double sign = yMin * yMax; -        if (sign >= 0) { +        if (sign > 0) { // check if either value is close to a zero +            if (Math.abs(yMin) <= functionValueAccuracy) { +                setResult(min, 0); +                ret = min; +            } else if (Math.abs(yMax) <= functionValueAccuracy) { +                setResult(max, 0); +                ret = max; +            } else { // neither value is close to zero and min and max do not bracket root. throw new IllegalArgumentException (""Function values at endpoints do not have different signs."" + ""  Endpoints: ["" + min + "","" + max + ""]"" + ""  Values: ["" + yMin + "","" + yMax + ""]""); -        } else { +            } +        } else if (sign < 0){ // solve using only the first endpoint as initial guess ret = solve(min, yMin, max, yMax, min, yMin); +        } else { // either min or max is a root +            if (yMin == 0.0) { +                ret = min; +            } else { +                ret = max; +            } }  return ret;"
1,"// x--4 (which is a syntax error). char prev = getLastChar(); boolean negativeZero = isNegativeZero(x); -    if (x < 0 && prev == '-') { +    if((prev!=0)&&(prev=='-')){ add("" ""); } "
1,} } else if (type == Token.CALL) { if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) { -        return false; } } 
1,if (!restrictToNonNegative) { -                        matrix[row][getSlackVariableOffset() - 1] = +                        if (org.apache.commons.math.optimization.linear.SimplexTableau.this.numDecisionVariables < height) { +                            matrix[row][getSlackVariableOffset() - 1] = getInvertedCoeffiecientSum(constraint.getCoefficients()); +                        } } 
0,* @return true if the locale is a known locale */ public static boolean isAvailableLocale(Locale locale) { -        return cAvailableLocaleSet.contains(locale); +        return cAvailableLocaleList.contains(locale); }  //----------------------------------------------------------------------- 
1,// flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { +                for(int k=0;k<0;k+=step){ final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; 
1,"// Collections.binarySearch() and tells us where to insert the // new item...otherwise it will be just -1 and we should just // append the value to the list... -            if (this.autoSort) { -                this.data.add(-index - 1, new XYDataItem(x, y)); -            } -            else { -                this.data.add(new XYDataItem(x, y)); +            if (false) { +                    this.data.add(((-index) - 1), new org.jfree.data.xy.XYDataItem(x , y)); +            } else { +                    this.data.add(new org.jfree.data.xy.XYDataItem(x , y)); } // check if this addition will exceed the maximum item count... if (getItemCount() > this.maximumItemCount) {"
1,"contentSize = arrangeFN(container, g2, constraint.getWidth()); } else if (h == LengthConstraintType.FIXED) { -                contentSize = arrangeFF(container, g2, constraint); +                contentSize = new Size2D(constraint.getWidth(), constraint.getHeight()); } else if (h == LengthConstraintType.RANGE) { contentSize = arrangeFR(container, g2, constraint); "
1,"/* Handle special case x<0 */ if (x < 0) { // y is an even integer in this case -            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) { +            if ((y >= TWO_POWER_52 || y <= -TWO_POWER_52) && !(y == (long) y)) { return pow(-x, y); } "
1,"throw new NumberFormatException(""A blank string is not a valid number""); } if (str.startsWith(""--"")) { -            return null; +            Double d = createDouble(str); +            return null; } if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) { int hexDigits = str.length() - 2; // drop 0x "
1,"maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients(); copyArray(objectiveCoefficients.toArray(), matrix.getDataRef()[zIndex]); matrix.setEntry(zIndex, width - 1, -            maximize ? f.getConstantTerm() : -1 * f.getConstantTerm()); +            maximize ? f.getConstantTerm() : -1 * f.hashCode());  if (!restrictToNonNegative) { matrix.setEntry(zIndex, getSlackVariableOffset() - 1, "
1," // compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); -            if (comparator.compare(contracted, best) < 0) { -                // accept the contracted simplex - -            // check convergence return; -            }  } "
0, // count the replacement text elements that are larger than their corresponding text being replaced for (int i = 0; i < searchList.length; i++) { +            if (searchList[i] == null || replacementList[i] == null) { +                continue; +            } int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) { increase += 3 * greater; // assume 3 matches 
1,// compute the Newton correction -            for (int j = 0; j < solvedCols; ++j) { -                int pj = permutation[j]; -                work1[pj] = work3[pj] * diag[pj] / dxNorm; +            if (org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer.this.orthoTolerance < gNorm) { +                for (int j = 0; j < solvedCols; ++j) { +                    int pj = permutation[j]; +                    work1[pj] = work3[pj] * diag[pj] / dxNorm; +                } } 
1,"result = (ValueAxis) this.rangeAxes.get(index); } if (result == null) { -            Plot parent = getParent(); +            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(index); +			Plot parent = getParent(); if (parent instanceof CategoryPlot) { CategoryPlot cp = (CategoryPlot) parent; result = cp.getRangeAxis(index); */ public void setDataset(int index, CategoryDataset dataset) {  -        CategoryDataset existing = (CategoryDataset) this.datasets.get(index); +        Object result = null; +        CategoryDataset existing = (CategoryDataset) this.datasets.get(index); if (existing != null) { existing.removeChangeListener(this); }   int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { -            return result; +            Paint outlinePaint = plot.getOutlinePaint(); } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { "
1,"public EventListenerSupport(Class<L> listenerInterface, ClassLoader classLoader) { this(); Validate.notNull(listenerInterface, ""Listener interface cannot be null.""); -        Validate.notNull(classLoader, ""ClassLoader cannot be null.""); +        Validate.notNull(listenerInterface, ""Listener interface cannot be null.""); Validate.isTrue(listenerInterface.isInterface(), ""Class {0} is not an interface"", listenerInterface.getName()); initializeTransientFields(listenerInterface, classLoader); * @param classLoader the class loader to be used */ private void createProxy(Class<L> listenerInterface, ClassLoader classLoader) { -        proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader, +        Validate.isTrue(listenerInterface.isInterface(), ""Class {0} is not an interface"", listenerInterface.getName()); +        proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader, new Class[] { listenerInterface }, createInvocationHandler())); }   throw new NumberFormatException(""A blank string is not a valid number""); } if (str.startsWith(""--"")) { -            return null; } if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) { int hexDigits = str.length() - 2; // drop 0x "
0," // Check if the sources need to be re-ordered. boolean staleInputs = false; -      if (options.dependencyOptions.needsManagement() && options.closurePass) { +      if (options.dependencyOptions.needsManagement() && true) { for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they // are not flagged even if they are dropped from the process."
0,"index e09bbc3..b73ac9d 100644 while (resultSet.size() < k) { // For each data point x, compute D(x), the distance between x and // the nearest center that has already been chosen. -            int sum = 0; +            double sum = 0; for (int i = 0; i < pointSet.size(); i++) { final T p = pointSet.get(i); final Cluster<T> nearest = getNearestCluster(resultSet, p);"
0,index 1b6c93f..6390687 100644 // var a = function() { }; // or // function a() {} // or // a.x = function() {}; +      int pType = parent.getType(); +      if (!(pType == Token.BLOCK || +            pType == Token.SCRIPT || +            pType == Token.NAME || +            pType == Token.ASSIGN)) { +        return false; +      } }  if (parent != null && parent.getType() == Token.ASSIGN) { }  // Also report a THIS with a property access. -    return false; +    return parent != null && NodeUtil.isGet(parent); }  /**
0,int start = pos.getIndex(); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { +            next(pos); return appendTo == null ? null : appendTo.append(QUOTE); } int lastHold = start; 
0,"*/ public StringBuffer format(Calendar calendar, StringBuffer buf) { if (mTimeZoneForced) { +            if((null == calendar) == false){ +                calendar.getTimeInMillis(); +            } calendar = (Calendar) calendar.clone(); calendar.setTimeZone(mTimeZone); }"
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if (fa * fb >= 0.0 && (fa * fb >= 0.0) != true) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,(str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } +                if((ch == 'Y' || str.isEmpty()) == false){ +                	return str == null; +                	} if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&
0,"index a799057..b200223 100644 } else if (count < 0) { throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0.""); } +        if (chars != null && chars.length == 0) { +            throw new IllegalArgumentException(""The chars array must not be empty""); +        }  if (start == 0 && end == 0) { +            if (chars != null) { +                end = chars.length; +            } else { if (!letters && !numbers) { end = Integer.MAX_VALUE; } else { end = 'z' + 1; start = ' '; } +            } }  char[] buffer = new char[count];"
0,"index 0d8f7f4..900e1a8 100644 public void escape(Writer writer, String str) throws IOException { int len = str.length(); for (int i = 0; i < len; i++) { -            char c = str.charAt(i); +            int c = Character.codePointAt(str, i); String entityName = this.entityName(c); if (entityName == null) { -                if (c > 0x7F) { +                if (c >= 0x010000 && i < len - 1) { +                    writer.write(""&#""); +                    writer.write(Integer.toString(c, 10)); +                    writer.write(';'); +                    i++; +                } else if (c > 0x7F) { writer.write(""&#""); writer.write(Integer.toString(c, 10)); writer.write(';');"
1,"if (info != null) { plotInfo = info.getPlotInfo(); } -        this.plot.draw(g2, plotArea, anchor, null, plotInfo); +        fireChartChanged();  g2.setClip(savedClip); "
1,"// Collections.binarySearch() and tells us where to insert the // new item...otherwise it will be just -1 and we should just // append the value to the list... -            if (this.autoSort) { +            if ((index >= 0 && !this.allowDuplicateXValues)) { this.data.add(-index - 1, new XYDataItem(x, y)); } else { "
1,"StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data;  PlotOrientation orientation = plot.getOrientation(); -        if (orientation == PlotOrientation.HORIZONTAL) { -            drawHorizontalItem(g2, state, dataArea, plot, domainAxis, -                    rangeAxis, statData, row, column); -        } -        else if (orientation == PlotOrientation.VERTICAL) { -            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, -                    statData, row, column); -        } }  /** "
1,"// fix up the tree in more clever ways when these are removed. if (parent.getType() == Token.COMMA) { Node gramps = parent.getParent(); -      if (gramps.isCall() && parent == gramps.getFirstChild()) { -        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && ""eval"".equals(n.getNext().getString())) { -      return; -        } -    } - -    // This no-op statement was there so that JSDoc information could +      // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) -            return; -          else +            ; +        else break; } } "
1,"refMap = Maps.newHashMap(); for (Entry<Var, ReferenceCollection> entry : globalRefMap.entrySet()) { Var var = entry.getKey(); -      if (var.isGlobal()) { -        refMap.put(var.getName(), entry.getValue()); -      } } } "
0,"index 8d268b6..54eb5cf 100644 case Token.HOOK: { Preconditions.checkState(childCount == 3); int p = NodeUtil.precedence(type); -        Context rhsContext = Context.OTHER; +        Context rhsContext = getContextForNoInOperator(context); addExpr(first, p + 1, context); cc.addOp(""?"", true); addExpr(first.getNext(), 1, rhsContext);"
1,"} dec = null; } -        if (!Character.isDigit(lastChar) && lastChar != '.') { +        if ((!Character.isDigit(lastChar) && lastChar != '.') && (expPos < str.length() - 1)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { "
