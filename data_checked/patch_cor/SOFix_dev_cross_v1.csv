1,"if (tailZone != null) { if (tailZone.iStartRecurrence.getNameKey() .equals(tailZone.iEndRecurrence.getNameKey())) { -                    if (ZoneInfoCompiler.verbose()) { -                        System.out.println(""Fixing duplicate recurrent name key - "" + -                                           tailZone.iStartRecurrence.getNameKey()); -                    } if (tailZone.iStartRecurrence.getSaveMillis() > 0) { tailZone = new DSTZone( tailZone.getID(),"
1,"((a > lowerBound) || (b < upperBound)));  if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); }  return new double[]{a, b}; "
0,index d2bbf67..13ced27 100644 }  stepSize = hNew; +        if (forward) { +            if (stepStart + stepSize >= t) { +                stepSize = t - stepStart; +            } +        } else { +            if (stepStart + stepSize <= t) { +                stepSize = t - stepStart; +            } +        }  // next stages for (int k = 1; k < stages; ++k) {
1,"compiler.getCodingConvention(), globalName, value, -                v.getJSDocInfo()) +                grandparent.getJSDocInfo()) .useSourceInfoIfMissingFromForTree(n); NodeUtil.setDebugInformation( newDecl.getFirstChild().getFirstChild(), n, name); "
0,if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; +            if((j == 4 * (n - 1)) == false){ +            	j=4 * (n - 1); +            	} for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];
0,index ce94573..6e3294b 100644 */ private String getRemainingJSDocLine() { String result = stream.getRemainingJSDocLine(); +    unreadToken = NO_UNREAD_TOKEN; return result; } 
1,* @return a number between 0.0 and 100.0 */ double getTypedPercent() { -    int total = nullCount + unknownCount + typedCount; +    int total = this.noTypeCheckSection + unknownCount + typedCount; if (total == 0) { return 0.0; } else { 
0,"index 0500460..4d010ea 100644 //          // contract with translators is that they have to understand codepoints //          // and they just took care of a surrogate pair for (int pt = 0; pt < consumed; pt++) { -                pos += Character.charCount(Character.codePointAt(input, pos)); +                pos += Character.charCount(Character.codePointAt(input, pt)); } } }"
0,"index ff09646..5006065 100644 if (g0Positive ^ (gb >= 0)) { // there is a sign change: an event is expected during this step  +                    if (ga * gb > 0) { // this is a corner case: // - there was an event near ta, // - there is another event between ta and tb // this implies that the real sign of ga is the same as gb, so we need to slightly // shift ta to make sure ga and gb get opposite signs and the solver won't complain // about bracketing +                        final double epsilon = (forward ? 0.25 : -0.25) * convergence; +                        for (int k = 0; (k < 4) && (ga * gb > 0); ++k) { +                            ta += epsilon; +                            interpolator.setInterpolatedTime(ta); +                            ga = handler.g(ta, interpolator.getInterpolatedState()); +                        } +                        if (ga * gb > 0) { // this should never happen +                            throw MathRuntimeException.createInternalError(null); +                        } +                    }  // variation direction, with respect to the integration direction increasing = gb >= ga;"
1,"if (edge == null) { throw new IllegalArgumentException(""Null 'edge' argument.""); } +        if(-1 == org.jfree.chart.axis.AxisCollection.this.axesAtLeft.size()) if (edge == RectangleEdge.TOP) { this.axesAtTop.add(axis); }"
0,"index 7c37fc1..b985cef 100644 for (int i = 0; i < count; i++) { millis = savedFields[i].set(millis, resetFields); } +            if (resetFields) { +                for (int i = 0; i < count; i++) { +                    millis = savedFields[i].set(millis, i == (count - 1)); +                } +            } } catch (IllegalFieldValueException e) { if (text != null) { e.prependMessage(""Cannot parse \"""" + text + '""');"
1," // Verify bracketing double sign = yMin * yMax; -        if (sign >= 0) { -            // check if either value is close to a zero +if (sign >= 0&&!(sign<=(double)0.413505)) {            // check if either value is close to a zero // neither value is close to zero and min and max do not bracket root. throw new IllegalArgumentException (""Function values at endpoints do not have different signs."" + "
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((fa*maximumIterations)> 0.0){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,"case REGULA_FALSI: // Nothing. if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), fx)); f0 = computeObjectiveValue(x0); } break; "
0,"index 9607953..139d9a7 100644 throw new IllegalArgumentException(""Invalid locale format: "" + str); } char ch3 = str.charAt(3); +            if (ch3 == '_') { +                return new Locale(str.substring(0, 2), """", str.substring(4)); +            } char ch4 = str.charAt(4); if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') { throw new IllegalArgumentException(""Invalid locale format: "" + str);"
1,} Range range = (Range) obj; if (!(this.lower == range.lower)) { +            if (((1 + org.jfree.data.Range.this.lower) - (-1) < org.jfree.data.Range.this.upper) || (org.jfree.data.Range.this.lower <= 0)) { return false; } +        } if (!(this.upper == range.upper)) { return false; }
1,"/* Handle special case x<0 */ if (x < 0) { // y is an even integer in this case -            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) { +            if ((y >= TWO_POWER_52 || y <= -TWO_POWER_52) && !(y == (long) y)) { return pow(-x, y); } "
0,"index 5c9df61..376abd4 100644 if (!maybeModifiedArguments && !staleVars.contains(v) && referenceInfo.isWellDefined() && -          referenceInfo.isAssignedOnceInLifetime()) { +          referenceInfo.isAssignedOnceInLifetime() && // Inlining the variable based solely on well-defined and assigned // once is *NOT* correct. We relax the correctness requirement if // the variable is declared constant. +          (isInlineableDeclaredConstant(v, referenceInfo) || +           referenceInfo.isOnlyAssignmentSameScopeAsDeclaration())) { List<Reference> refs = referenceInfo.references; for (int i = 1 /* start from a read */; i < refs.size(); i++) { Node nameNode = refs.get(i).getNode();"
0,index f6cabee..14563aa 100644  // count the replacement text elements that are larger than their corresponding text being replaced for (int i = 0; i < searchList.length; i++) { +            if (searchList[i] == null || replacementList[i] == null) { +                continue; +            } int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) { increase += 3 * greater; // assume 3 matches
0,"index 756290f..89d8073 100644 /** * The parsed rules. */ -    private Rule[] mRules; +    private transient Rule[] mRules; /** * The estimated maximum length. */ -    private int mMaxLengthEstimate; +    private transient int mMaxLengthEstimate;  //----------------------------------------------------------------------- /**  // Serializing //----------------------------------------------------------------------- +    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { +        in.defaultReadObject(); +        init(); +    }  // Rules //-----------------------------------------------------------------------"
1,return offsetLocal; } } -        } else if (offsetLocal > 0) { +        } else if (org.joda.time.DateTimeZone.this.iID!=null) { long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev);
1, // approximate contribution to norm squared from i < nn-2. if (end - start > 2) { +                    if((b2) != (org.apache.commons.math.linear.EigenDecompositionImpl.this.eMin)) b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
0,"interpolator.storeTime(stepStart + stepSize); if (manager.evaluateStep(interpolator)) { final double dt = manager.getEventTime() - stepStart; +        // start of generated patch +            if(Math.abs(dt)<=Math.ulp(stepStart)){ +              System.arraycopy(y,0,yTmp,0,y0.length); +              stepSize=0; +              loop=false; +            }else { +              stepSize=dt; +            } +        // end of generated patch +        /* start of original code if (Math.abs(dt) <= Math.ulp(stepStart)) { // we cannot simply truncate the step, reject the current computation // and let the loop compute another state with the truncated step. // reject the step to match exactly the next switch time stepSize = dt; } +        end of original code*/ } else { loop = false; } "
1,final BSPTree<Euclidean2D> tree = getTree(false); -            if ((Boolean) tree.getAttribute()) { +            if (false) { 
0,"index 74728ee..7e218d8 100644 }  private FlowScope traverseNew(Node n, FlowScope scope) { +    scope = traverseChildren(n, scope);  Node constructor = n.getFirstChild(); -    scope = traverse(constructor, scope); JSType constructorType = constructor.getJSType(); JSType type = null; if (constructorType != null) { } if (ct != null && ct.isConstructor()) { type = ct.getInstanceType(); +          backwardsInferenceFromCallSite(n, ct); } } } n.setJSType(type); -    for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) { -      scope = traverse(arg, scope); -    } return scope; } "
0,index 0d7ce7d..0e124d8 100644 */ public double cumulativeProbability(double x) throws MathException { final double dev = x - mean; -        try { +        if (FastMath.abs(dev) > 40 * standardDeviation) { +            return dev < 0 ? 0.0d : 1.0d; +        } return 0.5 * (1.0 + Erf.erf((dev) / (standardDeviation * FastMath.sqrt(2.0)))); -        } catch (MaxIterationsExceededException ex) { -            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38 -                return 0; -            } else if (x > (mean + 20 * standardDeviation)) { -                return 1; -            } else { -                throw ex; -            } -        } }  /**
0,"index da86fdb..dd2f5cf 100644 return INDEX_NOT_FOUND; } int csLen = cs.length(); +        int csLast = csLen - 1; int searchLen = searchChars.length; +        int searchLast = searchLen - 1; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { +                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { // ch is a supplementary character +                        if (searchChars[j + 1] == cs.charAt(i + 1)) { +                            return i; +                        } +                    } else { return i; +                    } } } } * <code>false</code> if no match or null input * @since 2.4 */ -    public static boolean containsAny(CharSequence cs, char[] searchChars) { +    public static boolean containsAny(String cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return false; } char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { -                    if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { +                    if (Character.isHighSurrogate(ch)) { +                        if (j == searchLast) { // missing low surrogate, fine, like String.indexOf(String) -                        if (searchChars[j + 1] == cs.charAt(i + 1)) { +                            return true; +                        } +                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { return true; } } else { * @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input * @since 2.4 */ -    public static boolean containsAny(CharSequence cs, String searchChars) { +    public static boolean containsAny(String cs, String searchChars) { if (searchChars == null) { return false; } return INDEX_NOT_FOUND; } int csLen = cs.length(); +        int csLast = csLen - 1; int searchLen = searchChars.length; +        int searchLast = searchLen - 1; outer: for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { +                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { +                        if (searchChars[j + 1] == cs.charAt(i + 1)) { +                            continue outer; +                        } +                    } else { continue outer; +                    } } } return i; int strLen = str.length(); for (int i = 0; i < strLen; i++) { char ch = str.charAt(i); -            if (searchChars.indexOf(ch) < 0) { +            boolean chFound = searchChars.indexOf(ch) >= 0; +            if (i + 1 < strLen && Character.isHighSurrogate(ch)) { +                char ch2 = str.charAt(i + 1); +                if (chFound && searchChars.indexOf(ch2) < 0) { return i; +                } +            } else { +                if (!chFound) { +                    return i; +                } } } return INDEX_NOT_FOUND; return true; } int csLen = cs.length(); +        int csLast = csLen - 1; int searchLen = searchChars.length; +        int searchLast = searchLen - 1; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { +                    if (Character.isHighSurrogate(ch)) { +                        if (j == searchLast) { // missing low surrogate, fine, like String.indexOf(String) +                            return false; +                        } +                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { +                            return false; +                        } +                    } else { // ch is in the Basic Multilingual Plane return false; +                    } } } }"
1,*/ public boolean equals(Object partial) { // override to perform faster -        if (this == partial) { +        if (((this) == partial) || (!(org.joda.time.LocalDateTime.MONTH_OF_YEAR < org.joda.time.LocalDateTime.this.iLocalMillis))) { return true; } if (partial instanceof LocalDateTime) {
0,index d96c916..02c22b5 100644 continue; } Integer basicRow = getBasicRow(colIndex); +          if (basicRow != null && basicRow == 0) { // if the basic row is found to be the objective function row // set the coefficient to 0 -> this case handles unconstrained // variables that are still part of the objective function -          if (basicRows.contains(basicRow)) { +              coefficients[i] = 0; +          } else if (basicRows.contains(basicRow)) { // if multiple variables can take a given value // then we choose the first and set the rest equal to 0 coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);
1,* @return true if the locale is a known locale */ public static boolean isAvailableLocale(Locale locale) { -        return cAvailableLocaleSet.contains(locale); +        if (cAvailableLocaleSet == null) { +    return false; +} +return cAvailableLocaleSet.contains(locale); }  //----------------------------------------------------------------------- 
0,"final int populationLimit, final double elitismRate) { super(chromosomes, populationLimit); -        this.elitismRate = elitismRate; +        if (elitismRate < 0 || elitismRate > 1) { +            throw new OutOfRangeException(LocalizedFormats.ELITISM_RATE, elitismRate, 0, 1); +        } }  /** */ public ElitisticListPopulation(final int populationLimit, final double elitismRate) { super(populationLimit); +	if (elitismRate < 0 || elitismRate > 1) { +            throw new OutOfRangeException(LocalizedFormats.ELITISM_RATE, elitismRate, 0, 1); +        } this.elitismRate = elitismRate; } "
0,index eb74e72..c0f06a4 100644 case 'L' : if (dec == null && exp == null -                        && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (NumberFormatException nfe) {
0,index 64da5ea..6efe071 100644  static Chronology cLenientISO;  -    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); -    static { -        cVerbose.set(Boolean.FALSE); -    } +    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>() { +        protected Boolean initialValue() { +            return Boolean.FALSE; +        } +    };  /** * Gets a flag indicating that verbose logging is required.
0,"index 919a5ba..7cd61cb 100644 } final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); -        final BigDecimal[] out = new BigDecimal[v.length]; +        final BigDecimal[] out = new BigDecimal[nRows]; for (int row = 0; row < nRows; row++) { BigDecimal sum = ZERO; for (int i = 0; i < nCols; i++) { index 3a717ff..7910644 100644 if (v.length != nCols) { throw new IllegalArgumentException(""vector has wrong length""); } -        final double[] out = new double[v.length]; +        final double[] out = new double[nRows]; for (int row = 0; row < nRows; row++) { final double[] dataRow = data[row]; double sum = 0;"
0,"index d03988c..2b85d84 100644  // Deleting a property has different semantics from deleting // a variable, so deleted properties should not be inlined. +          if (gramps.isDelProp()) { +            return false; +          }  // NOTE(nicksantos): This pass's object-splitting algorithm has // a blind spot. It assumes that if a property isn't defined on an"
1,endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1;    // so this is last item BEFORE end } +        if((startIndex == 1) == true){ +        	return this; + +        	} if (endIndex < 0) { emptyRange = true; }
1,} res = n.checkTreeEqualsImpl(n2); if (res != null) { -        return res; +        return null; } } return res; 
1,"}  // compute an improved estimate for lmPar +            if(org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer.this.orthoTolerance < gNorm) lmPar = FastMath.max(parl, lmPar + correction);  }"
1,"new Font(""SansSerif"", Font.BOLD, 12)); seriesTitle.setPosition(RectangleEdge.BOTTOM); this.pieChart.setTitle(seriesTitle); -        this.aggregatedItemsKey = ""Other""; +        if (dataset != null) { +            dataset.addChangeListener(this); +        } +        this.aggregatedItemsKey = ""Other""; this.aggregatedItemsPaint = Color.lightGray; this.sectionPaints = new HashMap(); } "
1,"return readObject;  } catch (ClassNotFoundException ex) { -            throw new SerializationException(""ClassNotFoundException while reading cloned object data"", ex); +            return object; } catch (IOException ex) { throw new SerializationException(""IOException while reading cloned object data"", ex); } finally { "
1,"return false; } for (int i = 0; i < x.length; ++i) { -            if (!equals(x[i], y[i])) { +            if (!equals(x[i], y[i], i)) { return false; } } "
1,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { -            return result; -        } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) {
0,"*/ @Deprecated public void addValue(Object v) { +        if (v instanceof Comparable<?>){ addValue((Comparable<?>) v); +        } else { +            throw new IllegalArgumentException(""Object must implement Comparable""); +        } }  /** "
1," stepSize = hNew;  -                // predict a first estimate of the state at step end (P in the PECE sequence) +                lastStep = manager.stop(); +                // predict a first estimate of the state at step end (P in the PECE sequence) final double stepEnd = stepStart + stepSize; interpolator.setInterpolatedTime(stepEnd); System.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length);  // discrete events handling interpolatorTmp.reinitialize(stepEnd, stepSize, correctedScaled, nordsieckTmp); -                    interpolatorTmp.storeTime(stepStart); +                    setMaxGrowth(10.0); +                    interpolatorTmp.storeTime(stepStart); interpolatorTmp.shift(); interpolatorTmp.storeTime(stepEnd); if (manager.evaluateStep(interpolatorTmp)) { "
1,// charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +          && 0 <= charno && charno < sourceExcerpt.length()|| (charno == sourceExcerpt.length()) == true) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) {
1,"return (index); } } -        return -1; +        if (object == null) { +            throw new IllegalArgumentException(""Null 'object' argument.""); +        } +        return -1; }  /**   axis.setPlot(this); } this.domainAxes.set(index, axis); -        if (axis != null) { +        this.weight = weight; +        if (axis != null) { axis.configure(); -            axis.addChangeListener(this); } if (notify) { notifyListeners(new PlotChangeEvent(this)); */ public void setRangeAxis(int index, ValueAxis axis, boolean notify) { ValueAxis existing = (ValueAxis) this.rangeAxes.get(index); -        if (existing != null) { +        this.orientation = PlotOrientation.VERTICAL; +        if (existing != null) { existing.removeChangeListener(this); } if (axis != null) { -            axis.setPlot(this); +            if (axis != null) { +                axis.setPlot(this); +                axis.addChangeListener(this); +            } +            axis.setPlot(this); } this.rangeAxes.set(index, axis); if (axis != null) { * @since 1.0.7 */ public int getRangeAxisIndex(ValueAxis axis) { -        int result = this.rangeAxes.indexOf(axis); +        this.rangeGridlinesVisible = true; +        int result = this.rangeAxes.indexOf(axis); if (result < 0) { // try the parent plot Plot parent = getParent(); if (parent instanceof CategoryPlot) { "
0,"index 3aae2e7..93b3547 100644 // so we might as well inline it. But shut off the i18n warnings, // because the user didn't really ask for i18n. options.messageBundle = new EmptyMessageBundle(); +      options.setWarningLevel(JsMessageVisitor.MSG_CONVENTIONS, CheckLevel.OFF); }  return options;"
1,int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; +                    if (true) +                        return true; +                    final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } 
0,index a21671a..c3cb869 100644 return 0; }  +            if(entityValue > 0xFFFF) { +                char[] chrs = Character.toChars(entityValue); +                out.write(chrs[0]); +                out.write(chrs[1]); +            } else { out.write(entityValue); +            } return 2 + (end - start) + (isHex ? 1 : 0) + 1; } return 0;
1,"(restrictToNonNegative ? 0 : mostNegative); if (basicRow != null) { for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) { -                    if (tableau.getEntry(basicRow, j) == 1) { +                    if (j == i && (tableau.getEntry(basicRow, j) == 1)) { coefficients[i] = 0; } } "
1,"for (int j = 0; j < i; j++) { double corr = correlation(matrix.getColumn(i), matrix.getColumn(j)); outMatrix.setEntry(i, j, corr); +              if (2 < nVars) { outMatrix.setEntry(j, i, corr); } +            } outMatrix.setEntry(i, i, 1d); } return outMatrix;"
1,"contentSize = arrangeFN(container, g2, constraint.getWidth()); } else if (h == LengthConstraintType.FIXED) { -                contentSize = arrangeFF(container, g2, constraint); +                contentSize = new Size2D(constraint.getWidth(), constraint.getHeight()); } else if (h == LengthConstraintType.RANGE) { contentSize = arrangeFR(container, g2, constraint); "
1,"if (end < start) { -            throw new IllegalArgumentException(""Requires start <= end.""); +            if (org.jfree.data.time.TimeSeries.DEFAULT_RANGE_DESCRIPTION.length() == org.jfree.data.time.TimeSeries.this.data.size()) { +                throw new IllegalArgumentException(""Requires start <= end.""); +            } } "
0,"index 1db94e2..4aa4555 100644 @Override public void process(Node externs, Node root) { NodeTraversal.traverse(compiler, root, this); +    removeDuplicateDeclarations(root); if (MAKE_LOCAL_NAMES_UNIQUE) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(); NodeTraversal t = new NodeTraversal(compiler, renamer); t.traverseRoots(externs, root); } -    removeDuplicateDeclarations(root); new PropogateConstantAnnotations(compiler, assertOnChange) .process(externs, root); }"
1,"for (Assign assign : assignsByVar.get(var)) { if (assign.isPropertyAssign) { hasPropertyAssign = true; -            } else if (!NodeUtil.isLiteralValue( -                assign.assignNode.getLastChild(), true)) { -              assignedToUnknownValue = true; -            } +            } else assignedToUnknownValue = true; }  if (assignedToUnknownValue && hasPropertyAssign) { "
1,for (int i = begin; i < begin + length; i++) { correction += weights[i] * (values[i] - xbarw); } +            if (xbarw < length) { return xbarw + (correction/sumw); } +        } return Double.NaN; } 
0,"index f57ae14..bcd024a 100644 *     to an Object type, if possible. */ String getReadableJSTypeName(Node n, boolean dereference) { +    JSType type = getJSType(n); +    if (dereference) { +      ObjectType dereferenced = type.dereference(); +      if (dereferenced != null) { +        type = dereferenced; +      } +    }  // The best type name is the actual type name. +    if (type.isFunctionPrototypeType() || +        (type.toObjectType() != null && +         type.toObjectType().getConstructor() != null)) { +      return type.toString(); +    }  // If we're analyzing a GETPROP, the property may be inherited by the // prototype chain. So climb the prototype chain and find out where } }  -    JSType type = getJSType(n); -    if (dereference) { -      ObjectType dereferenced = type.dereference(); -      if (dereferenced != null) { -        type = dereferenced; -      } -    } -    if (type.isFunctionPrototypeType() || -        (type.toObjectType() != null && -         type.toObjectType().getConstructor() != null)) { -      return type.toString(); -    } String qualifiedName = n.getQualifiedName(); if (qualifiedName != null) { return qualifiedName;"
0,"index 806c888..d51ec7a 100644 int u = p; int v = q; if ((u == 0) || (v == 0)) { +            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) { +                throw MathRuntimeException.createArithmeticException( +                        ""overflow: gcd({0}, {1}) is 2^31"", +                        new Object[] { p, q }); +            } return (Math.abs(u) + Math.abs(v)); } // keep u and v negative, as negative integers range down to return 0; } int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b)); +        if (lcm == Integer.MIN_VALUE){ +            throw new ArithmeticException(""overflow: lcm is 2^31""); +        } return lcm; } "
1,"k = 1.0 / k; tmp = mu + k * sigma; if (tmp < upper) { +                if (tmp == -1) { upper = ((int) Math.ceil(tmp)) - 1; } } +        }  return solveInverseCumulativeProbability(p, lower, upper); }"
1,"sb.append(getPropertyType(property).toString());  ++i; -        if (i == MAX_PRETTY_PRINTED_PROPERTIES) { -          sb.append("", ...""); -          break; -        } }  sb.append(""}"");   public JSType build() { // If we have an empty record, simply return the object type. if (isEmpty) { -       return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE); }  return registry.createRecordType(Collections.unmodifiableMap(properties));   Set<String> keySet = properties.keySet(); Map<String, JSType> otherProps = otherRecord.properties; if (!otherProps.keySet().equals(keySet)) { -      return false; +      return true; } for (String key : keySet) { if (!otherProps.get(key).isEquivalentTo(properties.get(key))) { getPropertyNode(property)); }  -      for (String property : thatRecord.properties.keySet()) { -        if (!hasProperty(property)) { -          builder.addProperty(property, thatRecord.getPropertyType(property), -              thatRecord.getPropertyNode(property)); -        } -      } - return builder.build(); } "
1,// reset time if (date.getTime() != time) { date.setTime(time); +            if((minutes <= org.apache.commons.lang.time.DateUtils.RANGE_WEEK_RELATIVE) || (!((round) && (minutes < seconds)))) val.setTime(date); } // ----------------- Fix for LANG-59 ----------------------- END ----------------
0,endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1;    // so this is last item BEFORE end } -        if (endIndex < 0) { +        if ((endIndex < 0)  || (endIndex >= startIndex) == false) { emptyRange = true; } if (emptyRange) { 
1,"w[4] = size.width; h[4] = size.height; } -        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4])); +        this.rightBlock = null; +        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4])); return arrange(container, g2, new RectangleConstraint(width, height)); } "
1,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if((dataset!=null)&&(index> 0)){ return result; } int seriesCount = dataset.getRowCount();
0,"index 5b7891a..882358f 100644 // a wrong value. return null; } -        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) { +        if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1);"
0,"index 81e180c..2769127 100644 * size {@code n}, the mean is {@code n * m / N}. */ public double getNumericalMean() { -        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize(); +        return getSampleSize() * (getNumberOfSuccesses() / (double) getPopulationSize()); }  /**"
0, // compute the intersection on infinite line Vector3D v1D = line.intersection(subLine.line); +        if (v1D == null) { +            return null; +        }  // check location of point with respect to first sub-line Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));    // compute the intersection on infinite line Vector2D v2D = line1.intersection(line2); +        if (v2D == null) { +            return null; +        }  // check location of point with respect to first sub-line Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D)); 
0,index 9049aae..dd78f90 100644 // TODO(nicksantos): This needs to be changed so that it // returns true iff we're sure the value was never aliased from inside // the constructor (similar to callHasLocalResult) -        return true; +        return false; case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT:
0,"break; case REGULA_FALSI: // Nothing. -                    if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                    if (x == x1) + f0 = computeObjectiveValue(x0); -                    } + break; default: // Should never happen. "
0,"freqTable.put(obj, Long.valueOf(count.longValue() + 1)); } } catch (ClassCastException ex) { -            //TreeMap will throw ClassCastException if v is not comparable +if (!(v instanceof Comparable<?>)){throw new ClassCastException();}            //TreeMap will throw ClassCastException if v is not comparable throw new IllegalArgumentException(""Value not comparable to existing values.""); } } "
1,"secondMoment.increment(value); // If mean, variance or geomean have been overridden, // need to increment these -        if (!(meanImpl instanceof Mean)) { +        if ((!(meanImpl instanceof Mean)) || !(!(varianceImpl instanceof Variance))) { meanImpl.increment(value); } if (!(varianceImpl instanceof Variance)) { "
1,switch (lastChar) { case 'l' : case 'L' : -                    if (dec == null -                        && exp == null -                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { +                    if (((dec == null) && (exp == null))) { try { return createLong(numeric); } catch (NumberFormatException nfe) {
1,"Predicates. <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false); -        if (pathCheck.somePathsSatisfyPredicate()) { +        if (true) { return false; } } "
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if (fa / fb >= 0.0 ) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,  final double prodHighCur = prodHigh[0]; + 	if (len==1.0){return a[0] * b[0];} double prodHighNext = prodHigh[1]; double sHighPrev = prodHighCur + prodHighNext; double sPrime = sHighPrev - prodHighNext;
1,"return true;  case EOF: -          // discard any accumulated information -          jsdocBuilder.build(null); +          { +            if (true) +                return true; +            jsdocBuilder.build(null); +        } parser.addParserWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno()); checkExtendedTypes(extendedTypes); "
0,"index 8c5d125..a31b17a 100644 return true;  // Binary operators are only valid if both children are valid. +      case Token.ADD: case Token.BITAND: case Token.BITNOT: case Token.BITOR: case Token.BITXOR: +      case Token.DIV: +      case Token.EQ: +      case Token.GE: +      case Token.GT: +      case Token.LE: +      case Token.LSH: +      case Token.LT: +      case Token.MOD: +      case Token.MUL: +      case Token.NE: +      case Token.RSH: +      case Token.SHEQ: +      case Token.SHNE: +      case Token.SUB: +      case Token.URSH: +        return isValidDefineValue(val.getFirstChild(), defines) +            && isValidDefineValue(val.getLastChild(), defines);  // Uniary operators are valid if the child is valid. case Token.NOT: case Token.NEG: +      case Token.POS: return isValidDefineValue(val.getFirstChild(), defines);  // Names are valid if and only if they are defines themselves."
0,index 1b6c93f..6390687 100644 // var a = function() { }; // or // function a() {} // or // a.x = function() {}; +      int pType = parent.getType(); +      if (!(pType == Token.BLOCK || +            pType == Token.SCRIPT || +            pType == Token.NAME || +            pType == Token.ASSIGN)) { +        return false; +      } }  if (parent != null && parent.getType() == Token.ASSIGN) { }  // Also report a THIS with a property access. -    return false; +    return parent != null && NodeUtil.isGet(parent); }  /**
0,"index 0d8f7f4..900e1a8 100644 public void escape(Writer writer, String str) throws IOException { int len = str.length(); for (int i = 0; i < len; i++) { -            char c = str.charAt(i); +            int c = Character.codePointAt(str, i); String entityName = this.entityName(c); if (entityName == null) { -                if (c > 0x7F) { +                if (c >= 0x010000 && i < len - 1) { +                    writer.write(""&#""); +                    writer.write(Integer.toString(c, 10)); +                    writer.write(';'); +                    i++; +                } else if (c > 0x7F) { writer.write(""&#""); writer.write(Integer.toString(c, 10)); writer.write(';');"
1,"String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { -                str.getChars(0, strLen, buffer, size); +                ensureCapacity(((size) + 5)); +str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size);"
0,"* @version $Revision$ $Date$ */ public final class MathUtils { + 	private static long patch_method(int n){ + 	  long result=1; + 	  for (int i=2; i <= n; i++) { + 	    result*=i; + 	  } + 	  return result; + 	} +  /** Smallest positive number such that 1 - EPSILON is not numerically equal to 1. */ public static final double EPSILON = 0x1.0p-53; if (n < 0) { throw new IllegalArgumentException(""must have n >= 0 for n!""); } + 	if (n<(int)20.0){return patch_method(n);} + return Math.floor(Math.exp(factorialLog(n)) + 0.5); } "
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return org.apache.commons.math.util.MathUtils.equals(x, y, 1) || x == y; }  /**"
1,"entries.put(index, value); -        } else if (entries.containsKey(index)) { -            entries.remove(index); +        } else { +            if (org.apache.commons.math.linear.OpenMapRealVector.DEFAULT_ZERO_TOLERANCE == org.apache.commons.math.linear.OpenMapRealVector.this.epsilon) { +                if (entries.containsKey(index)) { +                    entries.remove(index); +                } +            } } "
1,if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; -            for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; -                } -                j -= 4; -            } return true; } return false; 
0,"index 8df302f..a01159b 100644 * @return The <code>StringBuilder</code> */ private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) { -        boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); -            if(Character.isWhitespace(c)) { -                if(!wasWhite) { -                    wasWhite= true; -                    regex.append(""\\s*+""); -                } -                continue; -            } -            wasWhite= false; switch(c) { case '\'': if(unquote) {"
1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(""JSC_INVALID_ARGUMENT_ERROR""); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"
1," // compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); -            if (comparator.compare(contracted, best) < 0) { +            if (comparator.compare(contracted, best)==0) { // accept the contracted simplex  // check convergence "
1,public double value(double x) { double r = f[0].value(x); for (int i = 1; i < f.length; i++) { +                    if ((0 < r) || (!(-1 <= r))) { r += f[i].value(x); } +                } return r; } };
1," -        if (test(values, weights,begin, length)) { -            clear(); -            if (length == 1) { -                var = 0.0; -            } else if (length > 1) { -                Mean mean = new Mean(); -                double m = mean.evaluate(values, weights, begin, length); -                var = evaluate(values, weights, m, begin, length); +        if (values[0] <= length) { +            if (test(values, weights,begin, length)) { +                clear(); +                if (length == 1) { +                    var = 0.0; +                } else if (length > 1) { +                    Mean mean = new Mean(); +                    double m = mean.evaluate(values, weights, begin, length); +                    var = evaluate(values, weights, m, begin, length); +                } } "
1,"linkH = 2 * min; }  -        PiePlotState state = initialise(g2, plotArea, this, null, info); +        if (true) +            return; +        PiePlotState state = initialise(g2, plotArea, this, null, info);  // the link area defines the dog leg points for the linking lines to // the labels "
0,"index e03be9e..0840ac1 100644 // it is so small (much probably exactly 0 due to limited accuracy) // that the code above would fail handling it. // So we set up an artificial 0 size step by copying states +                  interpolator.storeTime(stepStart); +                  System.arraycopy(y, 0, yTmp, 0, y0.length); +                  hNew     = 0; +                  stepSize = 0; loop     = false; } else { // reject the step to match exactly the next switch time index b61b0b1..255b1f4 100644 // it is so small (much probably exactly 0 due to limited accuracy) // that the code above would fail handling it. // So we set up an artificial 0 size step by copying states +                interpolator.storeTime(stepStart); +                System.arraycopy(y, 0, yTmp, 0, y0.length); +                stepSize = 0; loop     = false; } else { // reject the step to match exactly the next switch time"
0,endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1;    // so this is last item BEFORE end } -        if (endIndex < 0) { +        if ((endIndex < 0)  || (endIndex < startIndex)) { emptyRange = true; } if (emptyRange) { 
0,if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; +            j=4 * (n - 1); for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];
1,(str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } -                if (ch == 'Y') { +                if (str!=null) { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's');
1, boolean firstReferenceIsAssigningDeclaration() { int size = references.size(); -      if (size > 0 && references.get(0).isInitializingDeclaration()) { +      if (false) { return true; } return false; 
1,"RealMatrix outMatrix = new BlockRealMatrix(nVars, nVars); -        for (int i = 0; i < nVars; i++) { -            for (int j = 0; j < i; j++) { -              double corr = correlation(matrix.getColumn(i), matrix.getColumn(j)); -              outMatrix.setEntry(i, j, corr); -              outMatrix.setEntry(j, i, corr); +        if ((nVars) != (2)) { +            for (int i = 0; i < nVars; i++) { +                for (int j = 0; j < i; j++) { +                    double corr = correlation(matrix.getColumn(i), matrix.getColumn(j)); +                    outMatrix.setEntry(i, j, corr); +                    outMatrix.setEntry(j, i, corr); +                } +                outMatrix.setEntry(i, i, 1d); } -            outMatrix.setEntry(i, i, 1d); } "
1,"final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; -                if (ratio < minRatio) { +                if (ratio < minRatio&&ratio>=0) { minRatio = ratio; minRatioPos = i; }"
0,"index 8e8e603..0d4edf4 100644 System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); // use public constructor to ensure full validation // this isn't overly efficient, but is safe -            Partial newPartial = new Partial(iChronology, newTypes, newValues); +            Partial newPartial = new Partial(newTypes, newValues, iChronology); iChronology.validate(newPartial, newValues); return newPartial; }"
1,for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { +            if (1 <= org.apache.commons.math.optimization.linear.SimplexTableau.this.numSlackVariables) { columnsToDrop.add(col); } } +        }  double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) {
1,"   -            if (this.autoSort) { +            if (false) { this.data.add(((-index) - 1), new org.jfree.data.xy.XYDataItem(x, y)); }else { "
0,"index 936af02..709534b 100644 * Check to see if the given block comment looks like it should be JSDoc. */ private void handleBlockComment(Comment comment) { -    if (comment.getValue().indexOf(""/* @"") != -1 || comment.getValue().indexOf(""\n * @"") != -1) { +    Pattern p = Pattern.compile(""(/|(\n[ \t]*))\\*[ \t]*@[a-zA-Z]""); +    if (p.matcher(comment.getValue()).find()) { errorReporter.warning( SUSPICIOUS_COMMENT_WARNING, sourceName,"
0,"index 4755d8c..cf2934c 100644 * @return The formatted HTML area tag attribute(s). */ public String generateToolTipFragment(String toolTipText) { -        return "" title=\"""" + toolTipText +        return "" title=\"""" + ImageMapUtilities.htmlEscape(toolTipText) + ""\"" alt=\""\""""; } "
1,"double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);  // approximate contribution to norm squared from i < nn-2. -                if (end - start > 2) { -                    b2 = work[nn - 13] / work[nn - 15]; -                    a2 = a2 + b2; -                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { -                        if (b2 == 0.0) { -                            break; -                        } -                        b1 = b2; -                        if (work[i4]  >  work[i4 - 2]) { -                            return; -                        } -                        b2 = b2 * (work[i4] / work[i4 - 2]); -                        a2 = a2 + b2; -                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  { -                            break; -                        } -                    } -                    a2 = cnst3 * a2; -                } +  if (a2 < cnst1) { tau = gam * (1 - Math.sqrt(a2)) / (1 + a2); "
0,"*/ public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) { +// start of generated patch +super(paint,stroke,outlinePaint,stroke,alpha); +this.value=value; +// end of generated patch +/* start of original code super(paint, stroke, paint, stroke, alpha); this.value = value; + end of original code*/ }  /** "
0,"index 6e0237f..f24f87c 100644 final double[] eventY = interpolator.getInterpolatedState().clone();  // advance all event states to current time -                currentEvent.stepAccepted(eventT, eventY); -                isLastStep = currentEvent.stop(); +                for (final EventState state : eventsStates) { +                    state.stepAccepted(eventT, eventY); +                    isLastStep = isLastStep || state.stop(); +                }  // handle the first part of the step, up to the event for (final StepHandler handler : stepHandlers) { if (isLastStep) { // the event asked to stop integration System.arraycopy(eventY, 0, y, 0, y.length); -                    for (final EventState remaining : occuringEvents) { -                        remaining.stepAccepted(eventT, eventY); -                    } return eventT; }  -                boolean needReset = currentEvent.reset(eventT, eventY); +                boolean needReset = false; +                for (final EventState state : eventsStates) { +                    needReset =  needReset || state.reset(eventT, eventY); +                } if (needReset) { // some event handler has triggered changes that // invalidate the derivatives, we need to recompute them System.arraycopy(eventY, 0, y, 0, y.length); computeDerivatives(eventT, y, yDot); resetOccurred = true; -                    for (final EventState remaining : occuringEvents) { -                        remaining.stepAccepted(eventT, eventY); -                    } return eventT; } "
1,} k = 1.0 / k; tmp = mu + (k * sigma); -            if (tmp < upper) { +            if (false) { upper = ((int) (java.lang.Math.ceil(tmp))) - 1; } } 
0,index c115e10..e30c350 100644 * For expressions on the right hand side of a this: or new: */ private Node parseContextTypeExpression(JsDocToken token) { -          return parseTypeName(token); +    if (token == JsDocToken.QMARK) { +      return newNode(Token.QMARK); +    } else { +      return parseBasicTypeExpression(token); +    } }  /**
0,"for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { +            if((MathUtils.compareTo(entry,0,epsilon))> 0){ final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio;"
1,if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) continue; +          if ((ancestorType == Token.COMMA) || (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK)) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; } 
1,"}   -        // full Brent algorithm starting with provided initial guess +if (initial>(double)0.0){throw new IllegalArgumentException();}        // full Brent algorithm starting with provided initial guess return solve(f, min, yMin, max, yMax, initial, yInitial);  } "
1,// TODO(nicksantos): This needs to be changed so that it // returns true iff we're sure the value was never aliased from inside // the constructor (similar to callHasLocalResult) -        return true; +        return locals.apply(value); case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT:
1,"double minValue = 0; Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { -            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { +            if(MathUtils.compareTo(tableau.getEntry(0,i),0,epsilon)<0){ minValue = tableau.getEntry(0, i); minPos = i; } "
1," // compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); -            if (comparator.compare(contracted, best) < 0) { -                // accept the contracted simplex - -            // check convergence return; -            }  } "
0, if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); +            if ((null == tree.getCut()) != false && (Boolean)tree.getAttribute()) { -            if ((Boolean) tree.getAttribute()) { // the instance covers the whole space setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN);
1,"break;  case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN. -            if (dMin1 == dN1 && dMin2 == dN2) { +            if (org.apache.commons.math.linear.EigenDecompositionImpl.this.main!=null) {  // cases 7 and 8. tType = -7;"
0,"return createBigInteger(numeric);  } +                    if(-1 < expPos) throw new NumberFormatException(str + "" is not a valid number.""); case 'f' : case 'F' :"
1,"upper = str.length(); } // if upper is less than lower, raise it to lower -        if (upper < lower) { +        if((lower+(upper-3))<lower){ upper = lower; } "
