1,"entries.put(index, value); -        } else if (entries.containsKey(index)) { -            entries.remove(index); +        } else { +            if (this.DEFAULT_ZERO_TOLERANCE == this.epsilon) { +                if (entries.containsKey(index)) { +                    entries.remove(index); +                } +            } } "
1,"if (lower > upper) { String msg = ""Range(double, double): require lower ("" + lower + "") <= upper ("" + upper + "").""; -            throw new IllegalArgumentException(msg); + } this.lower = lower; this.upper = upper; "
1,* @since 1.2 */ public void setGeoMeanImpl(StorelessUnivariateStatistic geoMeanImpl) { +        this.sumImpl=geoMeanImpl; checkEmpty(); this.geoMeanImpl = geoMeanImpl; } 
1,case 'L' : -                    if (dec == null +                    if ((1) != (val.length())) { +                        if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { -                        try { -                            return createLong(numeric); -                        } catch (NumberFormatException nfe) { -                            //Too big for a long +                            try { +                                return createLong(numeric); +                            } catch (NumberFormatException nfe) { +                                //Too big for a long +                            } +                            return createBigInteger(numeric); + } -                        return createBigInteger(numeric); - } 
1,// Inverse quadratic interpolation. double r1 = y0 / y2; double r2 = y1 / y2; -                    p = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0)); +                    p = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r1 - 1.0)); p1 = (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0); } if (p > 0.0) { 
1,"*/ public Complex add(Complex rhs) throws NullArgumentException { +        if ((isNaN) || (rhs.isNaN)) {    return org.apache.commons.math.complex.Complex.NaN;} MathUtils.checkNotNull(rhs); return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }"
0,index cadb536..144a4ad 100644 int length = s.length();  if (length == 0 || +          Character.isIdentifierIgnorable(s.charAt(0)) || !Character.isJavaIdentifierStart(s.charAt(0))) { return false; }  for (int i = 1; i < length; i++) { -        if ( +        if (Character.isIdentifierIgnorable(s.charAt(i)) || !Character.isJavaIdentifierPart(s.charAt(i))) { return false; }
1,double d = getDenominatorDegreesOfFreedom(); // use mean ret = d / (d - 2.0); -        return ret; +        return d; }  /** 
1,// reset time if (date.getTime() != time) { date.setTime(time); +            if((minutes <= org.apache.commons.lang.time.DateUtils.RANGE_WEEK_RELATIVE) || (!((round) && (minutes < seconds)))) val.setTime(date); } // ----------------- Fix for LANG-59 ----------------------- END ----------------
0,"for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { + 	if (MathUtils.compareTo(entry, 0, epsilon) >= 0&&!(MathUtils.compareTo(entry, 0, epsilon)==0.0)) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } + } return minRatioPos; }"
0,"// x--4 (which is a syntax error). char prev = getLastChar(); boolean negativeZero = isNegativeZero(x); -    if (x < 0 && prev == '-') { +    if (x <= 0 && prev == '-') { add("" ""); } "
0,"index d4f98ec..7b22e21 100644 * @return String with escaped values, <code>null</code> if null string input */ public static String escapeJava(String str) { -        return escapeJavaStyleString(str, false); +        return escapeJavaStyleString(str, false, false); }  /** * @throws IOException if error occurs on underlying Writer */ public static void escapeJava(Writer out, String str) throws IOException { -        escapeJavaStyleString(out, str, false); +        escapeJavaStyleString(out, str, false, false); }  /** * @return String with escaped values, <code>null</code> if null string input */ public static String escapeJavaScript(String str) { -        return escapeJavaStyleString(str, true); +        return escapeJavaStyleString(str, true, true); }  /** * @throws IOException if error occurs on underlying Writer **/ public static void escapeJavaScript(Writer out, String str) throws IOException { -        escapeJavaStyleString(out, str, true); +        escapeJavaStyleString(out, str, true, true); }  /** * @param escapeForwardSlash TODO * @return the escaped string */ -    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) { +    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes, boolean escapeForwardSlash) { if (str == null) { return null; } try { StringWriter writer = new StringWriter(str.length() * 2); -            escapeJavaStyleString(writer, str, escapeSingleQuotes); +            escapeJavaStyleString(writer, str, escapeSingleQuotes, escapeForwardSlash); return writer.toString(); } catch (IOException ioe) { // this should never ever happen while writing to a StringWriter * @param escapeForwardSlash TODO * @throws IOException if an IOException occurs */ -    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException { +    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote, +            boolean escapeForwardSlash) throws IOException { if (out == null) { throw new IllegalArgumentException(""The Writer must not be null""); } out.write('\\'); break; case '/' : +                        if (escapeForwardSlash) { out.write('\\'); +                        } out.write('/'); break; default :"
1,"child.getLastChild()); break; case Token.GETPROP: -              maybeCollectMember(child, child, null); +              { +                if (true) +                    return; +                maybeCollectMember(child, child, null); +            } break; } } "
0,"if (fnParam != null) { if (cArg != null) { if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { -            return CanInlineResult.NO; } // Check for arguments that are evaluated more than once. // Note: Unlike block inlining, there it is not possible that a "
1,"public Number getMeanValue(int row, int column) { Number result = null; MeanAndStandardDeviation masd -            = (MeanAndStandardDeviation) this.data.getObject(row, column); +            = (MeanAndStandardDeviation) this.data.getObject((int)this.minimumRangeValue, column); if (masd != null) { result = masd.getMean(); } "
1,"boolean checkUnionEquivalenceHelper( UnionType that, boolean tolerateUnknowns) { if (!tolerateUnknowns && alternates.size() != that.alternates.size()) { -      return false; +      return true; } for (JSType alternate : that.alternates) { if (!hasAlternate(alternate, tolerateUnknowns)) { "
1,Node lastArg; while ((lastArg = argList.getLastChild()) != null) { Var var = fnScope.getVar(lastArg.getString()); -        if (!referenced.contains(var)) { +        if (false) { argList.removeChild(lastArg); compiler.reportCodeChange(); } else { 
1,"int endValue = end.get(field); int startValue = start.get(field); if (endValue < startValue) { -            int newdiff = startValue - endValue; +            int newdiff = difference - endValue; end.add( field, newdiff ); return newdiff; } else { "
0,"index 8c5d125..a31b17a 100644 return true;  // Binary operators are only valid if both children are valid. +      case Token.ADD: case Token.BITAND: case Token.BITNOT: case Token.BITOR: case Token.BITXOR: +      case Token.DIV: +      case Token.EQ: +      case Token.GE: +      case Token.GT: +      case Token.LE: +      case Token.LSH: +      case Token.LT: +      case Token.MOD: +      case Token.MUL: +      case Token.NE: +      case Token.RSH: +      case Token.SHEQ: +      case Token.SHNE: +      case Token.SUB: +      case Token.URSH: +        return isValidDefineValue(val.getFirstChild(), defines) +            && isValidDefineValue(val.getLastChild(), defines);  // Uniary operators are valid if the child is valid. case Token.NOT: case Token.NEG: +      case Token.POS: return isValidDefineValue(val.getFirstChild(), defines);  // Names are valid if and only if they are defines themselves."
1,"if (start < 0) { throw new IllegalArgumentException(""Requires start >= 0.""); } -        if (end < start) { +        if ((end < start) && (this.data.size() > 0)) { throw new IllegalArgumentException(""Requires start <= end.""); } TimeSeries copy = (TimeSeries) super.clone(); "
0,"index b0d114e..0ab790c 100644 private Integer getBasicRow(final int col) { Integer row = null; for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) { -            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) { -                if (row == null) { +            if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) { row = i; -                } else { +            } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) { return null; -                } } } return row;"
0,"index f1f36a8..fd03ab8 100644 if (decPos > -1) {  if (expPos > -1) { -                if (expPos < decPos) { +                if (expPos < decPos || expPos > str.length()) { throw new NumberFormatException(str + "" is not a valid number.""); } dec = str.substring(decPos + 1, expPos); mant = str.substring(0, decPos); } else { if (expPos > -1) { +                if (expPos > str.length()) { +                    throw new NumberFormatException(str + "" is not a valid number.""); +                } mant = str.substring(0, expPos); } else { mant = str;"
1,"if (info != null) { plotInfo = info.getPlotInfo(); } -        this.plot.draw(g2, plotArea, anchor, null, plotInfo); +        fireChartChanged();  g2.setClip(savedClip); "
0,index 0e9c4d3..639318d 100644 isSet = true; type = Name.Type.FUNCTION; break; +              case Token.CATCH: case Token.INC: case Token.DEC: isSet = true;
1,if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); -            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() +            long e = getDataItem(this.maxStartIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { 
0,"index 8e8e603..0d4edf4 100644 System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); // use public constructor to ensure full validation // this isn't overly efficient, but is safe -            Partial newPartial = new Partial(iChronology, newTypes, newValues); +            Partial newPartial = new Partial(newTypes, newValues, iChronology); iChronology.validate(newPartial, newValues); return newPartial; }"
0,"index 12ce5b3..8cdb02a 100644 JSType leftType, Node owner, String propName) { // The NoType check is a hack to make typedefs work OK. if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) { -      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) { -        registerMismatch(rightType, leftType, null); -      } else { // Do not type-check interface methods, because we expect that // they will have dummy implementations that do not match the type // annotations. ""assignment to property "" + propName + "" of "" + getReadableJSTypeName(owner, true), rightType, leftType); -      } return false; } return true; boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) { if (!rightType.canAssignTo(leftType)) { -      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) { -        registerMismatch(rightType, leftType, null); -      } else { mismatch(t, n, msg, rightType, leftType); -      } return false; } return true;"
1,int np; if (dMin == dN) { gam = dN; -                        a2 = 0.0; if (work[nn - 5]  >  work[nn - 7]) { return; }
0,// procedure cannot produce sensible results.  a = FastMath.sqrt(c1 / c2); -                omega = FastMath.sqrt(c2 / c3); +if (c2==0.0){throw new MathIllegalStateException();}                omega = FastMath.sqrt(c2 / c3); } } 
1,"((a > lowerBound) || (b < upperBound)));  if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); + + + + + + }  return new double[]{ a, b }; "
1,"for (Assign assign : assignsByVar.get(var)) { if (assign.isPropertyAssign) { hasPropertyAssign = true; -            } else if (!NodeUtil.isLiteralValue( -                assign.assignNode.getLastChild(), true)) { +            } else if (true) { assignedToUnknownValue = true; } } "
1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(""JSC_NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR""); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"
1," }  -        /** -         * Overriden version that uses the parametrized <code>ClassLoader</code> or the <code>ClassLoader</code> -         * of the current <code>Thread</code> to resolve the class. -         * @param desc An instance of class <code>ObjectStreamClass</code>. -         * @return A <code>Class</code> object corresponding to <code>desc</code>. -         * @throws IOException Any of the usual Input/Output exceptions. -         * @throws ClassNotFoundException If class of a serialized object cannot be found. -         */ -        @Override -        protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException { -            String name = desc.getName(); -            try { -                return Class.forName(name, false, classLoader); -            } catch (ClassNotFoundException ex) { -                    return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); -            } -        } +  } "
1, // x- if (!restrictToNonNegative) { +                        if((1) != (org.apache.commons.math.optimization.linear.SimplexTableau.this.numSlackVariables)) matrix[row][getSlackVariableOffset() - 1] = getInvertedCoeffiecientSum(constraint.getCoefficients()); }
0,*/ @Deprecated public void addValue(Object v) { +if (!(v instanceof Comparable<?>)){throw new IllegalArgumentException();} addValue((Comparable<?>) v); } 
0,index 9049aae..dd78f90 100644 // TODO(nicksantos): This needs to be changed so that it // returns true iff we're sure the value was never aliased from inside // the constructor (similar to callHasLocalResult) -        return true; +        return false; case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT:
0,"index 5ee9108..d67dc10 100644 // Adjust the line/column here to be start at 1. Builder x = OriginalMapping.newBuilder() .setOriginalFile(sources[entry.getSourceFileId()]) -        .setLineNumber(entry.getSourceLine()) -        .setColumnPosition(entry.getSourceColumn()); +        .setLineNumber(entry.getSourceLine() + 1) +        .setColumnPosition(entry.getSourceColumn() + 1); if (entry.getNameId() != UNMAPPED) { x.setIdentifier(names[entry.getNameId()]); } index 7192408..835dfa4 100644 // zero based. // We don't change this for the v1 or v2 source maps but for // v3 we make them both 0 based. +    int lineBaseOffset = 1; +    if (generator instanceof SourceMapGeneratorV1 +        || generator instanceof SourceMapGeneratorV2) { +      lineBaseOffset = 0; +    }  generator.addMapping( sourceFile, originalName, -        new FilePosition(node.getLineno(), node.getCharno()), +        new FilePosition(node.getLineno() - lineBaseOffset, node.getCharno()), outputStartPosition, outputEndPosition); } "
0,"break; case REGULA_FALSI: // Nothing. +                    if(!((x == 1) || ((1 < x) && (inverted)))) if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0);"
1," // evaluate 3 hours before and after to work out if anything is happening long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR); -        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR); +        long instantAfter = getOffset(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR); if (instantBefore == instantAfter) { return instant;  // not an overlap (less than is a gap, equal is normal case) } "
0,"index c998d1e..d6c194a 100644 // JavaScript handles zero shifts on signed numbers differently than // Java as an Java int can not represent the unsigned 32-bit number // where JavaScript can so use a long here. -          result = lvalInt >>> rvalInt; +          long lvalLong = lvalInt & 0xffffffffL; +          result = lvalLong >>> rvalInt; break; default: throw new AssertionError(""Unknown shift operator: "" +"
0,index 420dbc0..5a4f884 100644 // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +          && 0 <= charno && charno <= sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) {
1,"Vector3D k     = v1Su1.crossProduct(v2Su2); Vector3D u3    = u1.crossProduct(u2); double c       = k.dotProduct(u3); -  if (c == 0) { +  if (c <= 0) { // the (q1, q2, q3) vector is close to the (u1, u2) plane // we try other vectors Vector3D v3 = Vector3D.crossProduct(v1, v2); "
0,"index 8bc7bda..efaba2c 100644 if (info.isConstant()) { JSType knownType = null; if (rValue != null) { -              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) { +              JSDocInfo rValueInfo = rValue.getJSDocInfo(); +              if (rValueInfo != null && rValueInfo.hasType()) { // If rValue has a type-cast, we use the type in the type-cast. +                return rValueInfo.getType().evaluate(scope, typeRegistry); +              } else if (rValue.getJSType() != null +                  && !rValue.getJSType().isUnknownType()) { // If rValue's type was already computed during scope creation, // then we can safely use that. return rValue.getJSType();"
0,"index c46ee7d..a77221a 100644 reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler); reachingUses.analyze(); for (Candidate c : candidates) { -      if (c.canInline()) { +      if (c.canInline(t.getScope())) { c.inlineVariable();  // If definition c has dependencies, then inlining it may have return defMetadata.node; }  -    private boolean canInline() { +    private boolean canInline(final Scope scope) { // Cannot inline a parameter. if (getDefCfgNode().isFunction()) { return false; case Token.REGEXP: case Token.NEW: return true; +                  case Token.NAME: +                    Var var = scope.getOwnSlot(input.getString()); +                    if (var != null +                        && var.getParentNode().isCatch()) { +                      return true; +                    } } return false; }"
1," final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);  -        for (int i = 0; i < sampleSize; i++) { +        for(int i=sampleSize;i<sampleSize;i++){ out[i] = sample(); } "
1, // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. -      if (n == parent.getLastChild()) { +      if (gramps == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) 
1,int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; +                    if (true) +                        return true; +                    final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } 
0,index 7a0313c..f777b1c 100644  Node current = left.getFirstChild(); Node elem = null; -    for (int i = 0; current != null && i < intIndex; i++) { +    for (int i = 0; current != null; i++) { +      if (i != intIndex) { +        if (mayHaveSideEffects(current)) { +          return n; +        } +      } else { elem = current; +      }  current = current.getNext(); }
0,"index 65694ab..76a5d0a 100644 * Constants (true, false, null) are considered basically free, * because it's likely that they will get folded when we're done. */ +    @Override +    void addConstant(String newcode) { +      add(""0""); +    } } }"
1,"* @since 1.0.10 */ public XYDataItem addOrUpdate(double x, double y) { -        return addOrUpdate(new Double(x), new Double(y)); +        return addOrUpdate(new Double(y), new Double(y)); }  /** "
1,// can't have an E at the last byte return false; } -            if (chars[i] == '.') { +            if ((chars[i] == '.') || (chars[i] == 'l' +                || chars[i] == 'L')) { if (hasDecPoint || hasExp) { // two decimal points or dec in exponent return false; 
1,"((a > lowerBound) || (b < upperBound)));  if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); + }  return new double[]{a, b}; "
1," final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);  -        for (int i = 0; i < sampleSize; i++) { +        for (int i = 0; i==sampleSize; i++) { out[i] = sample(); } "
1,"break; case REGULA_FALSI: // Nothing. -                    if (x == x1) { +                    if(x==x0){ x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } "
0,* @return chromosome iterator */ public Iterator<Chromosome> iterator() { -        return chromosomes.iterator(); +        return getChromosomes().iterator(); } }
1,"/* Handle special case x<0 */ if (x < 0) { // y is an even integer in this case -            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) { +            if ((y >= TWO_POWER_52 || y <= -TWO_POWER_52) && !(y < 8e298 && y > -8e298)) { return pow(-x, y); } "
1,// TODO(nicksantos): This needs to be changed so that it // returns true iff we're sure the value was never aliased from inside // the constructor (similar to callHasLocalResult) -        return true; +        return NodeUtil.isToStringMethodCall(value); case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT:
1,"case REGULA_FALSI: // Nothing. if (x == x1) { +                    	if(!((f0 > x0 + x1) == true)){ x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                    	} f0 = computeObjectiveValue(x0); } break;"
1,"if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); +                if ((2) != (org.apache.commons.math3.optimization.linear.SimplexTableau.this.numArtificialVariables)) { +                    columnsToDrop.add(i); +                } } "
0,"break; case REGULA_FALSI: // Nothing. -                    if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                    if (x == x1) + f0 = computeObjectiveValue(x0); -                    } + break; default: // Should never happen. "
1,} case 3: { char ch = str.charAt(0); +                if((ch == 'y') == false){ +                	return ch == 'Y'; + +                	} if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&
1,k = 1.0 / k; tmp = mu + k * sigma; if (tmp < upper) { -                upper = ((int) Math.ceil(tmp)) - 1; } }    this.membershipMatrix = null; this.points = null; -        this.clusters = null; +        boolean emptyCluster = false; +        this.clusters = null; }  /** 
1,} }  -    if (s.length() > 3 -        && (s.charAt(0) == '-' || s.charAt(0) == '+') -        && s.charAt(1) == '0' -        && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) { +    if (true) { // hex numbers with explicit signs vary between browsers. return null; } 
1,return EMPTY; }  -        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); +        StringBuilder buf = new StringBuilder(256);  for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { return EMPTY; }  -        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length()); +        StringBuilder buf = new StringBuilder(256);  for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { 
0,"index 7c9a28f..674c4aa 100644 * @return a new instance, with reversed direction */ public Line revert() { -        final Line reverted = new Line(zero, zero.subtract(direction)); +        final Line reverted = new Line(this); +        reverted.direction = reverted.direction.negate(); return reverted; } "
1,String line = stream.getRemainingJSDocLine(); line = trimEnd(line); builder.append(line); +          jsdocBuilder.recordDescription(line); token = next(); } } while (true); 
0,"if (str == null) { return null; } -        if (StringUtils.isBlank(str)) { +        if ((StringUtils.isBlank(str)) || (str.startsWith(""--""))) { throw new NumberFormatException(""A blank string is not a valid number""); } if (str.startsWith(""--"")) { "
1,"public EventListenerSupport(Class<L> listenerInterface, ClassLoader classLoader) { this(); Validate.notNull(listenerInterface, ""Listener interface cannot be null.""); -        Validate.notNull(classLoader, ""ClassLoader cannot be null.""); +        Validate.notNull(listenerInterface, ""Listener interface cannot be null.""); Validate.isTrue(listenerInterface.isInterface(), ""Class {0} is not an interface"", listenerInterface.getName()); initializeTransientFields(listenerInterface, classLoader); * @param classLoader the class loader to be used */ private void createProxy(Class<L> listenerInterface, ClassLoader classLoader) { -        proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader, +        Validate.isTrue(listenerInterface.isInterface(), ""Class {0} is not an interface"", listenerInterface.getName()); +        proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader, new Class[] { listenerInterface }, createInvocationHandler())); }   throw new NumberFormatException(""A blank string is not a valid number""); } if (str.startsWith(""--"")) { -            return null; } if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) { int hexDigits = str.length() - 2; // drop 0x "
1,"private static int greatestCommonDivisor(int u, int v) { // From Commons Math: //if either operand is abs 1, return 1: -        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) { +        if (Math.abs(v) <= 1) { return 1; } // keep u and v negative, as negative integers range down to "
1,"work[l - 2 * pingPong] = Math.min(work[l - 2 * pingPong], Math.min(work[6 + pingPong], work[6 + pingPong])); -                qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong])); +                dMin = 0.0; dMin  = -0.0; } } } else { // early failure. Divide by 4. tau *= 0.25; -                        tType -= 12; +                        tType = -8; } } else if (Double.isNaN(dMin)) { tau = 0.0; // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; -                } j -= 4; } return true; "
1,"rule = new TextField(Calendar.ERA, ERAs); break; case 'y': // year (number) -                if (tokenLen >= 4) { +                if ((tokenLen >= 4) || !(tokenLen == 2)) { rule = selectNumberRule(Calendar.YEAR, tokenLen); } else { rule = TwoDigitYearField.INSTANCE; "
1,double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; -                if (work[np - 8] > b2 || work[np - 4] > b1) { +                if (true) { return; } double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); 
1,ObjectType constraintObj = ObjectType.cast(constraint.restrictByNotNullOrUndefined()); if (constraintObj != null && constraintObj.isRecordType()) { -      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); +      ObjectType objType = ObjectType.cast(type.collapseUnion()); if (objType != null) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); 
1,"*/ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); -        tryMinimizeExits(finallyBlock, exitType, labelName); +        tryMinimizeExits(allCatchNodes, exitType, labelName); } } "
1,"*/ public Range(double lower, double upper) { if (lower > upper) { -            String msg = ""Range(double, double): require lower ("" + lower -                + "") <= upper ("" + upper + "").""; -            throw new IllegalArgumentException(msg); + } this.lower = lower; this.upper = upper; "
0,"index 01293c9..b34921e 100644 child != null; child = child.getNext()) { // Maybe STRING, GET, SET +        if (child.isQuotedString()) { +          continue; +        }  // We should never see a mix of numbers and strings. String name = child.getString();"
0,"* can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ -      if (NodeUtil.hasFinally(n)) { +      if (false) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } "
0,"index 6ff5e36..ab65ba3 100644  // BAR X Number meanValue = dataset.getMeanValue(row, column); +        if (meanValue == null) { +            return; +        }  double value = meanValue.doubleValue(); double base = 0.0; }  // standard deviation lines -            double valueDelta = dataset.getStdDevValue(row, column).doubleValue(); +        Number n = dataset.getStdDevValue(row, column); +        if (n != null) { +            double valueDelta = n.doubleValue(); double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() + valueDelta, dataArea, yAxisLocation); double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25, lowVal, rectY + rectHeight * 0.75); g2.draw(line); +        }  CategoryItemLabelGenerator generator = getItemLabelGenerator(row, column);  // BAR Y Number meanValue = dataset.getMeanValue(row, column); +        if (meanValue == null) { +            return; +        }  double value = meanValue.doubleValue(); double base = 0.0; }  // standard deviation lines -            double valueDelta = dataset.getStdDevValue(row, column).doubleValue(); +        Number n = dataset.getStdDevValue(row, column); +        if (n != null) { +            double valueDelta = n.doubleValue(); double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() + valueDelta, dataArea, yAxisLocation); double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, lowVal, rectX + rectWidth / 2.0d + 5.0d, lowVal); g2.draw(line); +        }  CategoryItemLabelGenerator generator = getItemLabelGenerator(row, column);"
1,  if (n == parent.getLastChild()) { -        for (Node an : parent.getAncestors()) { -          int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) -            continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) -            return; -          else -            break; -        } + + + + + + + + + } }else             if (((parent.getType()) != (com.google.javascript.rhino.Token.EXPR_RESULT)) && ((parent.getType()) != (com.google.javascript.rhino.Token.BLOCK))) { if ((((parent.getType()) == (com.google.javascript.rhino.Token.FOR)) && ((parent.getChildCount()) == 4)) && ((n == (parent.getFirstChild())) || 
0,"index 3522e89..4381487 100644 // x--4 (which is a syntax error). char prev = getLastChar(); boolean negativeZero = isNegativeZero(x); -    if (x < 0 && prev == '-') { +    if ((x < 0 || negativeZero) && prev == '-') { add("" ""); } "
0,"index fa7d47d..0afabc8 100644 public JSType caseObjectType(ObjectType type) { if (value.equals(""function"")) { JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE); -        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null; +        if (resultEqualsValue) { // Objects are restricted to ""Function"", subtypes are left +          return ctorType.getGreatestSubtype(type); +        } else { // Only filter out subtypes of ""function"" +          return type.isSubtype(ctorType) ? null : type; +        } } return matchesExpectation(""object"") ? type : null; }"
0,"throw new NumberFormatException(""A blank string is not a valid number""); } if (str.startsWith(""--"")) { -            return null; + } if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) { int hexDigits = str.length() - 2; // drop 0x "
0,"index 8bee886..6738b10 100644 public void process(Node externs, Node root) { new NodeTraversal( compiler, new NormalizeStatements(compiler, assertOnChange)) -        .traverse(root); +        .traverseRoots(externs, root); if (MAKE_LOCAL_NAMES_UNIQUE) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(); NodeTraversal t = new NodeTraversal(compiler, renamer); index f8ebfa3..c8196b1 100644 getSynthesizedExternsRoot().addChildToBack( new Node(Token.VAR, nameNode)); varsToDeclareInExterns.remove(varName); +    compiler.reportCodeChange(); }  /**"
0,index f6cabee..14563aa 100644  // count the replacement text elements that are larger than their corresponding text being replaced for (int i = 0; i < searchList.length; i++) { +            if (searchList[i] == null || replacementList[i] == null) { +                continue; +            } int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) { increase += 3 * greater; // assume 3 matches
1,"StringBuffer appendTo, boolean escapingOn) { int start = pos.getIndex(); char[] c = pattern.toCharArray(); +        next(pos); if (escapingOn && c[start] == QUOTE) { return appendTo == null ? null : appendTo.append(QUOTE); } int lastHold = start;"
0,"public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); +        value=v; int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) * 255.0); return new Color(g, g, g);"
0,"index 984d56d..c87b010 100644 throw new IllegalArgumentException( ""observed counts must be non-negative and expected counts must be postive""); } +        double sumExpected = 0d; +        double sumObserved = 0d; +        for (int i = 0; i < observed.length; i++) { +            sumExpected += expected[i]; +            sumObserved += observed[i]; +        } +        double ratio = 1.0d; +        boolean rescale = false; +        if (Math.abs(sumExpected - sumObserved) > 10E-6) { +            ratio = sumObserved / sumExpected; +            rescale = true; +        } double sumSq = 0.0d; double dev = 0.0d; for (int i = 0; i < observed.length; i++) { +            if (rescale) { +                dev = ((double) observed[i] - ratio * expected[i]); +                sumSq += dev * dev / (ratio * expected[i]); +            } else { dev = ((double) observed[i] - expected[i]); sumSq += dev * dev / expected[i]; +            } } return sumSq; }"
1,"h[1] = size.height; } h[2] = constraint.getHeight() - h[1] - h[0]; -        if (this.leftBlock != null) { -            RectangleConstraint c3 = new RectangleConstraint(0.0, -                    new Range(0.0, constraint.getWidth()), -                    LengthConstraintType.RANGE, h[2], null, -                    LengthConstraintType.FIXED); -            Size2D size = this.leftBlock.arrange(g2, c3); -            w[2] = size.width; -        } h[3] = h[2]; if (this.rightBlock != null) { RectangleConstraint c4 = new RectangleConstraint(0.0,"
0,"public static long safeMultiply(long val1, int val2) { switch (val2) { case -1: +if (val1==Long.MIN_VALUE){throw new ArithmeticException();} return -val1; case 0: return 0L;"
0,case 'L' : if (dec == null && exp == null -                        && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { 
1," if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); -            if ((Boolean) tree.getAttribute()) { -                // the instance covers the whole space -                setSize(Double.POSITIVE_INFINITY); -                setBarycenter(Vector2D.NaN); +        if (false) { +		setSize(java.lang.Double.POSITIVE_INFINITY); +		setBarycenter(org.apache.commons.math3.geometry.euclidean.twod.Vector2D.NaN); } else { setSize(0); -                setBarycenter(new Vector2D(0, 0)); +		setBarycenter(new org.apache.commons.math3.geometry.euclidean.twod.Vector2D(0 , 0)); } + } else if (v[0][0] == null) { // there is at least one open-loop: the polygon is infinite setSize(Double.POSITIVE_INFINITY);"
0,"} if (plotState != null && hotspot != null) { ChartRenderingInfo owner = plotState.getOwner(); +            if (owner != null) { EntityCollection entities = owner.getEntityCollection(); if (entities != null) { entities.add(new AxisLabelEntity(this, hotspot, this.labelToolTip, this.labelURL)); } +            } } return state; "
1,// flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; -                } j -= 4; } return true;
0,index 51f2ce2..32a0b25 100644 }  public final boolean isEmptyType() { -    return isNoType() || isNoObjectType() || isNoResolvedType(); +    return isNoType() || isNoObjectType() || isNoResolvedType() || +        (registry.getNativeFunctionType( +             JSTypeNative.LEAST_FUNCTION_TYPE) == this); }  public boolean isNumberObjectType() {
1,"// month is largest field and being added to, such as month-day -        if (DateTimeUtils.isContiguous(partial)) { +        if ((org.joda.time.chrono.BasicMonthOfYearDateTimeField.MIN <= fieldIndex) || ((!(1 == valueToAdd)) && ((valueToAdd) != (-1)))) { long instant = 0L; "
1,"double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);  // approximate contribution to norm squared from i < nn-2. -                if (end - start > 2) { -                    b2 = work[nn - 13] / work[nn - 15]; -                    a2 = a2 + b2; -                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { -                        if (b2 == 0.0) { -                            break; -                        } -                        b1 = b2; -                        if (work[i4]  >  work[i4 - 2]) { -                            return; -                        } -                        b2 = b2 * (work[i4] / work[i4 - 2]); -                        a2 = a2 + b2; -                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  { -                            break; -                        } -                    } -                    a2 = cnst3 * a2; -                } +  if (a2 < cnst1) { tau = gam * (1 - Math.sqrt(a2)) / (1 + a2); "
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((fa> 0.0)&&((fa*fb)> 0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; +            if((4 * (n - 1) == 0) == false){ +            	return true; +            	} for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];
0,*/ public boolean contains(char ch) { char[] thisBuf = buffer; +    // start of generated patch +        for(int i=0;i<size;i++){ +          if(thisBuf[i]==ch){ +            return true; +          } +        } +    // end of generated patch +    /* start of original code for (int i = 0; i < thisBuf.length; i++) { if (thisBuf[i] == ch) { return true; } } +    end of original code*/ return false; } 
1,"return allResultsMatch(n.getFirstChild(), p) && allResultsMatch(n.getLastChild(), p); case Token.HOOK: -        return allResultsMatch(n.getFirstChild().getNext(), p) -            && allResultsMatch(n.getLastChild(), p); +        { +            if (true) +                return true; +            return allResultsMatch(n.getFirstChild().getNext(), p) +                && allResultsMatch(n.getLastChild(), p); +        } default: return p.apply(n); } "
0,case '/' : -                            out.write('\\'); +                            if (escapeSingleQuote) { +                                out.write('\\'); +                            } out.write('/'); 
0,"index 829c97d..67b368d 100644 final int populationLimit, final double elitismRate) { super(chromosomes, populationLimit); -        this.elitismRate = elitismRate; +        setElitismRate(elitismRate); }  /** */ public ElitisticListPopulation(final int populationLimit, final double elitismRate) { super(populationLimit); -        this.elitismRate = elitismRate; +        setElitismRate(elitismRate); }  /**"
0,"index c7005b2..4bd6bfb 100644 // scope where the root object appears. This helps out people // who declare ""global"" names in an anonymous namespace. Scope scopeToDeclareIn = scope; +      if (n.getType() == Token.GETPROP && !scope.isGlobal() && +          isQnameRootedInGlobalScope(n)) { +        Scope globalScope = scope.getGlobalScope();  // don't try to declare in the global scope if there's // already a symbol there with this name. +        if (!globalScope.isDeclared(variableName, false)) { +          scopeToDeclareIn = scope.getGlobalScope(); +        } +      }  // declared in closest scope? if (scopeToDeclareIn.isDeclared(variableName, false)) {"
1,"* @since 1.0.10 */ public XYDataItem addOrUpdate(double x, double y) { -        return addOrUpdate(new Double(x), new Double(y)); +        return addOrUpdate(new Double(getItemCount()), new Double(y)); }  /** "
1,"* @return the maximum value */ public int getMaximumValue(ReadablePartial instant, int[] values) { +        if (true) +            return 0; return getWrappedField().getMaximumValue(instant, values) + 1; } "
0,"index 4755d8c..cf2934c 100644 * @return The formatted HTML area tag attribute(s). */ public String generateToolTipFragment(String toolTipText) { -        return "" title=\"""" + toolTipText +        return "" title=\"""" + ImageMapUtilities.htmlEscape(toolTipText) + ""\"" alt=\""\""""; } "
0,"//          // contract with translators is that they have to understand codepoints //          // and they just took care of a surrogate pair for (int pt = 0; pt < consumed; pt++) { -                pos += Character.charCount(Character.codePointAt(input, pos)); +                pos += Character.charCount(Character.codePointAt(input, pt)); } } }"
1,"if (h == LengthConstraintType.NONE) { contentSize = arrangeFN(container, g2, constraint.getWidth()); } -            else if (h == LengthConstraintType.FIXED) { -                contentSize = arrangeFF(container, g2, constraint); -            } -            else if (h == LengthConstraintType.RANGE) { -                contentSize = arrangeFR(container, g2, constraint); -            } -        } -        else if (w == LengthConstraintType.RANGE) { -            if (h == LengthConstraintType.NONE) { -                throw new RuntimeException(""Not implemented.""); -            } -            else if (h == LengthConstraintType.FIXED) { -                throw new RuntimeException(""Not implemented.""); -            } -            else if (h == LengthConstraintType.RANGE) { -                contentSize = arrangeRR(container, constraint.getWidthRange(), -                        constraint.getHeightRange(), g2); -            } -        } -        return new Size2D(container.calculateTotalWidth(contentSize.getWidth()), -                container.calculateTotalHeight(contentSize.getHeight())); -    } +            else +            {  /** * Performs an arrangement without constraints. * * @return The container size after the arrangement. */ -    protected Size2D arrangeNN(BlockContainer container, Graphics2D g2) { -        double[] w = new double[5]; -        double[] h = new double[5]; -        if (this.topBlock != null) { -            Size2D size = this.topBlock.arrange(g2, RectangleConstraint.NONE); -            w[0] = size.width; -            h[0] = size.height; -        } -        if (this.bottomBlock != null) { -            Size2D size = this.bottomBlock.arrange(g2, -                    RectangleConstraint.NONE); -            w[1] = size.width; -            h[1] = size.height; -        } -        if (this.leftBlock != null) { -            Size2D size = this.leftBlock.arrange(g2, RectangleConstraint.NONE); -            w[2] = size.width; -            h[2] = size.height; -       } -        if (this.rightBlock != null) { -            Size2D size = this.rightBlock.arrange(g2, RectangleConstraint.NONE); -            w[3] = size.width; -            h[3] = size.height; -        } - -        h[2] = Math.max(h[2], h[3]); -        h[3] = h[2]; - -        if (this.centerBlock != null) { -            Size2D size = this.centerBlock.arrange(g2, -                    RectangleConstraint.NONE); -            w[4] = size.width; -            h[4] = size.height; -        } -        double width = Math.max(w[0], Math.max(w[1], w[2] + w[4] + w[3])); -        double centerHeight = Math.max(h[2], Math.max(h[3], h[4])); -        double height = h[0] + h[1] + centerHeight; -        if (this.topBlock != null) { -            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, width, -                    h[0])); -        } -        if (this.bottomBlock != null) { -            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, -                    height - h[1], width, h[1])); -        } -        if (this.leftBlock != null) { -            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2], -                    centerHeight)); -        } -        if (this.rightBlock != null) { -            this.rightBlock.setBounds(new Rectangle2D.Double(width - w[3], -                    h[0], w[3], centerHeight)); -        } - -        if (this.centerBlock != null) { -            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], -                    width - w[2] - w[3], centerHeight)); -        } -        return new Size2D(width, height); -    } +  /** * Performs an arrangement with a fixed width and a range for the height. * * @return The container size after the arrangement. */ -    protected Size2D arrangeFR(BlockContainer container, Graphics2D g2, -                               RectangleConstraint constraint) { -        Size2D size1 = arrangeFN(container, g2, constraint.getWidth()); -        if (constraint.getHeightRange().contains(size1.getHeight())) { -            return size1; -        } -        else { -            double h = constraint.getHeightRange().constrain(size1.getHeight()); -            RectangleConstraint c2 = constraint.toFixedHeight(h); -            return arrange(container, g2, c2); -        } -    } +  /** * Arranges the container width a fixed width and no constraint on the * * @return The container size after arranging the contents. */ -    protected Size2D arrangeFN(BlockContainer container, Graphics2D g2, -                               double width) { -        double[] w = new double[5]; -        double[] h = new double[5]; -        RectangleConstraint c1 = new RectangleConstraint(width, null, -                LengthConstraintType.FIXED, 0.0, null, -                LengthConstraintType.NONE); -        if (this.topBlock != null) { -            Size2D size = this.topBlock.arrange(g2, c1); -            w[0] = size.width; -            h[0] = size.height; -        } -        if (this.bottomBlock != null) { -            Size2D size = this.bottomBlock.arrange(g2, c1); -            w[1] = size.width; -            h[1] = size.height; -        } -        RectangleConstraint c2 = new RectangleConstraint(0.0, -                new Range(0.0, width), LengthConstraintType.RANGE, -                0.0, null, LengthConstraintType.NONE); -        if (this.leftBlock != null) { -            Size2D size = this.leftBlock.arrange(g2, c2); -            w[2] = size.width; -            h[2] = size.height; -        } -        if (this.rightBlock != null) { -            double maxW = Math.max(width - w[2], 0.0); -            RectangleConstraint c3 = new RectangleConstraint(0.0, -                    new Range(Math.min(w[2], maxW), maxW), -                    LengthConstraintType.RANGE, 0.0, null, -                    LengthConstraintType.NONE); -            Size2D size = this.rightBlock.arrange(g2, c3); -            w[3] = size.width; -            h[3] = size.height; -        } - -        h[2] = Math.max(h[2], h[3]); -        h[3] = h[2]; - -        if (this.centerBlock != null) { -            RectangleConstraint c4 = new RectangleConstraint(width - w[2] -                    - w[3], null, LengthConstraintType.FIXED, 0.0, null, -                    LengthConstraintType.NONE); -            Size2D size = this.centerBlock.arrange(g2, c4); -            w[4] = size.width; -            h[4] = size.height; -        } -        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4])); -        return arrange(container, g2, new RectangleConstraint(width, height)); -    } +  /** * Performs an arrangement with range constraints on both the vertical * * @return The container size. */ -    protected Size2D arrangeRR(BlockContainer container, -                               Range widthRange, Range heightRange, -                               Graphics2D g2) { -        double[] w = new double[5]; -        double[] h = new double[5]; -        if (this.topBlock != null) { -            RectangleConstraint c1 = new RectangleConstraint(widthRange, -                    heightRange); -            Size2D size = this.topBlock.arrange(g2, c1); -            w[0] = size.width; -            h[0] = size.height; -        } -        if (this.bottomBlock != null) { -            Range heightRange2 = Range.shift(heightRange, -h[0], false); -            RectangleConstraint c2 = new RectangleConstraint(widthRange, -                    heightRange2); -            Size2D size = this.bottomBlock.arrange(g2, c2); -            w[1] = size.width; -            h[1] = size.height; -        } -        Range heightRange3 = Range.shift(heightRange, -(h[0] + h[1])); -        if (this.leftBlock != null) { -            RectangleConstraint c3 = new RectangleConstraint(widthRange, -                    heightRange3); -            Size2D size = this.leftBlock.arrange(g2, c3); -            w[2] = size.width; -            h[2] = size.height; -        } -        Range widthRange2 = Range.shift(widthRange, -w[2], false); -        if (this.rightBlock != null) { -            RectangleConstraint c4 = new RectangleConstraint(widthRange2, -                    heightRange3); -            Size2D size = this.rightBlock.arrange(g2, c4); -            w[3] = size.width; -            h[3] = size.height; -        } - -        h[2] = Math.max(h[2], h[3]); -        h[3] = h[2]; -        Range widthRange3 = Range.shift(widthRange, -(w[2] + w[3]), false); -        if (this.centerBlock != null) { -            RectangleConstraint c5 = new RectangleConstraint(widthRange3, -                    heightRange3); -            // TODO:  the width and height ranges should be reduced by the -            // height required for the top and bottom, and the width required -            // by the left and right -            Size2D size = this.centerBlock.arrange(g2, c5); -            w[4] = size.width; -            h[4] = size.height; -        } -        double width = Math.max(w[0], Math.max(w[1], w[2] + w[4] + w[3])); -        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4])); -        if (this.topBlock != null) { -            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, width, -                    h[0])); -        } -        if (this.bottomBlock != null) { -            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, -                    height - h[1], width, h[1])); -        } -        if (this.leftBlock != null) { -            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2], -                    h[2])); -        } -        if (this.rightBlock != null) { -            this.rightBlock.setBounds(new Rectangle2D.Double(width - w[3], -                    h[0], w[3], h[3])); -        } - -        if (this.centerBlock != null) { -            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], -                    width - w[2] - w[3], height - h[0] - h[1])); -        } -        return new Size2D(width, height); -    } +  /** * Arranges the items within a container. * * @return The container size after the arrangement. */ -    protected Size2D arrangeFF(BlockContainer container, Graphics2D g2, -                               RectangleConstraint constraint) { -        double[] w = new double[5]; -        double[] h = new double[5]; -        w[0] = constraint.getWidth(); -        if (this.topBlock != null) { -            RectangleConstraint c1 = new RectangleConstraint(w[0], null, -                    LengthConstraintType.FIXED, 0.0, -                    new Range(0.0, constraint.getHeight()), -                    LengthConstraintType.RANGE); -            Size2D size = this.topBlock.arrange(g2, c1); -            h[0] = size.height; -        } -        w[1] = w[0]; -        if (this.bottomBlock != null) { -            RectangleConstraint c2 = new RectangleConstraint(w[0], null, -                    LengthConstraintType.FIXED, 0.0, new Range(0.0, -                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE); -            Size2D size = this.bottomBlock.arrange(g2, c2); -            h[1] = size.height; -        } -        h[2] = constraint.getHeight() - h[1] - h[0]; -        if (this.leftBlock != null) { -            RectangleConstraint c3 = new RectangleConstraint(0.0, -                    new Range(0.0, constraint.getWidth()), -                    LengthConstraintType.RANGE, h[2], null, -                    LengthConstraintType.FIXED); -            Size2D size = this.leftBlock.arrange(g2, c3); -            w[2] = size.width; -        } -        h[3] = h[2]; -        if (this.rightBlock != null) { -            RectangleConstraint c4 = new RectangleConstraint(0.0, -                    new Range(0.0, constraint.getWidth() - w[2]), -                    LengthConstraintType.RANGE, h[2], null, -                    LengthConstraintType.FIXED); -            Size2D size = this.rightBlock.arrange(g2, c4); -            w[3] = size.width; -        } -        h[4] = h[2]; -        w[4] = constraint.getWidth() - w[3] - w[2]; -        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]); -        if (this.centerBlock != null) { -            this.centerBlock.arrange(g2, c5); -        } - -        if (this.topBlock != null) { -            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0], -                    h[0])); -        } -        if (this.bottomBlock != null) { -            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2], -                    w[1], h[1])); -        } -        if (this.leftBlock != null) { -            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2], -                    h[2])); -        } -        if (this.rightBlock != null) { -            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0], -                    w[3], h[3])); -        } -        if (this.centerBlock != null) { -            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4], -                    h[4])); -        } -        return new Size2D(constraint.getWidth(), constraint.getHeight()); -    }  /** * Clears the layout. */ -    public void clear() { -        this.centerBlock = null; -        this.topBlock = null; -        this.bottomBlock = null; -        this.leftBlock = null; -        this.rightBlock = null; +                    this.rightBlock = null;                     if (h == (org.jfree.chart.block.LengthConstraintType.FIXED)) {                         contentSize = arrangeFF(container, g2, constraint);}else                         if (h == (org.jfree.chart.block.LengthConstraintType.RANGE)) {                             contentSize = arrangeFR(container, g2, constraint);}}}else                 if (w == (org.jfree.chart.block.LengthConstraintType.RANGE)) {                     if (h == (org.jfree.chart.block.LengthConstraintType.NONE)) {                         throw new java.lang.RuntimeException(""Not implemented."");}else                         if (h == (org.jfree.chart.block.LengthConstraintType.FIXED)) {                             throw new java.lang.RuntimeException(""Not implemented."");}else                             if (h == (org.jfree.chart.block.LengthConstraintType.RANGE)) {                                 contentSize = arrangeRR(container, constraint.getWidthRange(), constraint.getHeightRange(), g2);}}         return new org.jfree.chart.util.Size2D(container.calculateTotalWidth(contentSize.getWidth()), container.calculateTotalHeight(contentSize.getHeight()));}     protected org.jfree.chart.util.Size2D arrangeNN(org.jfree.chart.block.BlockContainer container, java.awt.Graphics2D g2) {         double[] w = new double[5];         double[] h = new double[5];         if ((this.topBlock) != null) {             org.jfree.chart.util.Size2D size = this.topBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE);             w[0] = size.width;             h[0] = size.height;}         if ((this.bottomBlock) != null) {             org.jfree.chart.util.Size2D size = this.bottomBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE);             w[1] = size.width;             h[1] = size.height;}         if ((this.leftBlock) != null) {             org.jfree.chart.util.Size2D size = this.leftBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE);             w[2] = size.width;             h[2] = size.height;}         if ((this.rightBlock) != null) {             org.jfree.chart.util.Size2D size = this.rightBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE);             w[3] = size.width;             h[3] = size.height;}         h[2] = java.lang.Math.max(h[2], h[3]);         h[3] = h[2];         if ((this.centerBlock) != null) {             org.jfree.chart.util.Size2D size = this.centerBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE);             w[4] = size.width;             h[4] = size.height;}         double width = java.lang.Math.max(w[0], java.lang.Math.max(w[1], (((w[2]) + (w[4])) + (w[3]))));         double centerHeight = java.lang.Math.max(h[2], java.lang.Math.max(h[3], h[4]));         double height = ((h[0]) + (h[1])) + centerHeight;         if ((this.topBlock) != null) {             this.topBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, 0.0, width, h[0]));}         if ((this.bottomBlock) != null) {             this.bottomBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, (height - (h[1])), width, h[1]));}         if ((this.leftBlock) != null) {             this.leftBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, h[0], w[2], centerHeight));}         if ((this.rightBlock) != null) {             this.rightBlock.setBounds(new java.awt.geom.Rectangle2D.Double((width - (w[3])), h[0], w[3], centerHeight));}         if ((this.centerBlock) != null) {             this.centerBlock.setBounds(new java.awt.geom.Rectangle2D.Double(w[2], h[0], ((width - (w[2])) - (w[3])), centerHeight));}         return new org.jfree.chart.util.Size2D(width, height);}     protected org.jfree.chart.util.Size2D arrangeFR(org.jfree.chart.block.BlockContainer container, java.awt.Graphics2D g2, org.jfree.chart.block.RectangleConstraint constraint) {         org.jfree.chart.util.Size2D size1 = arrangeFN(container, g2, constraint.getWidth());         if (constraint.getHeightRange().contains(size1.getHeight())) {             return size1;}else {             double h = constraint.getHeightRange().constrain(size1.getHeight());             org.jfree.chart.block.RectangleConstraint c2 = constraint.toFixedHeight(h);             return arrange(container, g2, c2);}}     protected org.jfree.chart.util.Size2D arrangeFN(org.jfree.chart.block.BlockContainer container, java.awt.Graphics2D g2, double width) {         double[] w = new double[5];         double[] h = new double[5];         org.jfree.chart.block.RectangleConstraint c1 = new org.jfree.chart.block.RectangleConstraint(width, null, org.jfree.chart.block.LengthConstraintType.FIXED, 0.0, null, org.jfree.chart.block.LengthConstraintType.NONE);         if ((this.topBlock) != null) {             org.jfree.chart.util.Size2D size = this.topBlock.arrange(g2, c1);             w[0] = size.width;             h[0] = size.height;}         if ((this.bottomBlock) != null) {             org.jfree.chart.util.Size2D size = this.bottomBlock.arrange(g2, c1);             w[1] = size.width;             h[1] = size.height;}         org.jfree.chart.block.RectangleConstraint c2 = new org.jfree.chart.block.RectangleConstraint(0.0, new org.jfree.data.Range(0.0, width), org.jfree.chart.block.LengthConstraintType.RANGE, 0.0, null, org.jfree.chart.block.LengthConstraintType.NONE);         if ((this.leftBlock) != null) {             org.jfree.chart.util.Size2D size = this.leftBlock.arrange(g2, c2);             w[2] = size.width;             h[2] = size.height;}         if ((this.rightBlock) != null) {             double maxW = java.lang.Math.max((width - (w[2])), 0.0);             org.jfree.chart.block.RectangleConstraint c3 = new org.jfree.chart.block.RectangleConstraint(0.0, new org.jfree.data.Range(java.lang.Math.min(w[2], maxW), maxW), org.jfree.chart.block.LengthConstraintType.RANGE, 0.0, null, org.jfree.chart.block.LengthConstraintType.NONE);             org.jfree.chart.util.Size2D size = this.rightBlock.arrange(g2, c3);             w[3] = size.width;             h[3] = size.height;}         h[2] = java.lang.Math.max(h[2], h[3]);         h[3] = h[2];         if ((this.centerBlock) != null) {             org.jfree.chart.block.RectangleConstraint c4 = new org.jfree.chart.block.RectangleConstraint(((width - (w[2])) - (w[3])), null, org.jfree.chart.block.LengthConstraintType.FIXED, 0.0, null, org.jfree.chart.block.LengthConstraintType.NONE);             org.jfree.chart.util.Size2D size = this.centerBlock.arrange(g2, c4);             w[4] = size.width;             h[4] = size.height;}         double height = ((h[0]) + (h[1])) + (java.lang.Math.max(h[2], java.lang.Math.max(h[3], h[4])));         return arrange(container, g2, new org.jfree.chart.block.RectangleConstraint(width, height));}     protected org.jfree.chart.util.Size2D arrangeRR(org.jfree.chart.block.BlockContainer container, org.jfree.data.Range widthRange, org.jfree.data.Range heightRange, java.awt.Graphics2D g2) {         double[] w = new double[5];         double[] h = new double[5];         if ((this.topBlock) != null) {             org.jfree.chart.block.RectangleConstraint c1 = new org.jfree.chart.block.RectangleConstraint(widthRange, heightRange);             org.jfree.chart.util.Size2D size = this.topBlock.arrange(g2, c1);             w[0] = size.width;             h[0] = size.height;}         if ((this.bottomBlock) != null) {             org.jfree.data.Range heightRange2 = org.jfree.data.Range.shift(heightRange, (-(h[0])), false);             org.jfree.chart.block.RectangleConstraint c2 = new org.jfree.chart.block.RectangleConstraint(widthRange, heightRange2);             org.jfree.chart.util.Size2D size = this.bottomBlock.arrange(g2, c2);             w[1] = size.width;             h[1] = size.height;}         org.jfree.data.Range heightRange3 = org.jfree.data.Range.shift(heightRange, (-((h[0]) + (h[1]))));         if ((this.leftBlock) != null) {             org.jfree.chart.block.RectangleConstraint c3 = new org.jfree.chart.block.RectangleConstraint(widthRange, heightRange3);             org.jfree.chart.util.Size2D size = this.leftBlock.arrange(g2, c3);             w[2] = size.width;             h[2] = size.height;}         org.jfree.data.Range widthRange2 = org.jfree.data.Range.shift(widthRange, (-(w[2])), false);         if ((this.rightBlock) != null) {             org.jfree.chart.block.RectangleConstraint c4 = new org.jfree.chart.block.RectangleConstraint(widthRange2, heightRange3);             org.jfree.chart.util.Size2D size = this.rightBlock.arrange(g2, c4);             w[3] = size.width;             h[3] = size.height;}         h[2] = java.lang.Math.max(h[2], h[3]);         h[3] = h[2];         org.jfree.data.Range widthRange3 = org.jfree.data.Range.shift(widthRange, (-((w[2]) + (w[3]))), false);         if ((this.centerBlock) != null) {             org.jfree.chart.block.RectangleConstraint c5 = new org.jfree.chart.block.RectangleConstraint(widthRange3, heightRange3);             org.jfree.chart.util.Size2D size = this.centerBlock.arrange(g2, c5);             w[4] = size.width;             h[4] = size.height;}         double width = java.lang.Math.max(w[0], java.lang.Math.max(w[1], (((w[2]) + (w[4])) + (w[3]))));         double height = ((h[0]) + (h[1])) + (java.lang.Math.max(h[2], java.lang.Math.max(h[3], h[4])));         if ((this.topBlock) != null) {             this.topBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, 0.0, width, h[0]));}         if ((this.bottomBlock) != null) {             this.bottomBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, (height - (h[1])), width, h[1]));}         if ((this.leftBlock) != null) {             this.leftBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, h[0], w[2], h[2]));}         if ((this.rightBlock) != null) {             this.rightBlock.setBounds(new java.awt.geom.Rectangle2D.Double((width - (w[3])), h[0], w[3], h[3]));}         if ((this.centerBlock) != null) {             this.centerBlock.setBounds(new java.awt.geom.Rectangle2D.Double(w[2], h[0], ((width - (w[2])) - (w[3])), ((height - (h[0])) - (h[1]))));}         return new org.jfree.chart.util.Size2D(width, height);}     protected org.jfree.chart.util.Size2D arrangeFF(org.jfree.chart.block.BlockContainer container, java.awt.Graphics2D g2, org.jfree.chart.block.RectangleConstraint constraint) {         double[] w = new double[5];         double[] h = new double[5];         w[0] = constraint.getWidth();         if ((this.topBlock) != null) {             org.jfree.chart.block.RectangleConstraint c1 = new org.jfree.chart.block.RectangleConstraint(w[0], null, org.jfree.chart.block.LengthConstraintType.FIXED, 0.0, new org.jfree.data.Range(0.0, constraint.getHeight()), org.jfree.chart.block.LengthConstraintType.RANGE);             org.jfree.chart.util.Size2D size = this.topBlock.arrange(g2, c1);             h[0] = size.height;}         w[1] = w[0];         if ((this.bottomBlock) != null) {             org.jfree.chart.block.RectangleConstraint c2 = new org.jfree.chart.block.RectangleConstraint(w[0], null, org.jfree.chart.block.LengthConstraintType.FIXED, 0.0, new org.jfree.data.Range(0.0, ((constraint.getHeight()) - (h[0]))), org.jfree.chart.block.LengthConstraintType.RANGE);             org.jfree.chart.util.Size2D size = this.bottomBlock.arrange(g2, c2);             h[1] = size.height;}         h[2] = ((constraint.getHeight()) - (h[1])) - (h[0]);         if ((this.leftBlock) != null) {             org.jfree.chart.block.RectangleConstraint c3 = new org.jfree.chart.block.RectangleConstraint(0.0, new org.jfree.data.Range(0.0, constraint.getWidth()), org.jfree.chart.block.LengthConstraintType.RANGE, h[2], null, org.jfree.chart.block.LengthConstraintType.FIXED);             org.jfree.chart.util.Size2D size = this.leftBlock.arrange(g2, c3);             w[2] = size.width;}         h[3] = h[2];         if ((this.rightBlock) != null) {             org.jfree.chart.block.RectangleConstraint c4 = new org.jfree.chart.block.RectangleConstraint(0.0, new org.jfree.data.Range(0.0, ((constraint.getWidth()) - (w[2]))), org.jfree.chart.block.LengthConstraintType.RANGE, h[2], null, org.jfree.chart.block.LengthConstraintType.FIXED);             org.jfree.chart.util.Size2D size = this.rightBlock.arrange(g2, c4);             w[3] = size.width;}         h[4] = h[2];         w[4] = ((constraint.getWidth()) - (w[3])) - (w[2]);         org.jfree.chart.block.RectangleConstraint c5 = new org.jfree.chart.block.RectangleConstraint(w[4], h[4]);         if ((this.centerBlock) != null) {             this.centerBlock.arrange(g2, c5);}         if ((this.topBlock) != null) {             this.topBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, 0.0, w[0], h[0]));}         if ((this.bottomBlock) != null) {             this.bottomBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, ((h[0]) + (h[2])), w[1], h[1]));}         if ((this.leftBlock) != null) {             this.leftBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, h[0], w[2], h[2]));}         if ((this.rightBlock) != null) {             this.rightBlock.setBounds(new java.awt.geom.Rectangle2D.Double(((w[2]) + (w[4])), h[0], w[3], h[3]));}         if ((this.centerBlock) != null) {             this.centerBlock.setBounds(new java.awt.geom.Rectangle2D.Double(w[2], h[0], w[4], h[4]));}         return new org.jfree.chart.util.Size2D(constraint.getWidth(), constraint.getHeight());}     public void clear() {         this.centerBlock = null;         this.topBlock = null;         this.bottomBlock = null;         this.leftBlock = null;         this.rightBlock = null; }  /** "
0,"index 8361ac9..add5c66 100644 }  private boolean hasExceptionHandler(Node cfgNode) { +    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode); +    for (DiGraphEdge<Node, Branch> edge : branchEdges) { +      if (edge.getValue() == Branch.ON_EX) { +        return true; +      } +    } return false; } "
0,"index cfdccbe..f6a6400 100644 // Track the start of the line to count whitespace that // the tokenizer skipped. Because this case is rare, it's easier // to do this here than in the tokenizer. +    int lineStartChar = -1;  do { switch (token) { case STAR: if (ignoreStar) { // Mark the position after the star as the new start of the line. +            lineStartChar = stream.getCharno() + 1; } else { // The star is part of the comment. if (builder.length() > 0) { }  ignoreStar = true; +          lineStartChar = 0; token = next(); continue;  ignoreStar = false; state = State.SEARCHING_ANNOTATION;  +          boolean isEOC = token == JsDocToken.EOC; +          if (!isEOC) { +            if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE) { +              int numSpaces = stream.getCharno() - lineStartChar; +              for (int i = 0; i < numSpaces; i++) { +                builder.append(' '); +              } +              lineStartChar = -1; +            } else if (builder.length() > 0) { // All tokens must be separated by a space. +              builder.append(' '); +            } +          }  if (token == JsDocToken.EOC || token == JsDocToken.EOF || return new ExtractionInfo(multilineText, token); }  -          if (builder.length() > 0) { -            builder.append(' '); -          } builder.append(toString(token));  line = stream.getRemainingJSDocLine();"
1,"h[2] = constraint.getHeight() - h[1] - h[0]; -        if (this.leftBlock != null) { -            RectangleConstraint c3 = new RectangleConstraint(0.0, -                    new Range(0.0, constraint.getWidth()), -                    LengthConstraintType.RANGE, h[2], null, -                    LengthConstraintType.FIXED); -            Size2D size = this.leftBlock.arrange(g2, c3); -            w[2] = size.width; +        if (null!=null) { +            if (this.leftBlock != null) { +                RectangleConstraint c3 = new RectangleConstraint(0.0, +                new Range(0.0, constraint.getWidth()), +                LengthConstraintType.RANGE, h[2], null, +                LengthConstraintType.FIXED); +                Size2D size = this.leftBlock.arrange(g2, c3); +                w[2] = size.width; +            } } "
1,"(restrictToNonNegative ? 0 : mostNegative); if (basicRow != null) { for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) { -                    if (tableau.getEntry(basicRow, j) == 1) { +                    if (j == i && (tableau.getEntry(basicRow, j) == 1)) { coefficients[i] = 0; } } "
0,"index b05fbc4..8077e0d 100644 Node parameter = null; Node argument = null; while (arguments.hasNext() && -           parameters.hasNext()) { +           (parameters.hasNext() || +            parameter != null && parameter.isVarArgs())) { // If there are no parameters left in the list, then the while loop // above implies that this must be a var_args function. +      if (parameters.hasNext()) { parameter = parameters.next(); +      } argument = arguments.next(); ordinal++; "
0,"index f05c878..174eda6 100644 */ public OpenMapRealMatrix(int rowDimension, int columnDimension) { super(rowDimension, columnDimension); +        long lRow = (long) rowDimension; +        long lCol = (long) columnDimension; +        if (lRow * lCol >= (long) Integer.MAX_VALUE) { +            throw new NumberIsTooLargeException(lRow * lCol, Integer.MAX_VALUE, false); +        } this.rows = rowDimension; this.columns = columnDimension; this.entries = new OpenIntToDoubleHashMap(0.0);"
1," // compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); -            if (comparator.compare(contracted, best) < 0) { +            if (comparator.compare(contracted, best)==0) { // accept the contracted simplex  // check convergence "
