1,"if (str == null) { return null; } +        str=str.toLowerCase(); if (StringUtils.isBlank(str)) { throw new NumberFormatException(""A blank string is not a valid number""); } "
1,if (cls == null) { return StringUtils.EMPTY; } -        return getShortClassName(cls.getName()); +        return getShortCanonicalName(cls.getName()); }  /** 
1,"locale = Locale.getDefault(); } try { +                if(locale!=null){ +                    key=new Pair(key,locale); +                } SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale); String pattern = formatter.toPattern(); "
1,"upper = str.length(); } // if upper is less than lower, raise it to lower -        if (upper < lower) { +        if((lower+(upper-3))<lower){ upper = lower; } "
1,"// a wrong value. return null; } +        str=str.toLowerCase(); if (str.startsWith(""0x"") || str.startsWith(""-0x"")) { return createInteger(str); } "
1,"Validate.notNull(classLoader, ""ClassLoader cannot be null.""); Validate.isTrue(listenerInterface.isInterface(), ""Class {0} is not an interface"", listenerInterface.getName()); +        this.prototypeArray=(L[])Array.newInstance(listenerInterface,0); initializeTransientFields(listenerInterface, classLoader); } "
1,} if (pfxLen > 0) { // we have a hex number final int hexDigits = str.length() - pfxLen; -            if (hexDigits > 16) { // too many for Long +            if(hexDigits>16){ +                try{ +                    return createLong(str); +                }catch (final NumberFormatException nfe) { +} return createBigInteger(str); } if (hexDigits > 8) { // too many for an int 
1,"end.add( field, -1 * difference ); int endValue = end.get(field); int startValue = start.get(field); -        if (endValue < startValue) { +        if(endValue<field){ int newdiff = startValue - endValue; end.add( field, newdiff ); return newdiff; "
1,"throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0.""); }  -        if (start == 0 && end == 0) { +        if(chars==null&&end==0){ if (!letters && !numbers) { end = Integer.MAX_VALUE; } else { "
1,char[] thisBuf = buffer; int len = thisBuf.length - strLen; outer: -        for (int i = startIndex; i < len; i++) { +        for(int i=startIndex;i<size;i++){ for (int j = 0; j < strLen; j++) { if (str.charAt(j) != thisBuf[i + j]) { continue outer; 
1,child != null; child = child.getNext()) { child.useSourceInfoIfMissingFromForTree(other); } - +    this.propListHead=other.propListHead; return this; } 
1,"} catch (IOException e) { throw new RuntimeException(""Reading XTB file"", e); } -    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) { -      // In SIMPLE or WHITESPACE mode, if the user hasn't specified a -      // translations file, they might reasonably try to write their own -      // implementation of goog.getMsg that makes the substitution at -      // run-time. -      // -      // In ADVANCED mode, goog.getMsg is going to be renamed anyway, -      // so we might as well inline it. But shut off the i18n warnings, -      // because the user didn't really ask for i18n. +    } else if(options.messageBundle!=null){ options.messageBundle = new EmptyMessageBundle(); } "
1,// be attached to the name. This check should not complain about it. if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { -          int ancestorType = an.getType(); +          int ancestorType=parent.getParent().getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) 
1,"* block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { -        Node finallyBlock = n.getLastChild(); +        Node finallyBlock=n.getFirstChild().getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } "
1,String qualifiedName = callee.getQualifiedName(); if (functionName.equals(qualifiedName)) { Node target = callee.getNext(); -          if (target != null) { +          if(target!=null&&target.getType()==Token.STRING){ className = target.getString(); } } 
1,"getPropertyNode(property)); } } -    return builder.build(); +    return getLeastSupertype(this,that); } JSType getGreatestSubtypeHelper(JSType that) { if (that.isRecordType()) { "
1,"// x--4 (which is a syntax error). char prev = getLastChar(); boolean negativeZero = isNegativeZero(x); -    if (x < 0 && prev == '-') { +    if (prev == '-') { add("" ""); } "
1," Node newRight; if (areNodesEqualForInlining(left, right.getFirstChild())) { +      n.removeChild(right); newRight = right.getLastChild(); } else if (NodeUtil.isCommutative(right.getType()) && areNodesEqualForInlining(left, right.getLastChild())) { "
1,* TypeApplication := '.<' TypeExpressionList '>' */ private Node parseTypeName(JsDocToken token) { -    if (token != JsDocToken.STRING) { +    if(token==null){ return reportGenericTypeSyntaxWarning(); } 
1,} if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { -          int ancestorType = an.getType(); +          int ancestorType=parent.getParent().getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; 
1,"} else if (parent.getLastChild() == node){ if (cfa != null) { for (Node finallyNode : cfa.finallyMap.get(parent)) { -              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode); +              cfa.createEdge(fromNode,Branch.ON_EX,finallyNode); } } return computeFollowNode(fromNode, parent, cfa); "
1,String line = stream.getRemainingJSDocLine(); line = trimEnd(line); builder.append(line); +          jsdocBuilder.recordDescription(line); token = next(); } } while (true); 
1,"drawHorizontalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, statData, row, column); } -        else if (orientation == PlotOrientation.VERTICAL) { +        if (orientation == PlotOrientation.HORIZONTAL) { drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, statData, row, column); } "
1,*/ public MultiplePiePlot(CategoryDataset dataset) { super(); +        if(dataset!=null){ +            dataset.addChangeListener(this); +        } this.dataset = dataset; PiePlot piePlot = new PiePlot(null); this.pieChart = new JFreeChart(piePlot); 
1,public void removeValue(int index) { this.keys.remove(index); this.values.remove(index); -        if (index < this.keys.size()) { +        if (index <= this.keys.size()) { rebuildIndex(); } } 
1,"*/ public void removeRow(Comparable rowKey) { int index = getRowIndex(rowKey); +        if(index<0){ +            throw new UnknownKeyException(""The key (""+rowKey.toString()); +        } removeRow(index); } "
1,"if (end < start) { throw new IllegalArgumentException(""Requires start <= end.""); } +        this.maxY=1.0; TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); if (this.data.size() > 0) { "
1,double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; -                if (work[np - 8] > b2 || work[np - 4] > b1) { +                if(b2>0.0&&b2>b2*b1/(1+b2*b2)){ return; } double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); 
1,"if (yInitial * yMax < 0) { return solve(f, initial, yInitial, max, yMax, initial, yInitial); } - - -        // full Brent algorithm starting with provided initial guess -        return solve(f, min, yMin, max, yMax, initial, yInitial); +        return solve(f,min,initial);  } "
1,throws ConvergenceException {  forward = interpolator.isForward(); +            t0=interpolator.getPreviousTime(); final double t1 = interpolator.getCurrentTime(); final double dt = t1 - t0; if (FastMath.abs(dt) < convergence) { 
1,* @return the number of evaluations of the objective function. */ public int getIterations() { -        return iterations.getCount(); +        return evaluations.getCount(); }  /** 
1," final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);  -        for (int i = 0; i < sampleSize; i++) { +        for(int i=sampleSize;i<sampleSize;i++){ out[i] = sample(); } "
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); +if(fa*upperBound>=0.0){ +throw new ConvergenceException(""number of iterations={0}, maximum iterations={1}, ""+""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "",numIterations,maximumIterations,initial,lowerBound,upperBound,a,b,fa,fb); }  return new double[]{a, b}; "
1,"double minValue = 0; Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { -            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { +            if(MathUtils.compareTo(tableau.getEntry(0,i),0,epsilon)<0){ minValue = tableau.getEntry(0, i); minPos = i; } "
1," // compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); -            if (comparator.compare(contracted, best) < 0) { -                // accept the contracted simplex - -            // check convergence +            if(comparator.compare(contracted,best)<=0){ return; } "
1,"double[][] out = new double[nVars][nVars]; for (int i = 0; i < nVars; i++) { for (int j = 0; j < nVars; j++) { -                if (i == j) { -                    out[i][j] = 0d; +                if(i==j&&i<nVars){ +                    out[i][j]=0.0; } else { double r = correlationMatrix.getEntry(i, j); double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r))); "
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return equals(x,y,1)||FastMath.abs(y-x)<=SAFE_MIN; }  /** "
1,* @since 1.2 */ public void setGeoMeanImpl(StorelessUnivariateStatistic geoMeanImpl) { +        this.sumImpl=geoMeanImpl; checkEmpty(); this.geoMeanImpl = geoMeanImpl; } 
1,"break; case REGULA_FALSI: // Nothing. -                    if (x == x1) { +                    if(x==x0){ x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } "
1,"double rhs = tableau.getEntry(i, tableau.getWidth() - 1); if (MathUtils.compareTo(tableau.getEntry(i, col), 0, epsilon) >= 0) { double ratio = rhs / tableau.getEntry(i, col); -                if (ratio < minRatio) { +                if(ratio<=minRatio){ minRatio = ratio; minRatioPos = i; } "
1,// flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { +                for(int k=0;k<0;k+=step){ final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; 
1,"final long a1 = (long) FastMath.floor(r1); p2 = (a1 * p1) + p0; q2 = (a1 * q1) + q0; -            if ((p2 > overflow) || (q2 > overflow)) { -                // in maxDenominator mode, if the last fraction was very close to the actual value -                // q2 may overflow in the next iteration; in this case return the last one. +            if((n<maxIterations)&&(FastMath.abs(value-value)>epsilon)){ throw new FractionConversionException(value, p2, q2); } "
0, // count the replacement text elements that are larger than their corresponding text being replaced for (int i = 0; i < searchList.length; i++) { +            if (searchList[i] == null || replacementList[i] == null) { +                continue; +            } int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) { increase += 3 * greater; // assume 3 matches 
0,case 'L' : if (dec == null && exp == null -                        && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { 
0,} Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { -            classes[i] = array[i].getClass(); +            classes[i] = array[i] == null ? null : array[i].getClass(); } return classes; } 
0,*/ public boolean contains(char ch) { char[] thisBuf = buffer; +    // start of generated patch +        for(int i=0;i<size;i++){ +          if(thisBuf[i]==ch){ +            return true; +          } +        } +    // end of generated patch +    /* start of original code for (int i = 0; i < thisBuf.length; i++) { if (thisBuf[i] == ch) { return true; } } +    end of original code*/ return false; } 
0,int start = pos.getIndex(); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { +            next(pos); return appendTo == null ? null : appendTo.append(QUOTE); } int lastHold = start; 
0,"private Node parseFunctionType(JsDocToken token) { // NOTE(nicksantos): We're not implementing generics at the moment, so // just throw out TypeParameters. +    // start of generated patch if (token != JsDocToken.LP) { +      restoreLookAhead(token); return reportTypeSyntaxWarning(""msg.jsdoc.missing.lp""); } +    // end of generated patch +    /* start of original code +        if (token != JsDocToken.LP) { +          return reportTypeSyntaxWarning(""msg.jsdoc.missing.lp""); +        } +     end of original code*/  Node functionType = newNode(Token.FUNCTION); Node parameters = null; "
0,"// For each named parameter check if a mutable argument use more than one. if (fnParam != null) { if (cArg != null) { +    // start of generated patch +          if(cArg==null&&NodeUtil.canBeSideEffected(cArg)){ +            return CanInlineResult.NO; +          } +    // end of generated patch +    /* start of original code if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { return CanInlineResult.NO; } +    end of original code*/ // Check for arguments that are evaluated more than once. // Note: Unlike block inlining, there it is not possible that a // parameter reference will be in a loop. "
0,"boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) { if (!rightType.canAssignTo(leftType)) { +    // start of generated patch +      if(!shouldReport&&(shouldReport||!NodeUtil.mayHaveSideEffects(n,t.getCompiler()))){ +        registerMismatch(rightType,leftType,null); +      }else { +        mismatch(t,n,msg,rightType,leftType); +      } +    // end of generated patch +    /* start of original code if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) { registerMismatch(rightType, leftType, null); } else { mismatch(t, n, msg, rightType, leftType); } +    end of original code*/ return false; } return true; "
0,"if (condition.isCall() && condition.getChildCount() == 2) { Node callee = condition.getFirstChild(); Node param = condition.getLastChild(); -      if (callee.isGetProp() && param.isQualifiedName()) { +      if (param.isName()||param.isGetProp()) { JSType paramType =  getTypeIfRefinable(param, blindScope); Node left = callee.getFirstChild(); Node right = callee.getLastChild();"
0,}  if (this.maxMiddleIndex >= 0) { -            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() +            long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart() .getTime(); -            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() +            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { 
0,"*/ public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) { +// start of generated patch +super(paint,stroke,outlinePaint,stroke,alpha); +this.value=value; +// end of generated patch +/* start of original code super(paint, stroke, paint, stroke, alpha); this.value = value; + end of original code*/ }  /** "
0,"public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); +         if (isNaN || rhs.isNaN) { +             return NaN; +         } return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); } "
0,"interpolator.storeTime(stepStart + stepSize); if (manager.evaluateStep(interpolator)) { final double dt = manager.getEventTime() - stepStart; +        // start of generated patch +            if(Math.abs(dt)<=Math.ulp(stepStart)){ +              System.arraycopy(y,0,yTmp,0,y0.length); +              stepSize=0; +              loop=false; +            }else { +              stepSize=dt; +            } +        // end of generated patch +        /* start of original code if (Math.abs(dt) <= Math.ulp(stepStart)) { // we cannot simply truncate the step, reject the current computation // and let the loop compute another state with the truncated step. // reject the step to match exactly the next switch time stepSize = dt; } +        end of original code*/ } else { loop = false; } "
0,}  double sumWts = 0; -                for (int i = 0; i < weights.length; i++) { +                for (int i = begin; i < begin + length; i++) { sumWts += weights[i]; } 
0,}  if (real == 0.0 && imaginary == 0.0) { -            return NaN; +            return INF; }  if (isInfinite) { 
0," // return the first endpoint if it is good enough double yMin = f.value(min); +        // start of generated patch +        if(Math.abs(yMin)<=functionValueAccuracy){ +          setResult(min,0); +          return result; +        } +        // end of generated patch +        /* start of original code if (Math.abs(yMin) <= functionValueAccuracy) { setResult(yMin, 0); return result; } +        end of original code*/  // reduce interval if min and initial bracket the root if (yInitial * yMin < 0) { "
