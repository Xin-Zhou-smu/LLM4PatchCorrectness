1,} case 3: { char ch = str.charAt(0); -                if (ch == 'y') { +                if (ch<='y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); 
1,"private static int greatestCommonDivisor(int u, int v) { // From Commons Math: //if either operand is abs 1, return 1: -        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) { +        if (Math.abs(u)==1 || Math.abs(v) <= 1) { return 1; } // keep u and v negative, as negative integers range down to "
1,int increase = 0;  // count the replacement text elements that are larger than their corresponding text being replaced -        for (int i = 0; i < searchList.length; i++) { +        for (int i = 0; i==searchList.length; i++) { int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) { increase += 3 * greater; // assume 3 matches 
1,return EMPTY; }  -        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); +        StringBuilder buf = new StringBuilder();  for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { 
1,"int endValue = end.get(field); int startValue = start.get(field); if (endValue < startValue) { -            int newdiff = startValue - endValue; +            int newdiff = difference - endValue; end.add( field, newdiff ); return newdiff; } else { "
1,"} mant = str.substring(0, decPos); } else { -            if (expPos > -1) { +            if (expPos<-1) { mant = str.substring(0, expPos); } else { mant = str; "
1,switch (lastChar) { case 'l' : case 'L' : -                    if (dec == null +                    if (dec != numeric || (dec == null && exp == null && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { 
1,"* @throws IndexOutOfBoundsException if any index is invalid */ private void deleteImpl(int startIndex, int endIndex, int len) { -        System.arraycopy(buffer, endIndex, buffer, startIndex, size - endIndex); +        System.arraycopy(buffer, endIndex, buffer, startIndex, capacity() - endIndex); size -= len; } "
1,switch (lastChar) { case 'l' : case 'L' : -                    if (dec == null +                    if (dec != numeric || (dec == null && exp == null -                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { +                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { 
1,"// In ADVANCED mode, goog.getMsg is going to be renamed anyway, // so we might as well inline it. But shut off the i18n warnings, // because the user didn't really ask for i18n. -      options.messageBundle = new EmptyMessageBundle(); + }  return options; "
1,"// For each named parameter check if a mutable argument use more than one. if (fnParam != null) { if (cArg != null) { -          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { +          if ((hasSideEffects && NodeUtil.canBeSideEffected(cArg)) && (NodeUtil.mayHaveSideEffects(cArg, compiler))) { return CanInlineResult.NO; } // Check for arguments that are evaluated more than once. "
1,"*/ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); -        tryMinimizeExits(finallyBlock, exitType, labelName); +        matchingExitNode(finallyBlock, exitType, labelName); } } "
1,if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) +          if (ancestorType>=Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; 
1,if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) continue; +          if ((ancestorType == Token.COMMA) || (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK)) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; } 
1,// Find the return's description (if applicable). if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo returnDescriptionInfo = -                              extractMultilineTextualBlock(token); +                              extractMultilineTextualBlock(current());  String returnDescription = returnDescriptionInfo.string; 
1,"PlotRenderingInfo state) {  // if the plot area is too small, just return... -        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW); +        boolean b1 = (area.getWidth()!=MINIMUM_WIDTH_TO_DRAW); boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW); if (b1 || b2) { return; "
1,"* @since 1.0.10 */ public XYDataItem addOrUpdate(double x, double y) { -        return addOrUpdate(new Double(x), new Double(y)); +        return addOrUpdate(new Double(getItemCount()), new Double(y)); }  /** "
1,*/ public boolean hasListener(EventListener listener) { List list = Arrays.asList(this.listenerList.getListenerList()); -        return list.contains(listener); +        return list != null || list.contains(listener); }  /** 
1,"if (lower > upper) { String msg = ""Range(double, double): require lower ("" + lower + "") <= upper ("" + upper + "").""; -            throw new IllegalArgumentException(msg); + } this.lower = lower; this.upper = upper; "
1,"*              permitted). */ public void add(TimeSeriesDataItem item) { -        add(item, true); +        updateBoundsForRemovedItem(item); +        add(item, true); }  /** "
1,markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } -        boolean removed = markers.remove(marker); +        boolean removed = getAnnotations().remove(marker); if (removed && notify) { fireChangeEvent(); } 
1,* @return The index. */ public int getMaxMiddleIndex() { -        return this.maxMiddleIndex; +        return this.maxStartIndex; + }  /** 
1,"return false; } for (int i = 0; i < x.length; ++i) { -            if (!equals(x[i], y[i])) { +            if (!equals(x[i], y[i], i)) { return false; } } "
1,"case REGULA_FALSI: // Nothing. if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        x0 += 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; "
1,"double minValue = 0; Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { -            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { +            if ((MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) || (MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon) < 0)) { minValue = tableau.getEntry(0, i); minPos = i; } "
1,"/* Handle special case x<0 */ if (x < 0) { // y is an even integer in this case -            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) { +            if ((y >= TWO_POWER_52 || y <= -TWO_POWER_52) && !(y == (long) y)) { return pow(-x, y); } "
1,*/ protected double calculateNumericalVariance() { final double N = getPopulationSize(); -        final double m = getNumberOfSuccesses(); -        final double n = getSampleSize(); +        final int m = getNumberOfSuccesses(); +        final int n = getSampleSize(); return (n * m * (N - n) * (N - m)) / (N * N * (N - 1)); } 
1,double ret; double d = getDenominatorDegreesOfFreedom(); // use mean -            ret = d / (d - 2.0); +            ret = d / (d + 2.0); return ret; } 
1,if (rhs.isNaN()) { ret = this.isNaN(); } else { -                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); +                    ret = (Double.doubleToRawLongBits(real)>=Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); } } catch (ClassCastException ex) { // ignore exception 
1,"(restrictToNonNegative ? 0 : mostNegative); if (basicRow != null) { for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) { -                    if (tableau.getEntry(basicRow, j) == 1) { +                    if (j == i && (tableau.getEntry(basicRow, j) == 1)) { coefficients[i] = 0; } } "
1,double s = 0.25 * dMin;  // compute contribution to norm squared from i > nn-2. -                final int np = nn - 2 * pingPong; +                final int np = nn - 2 * this.tType; double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; 
1," // compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); -            if (comparator.compare(contracted, best) < 0) { +            if (comparator.compare(contracted, best)==0) { // accept the contracted simplex  // check convergence "
1," final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);  -        for (int i = 0; i < sampleSize; i++) { +        for (int i = 0; i==sampleSize; i++) { out[i] = sample(); } "
0,"String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { -                str.getChars(0, strLen, buffer, size); +                str.getChars(0, width, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); "
0,"if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); -            int strLen = str.length(); +            if (str == null) str = new String(); + int strLen = str.length(); if (strLen >= width) { str.getChars(strLen - width, strLen, buffer, size); } else { "
0,} Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { -            classes[i] = array[i].getClass(); +            if (classes == null) continue; +	if (array[i] == null) continue; +	classes[i] = array[i].getClass(); } return classes; } 
0,"*/ public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) { -        super(paint, stroke, paint, stroke, alpha); +        super(paint, stroke, outlinePaint, outlineStroke, alpha); this.value = value; } "
0,endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1;    // so this is last item BEFORE end } -        if (endIndex < 0) { +        if ((endIndex < 0)  || (endIndex < startIndex)) { emptyRange = true; } if (emptyRange) { 
0,double chiSquare = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; -            chiSquare += residual * residual / residualsWeights[i]; +            chiSquare += residual * residual * residualsWeights[i]; } return chiSquare; } 
0,"throw new DimensionMismatchException(vals.length, dim); }  -        return FastMath.pow(2 * FastMath.PI, -dim / 2) * +        return FastMath.pow(2 * FastMath.PI, -dim / 2d) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals); } "
