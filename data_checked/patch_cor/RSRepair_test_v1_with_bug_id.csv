1,"throw new NumberFormatException(""A blank string is not a valid number""); } if (str.startsWith(""--"")) { -            return null; +            return Short.parseShort(str); } if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) { int hexDigits = str.length() - 2; // drop 0x ",Lang-7
1,"return readObject;  } catch (ClassNotFoundException ex) { -            throw new SerializationException(""ClassNotFoundException while reading cloned object data"", ex); +            return object; } catch (IOException ex) { throw new SerializationException(""IOException while reading cloned object data"", ex); } finally { ",Lang-13
1,"*/ protected void error(DiagnosticType diagnostic, Node n) { JSError error = currentTraversal.makeError(n, diagnostic, n.toString()); -    currentTraversal.getCompiler().report(error); }  /** ",Closure-78
1,return; } if (n == parent.getLastChild()) { -        for (Node an : parent.getAncestors()) { -          int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; -          else break; -        } +        int index = -1; } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) { ,Closure-21
1,boolean canRemove = false;  if (specializationState == null) { -            canRemove = true; } else { Node specializableFunction = getSpecializableFunctionFromSymbol(declaration); ,Closure-67
1,for (Reduction reduction : reductions) { savings += reduction.estimateSavings(); } - -      // Compare estimated savings against the helper cost.  Apply -      // reductions if doing so will result in some savings. -      if (savings > (helperCodeCost + SAVINGS_THRESHOLD)) { -        for (Reduction reduction : reductions) { -          reduction.apply(); -        } - -        Node addingRoot = compiler.getNodeForCodeInsertion(null); -        addingRoot.addChildrenToFront(helperCode); -        compiler.reportCodeChange(); -      } } } ,Closure-55
1,"return allResultsMatch(n.getFirstChild(), p) && allResultsMatch(n.getLastChild(), p); case Token.HOOK: -        return allResultsMatch(n.getFirstChild().getNext(), p) -            && allResultsMatch(n.getLastChild(), p); +        int type = n.getType(); default: return p.apply(n); } ",Closure-10
1,"if (t.getScope().isGlobal()) { // Update global scope reference lists when we are done with it. compiler.updateGlobalVarReferences(referenceMap, t.getScopeRoot()); -      behavior.afterExitScope(t, compiler.getGlobalVarReferences()); } else { behavior.afterExitScope(t, new ReferenceMapWrapper(referenceMap)); } ",Closure-120
1, // checkSuspiciousCode needs to be enabled for CheckGlobalThis to get run. options.checkSuspiciousCode = true; -    options.checkGlobalThisLevel = CheckLevel.WARNING; options.checkSymbols = true; options.checkMissingReturn = CheckLevel.WARNING; ,Closure-59
1,// This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n == parent.getLastChild()) { -        for (Node an : parent.getAncestors()) { -          int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) -            continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) -            return; -          else -            break; -        } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || ,Closure-22
1,break;  case Token.STRING: -        return getStringNumberValue(n.getString()); +        break;  case Token.ARRAYLIT: case Token.OBJECTLIT: ,Closure-75
1,"typeToInfer = getNativeType(JSTypeNative.VOID_TYPE) .getLeastSupertype(propType); } -          defineInferredProperty(prop, typeToInfer, null); } } } ",Closure-33
1,} res = n.checkTreeEqualsImpl(n2); if (res != null) { -        return res; +        return null; } } return res; ,Closure-61
1,"parent.replaceChild(node, block); } else { for (Node newChild : replacements) { -        newChild.copyInformationFrom(node); parent.addChildBefore(newChild, node); } parent.removeChild(node);   }  if (parent.isAssign()) { -        return scopes.get(parent); } } ",Closure-114
1,"public void process(Node externs, Node root) { ReferenceCollectingCallback callback = new ReferenceCollectingCallback( compiler, new InliningBehavior(), getFilterForMode()); -    callback.process(externs, root); }  private Predicate<Var> getFilterForMode() { ",Closure-121
1,"// To protect against this, we simply only inline when the left side // is guaranteed to evaluate to the same L-value no matter what. Node leftSide = next.getFirstChild(); -          if (leftSide.isName() || -              leftSide.isGetProp() && -              leftSide.getFirstChild().isThis()) { -            // Dive down the right side of the assign. -            parent = next; -            next = leftSide.getNext(); -            break; -          } else { -            return false; -          } +          ;  default: if (NodeUtil.isImmutableValue(next) ",Closure-124
1,"Iterable<Node> declParams, Iterable<Node> callParams, Map<TemplateType, JSType> resolvedTypes) { -    maybeResolveTemplateTypeFromNodes( -        declParams.iterator(), callParams.iterator(), resolvedTypes); }  private void maybeResolveTemplateTypeFromNodes( ",Closure-112
1,"existing.setY(y); } else { -            // if the series is sorted, the negative index is a result from -            // Collections.binarySearch() and tells us where to insert the -            // new item...otherwise it will be just -1 and we should just -            // append the value to the list... -            if (this.autoSort) { -                this.data.add(-index - 1, new XYDataItem(x, y)); -            } -            else { -                this.data.add(new XYDataItem(x, y)); -            } +            this.data.add(new XYDataItem(x, y)); // check if this addition will exceed the maximum item count... if (getItemCount() > this.maximumItemCount) { this.data.remove(0); ",Chart-5
1,"new Font(""SansSerif"", Font.BOLD, 12)); seriesTitle.setPosition(RectangleEdge.BOTTOM); this.pieChart.setTitle(seriesTitle); -        this.aggregatedItemsKey = ""Other""; +        if (dataset != null) { +            dataset.addChangeListener(this); +        } +        this.aggregatedItemsKey = ""Other""; this.aggregatedItemsPaint = Color.lightGray; this.sectionPaints = new HashMap(); } ",Chart-12
1,"Number result = null; MeanAndStandardDeviation masd = (MeanAndStandardDeviation) this.data.getObject(row, column); -        if (masd != null) { -            result = masd.getMean(); -        } return result; }   rectY = rectY + row * (state.getBarWidth() + seriesGap); } else { -            rectY = rectY + row * state.getBarWidth(); +            RectangleEdge rangeAxisLocation = plot.getRangeAxisEdge(); +            rectY = rectY + row * state.getBarWidth(); }  // BAR X ",Chart-25
1,"LengthConstraintType.RANGE, 0.0, null, LengthConstraintType.NONE); Size2D size = this.rightBlock.arrange(g2, c3); -            w[3] = size.width; h[3] = size.height; }   if (lower > upper) { String msg = ""Range(double, double): require lower ("" + lower + "") <= upper ("" + upper + "").""; -            throw new IllegalArgumentException(msg); +            Comparable result = null; } this.lower = lower; this.upper = upper; ",Chart-13
1,"// positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } }  // non-basic artificial variables ",Math-33
1,} } } -                return minRow; } return minRatioPositions.get(0); } ,Math-28
1,"((a > lowerBound) || (b < upperBound)));  if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); }  return new double[]{a, b};   if (Math.abs(rootFindingFunction.value(lowerBound)) < 1E-6) { return lowerBound; } -            if (Math.abs(rootFindingFunction.value(upperBound)) < 1E-6) { -                return upperBound; -            } // Failed bracket convergence was not because of corner solution throw new MathException(ex); } ",Math-85
1,if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; -            for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; -                } -                j -= 4; -            } +            int mBlockIndex = 0; return true; } return false; ,Math-80
1,protected double getInitialDomain(double p) { double ret; double d = getDenominatorDegreesOfFreedom(); -            // use mean -            ret = d / (d - 2.0); +            ret = 1.0; return ret; } ,Math-95
1," while (true) {  -            incrementIterationsCounter(); +            final double[] xSmallest = simplex[0].getPointRef(); +            incrementIterationsCounter();  // save the original vertex final RealPointValuePair[] original = simplex;  // compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); -            if (comparator.compare(contracted, best) < 0) { -                // accept the contracted simplex - -            // check convergence -                return; -            } +            return;  } ",Math-84
1,// calculate series double n = 0.0; // current element index double an = 1.0 / a; // n-th element in the series -            double sum = an; // partial sum +            if (Double.isNaN(x) || (x <= 0.0)) { +                ret = Double.NaN; +            } else { +                double g = 607.0 / 128.0; +                double sum = 0.0; +                for (int i = lanczos.length - 1; i > 0; --i) { +                    sum = sum + (lanczos[i] / (x + i)); +                } +                sum = sum + lanczos[0]; +                double tmp = x + g + .5; +                ret = ((x + .5) * Math.log(tmp)) - tmp + HALF_LOG_2_PI + Math.log(sum / x); +            } +            double sum = an; // partial sum while (Math.abs(an) > epsilon && n < maxIterations) { // compute next element in the series n = n + 1.0; sum = sum + an; } if (n >= maxIterations) { -                throw new MaxIterationsExceededException(maxIterations); } else { ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum; } ,Math-103
1,if (!((nextX > xA) && (nextX < xB))) { // the guessed root is not strictly inside of the tightest bracketing interval  -                    // the guessed root is either not strictly inside the interval or it +                    signChangeIndex = 2; +                    // the guessed root is either not strictly inside the interval or it // is a NaN (which occurs when some sampling points share the same y) // we try again with a lower interpolation order if (signChangeIndex - start >= end - signChangeIndex) { ,Math-40
1,"return; }  -            // compute the Newton correction -            for (int j = 0; j < solvedCols; ++j) { -                int pj = permutation[j]; -                work1[pj] = work3[pj] * diag[pj] / dxNorm; -            } for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] /= work2[j]; // depending on the sign of the function, update parl or paru. if (fp > 0) { parl = FastMath.max(parl, lmPar); -            } else if (fp < 0) { -                paru = FastMath.min(paru, lmPar); -            } +            } else { +                for (int j = rank; j < cols; ++j) { +                    lmDir[permutation[j]] = 0; +                } +                if (fp < 0) { +                    paru = FastMath.min(paru, lmPar); +                } +            }  // compute an improved estimate for lmPar lmPar = FastMath.max(parl, lmPar + correction); ",Math-58
1,final int np = nn - 2 * pingPong; double b1 = work[np - 2]; double b2 = work[np - 6]; -                final double gam = dN2; +                b2 = work[nn - 5] / work[nn - 7]; +                final double gam = dN2; if (work[np - 8] > b2 || work[np - 4] > b1) { return; } ,Math-81
0,"Preconditions.checkState(block.hasOneChild()); Node stmt = block.getFirstChild(); if (stmt.isReturn()) { -        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler); +        int start = 0; } } // CALL NODE: [ NAME, ARG1, ARG2, ... ] ",Closure-115
0,"* can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ -      if (NodeUtil.hasFinally(n)) { -        Node finallyBlock = n.getLastChild(); -        tryMinimizeExits(finallyBlock, exitType, labelName); -      } }  // Just a 'label'. ",Closure-126
