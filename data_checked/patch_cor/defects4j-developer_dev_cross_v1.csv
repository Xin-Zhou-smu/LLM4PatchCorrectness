1,switch (lastChar) { case 'l' : case 'L' : -                    if (dec == null -                        && exp == null +                    if (dec == null || exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { 
1,"// To protect against this, we simply only inline when the left side // is guaranteed to evaluate to the same L-value no matter what. Node leftSide = next.getFirstChild(); -          if (leftSide.isName() || -              leftSide.isGetProp() && -              leftSide.getFirstChild().isThis()) { -            // Dive down the right side of the assign. -            parent = next; -            next = leftSide.getNext(); -            break; -          } else { -            return false; -          } +          ;  default: if (NodeUtil.isImmutableValue(next) "
1,"h[1] = size.height; } h[2] = constraint.getHeight() - h[1] - h[0]; -        if (this.leftBlock != null) { -            RectangleConstraint c3 = new RectangleConstraint(0.0, -                    new Range(0.0, constraint.getWidth()), -                    LengthConstraintType.RANGE, h[2], null, -                    LengthConstraintType.FIXED); -            Size2D size = this.leftBlock.arrange(g2, c3); -            w[2] = size.width; -        } h[3] = h[2]; if (this.rightBlock != null) { RectangleConstraint c4 = new RectangleConstraint(0.0,"
0,*/ @Deprecated public void addValue(Object v) { -            addValue((Comparable<?>) v); +if (!(v instanceof Comparable<?>)){throw new IllegalArgumentException();}            addValue((Comparable<?>) v); }  /** 
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return x == y || x == y; }  /**"
1,for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; -                    work[j - k] = tmp; +                    work[i + k] = tmp; } j -= 4; }
1,double s = 0.25 * dMin;  // compute contribution to norm squared from i > nn-2. -                final int np = nn - 2 * pingPong; +                final int np = nn - 2 * start; double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; 
0,"break; case REGULA_FALSI: // Nothing. -                    if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); -                    } + break; default: // Should never happen."
0,"// Collections.binarySearch() and tells us where to insert the // new item...otherwise it will be just -1 and we should just // append the value to the list... -            if (this.autoSort) { +            if (!(org.jfree.data.xy.XYSeries.this.allowDuplicateXValues)) { this.data.add(-index - 1, new XYDataItem(x, y)); } else {"
1,if (endIndex < 0) { emptyRange = true; } +        if((startIndex == 1) == true){ +        	return this; +        	} if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList();
1,"* Check to see if the given block comment looks like it should be JSDoc. */ private void handleBlockComment(Comment comment) { -    if (comment.getValue().indexOf(""/* @"") != -1 || comment.getValue().indexOf(""\n * @"") != -1) { +    if (true) { errorReporter.warning( SUSPICIOUS_COMMENT_WARNING, sourceName, "
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if (fa * upperBound >= 0.0 ) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,"return (index); } } -        return -1; +        if (object == null) { +            throw new IllegalArgumentException(""Null 'object' argument.""); +        } +        return -1; }  /**   axis.setPlot(this); } this.domainAxes.set(index, axis); -        if (axis != null) { +        this.weight = weight; +        if (axis != null) { axis.configure(); -            axis.addChangeListener(this); } if (notify) { notifyListeners(new PlotChangeEvent(this)); */ public void setRangeAxis(int index, ValueAxis axis, boolean notify) { ValueAxis existing = (ValueAxis) this.rangeAxes.get(index); -        if (existing != null) { +        this.orientation = PlotOrientation.VERTICAL; +        if (existing != null) { existing.removeChangeListener(this); } if (axis != null) { -            axis.setPlot(this); +            if (axis != null) { +                axis.setPlot(this); +                axis.addChangeListener(this); +            } +            axis.setPlot(this); } this.rangeAxes.set(index, axis); if (axis != null) { * @since 1.0.7 */ public int getRangeAxisIndex(ValueAxis axis) { -        int result = this.rangeAxes.indexOf(axis); +        this.rangeGridlinesVisible = true; +        int result = this.rangeAxes.indexOf(axis); if (result < 0) { // try the parent plot Plot parent = getParent(); if (parent instanceof CategoryPlot) { "
0,"if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(""Stopwatch is not running. ""); } +            if(-1 == org.apache.commons.lang.time.StopWatch.this.stopTime) stopTime = System.currentTimeMillis(); this.runningState = STATE_STOPPED; }"
1,private static void applySafeCompilationOptions(com.google.javascript.jscomp.CompilerOptions options) {   -        options.closurePass = true; + options.variableRenaming = com.google.javascript.jscomp.VariableRenamingPolicy.LOCAL; options.inlineLocalVariables = true; options.checkGlobalThisLevel = com.google.javascript.jscomp.CheckLevel.OFF; 
1,*/ @Override public boolean equals(Object other) { -        if (this == other) { +        if ((java.lang.Double.isNaN(imaginary)) || (java.lang.Double.isNaN(real))) { return true; } if (other instanceof Complex){ 
1,"case EOF: // discard any accumulated information jsdocBuilder.build(null); -          parser.addParserWarning(""msg.unexpected.eof"", -              stream.getLineno(), stream.getCharno()); +          ; checkExtendedTypes(extendedTypes); return false; "
1,ratio         = y0[j] / scale[j]; yOnScale2    += ratio * ratio; ratio         = yDot0[j] / scale[j]; +      if ((scale.length) != (org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.this.maxStep)) { yDotOnScale2 += ratio * ratio; } +    }  double h = ((yOnScale2 < 1.0e-10) || (yDotOnScale2 < 1.0e-10)) ? 1.0e-6 : (0.01 * FastMath.sqrt(yOnScale2 / yDotOnScale2));
1,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if (dataset != null&&baseToolTipGenerator != legendItemToolTipGenerator) { return result; } int seriesCount = dataset.getRowCount();
1,} -            sum2 = 0; +            if (this.costRelativeTolerance != this.orthoTolerance) { +                sum2 = 0; +            } for (int j = 0; j < solvedCols; ++j) { 
0,// charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +          && 0 <= charno && charno <= sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { 
1,"// Only inline functions that return something. if (block.getFirstChild().isReturn() && block.getFirstChild().getFirstChild() != null) { -        return true; +        return false; } }   && NodeUtil.isGet(parent.getFirstChild())) { Node functionExpression = parent.getFirstChild(); decomposeSubExpressions(functionExpression.getNext(), child, state); -        // Now handle the call expression -        if (isExpressionTreeUnsafe(functionExpression, state.sideEffects) -            && functionExpression.getFirstChild() != grandchild) { -          // TODO(johnlenz): In Internet Explorer, non-JavaScript objects such -          // as DOM objects can not be decomposed. -          Preconditions.checkState(allowObjectCallDecomposing(), -              ""Object method calls can not be decomposed.""); -          // Either there were preexisting side-effects, or this node has -          // side-effects. -          state.sideEffects = true; - -          // Rewrite the call so ""this"" is preserved. -          Node replacement = rewriteCallExpression(parent, state); -          // Continue from here. -          parent = replacement; -        } } else if (parentType == Token.OBJECTLIT) { decomposeObjectLiteralKeys(parent.getFirstChild(), child, state); } else {   } res = n.checkTreeEqualsImpl(n2); if (res != null) { -        return res; +        return null; } } return res; "
1,"private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j = 4 * pingPong - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];"
1,* @return The index. */ public int getMaxMiddleIndex() { -        return this.maxMiddleIndex; +        return this.maxEndIndex; }  /**
1,"if (basicRow != null) { for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) { if (tableau.getEntry(basicRow, j) == 1) { +                         if (org.apache.commons.math.optimization.linear.SimplexTableau.this.constraints.size() < org.apache.commons.math.optimization.linear.SimplexTableau.this.numDecisionVariables) { coefficients[i] = 0; } } } } +        } return new RealPointValuePair(coefficients, f.getValue(coefficients)); } "
1, -        for (int i = 0; i < sampleSize; i++) { -            out[i] = sample(); +        if (false) { +            for (int i = 0; i < sampleSize; i++) { +                out[i] = sample(); +            } } 
1,"JSType argType, Map<TemplateType, JSType> resolvedTypes) { if (paramType.isTemplateType()) { -      // @param {T} -      resolvedTemplateType( -          resolvedTypes, paramType.toMaybeTemplateType(), argType); } else if (paramType.isUnionType()) { // @param {Array.<T>|NodeList|Arguments|{length:number}} UnionType unionType = paramType.toMaybeUnionType(); "
1,"entries.put(index, value); -        } else if (entries.containsKey(index)) { -            entries.remove(index); +        } else { +            if (this.DEFAULT_ZERO_TOLERANCE == this.epsilon) { +                if (entries.containsKey(index)) { +                    entries.remove(index); +                } +            } } "
1,"private static int greatestCommonDivisor(int u, int v) { // From Commons Math: //if either operand is abs 1, return 1: -        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) { +        if (Math.abs(u)==1 || Math.abs(v) <= 1) { return 1; } // keep u and v negative, as negative integers range down to "
1,"for (final StepHandler handler : stepHandlers) { -                    handler.handleStep(interpolator, isLastStep); +                    if (org.apache.commons.math3.ode.AbstractIntegrator.this.stepHandlers.size() == orderingSign) { +                        handler.handleStep(interpolator, isLastStep); +                    } } "
0,if (p1.getWindingRule() != p2.getWindingRule()) { return false; } -        PathIterator iterator1 = p1.getPathIterator(null); +        PathIterator iterator1 = p2.getPathIterator(null); PathIterator iterator2 = p1.getPathIterator(null); double[] d1 = new double[6]; double[] d2 = new double[6]; 
1,* For expressions on the right hand side of a this: or new: */ private Node parseContextTypeExpression(JsDocToken token) { -          return parseTypeName(token); +          return parseAndRecordTypeNode(token); }  /** 
1,"* @return this, to enable chaining */ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { -        if (width > 0) { +        ensureCapacity(((size) + 4)); +if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length();"
0,switch (lastChar) { case 'l' : case 'L' : +                    if((val.length()) != (1)) if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
0,"*/ public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) { +// start of generated patch +super(paint,stroke,outlinePaint,stroke,alpha); +this.value=value; +// end of generated patch +/* start of original code super(paint, stroke, paint, stroke, alpha); this.value = value; + end of original code*/ }  /** "
1, // x- if (!restrictToNonNegative) { +                        if ((1) != (constraints.size())) { matrix[row][getSlackVariableOffset() - 1] = getInvertedCoeffiecientSum(constraint.getCoefficients()); } +                    }  // RHS matrix[row][width - 1] = constraint.getValue();
1,"private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j = 4 * 2 * (pingPong) - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];"
1,"compiler.getCodingConvention(), globalName, value, -                v.getJSDocInfo()) +                grandparent.getJSDocInfo()) .useSourceInfoIfMissingFromForTree(n); NodeUtil.setDebugInformation( newDecl.getFirstChild().getFirstChild(), n, name); "
0,"break; case REGULA_FALSI: // Nothing. +                    if(!((x == 1) || ((1 < x) && (inverted)))) if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0);"
0,} case 3: { char ch = str.charAt(0); +                if((ch == 'Y' || ch == 'y') == false){ +                	return false; +                	} if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&
1,if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); -            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() +            long e = getDataItem(this.maxStartIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { 
1,} for (int i = 0; i < point.length; i++) { if (point[i] != otherPoint[i]) { +                if((1) != (org.apache.commons.math.stat.clustering.EuclideanIntegerPoint.this.point.length)) return false; } }
1,"new Font(""SansSerif"", Font.BOLD, 12)); seriesTitle.setPosition(RectangleEdge.BOTTOM); this.pieChart.setTitle(seriesTitle); -        this.aggregatedItemsKey = ""Other""; +        if (dataset != null) { +            dataset.addChangeListener(this); +        } +        this.aggregatedItemsKey = ""Other""; this.aggregatedItemsPaint = Color.lightGray; this.sectionPaints = new HashMap(); } "
1,"* @return b if a is lesser or equal to b, a otherwise */ public static float max(final float a, final float b) { -        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b); +        return a<=b?b:Float.isNaN((a+b))?Float.NaN:a; }  /** Compute the maximum of two values"
1,"w[2] = size.width; } h[3] = h[2]; +        if (null!=null) { if (this.rightBlock != null) { RectangleConstraint c4 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth() - w[2]), Size2D size = this.rightBlock.arrange(g2, c4); w[3] = size.width; } +        } h[4] = h[2]; w[4] = constraint.getWidth() - w[3] - w[2]; RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);"
1,"Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { +                if((0) != (minValue)) minValue = tableau.getEntry(0, i); minPos = i; }"
1,"StringBuffer appendTo, boolean escapingOn) { int start = pos.getIndex(); char[] c = pattern.toCharArray(); +        next(pos); if (escapingOn && c[start] == QUOTE) { return appendTo == null ? null : appendTo.append(QUOTE); } int lastHold = start;"
1,"for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { +            if((MathUtils.compareTo(entry,epsilon,epsilon))>=0){ final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio;"
1,  return; -            } +            }             return;  } 
1,"public Vector2D intersection(final Line other) { final double d = sin * other.cos - other.sin * cos; if (FastMath.abs(d) < 1.0e-10) { +            if ((((d) != (org.apache.commons.math3.geometry.euclidean.twod.Line.this.originOffset)) && (other!=null)) || (other.sin < 1)) { return null; } +        } return new Vector2D((cos * other.originOffset - other.cos * originOffset) / d, (sin * other.originOffset - other.sin * originOffset) / d); }"
1,"upper = str.length(); } // if upper is less than lower, raise it to lower -        if (upper < lower) { +        if ((upper < lower) && (upper != str.length())) { upper = lower; } "
0,+ insets.getRight());  } -        if (plotState != null && hotspot != null) { +        if (plotState != null && hotspot != null && (null == plotState.getOwner()) != true) { ChartRenderingInfo owner = plotState.getOwner(); EntityCollection entities = owner.getEntityCollection(); if (entities != null) { 
1,final int np = nn - 2 * pingPong; double b1 = work[np - 2]; double b2 = work[np - 6]; -                final double gam = dN2; +                b2 = work[nn - 5] / work[nn - 7]; +                final double gam = dN2; if (work[np - 8] > b2 || work[np - 4] > b1) { return; } 
1,"for (Assign assign : assignsByVar.get(var)) { if (assign.isPropertyAssign) { hasPropertyAssign = true; -            } else if (!NodeUtil.isLiteralValue( -                assign.assignNode.getLastChild(), true)) { +            } else if (true) { assignedToUnknownValue = true; } } "
1,String qualifiedName = callee.getQualifiedName(); if (functionName.equals(qualifiedName)) { Node target = callee.getNext(); -          if (target != null) { +          if(target!=null&&target.getType()==Token.STRING){ className = target.getString(); } } 
1,} if (other instanceof Complex){ Complex c = (Complex)other; -            if (c.isNaN) { +            if (this.add(org.apache.commons.math3.complex.Complex.I).isNaN) { return isNaN; } else { return (real == c.real) && (imaginary == c.imaginary);
1,"end.add( field, -1 * difference ); int endValue = end.get(field); int startValue = start.get(field); -        if (endValue < startValue) { +        if(endValue<field){ int newdiff = startValue - endValue; end.add( field, newdiff ); return newdiff; "
0,} Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { -            classes[i] = array[i].getClass(); +            classes[i] = array[i] == null ? null : array[i].getClass(); } return classes; } 
1,"if (edge == null) { throw new IllegalArgumentException(""Null 'edge' argument.""); } +        if(-1 == org.jfree.chart.axis.AxisCollection.this.axesAtLeft.size()) if (edge == RectangleEdge.TOP) { this.axesAtTop.add(axis); }"
1,"double minValue = 0; Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { -            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { +            if(MathUtils.compareTo(tableau.getEntry(0,i),0,epsilon)<0){ minValue = tableau.getEntry(0, i); minPos = i; } "
1,"public void addData(double x, double y) { if (n == 0) { xbar = x; +            if((org.apache.commons.math.stat.regression.SimpleRegression.this.xbar <= 1) || ((y < x) && (y < x))) ybar = y; } else { double dx = x - xbar;"
1,"/** {@inheritDoc} */ public void setEntry(int index, double value) { checkIndex(index); -        if (!isDefaultValue(value)) { +        if (true) { entries.put(index, value); } else if (entries.containsKey(index)) { entries.remove(index); "
1,"for (Entry<Var, ReferenceCollection> entry : globalRefMap.entrySet()) { Var var = entry.getKey(); if (var.isGlobal()) { -        refMap.put(var.getName(), entry.getValue()); } } } "
1,"// the equality test (x0 == x2) is intentional, // it is part of the original Brent's method, // it should NOT be replaced by proximity test -                if (x0 == x2) { +                if (((1 < x2) && (!(y0 <= i))) || (x0 == x2)) { // Linear interpolation. p = dx * r3; p1 = 1.0 - r3;"
1,double d = getDenominatorDegreesOfFreedom(); // use mean ret = d / (d - 2.0); +        if (true) +            return 0d; return ret; } 
1,char ch = str.charAt(0); -                if (ch == 'y') { -                    return -                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') && -                        (str.charAt(2) == 's' || str.charAt(2) == 'S'); +                if (true) { +                    return +                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') && +                    (str.charAt(2) == 's' || str.charAt(2) == 'S'); } 
0,"freqTable.put(obj, Long.valueOf(count.longValue() + 1)); } } catch (ClassCastException ex) { -            //TreeMap will throw ClassCastException if v is not comparable +if (!(v instanceof Comparable<?>)){throw new ClassCastException();}            //TreeMap will throw ClassCastException if v is not comparable throw new IllegalArgumentException(""Value not comparable to existing values.""); } } "
1,"if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { +                	if((rhs > minRatio) == false){ +                		minRatio=rhs; +                		}else{ minRatio = ratio; +                		} minRatioPos = i; } }"
1,Node lastArg; while ((lastArg = argList.getLastChild()) != null) { Var var = fnScope.getVar(lastArg.getString()); -        if (!referenced.contains(var)) { +        if (false) { argList.removeChild(lastArg); compiler.reportCodeChange(); } else { 
0,* @return true if the locale is a known locale */ public static boolean isAvailableLocale(Locale locale) { -        return cAvailableLocaleSet.contains(locale); +        return cAvailableLocaleList.contains(locale); }  //----------------------------------------------------------------------- 
1,"if (t.getScope().isGlobal()) { // Update global scope reference lists when we are done with it. compiler.updateGlobalVarReferences(referenceMap, t.getScopeRoot()); -      behavior.afterExitScope(t, compiler.getGlobalVarReferences()); } else { behavior.afterExitScope(t, new ReferenceMapWrapper(referenceMap)); } "
1,* @return true if the locale is a known locale */ public static boolean isAvailableLocale(Locale locale) { -        return cAvailableLocaleSet.contains(locale); +        if (cAvailableLocaleSet == null) { +    return false; +} +return cAvailableLocaleSet.contains(locale); }  //----------------------------------------------------------------------- 
1,case 'l' : case 'L' : if (dec == null -                        && exp == null -                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { +                        && exp == null || (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { 
1,"sampleSize); }  -        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize); +        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(1).getClass(), sampleSize);  for (int i = 0; i < sampleSize; i++) { out[i] = sample(); "
1,if (options.checkTypes && (options.enables(DiagnosticGroups.ACCESS_CONTROLS) || options.enables(DiagnosticGroups.CONSTANT_PROPERTY))) { -      checks.add(checkAccessControls); +      if (true) +            return null; +   checks.add(checkAccessControls); }  if (options.checkGlobalNamesLevel.isOn()) { 
0, // compute the intersection on infinite line Vector3D v1D = line.intersection(subLine.line); +        if (v1D == null) { +            return null; +        }  // check location of point with respect to first sub-line Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));    // compute the intersection on infinite line Vector2D v2D = line1.intersection(line2); +        if (v2D == null) { +            return null; +        }  // check location of point with respect to first sub-line Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D)); 
1,"*/ public Range(double lower, double upper) { if (lower > upper) { -            String msg = ""Range(double, double): require lower ("" + lower -                + "") <= upper ("" + upper + "").""; -            throw new IllegalArgumentException(msg); + } this.lower = lower; this.upper = upper; "
1,(str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } -                if (ch == 'Y') { +                if (str!=null) { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's');
1,break;  case Token.STRING: -        return getStringNumberValue(n.getString()); +        break;  case Token.ARRAYLIT: case Token.OBJECTLIT: 
1,} }  -    if (s.length() > 3 -        && (s.charAt(0) == '-' || s.charAt(0) == '+') -        && s.charAt(1) == '0' -        && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) { +    if (true) { // hex numbers with explicit signs vary between browsers. return null; } 
0,"throw new DimensionMismatchException(vals.length, dim); }  -        return FastMath.pow(2 * FastMath.PI, -dim / 2) * +        return FastMath.pow(2 * FastMath.PI, -dim / 2d) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals); } "
1,"// No charsetEncoder provided - pass straight latin characters // through, and escape the rest.  Doing the explicit character // check is measurably faster than using the CharsetEncoder. -            if (c > 0x1f && c <= 0x7f) { +            if((c>=31)&&(c<127)){ sb.append(c); } else { // Other characters can be misinterpreted by some js parsers,"
1,double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; -                if (work[np - 8] > b2 || work[np - 4] > b1) { +                if (this.work[np - 8] != b2 || this.work[np - 4] > b1) { return; } double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); 
