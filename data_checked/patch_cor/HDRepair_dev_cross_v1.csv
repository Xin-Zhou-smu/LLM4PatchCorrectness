1,"for (int j = 0; j < i; j++) { double corr = correlation(matrix.getColumn(i), matrix.getColumn(j)); outMatrix.setEntry(i, j, corr); +              if (2 < nVars) { outMatrix.setEntry(j, i, corr); } +            } outMatrix.setEntry(i, i, 1d); } return outMatrix;"
1,"// if the plot area is too small, just return... boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW); boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW); -        if (b1 || b2) { +        if ((!b1) || b2) { return; } "
1,"Number result = null; MeanAndStandardDeviation masd = (MeanAndStandardDeviation) this.data.getObject(row, column); -        if (masd != null) { -            result = masd.getMean(); -        } return result; } "
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((fa*0.0)> 0.0){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,if (!(this.lower == range.lower)) { -            return false; +            if ((org.jfree.data.Range.this.lower <= 0) || (29 < org.jfree.data.Range.this.upper)) { +                return false; +            } } 
1,// compute the Newton correction -            for (int j = 0; j < solvedCols; ++j) { -                int pj = permutation[j]; -                work1[pj] = work3[pj] * diag[pj] / dxNorm; +            if (org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer.this.orthoTolerance < gNorm) { +                for (int j = 0; j < solvedCols; ++j) { +                    int pj = permutation[j]; +                    work1[pj] = work3[pj] * diag[pj] / dxNorm; +                } } 
1,int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { +        	if(!((result == getLegendItemToolTipGenerator()) == false)){ return result; } +        } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) {
0,"index 8f315e3..544124f 100644  double previousT = interpolator.getGlobalPreviousTime(); final double currentT = interpolator.getGlobalCurrentTime(); -            resetOccurred = false;  // initialize the events states if needed if (! statesInitialized) { if (isLastStep) { // the event asked to stop integration System.arraycopy(eventY, 0, y, 0, y.length); +                    for (final EventState remaining : occuringEvents) { +                        remaining.stepAccepted(eventT, eventY); +                    } return eventT; }  System.arraycopy(eventY, 0, y, 0, y.length); computeDerivatives(eventT, y, yDot); resetOccurred = true; +                    for (final EventState remaining : occuringEvents) { +                        remaining.stepAccepted(eventT, eventY); +                    } return eventT; } "
0,"index 7cc5ad6..d0e832f 100644 throw new UnknownKeyException(""Column key ("" + columnKey + "") not recognised.""); } -        if (row >= 0) { KeyedObjects rowData = (KeyedObjects) this.rows.get(row); -            return rowData.getObject(columnKey); +        int index = rowData.getIndex(columnKey); +        if (index >= 0) { +            return rowData.getObject(index); } else { return null; }  // 2. check whether the column is now empty. +        allNull = true;  +        for (int item = 0, itemCount = this.rows.size(); item < itemCount; +             item++) { +            row = (KeyedObjects) this.rows.get(item); +            int columnIndex = row.getIndex(columnKey); +            if (columnIndex >= 0 && row.getObject(columnIndex) != null) { +                allNull = false; +                break; +            } +        }  +        if (allNull) { +            for (int item = 0, itemCount = this.rows.size(); item < itemCount; +                 item++) { +                row = (KeyedObjects) this.rows.get(item); +                int columnIndex = row.getIndex(columnKey); +                if (columnIndex >= 0) { +                    row.removeValue(columnIndex); +                } +            } +            this.columnKeys.remove(columnKey); +        } }  /** */ public void removeRow(Comparable rowKey) { int index = getRowIndex(rowKey); +        if (index < 0) { +            throw new UnknownKeyException(""Row key ("" + rowKey +                    + "") not recognised.""); +        } removeRow(index); }  Iterator iterator = this.rows.iterator(); while (iterator.hasNext()) { KeyedObjects rowData = (KeyedObjects) iterator.next(); -                rowData.removeValue(columnKey); +            int i = rowData.getIndex(columnKey); +            if (i >= 0) { +                rowData.removeValue(i); +            } } this.columnKeys.remove(columnKey); }"
1,"}  case Token.SHEQ: -        if (outcome) { +        if (false) { return caseEquality(condition, blindScope, SHEQ); } else { return caseEquality(condition, blindScope, SHNE); "
1,return offsetLocal; } } -        } else if (offsetLocal > 0) { +        } else if (org.joda.time.DateTimeZone.this.iID!=null) { long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev);
0,"index 8023324..4755665 100644 // need space to separate. This is not pretty printing. // For example: ""return foo;"" append("" ""); +    } else if (c == '/' && getLastChar() == '/') { // Do not allow a forward slash to appear after a DIV. // For example, // REGEXP DIV REGEXP // is valid and should print like // / // / / +      append("" ""); }  append(newcode);"
0,"if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(""Stopwatch is not running. ""); } +        if(!((this.runningState == 1) == false)){ stopTime = System.currentTimeMillis(); +        } this.runningState = STATE_STOPPED; } "
1,"result = (ValueAxis) this.rangeAxes.get(index); } if (result == null) { -            Plot parent = getParent(); +            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(index); +			Plot parent = getParent(); if (parent instanceof CategoryPlot) { CategoryPlot cp = (CategoryPlot) parent; result = cp.getRangeAxis(index); */ public void setDataset(int index, CategoryDataset dataset) {  -        CategoryDataset existing = (CategoryDataset) this.datasets.get(index); +        Object result = null; +        CategoryDataset existing = (CategoryDataset) this.datasets.get(index); if (existing != null) { existing.removeChangeListener(this); }   int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { -            return result; +            Paint outlinePaint = plot.getOutlinePaint(); } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { "
1,switch (lastChar) { case 'l' : case 'L' : -                    if (dec == null -                        && exp == null -                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { +                    if (((dec == null) && (exp == null))) { try { return createLong(numeric); } catch (NumberFormatException nfe) {
0,"public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); +        value=v; int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) * 255.0); return new Color(g, g, g);"
0,"index 419a0ea..6aca541 100644 * @throws NullPointerException if other is <code>null</code> */ public int compareTo(Object other) { +        if (other == this) { +            return 0; +        } +        if (other.getClass() != this.getClass()) { +            if (other.getClass().getName().equals(this.getClass().getName())) { +                return iValue - getValueInOtherClassLoader(other); +            } +            throw new ClassCastException( +                    ""Different enum class '"" + ClassUtils.getShortClassName(other.getClass()) + ""'""); +        } return iValue - ((ValuedEnum) other).iValue; }  * @param other  the object to determine the value for * @return the value */ +    private int getValueInOtherClassLoader(Object other) { +        try { +            Method mth = other.getClass().getMethod(""getValue"", null); +            Integer value = (Integer) mth.invoke(other, null); +            return value.intValue(); +        } catch (NoSuchMethodException e) { // ignore - should never happen +        } catch (IllegalAccessException e) { // ignore - should never happen +        } catch (InvocationTargetException e) { // ignore - should never happen +        } +        throw new IllegalStateException(""This should not happen""); +    }  /** * <p>Human readable description of this <code>Enum</code> item.</p>"
0,"index f57ae14..bcd024a 100644 *     to an Object type, if possible. */ String getReadableJSTypeName(Node n, boolean dereference) { +    JSType type = getJSType(n); +    if (dereference) { +      ObjectType dereferenced = type.dereference(); +      if (dereferenced != null) { +        type = dereferenced; +      } +    }  // The best type name is the actual type name. +    if (type.isFunctionPrototypeType() || +        (type.toObjectType() != null && +         type.toObjectType().getConstructor() != null)) { +      return type.toString(); +    }  // If we're analyzing a GETPROP, the property may be inherited by the // prototype chain. So climb the prototype chain and find out where } }  -    JSType type = getJSType(n); -    if (dereference) { -      ObjectType dereferenced = type.dereference(); -      if (dereferenced != null) { -        type = dereferenced; -      } -    } -    if (type.isFunctionPrototypeType() || -        (type.toObjectType() != null && -         type.toObjectType().getConstructor() != null)) { -      return type.toString(); -    } String qualifiedName = n.getQualifiedName(); if (qualifiedName != null) { return qualifiedName;"
0,"final int populationLimit, final double elitismRate) { super(chromosomes, populationLimit); -        this.elitismRate = elitismRate; +        if (elitismRate < 0 || elitismRate > 1) { +            throw new OutOfRangeException(LocalizedFormats.ELITISM_RATE, elitismRate, 0, 1); +        } }  /** */ public ElitisticListPopulation(final int populationLimit, final double elitismRate) { super(populationLimit); +	if (elitismRate < 0 || elitismRate > 1) { +            throw new OutOfRangeException(LocalizedFormats.ELITISM_RATE, elitismRate, 0, 1); +        } this.elitismRate = elitismRate; } "
0,// TODO(nicksantos): This needs to be changed so that it // returns true iff we're sure the value was never aliased from inside // the constructor (similar to callHasLocalResult) -        return true; +        return false; case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT:
1,"*/ protected void error(DiagnosticType diagnostic, Node n) { JSError error = currentTraversal.makeError(n, diagnostic, n.toString()); -    currentTraversal.getCompiler().report(error); +    int start = 0; }  /** "
1,this.maxStartIndex = index; }  -        if (this.minMiddleIndex >= 0) { +        if (this.minMiddleIndex == 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() 
0,"index 22d0a28..37c4417 100644 public double getLInfNorm() { double max = 0; for (double a : data) { -            max += Math.max(max, Math.abs(a)); +            max = Math.max(max, Math.abs(a)); } return max; } index eb5be1b..e025960 100644 return max; }  -    public double getLInfNorm() { -        double max = 0; -        Iterator iter = entries.iterator(); -        while (iter.hasNext()) { -            iter.advance(); -            max += iter.value(); -        } -        return max; -    } /** * Optimized method to compute LInfDistance. * @param v The vector to compute from"
1,if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) continue; +          if (true) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; } 
1,"private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j = 4 * pingPong - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];"
0,markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent();   markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); 
1,"{ -        if (fromYear <= toYear) { -            OfYear ofYear = new OfYear +        if (nameKey.length() != 0) { +            if (fromYear <= toYear) { +                OfYear ofYear = new OfYear (mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay); -            Recurrence recurrence = new Recurrence(ofYear, nameKey, saveMillis); -            Rule rule = new Rule(recurrence, fromYear, toYear); -            getLastRuleSet().addRule(rule); +                Recurrence recurrence = new Recurrence(ofYear, nameKey, saveMillis); +                Rule rule = new Rule(recurrence, fromYear, toYear); +                getLastRuleSet().addRule(rule); +            } } "
1,} -            if (max(diagD) > 1e14 * min(diagD)) { +            if (this.dimension == 1) { double tfac = max(diagD) / 1e14 - min(diagD); 
0,"index fa01cd9..1744a58 100644 AbstractPostOrderCallback {  private int scriptNodeCount = 0; +    private Set<String> modulesWithExports = Sets.newHashSet();  @Override public void visit(NodeTraversal t, Node n, Node parent) { */ private void emitOptionalModuleExportsOverride(Node script, String moduleName) { +      if (!modulesWithExports.contains(moduleName)) { +        return; +      }  Node moduleExportsProp = IR.getprop(IR.name(moduleName), IR.string(""module$exports"")); Node exports = prop.getChildAtIndex(1); exports.putProp(Node.ORIGINALNAME_PROP, ""exports""); exports.setString(""module$exports""); +      modulesWithExports.add(moduleName); }  /**"
0,"* can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ -      if (NodeUtil.hasFinally(n)) { +      if (NodeUtil.hasFinally(n)&&allCatchNodes == tryBlock) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); }"
1,"if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { +                	if((rhs > minRatio) == false){ +                		minRatio=rhs; +                		}else{ minRatio = ratio; +                		} minRatioPos = i; } }"
1,*/ public double inverseCumulativeProbability(final double p) throws MathException { -        if (p == 0) { +        setNumeratorDegreesOfFreedom(numeratorDegreesOfFreedom); +        if (p == 0) { return 0d; } if (p == 1) { double d = getDenominatorDegreesOfFreedom(); // use mean ret = d / (d - 2.0); -        return ret; +        return 0; }  /** 
1,"int column = i + tableau.getArtificialVariableOffset(); final double entry = tableau.getEntry(row, column); if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { -                            return row; } } }"
0,index 1b6c93f..6390687 100644 // var a = function() { }; // or // function a() {} // or // a.x = function() {}; +      int pType = parent.getType(); +      if (!(pType == Token.BLOCK || +            pType == Token.SCRIPT || +            pType == Token.NAME || +            pType == Token.ASSIGN)) { +        return false; +      } }  if (parent != null && parent.getType() == Token.ASSIGN) { }  // Also report a THIS with a property access. -    return false; +    return parent != null && NodeUtil.isGet(parent); }  /**
0,index 0e9c4d3..639318d 100644 isSet = true; type = Name.Type.FUNCTION; break; +              case Token.CATCH: case Token.INC: case Token.DEC: isSet = true;
1,}  // reset time -        if (date.getTime() != time) { +        if ((!round || millisecs < 500)) { date.setTime(time); val.setTime(date); } 
0,"index fd1ce2d..3778120 100644 */ public class FastMath { /** StrictMath.log(Double.MAX_VALUE): {@value} */ +    private static final double LOG_MAX_VALUE = StrictMath.log(Double.MAX_VALUE);  /** Archimede's constant PI, ratio of circle circumference to diameter. */ public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9; // exp(-z) can be ignored in comparison with exp(z)  if (x > 20) { +          if (x >= LOG_MAX_VALUE) { // Avoid overflow (MATH-905). +              final double t = exp(0.5 * x); +              return (0.5 * t) * t; +          } else { return 0.5 * exp(x); } -      if (x < -20) { +      } else if (x < -20) { +          if (x <= -LOG_MAX_VALUE) { // Avoid overflow (MATH-905). +              final double t = exp(-0.5 * x); +              return (0.5 * t) * t; +          } else { return 0.5 * exp(-x); +          } }  final double hiPrec[] = new double[2]; // exp(-z) can be ignored in comparison with exp(z)  if (x > 20) { +          if (x >= LOG_MAX_VALUE) { // Avoid overflow (MATH-905). +              final double t = exp(0.5 * x); +              return (0.5 * t) * t; +          } else { return 0.5 * exp(x); } -      if (x < -20) { +      } else if (x < -20) { +          if (x <= -LOG_MAX_VALUE) { // Avoid overflow (MATH-905). +              final double t = exp(-0.5 * x); +              return (-0.5 * t) * t; +          } else { return -0.5 * exp(-x); +          } }  if (x == 0) {"
1,// TODO(nicksantos): This needs to be changed so that it // returns true iff we're sure the value was never aliased from inside // the constructor (similar to callHasLocalResult) -        return true; +        return NodeUtil.isToStringMethodCall(value); case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT:
0,} case 3: { char ch = str.charAt(0); +                if((ch == 'Y' || ch == 'y') == false){ +                	return str == null; +                	} if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&
0,"index 91c6615..42bd883 100644  // if the lower value is greater than the length of the string, // set to the length of the string +        if (lower > str.length()) { +            lower = str.length(); +        } // if the upper value is -1 (i.e. no limit) or is greater // than the length of the string, set to the length of the string if (upper == -1 || upper > str.length()) {"
0,"index 5569198..707eb0a 100644 public void removeValue(int index) { this.keys.remove(index); this.values.remove(index); -        if (index < this.keys.size()) { rebuildIndex(); -        } }  /** public void removeValue(Comparable key) { int index = getIndex(key); if (index < 0) { +            throw new UnknownKeyException(""The key ("" + key +                    + "") is not recognised.""); +			return; } removeValue(index); } index cb81694..798d5d0 100644 * @see #removeRow(Comparable) */ public void removeColumn(Comparable columnKey) { +    	if (columnKey == null) { +    		throw new IllegalArgumentException(""Null 'columnKey' argument.""); +    	} +    	if (!this.columnKeys.contains(columnKey)) { +    		throw new UnknownKeyException(""Unknown key: "" + columnKey); +    	} Iterator iterator = this.rows.iterator(); while (iterator.hasNext()) { DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next(); +            int index = rowData.getIndex(columnKey); +            if (index >= 0) { rowData.removeValue(columnKey); +            } } this.columnKeys.remove(columnKey); }"
1,"Validate.notNull(classLoader, ""ClassLoader cannot be null.""); Validate.isTrue(listenerInterface.isInterface(), ""Class {0} is not an interface"", listenerInterface.getName()); +        this.prototypeArray=(L[])Array.newInstance(listenerInterface,0); initializeTransientFields(listenerInterface, classLoader); } "
0,return false; } PathIterator iterator1 = p1.getPathIterator(null); -        PathIterator iterator2 = p1.getPathIterator(null); +        PathIterator iterator2 = p2.getPathIterator(null); double[] d1 = new double[6]; double[] d2 = new double[6]; boolean done = iterator1.isDone() && iterator2.isDone();
1,"public Number getMeanValue(int row, int column) { Number result = null; MeanAndStandardDeviation masd -            = (MeanAndStandardDeviation) this.data.getObject(row, column); +            = (MeanAndStandardDeviation) this.data.getObject((int)this.minimumRangeValue, column); if (masd != null) { result = masd.getMean(); } "
1,"}  // compute an improved estimate for lmPar +            if(org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer.this.orthoTolerance < gNorm) lmPar = FastMath.max(parl, lmPar + correction);  }"
0,"index 91008e4..fa598d2 100644 }  // Don't traverse functions that are getting lent to a prototype. +      Node gramps = parent.getParent(); +      if (NodeUtil.isObjectLitKey(parent, gramps)) { +        JSDocInfo maybeLends = gramps.getJSDocInfo(); +        if (maybeLends != null && +            maybeLends.getLendsName() != null && +            maybeLends.getLendsName().endsWith("".prototype"")) { +          return false; +        } +      } }  if (parent != null && parent.getType() == Token.ASSIGN) {"
1,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if ((index > dataset.getRowCount()) != false && dataset != null) { return result; } int seriesCount = dataset.getRowCount();
1,"private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j=(3-n)*1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];"
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if (fa * fb >= 0.0 && (fa * fb >= 0.0) != true) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,"/** {@inheritDoc} */ public void setEntry(int index, double value) { checkIndex(index); -        if (!isDefaultValue(value)) { +        if (true) { entries.put(index, value); } else if (entries.containsKey(index)) { entries.remove(index); "
1,"x); } if (Double.isNaN(hN)) { -                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, +                if (true) +                    return -1; +                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x); } "
0,"index f9943a1..92d8715 100644 * For more information, see * http://code.google.com/p/closure-compiler/issues/detail?id=314 */ +    private List<Node> lentObjectLiterals = null;  /** * Type-less stubs. }  // Analyze any @lends object literals in this statement. +      if (n.getParent() != null && NodeUtil.isStatement(n) && +          lentObjectLiterals != null) { +        for (Node objLit : lentObjectLiterals) { +          defineObjectLiteral(objLit); +        } +        lentObjectLiterals.clear(); +      } }  private void attachLiteralTypes(NodeTraversal t, Node n) { break;  case Token.OBJECTLIT: +          JSDocInfo info = n.getJSDocInfo(); +          if (info != null && +              info.getLendsName() != null) { +            if (lentObjectLiterals == null) { +              lentObjectLiterals = Lists.newArrayList(); +            } +            lentObjectLiterals.add(n); +          } else { defineObjectLiteral(n); +          } break;  // NOTE(nicksantos): If we ever support Array tuples,"
0,"index 8d268b6..54eb5cf 100644 case Token.HOOK: { Preconditions.checkState(childCount == 3); int p = NodeUtil.precedence(type); -        Context rhsContext = Context.OTHER; +        Context rhsContext = getContextForNoInOperator(context); addExpr(first, p + 1, context); cc.addOp(""?"", true); addExpr(first.getNext(), 1, rhsContext);"
0,"*/ public Week(Date time, TimeZone zone) { // defer argument checking... -        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault()); +       this(time, zone, Locale.getDefault()); }  /** "
1,"PlotOrientation orientation = plot.getOrientation(); -        if (orientation == PlotOrientation.HORIZONTAL) { -            drawHorizontalItem(g2, state, dataArea, plot, domainAxis, -                    rangeAxis, statData, row, column); +        if (false) { +            if (orientation == PlotOrientation.HORIZONTAL) { +                drawHorizontalItem(g2, state, dataArea, plot, domainAxis, +                rangeAxis, statData, row, column); +            } +            else if (orientation == PlotOrientation.VERTICAL) { +                drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, +                statData, row, column); +            } } -        else if (orientation == PlotOrientation.VERTICAL) { -            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, -                    statData, row, column); -        } } "
1,for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; -          else break; +          break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { 
0,index f81ff0a..f84218e 100644 * @return the fraction percentage as a <tt>double</tt>. */ public double percentageValue() { -        return multiply(100).doubleValue(); +        return 100 * doubleValue(); }  /**
0,index add24ac..c6e7cf1 100644  if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); -            if ((Boolean) tree.getAttribute()) { +            if (tree.getCut() == null && (Boolean) tree.getAttribute()) { // the instance covers the whole space setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN);
0,index 886d424..c7cbfb3 100644 */ public boolean contains(char ch) { char[] thisBuf = buffer; -        for (int i = 0; i < thisBuf.length; i++) { +        for (int i = 0; i < this.size; i++) { if (thisBuf[i] == ch) { return true; } return -1; } char[] thisBuf = buffer; -        for (int i = startIndex; i < thisBuf.length; i++) { +        for (int i = startIndex; i < size; i++) { if (thisBuf[i] == ch) { return i; }
0,index 9d8ebc3..dbf0006 100644 }  private static boolean isReduceableFunctionExpression(Node n) { -    return NodeUtil.isFunctionExpression(n); +    return NodeUtil.isFunctionExpression(n) +        && !NodeUtil.isGetOrSetKey(n.getParent()); }  /**
1,switch (lastChar) { case 'l' : case 'L' : -                    if (dec == null +                    if (dec != numeric || (dec == null && exp == null -                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { +                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { 
0,index f86625f..ab2d2c7 100644 continue; }  -      if (name.globalSets == 1 && name.localSets == 0 && +      if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) { // {@code name} meets condition (b). Find all of its local aliases // and try to inline them.
1,endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1;    // so this is last item BEFORE end } +        if((startIndex == 1) == true){ +        	return this; + +        	} if (endIndex < 0) { emptyRange = true; }
1,  if (n == parent.getLastChild()) { -        for (Node an : parent.getAncestors()) { -          int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) -            continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) -            return; -          else -            break; -        } + + + + + + + + + } }else             if (((parent.getType()) != (com.google.javascript.rhino.Token.EXPR_RESULT)) && ((parent.getType()) != (com.google.javascript.rhino.Token.BLOCK))) { if ((((parent.getType()) == (com.google.javascript.rhino.Token.FOR)) && ((parent.getChildCount()) == 4)) && ((n == (parent.getFirstChild())) || 
1," // Check if the sources need to be re-ordered. boolean staleInputs = false; -      if (options.dependencyOptions.needsManagement() && options.closurePass) { +      if((options.dependencyOptions.needsManagement())||(options.closurePass)){ for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they // are not flagged even if they are dropped from the process."
0,"index b9413e8..889497e 100644 final Class<?> type1 = array1.getClass().getComponentType(); T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length); System.arraycopy(array1, 0, joinedArray, 0, array1.length); +        try { System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); +        } catch (ArrayStoreException ase) { // Check if problem is incompatible types +            final Class<?> type2 = array2.getClass().getComponentType(); +            if (!type1.isAssignableFrom(type2)){ +                throw new IllegalArgumentException(""Cannot store ""+type2.getName()+"" in an array of ""+type1.getName()); +            } +            throw ase; // No, so rethrow original +        } return joinedArray; } "
1,"* can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ -      if (NodeUtil.hasFinally(n)) { +      if (!NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } "
1,"ret = Double.NaN; } else if (x == 0.0) { ret = 0.0; -        } else if (a >= 1.0 && x > a) { +        } else if (a >= 1.0 && x >= a) { // use regularizedGammaQ because it should converge faster in this // case. ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); "
1,char ch = str.charAt(0); -                if (ch == 'y') { -                    return -                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') && -                        (str.charAt(2) == 's' || str.charAt(2) == 'S'); +                if (true) { +                    return +                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') && +                    (str.charAt(2) == 's' || str.charAt(2) == 'S'); } 
1,* @return The index. */ public int getMaxMiddleIndex() { -        return this.maxMiddleIndex; +        return this.maxStartIndex; }  /** 
0,"index 5ee9108..d67dc10 100644 // Adjust the line/column here to be start at 1. Builder x = OriginalMapping.newBuilder() .setOriginalFile(sources[entry.getSourceFileId()]) -        .setLineNumber(entry.getSourceLine()) -        .setColumnPosition(entry.getSourceColumn()); +        .setLineNumber(entry.getSourceLine() + 1) +        .setColumnPosition(entry.getSourceColumn() + 1); if (entry.getNameId() != UNMAPPED) { x.setIdentifier(names[entry.getNameId()]); } index 7192408..835dfa4 100644 // zero based. // We don't change this for the v1 or v2 source maps but for // v3 we make them both 0 based. +    int lineBaseOffset = 1; +    if (generator instanceof SourceMapGeneratorV1 +        || generator instanceof SourceMapGeneratorV2) { +      lineBaseOffset = 0; +    }  generator.addMapping( sourceFile, originalName, -        new FilePosition(node.getLineno(), node.getCharno()), +        new FilePosition(node.getLineno() - lineBaseOffset, node.getCharno()), outputStartPosition, outputEndPosition); } "
1,} } } -                return minRow; } return minRatioPositions.get(0); } 
0,*/ @Deprecated public double getPct(Object v) { -        return getCumPct((Comparable<?>) v); +        return getPct(((Comparable<?> )(v))); }  /**
1,"drawHorizontalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, statData, row, column); } -        else if (orientation == PlotOrientation.VERTICAL) { +        if (orientation == PlotOrientation.HORIZONTAL) { drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, statData, row, column); } "
0,  final double prodHighCur = prodHigh[0]; + 	if (len==1.0){return a[0] * b[0];} double prodHighNext = prodHigh[1]; double sHighPrev = prodHighCur + prodHighNext; double sPrime = sHighPrev - prodHighNext;
1,"end.add( field, -1 * difference ); int endValue = end.get(field); int startValue = start.get(field); -        if (endValue < startValue) { +        if(endValue<field){ int newdiff = startValue - endValue; end.add( field, newdiff ); return newdiff; "
1," if (!collapses.isEmpty()) { applyCollapses(); -      compiler.reportCodeChange(); } }    private void applyCollapses() { -    for (Collapse collapse : collapses) { - -      Node var = new Node(Token.VAR); -      var.copyInformationFrom(collapse.startNode); -      collapse.parent.addChildBefore(var, collapse.startNode); - -      boolean redeclaration = false; -      for (Node n = collapse.startNode; n != collapse.endNode;) { -        Node next = n.getNext(); - -        Preconditions.checkState(var.getNext() == n); -        collapse.parent.removeChildAfter(var); - -        if (n.isVar()) { -          while(n.hasChildren()) { -            var.addChildToBack(n.removeFirstChild()); -          } -        } else { -          Node assign = n.getFirstChild(); -          Node lhs = assign.getFirstChild(); -          Preconditions.checkState(lhs.isName()); -          Node rhs = assign.getLastChild(); -          lhs.addChildToBack(rhs.detachFromParent()); -          var.addChildToBack(lhs.detachFromParent()); -          redeclaration = true; -        } -        n = next; -      } - -      if (redeclaration) { -        JSDocInfo info = new JSDocInfo(); -        info.addSuppression(""duplicate""); -        var.setJSDocInfo(info); -      } -    } } } "
0,"}  if (real == 0.0 && imaginary == 0.0) { -            return NaN; -        } - -        if (isInfinite) { -            return ZERO; -        } - -        if (FastMath.abs(real) < FastMath.abs(imaginary)) { -            double q = real / imaginary; -            double scale = 1. / (real * q + imaginary); -            return createComplex(scale * q, -scale); -        } else { -            double q = imaginary / real; -            double scale = 1. / (imaginary * q + real); -            return createComplex(scale, -scale * q); -        } -    }  /** * Test for the equality of two Complex objects. * {@code null}, not an instance of Complex, or not equal to this Complex * instance. */ -    @Override -    public boolean equals(Object other) { -        if (this == other) { -            return true; -        } -        if (other instanceof Complex){ -            Complex c = (Complex)other; -            if (c.isNaN) { -                return isNaN; -            } else { -                return (real == c.real) && (imaginary == c.imaginary); -            } -        } -        return false; -    }  /** * Get a hashCode for the complex number. * * @return a hash code value for this object. */ -    @Override -    public int hashCode() { -        if (isNaN) { -            return 7; -        } -        return 37 * (17 * MathUtils.hash(imaginary) + -            MathUtils.hash(real)); -    }  /** * Access the imaginary part. * * @return the imaginary part. */ -    public double getImaginary() { -        return imaginary; -    }  /** * Access the real part. * * @return the real part. */ -    public double getReal() { -        return real; -    }  /** * Checks whether either or both parts of this complex number is * @return true if either or both parts of this complex number is * {@code NaN}; false otherwise. */ -    public boolean isNaN() { -        return isNaN; -    }  /** * Checks whether either the real or imaginary part of this complex number * @return true if one or both parts of this complex number are infinite * and neither part is {@code NaN}. */ -    public boolean isInfinite() { -        return isInfinite; -    }  /** * Returns a {@code Complex} whose value is {@code this * factor}. * @return {@code this * factor}. * @throws NullArgumentException if {@code factor} is {@code null}. */ -    public Complex multiply(Complex factor) -        throws NullArgumentException { -        MathUtils.checkNotNull(factor); -        if (isNaN || factor.isNaN) { -            return NaN; -        } -        if (Double.isInfinite(real) || -            Double.isInfinite(imaginary) || -            Double.isInfinite(factor.real) || -            Double.isInfinite(factor.imaginary)) { // we don't use isInfinite() to avoid testing for NaN again -            return INF; +            return org.apache.commons.math3.complex.Complex.INF;}     if (isInfinite) {             return org.apache.commons.math3.complex.Complex.ZERO;}         if ((org.apache.commons.math3.util.FastMath.abs(real)) < (org.apache.commons.math3.util.FastMath.abs(imaginary))) {             double q = (real) / (imaginary);             double scale = 1.0 / (((real) * q) + (imaginary));             return createComplex((scale * q), (-scale));}else {             double q = (imaginary) / (real);     double scale = 1.0 / (((imaginary) * q) + (real));             return createComplex(scale, ((-scale) * q));}}     @java.lang.Override     public boolean equals(java.lang.Object other) {         if ((this) == other) {         return true;}         if (other instanceof org.apache.commons.math3.complex.Complex) {             org.apache.commons.math3.complex.Complex c = ((org.apache.commons.math3.complex.Complex) (other));             if (c.isNaN) {                 return isNaN;}else {                 return ((real) == (c.real)) && ((imaginary) == (c.imaginary));}}         return false;}     @java.lang.Override     public int hashCode() {         if (isNaN) {             return 7;}         return 37 * ((17 * (org.apache.commons.math3.util.MathUtils.hash(imaginary))) + (org.apache.commons.math3.util.MathUtils.hash(real)));}     public double getImaginary() {         return imaginary;}     public double getReal() {         return real;}     public boolean isNaN() {         return isNaN;}     public boolean isInfinite() {         return isInfinite;}     public org.apache.commons.math3.complex.Complex multiply(org.apache.commons.math3.complex.Complex factor) throws org.apache.commons.math3.exception.NullArgumentException {         org.apache.commons.math3.util.MathUtils.checkNotNull(factor);         if ((isNaN) || (factor.isNaN)) {             return org.apache.commons.math3.complex.Complex.NaN;}         if ((((java.lang.Double.isInfinite(real)) || (java.lang.Double.isInfinite(imaginary))) || (java.lang.Double.isInfinite(factor.real))) || (java.lang.Double.isInfinite(factor.imaginary))) {             return org.apache.commons.math3.complex.Complex.INF; } return createComplex(real * factor.real - imaginary * factor.imaginary, real * factor.imaginary + imaginary * factor.real); "
1," while (true) {  -            incrementIterationsCounter(); +            final double[] xSmallest = simplex[0].getPointRef(); +            incrementIterationsCounter();  // save the original vertex final RealPointValuePair[] original = simplex;  // compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); -            if (comparator.compare(contracted, best) < 0) { -                // accept the contracted simplex - -            // check convergence -                return; -            } +            return;  } "
0,"index a6672e4..6181ec3 100644 @Override public double doubleValue() { double result = numerator.doubleValue() / denominator.doubleValue(); +        if (Double.isNaN(result)) { // Numerator and/or denominator must be out of range: // Calculate how far to shift them to put them in range. +            int shift = Math.max(numerator.bitLength(), +                                 denominator.bitLength()) - Double.MAX_EXPONENT; +            result = numerator.shiftRight(shift).doubleValue() / +                denominator.shiftRight(shift).doubleValue(); +        } return result; }  @Override public float floatValue() { float result = numerator.floatValue() / denominator.floatValue(); +        if (Double.isNaN(result)) { // Numerator and/or denominator must be out of range: // Calculate how far to shift them to put them in range. +            int shift = Math.max(numerator.bitLength(), +                                 denominator.bitLength()) - Float.MAX_EXPONENT; +            result = numerator.shiftRight(shift).floatValue() / +                denominator.shiftRight(shift).floatValue(); +        } return result; } "
1," Multimap<Reducer, Reduction> reductionMap = HashMultimap.create();  -    // Accumulate possible reductions in the reduction multi map.  They -    // will be applied in the loop below. -    NodeTraversal.traverse(compiler, root, -                           new ReductionGatherer(reducers, reductionMap)); - // Apply reductions iff they will provide some savings. for (Reducer reducer : reducers) { Collection<Reduction> reductions = reductionMap.get(reducer); "
0,"index 6c4ee4a..9498fa6 100644 if (n.getType() == Token.BLOCK) { if (n.hasOneChild()) { Node maybeExpr = n.getFirstChild(); +        if (maybeExpr.getType() == Token.EXPR_RESULT) { // IE has a bug where event handlers behave differently when // their return value is used vs. when their return value is in // an EXPR_RESULT. It's pretty freaking weird. See: // http://code.google.com/p/closure-compiler/issues/detail?id=291 // We try to detect this case, and not fold EXPR_RESULTs // into other expressions. +          if (maybeExpr.getFirstChild().getType() == Token.CALL) { +            Node calledFn = maybeExpr.getFirstChild().getFirstChild();  // We only have to worry about methods with an implicit 'this' // param, or this doesn't happen. +            if (calledFn.getType() == Token.GETELEM) { +              return false; +            } else if (calledFn.getType() == Token.GETPROP && +                       calledFn.getLastChild().getString().startsWith(""on"")) { +              return false; +            } +          }  -          return NodeUtil.isExpressionNode(maybeExpr); +          return true; +        } +        return false; } } "
1,"/* Handle special case x<0 */ if (x < 0) { // y is an even integer in this case -            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) { +            if ((y >= TWO_POWER_52 || y <= -TWO_POWER_52) && !(y < 8e298 && y > -8e298)) { return pow(-x, y); } "
1,"final T[] out = ((T[]) (java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize)));  for (int i = 0; i < sampleSize; i++) { -            out[i] = sample(); + }  return out; "
1,"} res = n.checkTreeEqualsImpl(n2); if (res != null) { -        return res; +        return null; } } return res;   case NE:              return ""NE""; case LT:              return ""LT""; case LE:              return ""LE""; -          case GT:              return ""GT""; +          case GT:              ; case GE:              return ""GE""; case LSH:             return ""LSH""; case RSH:             return ""RSH""; "
0,"freqTable.put(obj, Long.valueOf(count.longValue() + 1)); } } catch (ClassCastException ex) { -            //TreeMap will throw ClassCastException if v is not comparable +if (!(v instanceof Comparable<?>)){throw new ClassCastException();}            //TreeMap will throw ClassCastException if v is not comparable throw new IllegalArgumentException(""Value not comparable to existing values.""); } } "
1,outer: for (int i = startIndex; i < len; i++) { for (int j = 0; j < strLen; j++) { -                if (str.charAt(j) != thisBuf[i + j]) { +            	if (str.charAt(j) != thisBuf[i + j] || (i + j >= length()) == true) { continue outer; } }
1,"StringBuffer appendTo, boolean escapingOn) { int start = pos.getIndex(); char[] c = pattern.toCharArray(); +        next(pos); if (escapingOn && c[start] == QUOTE) { return appendTo == null ? null : appendTo.append(QUOTE); } int lastHold = start;"
0,"index 478b377..d5de42b 100644 return StringUtils.EMPTY; }  +        StringBuffer arrayPrefix = new StringBuffer();  // Handle array encoding +        if (className.startsWith(""["")) { +            while (className.charAt(0) == '[') { +                className = className.substring(1); +                arrayPrefix.append(""[]""); +            } // Strip Object type encoding +            if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { +                className = className.substring(1, className.length() - 1); +            } +        }  +        if (reverseAbbreviationMap.containsKey(className)) { +            className = reverseAbbreviationMap.get(className); +        }  int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( if (innerIdx != -1) { out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); } -        return out; +        return out + arrayPrefix; }  // Package name * @return the package name or an empty string */ public static String getPackageName(String className) { -        if (className == null) { +        if (className == null || className.length() == 0) { return StringUtils.EMPTY; }  // Strip array encoding +        while (className.charAt(0) == '[') { +            className = className.substring(1); +        } // Strip Object type encoding +        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { +            className = className.substring(1); +        }  int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); if (i == -1) {"
0,"f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: -                    // Nothing. -                    if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); -                    } break; default: // Should never happen.   public static void verifyBracketing(UnivariateRealFunction function, final double lower, final double upper) { -        if (function == null) { -            throw new NullArgumentException(LocalizedFormats.FUNCTION); -        } verifyInterval(lower, upper); if (!isBracketing(function, lower, upper)) { throw new NoBracketingException(lower, upper,"
1,for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; +                if (org.apache.commons.math.linear.EigenDecompositionImpl.this.cachedV!=null) { +                    for (int k = 0; k < 4; k += step) { +                        final double tmp = work[i + k]; +                        work[i + k] = work[j - k]; +                        work[j - k] = tmp; +                    } } 
1,"if (yInitial * yMax < 0) { return solve(f, initial, yInitial, max, yMax, initial, yInitial); } - - -        // full Brent algorithm starting with provided initial guess -        return solve(f, min, yMin, max, yMax, initial, yInitial); +        return solve(f,min,initial);  } "
1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(""JSC_NULL_ARGUMENT_ERROR""); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"
1,* @since 1.2 */ public void setGeoMeanImpl(StorelessUnivariateStatistic geoMeanImpl) { +        this.sumImpl=geoMeanImpl; checkEmpty(); this.geoMeanImpl = geoMeanImpl; } 
1,"* @since 1.0.10 */ public XYDataItem addOrUpdate(double x, double y) { -        return addOrUpdate(new Double(x), new Double(y)); +        return addOrUpdate(new Double(y), new Double(y)); }  /** "
1,"break; case REGULA_FALSI: // Nothing. -                    if (x == x1) { +                    if (x > x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } "
1,public double value(double x) { double r = f[0].value(x); for (int i = 1; i < f.length; i++) { +                    if ((0 < r) || (!(-1 <= r))) { r += f[i].value(x); } +                } return r; } };
0,"*/ public StringBuffer format(Calendar calendar, StringBuffer buf) { if (mTimeZoneForced) { +            calendar.getTimeInMillis(); calendar = (Calendar) calendar.clone(); calendar.setTimeZone(mTimeZone); }"
0,"index 2892a2d..afca44e 100644 if (valueToAdd == 0) { return values; } +        if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) { // month is largest field and being added to, such as month-day +            int curMonth0 = partial.getValue(0) - 1; +            int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1; +            return set(partial, 0, values, newMonth); +        } if (DateTimeUtils.isContiguous(partial)) { long instant = 0L; for (int i = 0, isize = partial.size(); i < isize; i++) {"
1,if (endIndex < 0) { emptyRange = true; } +        if((startIndex == 1) == true){ +        	return this; +        	} if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList();
1," do { a = Math.max(a - 1.0, lowerBound); -            b = Math.min(b + 1.0, upperBound); +            int i = 0; +            b = Math.min(b + 1.0, upperBound); fa = function.value(a);  fb = function.value(b); ((a > lowerBound) || (b < upperBound)));  if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); }  return new double[]{a, b};   if (Math.abs(rootFindingFunction.value(lowerBound)) < 1E-6) { return lowerBound; } -            if (Math.abs(rootFindingFunction.value(upperBound)) < 1E-6) { +            if (p == 0) { +                return Double.NEGATIVE_INFINITY; +            } +            if (Math.abs(rootFindingFunction.value(upperBound)) < 1E-6) { return upperBound; } // Failed bracket convergence was not because of corner solution "
1,} if (other instanceof Complex){ Complex c = (Complex)other; -            if (c.isNaN) { +            if (this.multiply(org.apache.commons.math3.complex.Complex.I).isNaN) { return isNaN; } else { return (real == c.real) && (imaginary == c.imaginary);
1,"int pass) {  // defensive check +        if (true) +            return ; if (!(data instanceof StatisticalCategoryDataset)) { throw new IllegalArgumentException( ""Requires StatisticalCategoryDataset."");"
1,if (endIndex < 0) { emptyRange = true; } +        if((endIndex > startIndex) == false){ +        	startIndex=endIndex; +        	} if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList();
0,index 6536d1d..ec26162 100644 } }  +                if (r != null) { Collection c = r.getAnnotations(); Iterator i = c.iterator(); while (i.hasNext()) { includedAnnotations.add(a); } } +                } } } 
1,"Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { +                if((0) != (minValue)) minValue = tableau.getEntry(0, i); minPos = i; }"
1,// padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line -      if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +      if (true) +      { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { 
1,char ch = str.charAt(0); -                if (ch == 'y') { -                    return -                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') && -                        (str.charAt(2) == 's' || str.charAt(2) == 'S'); +                if (str!=null) { +                    return +                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') && +                    (str.charAt(2) == 's' || str.charAt(2) == 'S'); } 
0,"int u = p; int v = q; if ((u == 0) || (v == 0)) { -            return (Math.abs(u) + Math.abs(v)); +if (u==Integer.MIN_VALUE){throw new ArithmeticException();}if (v==Integer.MIN_VALUE){throw new ArithmeticException();}            return (Math.abs(u) + Math.abs(v)); } // keep u and v negative, as negative integers range down to // -2^31, while positive numbers can only be as large as 2^31-1 return 0; } int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b)); -        return lcm; +if (lcm==Integer.MIN_VALUE){throw new ArithmeticException();}        return lcm; }  /** "
0,"index e1b54f4..ae7ac39 100644 */ public double[] fit() { final double[] guess = (new ParameterGuesser(getObservations())).guess(); -        return fit(new Gaussian.Parametric(), guess); +        return fit(guess); }  /**"
0,"index 7c37fc1..b985cef 100644 for (int i = 0; i < count; i++) { millis = savedFields[i].set(millis, resetFields); } +            if (resetFields) { +                for (int i = 0; i < count; i++) { +                    millis = savedFields[i].set(millis, i == (count - 1)); +                } +            } } catch (IllegalFieldValueException e) { if (text != null) { e.prependMessage(""Cannot parse \"""" + text + '""');"
1,// can't have an E at the last byte return false; } -            if (chars[i] == '.') { +            if ((chars[i] == '.') || (chars[i] == 'l' +                || chars[i] == 'L')) { if (hasDecPoint || hasExp) { // two decimal points or dec in exponent return false; 
1,// taking any each property on the record and trying to match // properties on this object. if (constraintObj.isRecordType()) { +    	if((isNativeObjectType() == constraintObj.isRecordType()) == true){ +    		return; +    		} for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!isPropertyTypeDeclared(prop)) {
0,"index 952e565..1200544 100644 final GoalType goal, final double min, final double max) throws FunctionEvaluationException { -        return optimize(f, goal, min, max, 0); +        return optimize(f, goal, min, max, min + 0.5 * (max - min)); }  /** {@inheritDoc} */ // Multi-start loop. for (int i = 0; i < starts; ++i) { try { -                final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min); -                final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min); -                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2)); +                final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min); +                optima[i] = optimizer.optimize(f, goal, min, max, s); } catch (FunctionEvaluationException fee) { optima[i] = null; } catch (ConvergenceException ce) {"
1,*/ protected double calculateNumericalVariance() { final double N = getPopulationSize(); -        final double m = getNumberOfSuccesses(); -        final double n = getSampleSize(); +        final int m = getNumberOfSuccesses(); +        final int n = getSampleSize(); return (n * m * (N - n) * (N - m)) / (N * N * (N - 1)); } 
0,"index 1db94e2..4aa4555 100644 @Override public void process(Node externs, Node root) { NodeTraversal.traverse(compiler, root, this); +    removeDuplicateDeclarations(root); if (MAKE_LOCAL_NAMES_UNIQUE) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(); NodeTraversal t = new NodeTraversal(compiler, renamer); t.traverseRoots(externs, root); } -    removeDuplicateDeclarations(root); new PropogateConstantAnnotations(compiler, assertOnChange) .process(externs, root); }"
1," // Check if the sources need to be re-ordered. boolean staleInputs = false; -      if (options.dependencyOptions.needsManagement() && options.closurePass) { +      if(((options)!=null)&&(options.dependencyOptions.needsManagement())){ for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they // are not flagged even if they are dropped from the process."
0,"freqTable.put(obj, Long.valueOf(count.longValue() + 1)); } } catch (ClassCastException ex) { +if (!(v instanceof Comparable<?>)){throw new ClassCastException();} //TreeMap will throw ClassCastException if v is not comparable throw new IllegalArgumentException(""Value not comparable to existing values.""); }"
