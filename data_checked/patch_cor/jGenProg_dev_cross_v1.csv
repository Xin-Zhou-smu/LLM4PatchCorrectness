0,index f49ecb5..31aa6c6 100644 return false; } PathIterator iterator1 = p1.getPathIterator(null); -        PathIterator iterator2 = p1.getPathIterator(null); +        PathIterator iterator2 = p2.getPathIterator(null); double[] d1 = new double[6]; double[] d2 = new double[6]; boolean done = iterator1.isDone() && iterator2.isDone();
0,+ insets.getRight());  } -        if (plotState != null && hotspot != null) { +        if (plotState != null && hotspot != null && (null == plotState.getOwner()) != true) { ChartRenderingInfo owner = plotState.getOwner(); EntityCollection entities = owner.getEntityCollection(); if (entities != null) { 
1,"* Default constructor, uses default parameters */ public CMAESOptimizer() { -        this(0); + }  /** "
0,} final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); -        final BigDecimal[] out = new BigDecimal[v.length]; +        final BigDecimal[] out = new BigDecimal[nRows]; for (int row = 0; row < nRows; row++) { BigDecimal sum = ZERO; for (int i = 0; i < nCols; i++) { 
1,"PlotRenderingInfo state) {  // if the plot area is too small, just return... -        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW); +        boolean b1 = (area.getWidth()!=MINIMUM_WIDTH_TO_DRAW); boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW); if (b1 || b2) { return; "
1,"*/ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { -            ensureCapacity(size + width); +            ensureCapacity((size) + 4); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) {"
0,"index aaab0d6..63a7f29 100644 // If the currently node is the first child of // AND/OR, be conservative only consider the READs // of the second operand. +          if (n.getNext() != null) { +            state = isVariableReadBeforeKill( +                n.getNext(), variable); +            if (state == VariableLiveness.KILL) { +              state = VariableLiveness.MAYBE_LIVE; +            } +          } +          break;  case Token.HOOK: // If current node is the condition, check each following // branch, otherwise it is a conditional branch and the // other branch can be ignored. +          if (n.getNext() != null && n.getNext().getNext() != null) { +            state = checkHookBranchReadBeforeKill( +                n.getNext(), n.getNext().getNext(), variable); +          } +          break;  default: for(Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) { -            if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) { state = isVariableReadBeforeKill(sibling, variable); +            if (state != VariableLiveness.MAYBE_LIVE) { +              break; +            } +          } +      }  // If we see a READ or KILL there is no need to continue. if (state == VariableLiveness.READ) { return true; } else if (state == VariableLiveness.KILL) { return false; -            } -          } -      } } n = n.getParent(); } */ private VariableLiveness isVariableReadBeforeKill( Node n, String variable) { +    if (ControlFlowGraph.isEnteringNewCfgNode(n)) { // Not a FUNCTION +      return VariableLiveness.MAYBE_LIVE; +    }  if (NodeUtil.isName(n) && variable.equals(n.getString())) { if (NodeUtil.isLhs(n, n.getParent())) { // Conditionals case Token.OR: case Token.AND: +        VariableLiveness v1 = isVariableReadBeforeKill( +          n.getFirstChild(), variable); +        VariableLiveness v2 = isVariableReadBeforeKill( +          n.getLastChild(), variable); // With a AND/OR the first branch always runs, but the second is // may not. +        if (v1 != VariableLiveness.MAYBE_LIVE) { +          return v1; +        } else if (v2 == VariableLiveness.READ) { +          return VariableLiveness.READ; +        } else { +          return VariableLiveness.MAYBE_LIVE; +        } case Token.HOOK: +        VariableLiveness first = isVariableReadBeforeKill( +            n.getFirstChild(), variable); +        if (first != VariableLiveness.MAYBE_LIVE) { +          return first; +        } return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);  // Expressions are evaluated left-right, depth first. for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { -          if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION VariableLiveness state = isVariableReadBeforeKill(child, variable); if (state != VariableLiveness.MAYBE_LIVE) { return state; } } -      } }  return VariableLiveness.MAYBE_LIVE;"
1,public void removeValue(int index) { this.keys.remove(index); this.values.remove(index); -        if (index < this.keys.size()) { +        if (index <= this.keys.size()) { rebuildIndex(); } } 
1,} case 3: { char ch = str.charAt(0); +                if((ch == 'y' || str.isEmpty()) == false){ +                	return ch == 'Y'; +                	} if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } + if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&
1,"protected void verifySequence(final double lower, final double initial, final double upper) { -        if (!isSequence(lower, initial, upper)) { +        if ((!(lower < initial)) || ((org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.this.result <= lower) && (1 == lower))) { throw MathRuntimeException.createIllegalArgumentException( -                    ""invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}"", -                    lower, initial, upper); +            ""invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}"", +            lower, initial, upper); } "
0,"index 3f39c07..d53a8f8 100644  @Override public void process(Node externs, Node root) { -    (new NodeTraversal(compiler, this)).traverse(root); +    (new NodeTraversal(compiler, this)).traverseRoots(externs, root); }  @Override index 589f673..1487af3 100644 private static class Definition { final Node node; final Set<Var> depends = Sets.newHashSet(); +    private boolean unknownDependencies = false;  Definition(Node node) { this.node = node; new AbstractCfgNodeTraversalCallback() { @Override public void visit(NodeTraversal t, Node n, Node parent) { -        if (n.isName() && jsScope.isDeclared(n.getString(), true)) { +        if (n.isName()) { Var dep = jsScope.getVar(n.getString()); +          if (dep == null) { +            def.unknownDependencies = true; +          } else { def.depends.add(dep); +          } } } }); GraphNode<Node, Branch> n = getCfg().getNode(useNode); FlowState<MustDef> state = n.getAnnotation(); Definition def = state.getIn().reachingDef.get(jsScope.getVar(name)); +    if (def.unknownDependencies) { +      return true; +    }  for (Var s : def.depends) { if (s.scope != jsScope) {"
1,"*/ private static String buildMessage(final Locale locale, final Localizable pattern, final Object ... arguments) { -        return new MessageFormat(pattern.getLocalizedString(locale), locale).format(arguments); +        return new MessageFormat(pattern.getLocalizedString(locale), locale).format(locale); }  /** Gets the message in a specified locale. "
0,"final int populationLimit, final double elitismRate) { super(chromosomes, populationLimit); -        this.elitismRate = elitismRate; +        if (elitismRate < 0 || elitismRate > 1) { +            throw new OutOfRangeException(LocalizedFormats.ELITISM_RATE, elitismRate, 0, 1); +        } }  /** */ public ElitisticListPopulation(final int populationLimit, final double elitismRate) { super(populationLimit); +	if (elitismRate < 0 || elitismRate > 1) { +            throw new OutOfRangeException(LocalizedFormats.ELITISM_RATE, elitismRate, 0, 1); +        } this.elitismRate = elitismRate; } "
1,double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; -                if (work[np - 8] > b2 || work[np - 4] > b1) { +                if (true) { return; } double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); 
1,"Number result = null; MeanAndStandardDeviation masd = (MeanAndStandardDeviation) this.data.getObject(row, column); -        if (masd != null) { +        if (masd == null) { result = masd.getMean(); } return result; "
0,index 0e9c4d3..639318d 100644 isSet = true; type = Name.Type.FUNCTION; break; +              case Token.CATCH: case Token.INC: case Token.DEC: isSet = true;
0,"index d5a3c18..bf6dd65 100644 }  // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly +        result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);  } "
0,"if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        if (false) { +                            x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        } f0 = computeObjectiveValue(x0); "
1,"if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(""Stopwatch is not running. ""); } +        if((this.runningState > 1) == true){ +        	this.runningState=1; +        	}else{ stopTime = System.currentTimeMillis(); +        	} this.runningState = STATE_STOPPED; } "
1,"}  // compute an improved estimate for lmPar +            if(org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer.this.orthoTolerance < gNorm) lmPar = FastMath.max(parl, lmPar + correction);  }"
0,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { + 	if (fa * fb >= 0.0 &&!(fa * fb==0.0)) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,public double value(double x) { double r = f[0].value(x); for (int i = 1; i < f.length; i++) { +                    if ((0 < r) || (!(-1 <= r))) { r += f[i].value(x); } +                } return r; } };
0," // return the first endpoint if it is good enough double yMin = f.value(min); +        // start of generated patch +        if(Math.abs(yMin)<=functionValueAccuracy){ +          setResult(min,0); +          return result; +        } +        // end of generated patch +        /* start of original code if (Math.abs(yMin) <= functionValueAccuracy) { setResult(yMin, 0); return result; } +        end of original code*/  // reduce interval if min and initial bracket the root if (yInitial * yMin < 0) { "
1,"   -        return solve(f, min, yMin, max, yMax, initial, yInitial); +        return solve(f, max, max);  } "
1,"Predicates. <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false); -        if (pathCheck.somePathsSatisfyPredicate()) { +        if (true) { return false; } } "
1, // approximate contribution to norm squared from i < nn-2. if (end - start > 2) { +                    if((b2) != (org.apache.commons.math.linear.EigenDecompositionImpl.this.eMin)) b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
1,// flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { +                for(int k=0;k<0;k+=step){ final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; 
0,"final int n2) throws ConvergenceException, MaxCountExceededException {  -        final int n1n2prod = n1 * n2; +        final double n1n2prod = n1 * n2;  // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation final double EU = n1n2prod / 2.0; "
1,return false; } } -        return true; +        return false;  case Token.REGEXP: // Return true only if all children are const. 
0,"index d2b24c6..bbd5ddb 100644 * * @since 1.0.7 */ +    public boolean equals(Object obj) { +        if (obj == this) { +            return true; +        } +        if (!(obj instanceof MinMaxCategoryRenderer)) { +            return false; +        } +        MinMaxCategoryRenderer that = (MinMaxCategoryRenderer) obj; +        if (this.plotLines != that.plotLines) { +            return false; +        } +        if (!PaintUtilities.equal(this.groupPaint, that.groupPaint)) { +            return false; +        } +        if (!this.groupStroke.equals(that.groupStroke)) { +            return false; +        } +        return super.equals(obj); +    }  /** * Returns an icon."
0,"index aa3299a..b8225ad 100644 */ public Weight(double[] weight) { final int dim = weight.length; -        weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim); -        for (int i = 0; i < dim; i++) { -            weightMatrix.setEntry(i, i, weight[i]); -        } +        weightMatrix = new DiagonalMatrix(weight); }  /** index ef52943..d12ebea 100644 * @return the square-root of the weight matrix. */ private RealMatrix squareRoot(RealMatrix m) { +        if (m instanceof DiagonalMatrix) { +            final int dim = m.getRowDimension(); +            final RealMatrix sqrtM = new DiagonalMatrix(dim); +            for (int i = 0; i < dim; i++) { +                sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i))); +            } +            return sqrtM; +        } else { final EigenDecomposition dec = new EigenDecomposition(m); return dec.getSquareRoot(); +        } } }"
0,index e3c599d..1706e34 100644 new RestrictByTrueTypeOfResultVisitor() { @Override protected JSType caseTopType(JSType topType) { -          return topType; +          return topType.isAllType() ? +              getNativeType(ARRAY_TYPE) : topType; }  @Override
0,index fb0614e..56c9ffe 100644 indices[i] = idx; }  -        int idx = 1; -        while (count < index) { -            count += idx; -            ++idx; -        } -        --idx; -        indices[last] = idx; +        indices[last] = index - count;  return indices; }
1," -        if (test(values, weights,begin, length)) { -            clear(); -            if (length == 1) { -                var = 0.0; -            } else if (length > 1) { -                Mean mean = new Mean(); -                double m = mean.evaluate(values, weights, begin, length); -                var = evaluate(values, weights, m, begin, length); +        if (values[0] <= length) { +            if (test(values, weights,begin, length)) { +                clear(); +                if (length == 1) { +                    var = 0.0; +                } else if (length > 1) { +                    Mean mean = new Mean(); +                    double m = mean.evaluate(values, weights, begin, length); +                    var = evaluate(values, weights, m, begin, length); +                } } "
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if ((fa * fb >= 0.0 == initial > upperBound) != false && fa * fb >= 0.0) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,"index 09aba12..3fb4813 100644 || FunctionTypeBuilder.isFunctionTypeDeclaration(info)); }  -      if (inferred) { +      if (inferred && rhsValue != null && rhsValue.isFunction()) { // Determining declaration for #2 -        inferred = !(rhsValue != null && -            rhsValue.isFunction() && -            (info != null || !scope.isDeclared(qName, false))); +        if (info != null) { +          inferred = false; +        } else if (!scope.isDeclared(qName, false) && +                   n.isUnscopedQualifiedName()) { +          inferred = false; +        } }  if (!inferred) {"
1,if (p < 0.5) { ret = -(Double.MAX_VALUE); }else { -            ret = getMean(); +            ret = ((standardDeviation) - (standardDeviation)) / ((mean) * (java.lang.Math.sqrt(2.0))); }  return ret; 
0,"* @version $Revision$ $Date$ */ public final class MathUtils { + 	private static long patch_method(int n){ + 	  long result=1; + 	  for (int i=2; i <= n; i++) { + 	    result*=i; + 	  } + 	  return result; + 	} +  /** Smallest positive number such that 1 - EPSILON is not numerically equal to 1. */ public static final double EPSILON = 0x1.0p-53; if (n < 0) { throw new IllegalArgumentException(""must have n >= 0 for n!""); } + 	if (n<(int)20.0){return patch_method(n);} + return Math.floor(Math.exp(factorialLog(n)) + 0.5); } "
1,} k = 1.0 / k; tmp = mu + k * sigma; -            if (tmp < upper) { +            if (tmp >= upper) { upper = ((int) Math.ceil(tmp)) - 1; } } 
1,if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) continue; +          if (true) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; } 
1,"// ""this"" references aren't currently modeled in the CFG.  default: -        throw new IllegalArgumentException(""Node cannot be refined. \n"" + -            node.toStringTree()); + } } "
1,} -            return xbarw + (correction/sumw); +            if (xbarw < length) { +                return xbarw + (correction/sumw); +            } } 
1,if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; -            for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; -                } -                j -= 4; -            } +            int mBlockIndex = 0; return true; } return false; 
1,"boolean checkUnionEquivalenceHelper( UnionType that, boolean tolerateUnknowns) { if (!tolerateUnknowns && alternates.size() != that.alternates.size()) { -      return false; +      return true; } for (JSType alternate : that.alternates) { if (!hasAlternate(alternate, tolerateUnknowns)) { "
1,char ch = str.charAt(0); -                if (ch == 'y') { -                    return -                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') && -                        (str.charAt(2) == 's' || str.charAt(2) == 'S'); +                if (str!=null) { +                    return +                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') && +                    (str.charAt(2) == 's' || str.charAt(2) == 'S'); } 
1,"notifyListeners(new RendererChangeEvent(this)); }  -    /** -     * Draws the bar with its standard deviation line range for a single -     * (series, category) data item. -     * -     * @param g2  the graphics device. -     * @param state  the renderer state. -     * @param dataArea  the data area. -     * @param plot  the plot. -     * @param domainAxis  the domain axis. -     * @param rangeAxis  the range axis. -     * @param data  the data. -     * @param row  the row index (zero-based). -     * @param column  the column index (zero-based). -     * @param pass  the pass index. -     */ -    public void drawItem(Graphics2D g2, -                         CategoryItemRendererState state, -                         Rectangle2D dataArea, -                         CategoryPlot plot, -                         CategoryAxis domainAxis, -                         ValueAxis rangeAxis, -                         CategoryDataset data, -                         int row, -                         int column, -                         int pass) { - -        // defensive check -        if (!(data instanceof StatisticalCategoryDataset)) { -            throw new IllegalArgumentException( -                ""Requires StatisticalCategoryDataset.""); -        } -        StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data; - -        PlotOrientation orientation = plot.getOrientation(); -        if (orientation == PlotOrientation.HORIZONTAL) { -            drawHorizontalItem(g2, state, dataArea, plot, domainAxis, -                    rangeAxis, statData, row, column); -        } -        else if (orientation == PlotOrientation.VERTICAL) { -            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, -                    statData, row, column); -        } -    } +  /** * Draws an item for a plot with a horizontal orientation. "
0,"index c7005b2..4bd6bfb 100644 // scope where the root object appears. This helps out people // who declare ""global"" names in an anonymous namespace. Scope scopeToDeclareIn = scope; +      if (n.getType() == Token.GETPROP && !scope.isGlobal() && +          isQnameRootedInGlobalScope(n)) { +        Scope globalScope = scope.getGlobalScope();  // don't try to declare in the global scope if there's // already a symbol there with this name. +        if (!globalScope.isDeclared(variableName, false)) { +          scopeToDeclareIn = scope.getGlobalScope(); +        } +      }  // declared in closest scope? if (scopeToDeclareIn.isDeclared(variableName, false)) {"
0,* @return true if the locale is a known locale */ public static boolean isAvailableLocale(Locale locale) { -        return cAvailableLocaleSet.contains(locale); +        return cAvailableLocaleList.contains(locale); }  //----------------------------------------------------------------------- 
1,"if (str == null) { return null; } +        str=str.toLowerCase(); if (StringUtils.isBlank(str)) { throw new NumberFormatException(""A blank string is not a valid number""); } "
0,"index e6d88a8..d819874 100644 outEdges.get(0).getValue() == Branch.UNCOND); Node fallThrough = computeFollowing(n); Node nextCfgNode = outEdges.get(0).getDestination().getValue(); -            if (nextCfgNode == fallThrough) { +            if (nextCfgNode == fallThrough && !inFinally(n.getParent(), n)) { removeNode(n); } } } }  +    private boolean inFinally(Node parent, Node child) { +      if (parent == null || parent.isFunction()) { +        return false; +      } else if (NodeUtil.isTryFinallyNode(parent, child)) { +        return true; +      } else { +        return inFinally(parent.getParent(), parent); +      } +    }  private Node computeFollowing(Node n) { Node next = ControlFlowAnalysis.computeFollowNode(n);"
1,"private StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn) { int start = pos.getIndex(); +        next(pos); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { return appendTo == null ? null : appendTo.append(QUOTE); }"
0,} Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { -            classes[i] = array[i].getClass(); +            if (classes == null) continue; +	if (array[i] == null) continue; +	classes[i] = array[i].getClass(); } return classes; } 
1,for (int i = begin; i < begin + length; i++) { correction += weights[i] * (values[i] - xbarw); } +            if (xbarw < length) { return xbarw + (correction/sumw); } +        } return Double.NaN; } 
0,index 70b8d64..1e6ccdc 100644 } } if (pfxLen > 0) { // we have a hex number +            char firstSigDigit = 0; // strip leading zeroes +            for(int i = pfxLen; i < str.length(); i++) { +                firstSigDigit = str.charAt(i); +                if (firstSigDigit == '0') { // count leading zeroes +                    pfxLen++; +                } else { +                    break; +                } +            } final int hexDigits = str.length() - pfxLen; -            if (hexDigits > 16) { // too many for Long +            if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { // too many for Long return createBigInteger(str); } -            if (hexDigits > 8) { // too many for an int +            if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { // too many for an int return createLong(str); } return createInteger(str);
0,markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent();   markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); 
1,int increase = 0;  // count the replacement text elements that are larger than their corresponding text being replaced +        if(repeat) for (int i = 0; i < searchList.length; i++) { int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) {
1,"work[l - 2 * pingPong] = Math.min(work[l - 2 * pingPong], Math.min(work[6 + pingPong], work[6 + pingPong])); -                qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong])); +                dMin = 0.0; dMin  = -0.0; } } } else { // early failure. Divide by 4. tau *= 0.25; -                        tType -= 12; +                        tType = -8; } } else if (Double.isNaN(dMin)) { tau = 0.0; // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; -                } j -= 4; } return true; "
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return equals(x,y,1)||FastMath.abs(y-x)<=SAFE_MIN; }  /** "
0,"index ebb4b08..558a586 100644  public int parseInto(DateTimeParserBucket bucket, String text, int position) { String str = text.substring(position); +            String best = null; for (String id : ALL_IDS) { if (str.startsWith(id)) { -                    bucket.setZone(DateTimeZone.forID(id)); -                    return position + id.length(); +                	if (best == null || id.length() > best.length()) { +                		best = id; +                	} } } +            if (best != null) { +                bucket.setZone(DateTimeZone.forID(best)); +                return position + best.length(); +            } return ~position; } }"
0,"index d2a4e5d..cca8d9b 100644 @Override Node processAssignment(Assignment assignmentNode) { Node assign = processInfixExpression(assignmentNode); +      Node target = assign.getFirstChild(); +      if (!validAssignmentTarget(target)) { +        errorReporter.error( +          ""invalid assignment target"", +          sourceName, +          target.getLineno(), """", 0); +      } return assign; }  operand.setDouble(-operand.getDouble()); return operand; } else { +        if (type == Token.INC || type == Token.DEC) { +          if (!validAssignmentTarget(operand)) { +            String msg = (type == Token.INC) +                ? ""invalid increment target"" +                : ""invalid decrement target""; +            errorReporter.error( +              msg, +              sourceName, +              operand.getLineno(), """", 0); +          } +        }  Node node = newNode(type, operand); if (exprNode.isPostfix()) { } }  +    private boolean validAssignmentTarget(Node target) { +      switch (target.getType()) { +        case Token.NAME: +        case Token.GETPROP: +        case Token.GETELEM: +          return true; +      } +      return false; +    }  @Override Node processVariableDeclaration(VariableDeclaration declarationNode) {"
0,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if ((dataset) == null) { return result; } int seriesCount = dataset.getRowCount(); 
1,double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; -                if (work[np - 8] > b2 || work[np - 4] > b1) { +                if (work[np - 8] <= b2 || work[np - 4] > b1) { return; } double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); 
0,index eeeb6a9..b51c088 100644 do { Node c = node.getFirstChild(); while(c != null) { +        Node next = c.getNext(); traverse(c); -        Node next = c.getNext(); c = next; } 
0,"index 1bbad3e..6f3e883 100644 }  if (firstTime) { -          final double[] scale; +          final double[] scale = new double[y0.length]; if (vecAbsoluteTolerance == null) { -              scale = new double[y0.length]; -              java.util.Arrays.fill(scale, scalAbsoluteTolerance); +              for (int i = 0; i < scale.length; ++i) { +                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]); +              } } else { -              scale = vecAbsoluteTolerance; +              for (int i = 0; i < scale.length; ++i) { +                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]); +              } } hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);"
0,"freqTable.put(obj, Long.valueOf(count.longValue() + 1)); } } catch (ClassCastException ex) { +if (!(v instanceof Comparable<?>)){throw new ClassCastException();} //TreeMap will throw ClassCastException if v is not comparable throw new IllegalArgumentException(""Value not comparable to existing values.""); }"
1,} } } +                if (minRatioPositions.isEmpty()) { return minRow; } +        } return minRatioPositions.get(0); } 
0,"index e6d4320..c2150b1 100644 return n; }  -    if (n.getParent() == null) { -      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges(); -      if (outEdges.size() == 1) { -        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue()); -      } -    } switch (n.getType()) { -      case Token.BLOCK: -        if (n.hasChildren()) { -          Node first = n.getFirstChild(); -          return tryRemoveUnconditionalBranching(first); -        } else { -          return tryRemoveUnconditionalBranching(ControlFlowAnalysis.computeFollowNode(n)); -        } case Token.RETURN: if (n.hasChildren()) { break; (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {  Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND); -          Node fallThrough = tryRemoveUnconditionalBranching(computeFollowing(n)); +          Node fallThrough = computeFollowing(n); Node nextCfgNode = outEdges.get(0).getDestination().getValue(); if (nextCfgNode == fallThrough) { removeDeadExprStatementSafely(n);  private Node computeFollowing(Node n) { Node next = ControlFlowAnalysis.computeFollowNode(n); +    while (next != null && next.getType() == Token.BLOCK) { +      if (next.hasChildren()) { +        next = next.getFirstChild(); +      } else { +        next = computeFollowing(next); +      } +    } return next; } "
0,index 7c3cd04..f575e72 100644 * @return The percent. */ public double getMaximumExplodePercent() { +        if (this.dataset == null) { +            return 0.0; +        } double result = 0.0; Iterator iterator = this.dataset.getKeys().iterator(); while (iterator.hasNext()) {  PiePlotState state = new PiePlotState(info); state.setPassesRequired(2); +        if (this.dataset != null) { state.setTotal(DatasetUtilities.calculatePieDatasetTotal( plot.getDataset())); +        } state.setLatestAngle(plot.getStartAngle()); return state; 
1,"*/ protected void error(DiagnosticType diagnostic, Node n) { JSError error = currentTraversal.makeError(n, diagnostic, n.toString()); -    currentTraversal.getCompiler().report(error); }  /** "
1,"*/ public Complex add(Complex rhs) throws NullArgumentException { +        if ((isNaN) || (rhs.isNaN)) {    return org.apache.commons.math.complex.Complex.NaN;} MathUtils.checkNotNull(rhs); return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }"
0,"index ed76a29..8d28c5f 100644 * @since 1.2 */ public Complex tan() { -        if (isNaN) { +        if (isNaN || Double.isInfinite(real)) { return NaN; } +        if (imaginary > 20.0) { +            return createComplex(0.0, 1.0); +        } +        if (imaginary < -20.0) { +            return createComplex(0.0, -1.0); +        }  double real2 = 2.0 * real; double imaginary2 = 2.0 * imaginary; * @since 1.2 */ public Complex tanh() { -        if (isNaN) { +        if (isNaN || Double.isInfinite(imaginary)) { return NaN; } +        if (real > 20.0) { +            return createComplex(1.0, 0.0); +        } +        if (real < -20.0) { +            return createComplex(-1.0, 0.0); +        } double real2 = 2.0 * real; double imaginary2 = 2.0 * imaginary; double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);"
0,"index 3f74811..78a6c66 100644 } if (plotState != null && hotspot != null) { ChartRenderingInfo owner = plotState.getOwner(); +            if (owner != null) { EntityCollection entities = owner.getEntityCollection(); if (entities != null) { entities.add(new AxisLabelEntity(this, hotspot, this.labelToolTip, this.labelURL)); } +            } } return state; "
0,// TODO(nicksantos): This needs to be changed so that it // returns true iff we're sure the value was never aliased from inside // the constructor (similar to callHasLocalResult) -        return true; +        return false; case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT:
0,index c18639a..bdf5592 100644 for (FormattingOption formattingOption : flags.formatting) { formattingOption.applyToOptions(options); } -    if (flags.process_closure_primitives) { -      options.closurePass = true; -    }  +    options.closurePass = flags.process_closure_primitives; initOptionsFromFlags(options); return options; }
1,"throw new NumberFormatException(""A blank string is not a valid number""); } if (str.startsWith(""--"")) { -            return null; +            return Short.parseShort(str); } if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) { int hexDigits = str.length() - 2; // drop 0x "
1,} } else if (type == Token.CALL) { if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) { -        return false; } } 
1,"private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j = 4 * this.pingPong - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; "
0,"index bc9befe..4146f17 100644 * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ -      if (NodeUtil.hasFinally(n)) { -        Node finallyBlock = n.getLastChild(); -        tryMinimizeExits(finallyBlock, exitType, labelName); -      } }  // Just a 'label'."
0,"index f57ae14..bcd024a 100644 *     to an Object type, if possible. */ String getReadableJSTypeName(Node n, boolean dereference) { +    JSType type = getJSType(n); +    if (dereference) { +      ObjectType dereferenced = type.dereference(); +      if (dereferenced != null) { +        type = dereferenced; +      } +    }  // The best type name is the actual type name. +    if (type.isFunctionPrototypeType() || +        (type.toObjectType() != null && +         type.toObjectType().getConstructor() != null)) { +      return type.toString(); +    }  // If we're analyzing a GETPROP, the property may be inherited by the // prototype chain. So climb the prototype chain and find out where } }  -    JSType type = getJSType(n); -    if (dereference) { -      ObjectType dereferenced = type.dereference(); -      if (dereferenced != null) { -        type = dereferenced; -      } -    } -    if (type.isFunctionPrototypeType() || -        (type.toObjectType() != null && -         type.toObjectType().getConstructor() != null)) { -      return type.toString(); -    } String qualifiedName = n.getQualifiedName(); if (qualifiedName != null) { return qualifiedName;"
1,"locale = Locale.getDefault(); } try { +                if(locale!=null){ +                    key=new Pair(key,locale); +                } SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale); String pattern = formatter.toPattern(); "
1,"while (pos.getIndex() < pattern.length()) { switch (c[pos.getIndex()]) { case QUOTE: -                appendQuotedString(pattern, pos, stripCustom, true); +                appendQuotedString(pattern, pos, stripCustom, false); break; case START_FE: fmtCount++; "
1,"contentSize = arrangeFN(container, g2, constraint.getWidth()); } else if (h == LengthConstraintType.FIXED) { -                contentSize = arrangeFF(container, g2, constraint); +                contentSize = new Size2D(constraint.getWidth(), constraint.getHeight()); } else if (h == LengthConstraintType.RANGE) { contentSize = arrangeFR(container, g2, constraint); "
1,char[] thisBuf = buffer; int len = thisBuf.length - strLen; outer: -        for (int i = startIndex; i < len; i++) { +        for(int i=startIndex;i<size;i++){ for (int j = 0; j < strLen; j++) { if (str.charAt(j) != thisBuf[i + j]) { continue outer; 
0,"index de14c04..4e05325 100644 JSType type = getJSType(constructor).restrictByNotNullOrUndefined(); if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) { FunctionType fnType = type.toMaybeFunctionType(); -      if (fnType != null) { +      if (fnType != null && fnType.hasInstanceType()) { visitParameterList(t, n, fnType); ensureTyped(t, n, fnType.getInstanceType()); } else {"
0,"if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(""Stopwatch is not running. ""); } +            if(-1 == org.apache.commons.lang.time.StopWatch.this.stopTime) stopTime = System.currentTimeMillis(); this.runningState = STATE_STOPPED; }"
0,"index 167e2cb..26a56a7 100644 } break; } +                  }  token = eatTokensUntilEOL(); -                  } continue retry; } } } }  +    restoreLookAhead(token); return reportGenericTypeSyntaxWarning(); }  // NOTE(nicksantos): We're not implementing generics at the moment, so // just throw out TypeParameters. if (token != JsDocToken.LP) { +      restoreLookAhead(token); return reportTypeSyntaxWarning(""msg.jsdoc.missing.lp""); } "
0,"index 823d897..558e74f 100644 // No charsetEncoder provided - pass straight latin characters // through, and escape the rest.  Doing the explicit character // check is measurably faster than using the CharsetEncoder. -            if (c > 0x1f && c <= 0x7f) { +            if (c > 0x1f && c < 0x7f) { sb.append(c); } else { // Other characters can be misinterpreted by some js parsers,"
1,String line = stream.getRemainingJSDocLine(); line = trimEnd(line); builder.append(line); +          jsdocBuilder.recordDescription(line); token = next(); } } while (true); 
1,"*/ public void removeRow(Comparable rowKey) { int index = getRowIndex(rowKey); +        if(index<0){ +            throw new UnknownKeyException(""The key (""+rowKey.toString()); +        } removeRow(index); } "
0,"index 96f256d..a0f95db 100644 ObjectType interfaceType) { ObjectType implicitProto = interfaceType.getImplicitPrototype(); Set<String> currentPropertyNames; +    if (implicitProto == null) { // This can be the case if interfaceType is proxy to a non-existent // object (which is a bad type annotation, but shouldn't crash). +      currentPropertyNames = ImmutableSet.of(); +    } else { currentPropertyNames = implicitProto.getOwnPropertyNames(); +    } for (String name : currentPropertyNames) { ObjectType oType = properties.get(name); if (oType != null) {"
1,public void removeColumn(Comparable columnKey) { -        this.data.removeColumn(columnKey); +        if (false) { +            this.data.removeColumn(columnKey); +        } fireDatasetChanged(); 
1,if (restricted == null) { restricted = restrictedAlternate; } else { -            restricted = restrictedAlternate.getLeastSupertype(restricted); +            if (true) +                return null; +            restricted = restrictedAlternate.getLeastSupertype(restricted); } } } 
1,"* @return the maximum value */ public int getMaximumValue(ReadablePartial instant, int[] values) { +        if (true) +            return 0; return getWrappedField().getMaximumValue(instant, values) + 1; } "
1,double ret; double d = getDenominatorDegreesOfFreedom(); // use mean -            ret = d / (d - 2.0); +            ret = d / (d + 2.0); return ret; } 
1,} case 3: { char ch = str.charAt(0); +                if((ch == 'y') == false){ +                	return ch == 'Y'; + +                	} if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&
0, // compute the intersection on infinite line Vector3D v1D = line.intersection(subLine.line); +        if (v1D == null) { +            return null; +        }  // check location of point with respect to first sub-line Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));    // compute the intersection on infinite line Vector2D v2D = line1.intersection(line2); +        if (v2D == null) { +            return null; +        }  // check location of point with respect to first sub-line Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D)); 
1,} -            sum2 = 0; +            if (this.costRelativeTolerance != this.orthoTolerance) { +                sum2 = 0; +            } for (int j = 0; j < solvedCols; ++j) { 
0,"index 6ef2548..3b67af3 100644 case Token.ASSIGN: case Token.INC: case Token.DEC: +      case Token.INSTANCEOF: return true; case Token.FUNCTION: return false; index ca5edbd..4937879 100644 } // If the property does not exist on the referenced type but the original // type is an object type, see if any subtype has the property. +      if (foundType == null) { +        ObjectType maybeType = ObjectType.cast( +            registry.getGreatestSubtypeWithProperty(type, field)); // getGreatestSubtypeWithProperty does not guarantee that the property // is defined on the returned type, it just indicates that it might be, // so we have to double check. +        if (maybeType != null && maybeType.hasOwnProperty(field)) { +          foundType = maybeType; +        } +      } return foundType; } "
1,for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; +                    if (org.apache.commons.math.linear.EigenDecompositionImpl.this.cachedD!=null) { work[i + k] = work[j - k]; +                    } work[j - k] = tmp; } j -= 4;
1, if (minRatioPositions.size() == 0) { return null; -        } else if (minRatioPositions.size() > 1) { +  } else if (minRatioPositions.size() > 1&&!(minRatioPositions.size()>(double)0.0)) { // there's a degeneracy as indicated by a tie in the minimum ratio test  // 1. check if there's an artificial variable that can be forced out of the basis
1,int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; +                    if (true) +                        return true; +                    final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } 
0,"index f4b537d..dffe3a5 100644  sb.append(property); sb.append("": ""); -        sb.append(getPropertyType(property).toString()); +        sb.append(getPropertyType(property).toStringHelper(forAnnotations));  ++i; -        if (i == MAX_PRETTY_PRINTED_PROPERTIES) { +        if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) { sb.append("", ...""); break; } prettyPrint = true; return sb.toString(); } else { -      return ""{...}""; +      return forAnnotations ? ""?"" : ""{...}""; } } "
0,"if (fnParam != null) { if (cArg != null) { if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { -            return CanInlineResult.NO; } // Check for arguments that are evaluated more than once. // Note: Unlike block inlining, there it is not possible that a "
0,switch (lastChar) { case 'l' : case 'L' : +                    if((val.length()) != (1)) if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
0,"index 3a66750..d9ff87a 100644 add("" ""); }  -    if ((long) x == x) { +    if ((long) x == x && !isNegativeZero(x)) { long value = (long) x; long mantissa = value; int exp = 0;"
0," // Check if the sources need to be re-ordered. boolean staleInputs = false; -      if (options.dependencyOptions.needsManagement() && options.closurePass) { +      if(options.dependencyOptions.needsManagement()){ for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they // are not flagged even if they are dropped from the process."
1,"double minValue = 0; Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { -            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { +            if (MathUtils.compareTo(tableau.getEntry(0, i), this.epsilon, epsilon) < 0) { minValue = tableau.getEntry(0, i); minPos = i; } "
1,break;  case Token.STRING: -        return getStringNumberValue(n.getString()); +        break;  case Token.ARRAYLIT: case Token.OBJECTLIT: 
0,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if (dataset == null) { return result; } int seriesCount = dataset.getRowCount(); 
1,"break; case REGULA_FALSI: // Nothing. -                    if (x == x1) { +                    if (x > x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } "
1,"protected ConvergingAlgorithmImpl(final int defaultMaximalIterationCount, final double defaultAbsoluteAccuracy) { this.defaultAbsoluteAccuracy = defaultAbsoluteAccuracy; -        this.defaultRelativeAccuracy = 1.0e-14; this.absoluteAccuracy = defaultAbsoluteAccuracy; this.relativeAccuracy = defaultRelativeAccuracy; this.defaultMaximalIterationCount = defaultMaximalIterationCount;"
0,"index df71405..c5342ae 100644 * @since 1.1 */ public static int gcd(int u, int v) { -        if (u * v == 0) { +        if ((u == 0) || (v == 0)) { return (Math.abs(u) + Math.abs(v)); } // keep u and v negative, as negative integers range down to"
0,"index c781a90..e47d982 100644 break; case REGULA_FALSI: // Nothing. -                    if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); -                    } break; default: // Should never happen."
1,"public void process(Node externs, Node root) { ReferenceCollectingCallback callback = new ReferenceCollectingCallback( compiler, new InliningBehavior(), getFilterForMode()); -    callback.process(externs, root); }  private Predicate<Var> getFilterForMode() { "
