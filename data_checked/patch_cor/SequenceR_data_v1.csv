,project,label,content,tool,bug_id,filename,project_with_label,all_paths
457,Lang,1,"//          // contract with translators is that they have to understand codepoints //          // and they just took care of a surrogate pair for (int pt = 0; pt < consumed; pt++) { -                pos += Character.charCount(Character.codePointAt(input, pos)); +                pos+=Character.charCount(Character.codePointAt(input,0)); } } }",SequenceR,6,patch2-Lang-6-SequenceR-plausible.patch,Lang-overfit,patches_remove_inconsistent/overfitting/SequenceR/Lang/patch2-Lang-6-SequenceR-plausible.patch
458,Closure,1,"// No charsetEncoder provided - pass straight latin characters // through, and escape the rest.  Doing the explicit character // check is measurably faster than using the CharsetEncoder. -            if (c > 0x1f && c <= 0x7f) { +            if((c>=31)&&(c<127)){ sb.append(c); } else { // Other characters can be misinterpreted by some js parsers,",SequenceR,73,patch1-Closure-73-SequenceR-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/SequenceR/Closure/patch1-Closure-73-SequenceR-plausible.patch
459,Closure,1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(""JSC_LATE_PROVIDE_ERROR""); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)",SequenceR,92,patch7-Closure-92-SequenceR-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/SequenceR/Closure/patch7-Closure-92-SequenceR-plausible.patch
460,Closure,1,// TODO(nicksantos): This needs to be changed so that it // returns true iff we're sure the value was never aliased from inside // the constructor (similar to callHasLocalResult) -        return true; +        return locals.apply(value); case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT:,SequenceR,86,patch3-Closure-86-SequenceR-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/SequenceR/Closure/patch3-Closure-86-SequenceR-plausible.patch
461,Closure,1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(""JSC_NULL_ARGUMENT_ERROR""); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)",SequenceR,93,patch2-Closure-93-SequenceR-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/SequenceR/Closure/patch2-Closure-93-SequenceR-plausible.patch
462,Closure,1,// TODO(nicksantos): This needs to be changed so that it // returns true iff we're sure the value was never aliased from inside // the constructor (similar to callHasLocalResult) -        return true; +        return NodeUtil.evaluatesToLocalValue(value.getFirstChild()); case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT:,SequenceR,86,patch5-Closure-86-SequenceR-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/SequenceR/Closure/patch5-Closure-86-SequenceR-plausible.patch
463,Closure,1," // Check if the sources need to be re-ordered. boolean staleInputs = false; -      if (options.dependencyOptions.needsManagement() && options.closurePass) { +      if(((options)!=null)&&(options.dependencyOptions.needsManagement())){ for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they // are not flagged even if they are dropped from the process.",SequenceR,18,patch3-Closure-18-SequenceR-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/SequenceR/Closure/patch3-Closure-18-SequenceR-plausible.patch
464,Closure,1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf('.','.'); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)",SequenceR,93,patch1-Closure-93-SequenceR-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/SequenceR/Closure/patch1-Closure-93-SequenceR-plausible.patch
465,Closure,1,"case Token.HOOK: { Preconditions.checkState(childCount == 3); int p = NodeUtil.precedence(type); -        Context rhsContext = Context.OTHER; +        CodeGenerator.Context rhsContext=CodeGenerator.Context.IN_FOR_INIT_CLAUSE; addExpr(first, p + 1, context); cc.addOp(""?"", true); addExpr(first.getNext(), 1, rhsContext);",SequenceR,123,patch1-Closure-123-SequenceR-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/SequenceR/Closure/patch1-Closure-123-SequenceR-plausible.patch
466,Closure,1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(""JSC_INVALID_ARGUMENT_ERROR""); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)",SequenceR,93,patch3-Closure-93-SequenceR-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/SequenceR/Closure/patch3-Closure-93-SequenceR-plausible.patch
467,Closure,1,// TODO(nicksantos): This needs to be changed so that it // returns true iff we're sure the value was never aliased from inside // the constructor (similar to callHasLocalResult) -        return true; +        return NodeUtil.isImmutableValue(value); case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT:,SequenceR,86,patch2-Closure-86-SequenceR-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/SequenceR/Closure/patch2-Closure-86-SequenceR-plausible.patch
468,Closure,1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(""JSC_NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR""); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)",SequenceR,93,patch4-Closure-93-SequenceR-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/SequenceR/Closure/patch4-Closure-93-SequenceR-plausible.patch
469,Closure,1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(""JSC_BASE_CLASS_ERROR""); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)",SequenceR,93,patch9-Closure-93-SequenceR-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/SequenceR/Closure/patch9-Closure-93-SequenceR-plausible.patch
470,Closure,1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(""JSC_DUPLICATE_NAMESPACE_ERROR""); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)",SequenceR,93,patch5-Closure-93-SequenceR-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/SequenceR/Closure/patch5-Closure-93-SequenceR-plausible.patch
471,Closure,1," // Check if the sources need to be re-ordered. boolean staleInputs = false; -      if (options.dependencyOptions.needsManagement() && options.closurePass) { +      if(((options.dependencyOptions)!=null)&&(options.dependencyOptions.needsManagement())){ for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they // are not flagged even if they are dropped from the process.",SequenceR,18,patch4-Closure-18-SequenceR-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/SequenceR/Closure/patch4-Closure-18-SequenceR-plausible.patch
472,Closure,1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(namespace,'.'); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)",SequenceR,93,patch10-Closure-93-SequenceR-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/SequenceR/Closure/patch10-Closure-93-SequenceR-plausible.patch
473,Closure,1," // Check if the sources need to be re-ordered. boolean staleInputs = false; -      if (options.dependencyOptions.needsManagement() && options.closurePass) { +      if(((options)==null)||(options.dependencyOptions.needsManagement())){ for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they // are not flagged even if they are dropped from the process.",SequenceR,18,patch5-Closure-18-SequenceR-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/SequenceR/Closure/patch5-Closure-18-SequenceR-plausible.patch
474,Closure,1,"// x--4 (which is a syntax error). char prev = getLastChar(); boolean negativeZero = isNegativeZero(x); -    if (x < 0 && prev == '-') { +    if((prev<0)||(prev=='-')){ add("" ""); } ",SequenceR,38,patch3-Closure-38-SequenceR-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/SequenceR/Closure/patch3-Closure-38-SequenceR-plausible.patch
475,Closure,1,// TODO(nicksantos): This needs to be changed so that it // returns true iff we're sure the value was never aliased from inside // the constructor (similar to callHasLocalResult) -        return true; +        return NodeUtil.isToStringMethodCall(value); case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT:,SequenceR,86,patch4-Closure-86-SequenceR-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/SequenceR/Closure/patch4-Closure-86-SequenceR-plausible.patch
476,Closure,1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(0,'.'); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)",SequenceR,93,patch8-Closure-93-SequenceR-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/SequenceR/Closure/patch8-Closure-93-SequenceR-plausible.patch
477,Closure,1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(""JSC_TOO_MANY_ARGUMENTS_ERROR""); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)",SequenceR,93,patch6-Closure-93-SequenceR-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/SequenceR/Closure/patch6-Closure-93-SequenceR-plausible.patch
478,Closure,1," // Check if the sources need to be re-ordered. boolean staleInputs = false; -      if (options.dependencyOptions.needsManagement() && options.closurePass) { +      if((options.dependencyOptions.needsManagement())||(options.closurePass)){ for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they // are not flagged even if they are dropped from the process.",SequenceR,18,patch1-Closure-18-SequenceR-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/SequenceR/Closure/patch1-Closure-18-SequenceR-plausible.patch
479,Closure,1,"// x--4 (which is a syntax error). char prev = getLastChar(); boolean negativeZero = isNegativeZero(x); -    if (x < 0 && prev == '-') { +    if((prev!=0)&&(prev=='-')){ add("" ""); } ",SequenceR,38,patch2-Closure-38-SequenceR-plausible.patch,Closure-overfit,patches_remove_inconsistent/overfitting/SequenceR/Closure/patch2-Closure-38-SequenceR-plausible.patch
480,Chart,1,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if((dataset!=null)&&(!(dataset.equals(dataset)))){ return result; } int seriesCount = dataset.getRowCount();,SequenceR,1,patch3-Chart-1-SequenceR-plausible.patch,Chart-overfit,patches_remove_inconsistent/overfitting/SequenceR/Chart/patch3-Chart-1-SequenceR-plausible.patch
481,Chart,1,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if((dataset!=null)&&(index> 0)){ return result; } int seriesCount = dataset.getRowCount();,SequenceR,1,patch4-Chart-1-SequenceR-plausible.patch,Chart-overfit,patches_remove_inconsistent/overfitting/SequenceR/Chart/patch4-Chart-1-SequenceR-plausible.patch
482,Chart,1,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if((dataset!=null)&&(index!=0)){ return result; } int seriesCount = dataset.getRowCount();,SequenceR,1,patch2-Chart-1-SequenceR-plausible.patch,Chart-overfit,patches_remove_inconsistent/overfitting/SequenceR/Chart/patch2-Chart-1-SequenceR-plausible.patch
483,Math,1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((Math.max((fa*0.0),0.0))> 0.0){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +",SequenceR,85,patch14-Math-85-SequenceR-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/SequenceR/Math/patch14-Math-85-SequenceR-plausible.patch
484,Math,1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((fa)> 0.0){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +",SequenceR,85,patch3-Math-85-SequenceR-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/SequenceR/Math/patch3-Math-85-SequenceR-plausible.patch
485,Math,1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((fa> fb)&&((fa*fb)>=0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +",SequenceR,85,patch10-Math-85-SequenceR-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/SequenceR/Math/patch10-Math-85-SequenceR-plausible.patch
486,Math,1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if(((fa*fb)> 0.0)&&((initial)!=0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +",SequenceR,85,patch17-Math-85-SequenceR.patch,Math-overfit,patches_remove_inconsistent/overfitting/SequenceR/Math/patch17-Math-85-SequenceR.patch
487,Math,1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((fa)>=0.0){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +",SequenceR,85,patch4-Math-85-SequenceR-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/SequenceR/Math/patch4-Math-85-SequenceR-plausible.patch
488,Math,1,"for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { +            if((MathUtils.compareTo(entry,epsilon,epsilon))>=0){ final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio;",SequenceR,82,patch3-Math-82-SequenceR-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/SequenceR/Math/patch3-Math-82-SequenceR-plausible.patch
489,Math,1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((fa!=fb)&&((fa)>=0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +",SequenceR,85,patch8-Math-85-SequenceR-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/SequenceR/Math/patch8-Math-85-SequenceR-plausible.patch
490,Math,1,"private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j=(3-n)*1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];",SequenceR,80,patch1-Math-80-SequenceR-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/SequenceR/Math/patch1-Math-80-SequenceR-plausible.patch
491,Math,1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if(((fa*fb)> 0.0)&&((fa)!=0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +",SequenceR,85,patch11-Math-85-SequenceR-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/SequenceR/Math/patch11-Math-85-SequenceR-plausible.patch
492,Math,1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((fa!=fb)&&((fa*fb)> 0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +",SequenceR,85,patch7-Math-85-SequenceR-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/SequenceR/Math/patch7-Math-85-SequenceR-plausible.patch
493,Math,1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((Math.min((fa*fb),0.0))> 0.0){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +",SequenceR,85,patch15-Math-85-SequenceR-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/SequenceR/Math/patch15-Math-85-SequenceR-plausible.patch
494,Math,1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if(((fa)==0.0)||((fa*fb)> 0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +",SequenceR,85,patch16-Math-85-SequenceR-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/SequenceR/Math/patch16-Math-85-SequenceR-plausible.patch
495,Math,1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((fa> 0.0)&&((fa*fb)>=0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +",SequenceR,85,patch6-Math-85-SequenceR-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/SequenceR/Math/patch6-Math-85-SequenceR-plausible.patch
496,Math,1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((fa> 0.0)&&((fa*fb)> 0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +",SequenceR,85,patch9-Math-85-SequenceR-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/SequenceR/Math/patch9-Math-85-SequenceR-plausible.patch
497,Math,1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((fa*0.0)> 0.0){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +",SequenceR,85,patch2-Math-85-SequenceR-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/SequenceR/Math/patch2-Math-85-SequenceR-plausible.patch
498,Math,1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((fa*maximumIterations)> 0.0){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +",SequenceR,85,patch5-Math-85-SequenceR-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/SequenceR/Math/patch5-Math-85-SequenceR-plausible.patch
499,Math,1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((Math.max((fa*fb),0.0))> 0.0){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +",SequenceR,85,patch12-Math-85-SequenceR-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/SequenceR/Math/patch12-Math-85-SequenceR-plausible.patch
500,Math,1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if(((fa*fb)> 0.0)&&(fa> 0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +",SequenceR,85,patch13-Math-85-SequenceR-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/SequenceR/Math/patch13-Math-85-SequenceR-plausible.patch
501,Math,1,"* @return b if a is lesser or equal to b, a otherwise */ public static float max(final float a, final float b) { -        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b); +        return a<=b?b:Float.isNaN((a+b))?Float.NaN:a; }  /** Compute the maximum of two values",SequenceR,59,patch1-Math-59-SequenceR-plausible.patch,Math-overfit,patches_remove_inconsistent/overfitting/SequenceR/Math/patch1-Math-59-SequenceR-plausible.patch
1143,Closure,0,// TODO(nicksantos): This needs to be changed so that it // returns true iff we're sure the value was never aliased from inside // the constructor (similar to callHasLocalResult) -        return true; +        return false; case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT:,SequenceR,86,patch1-Closure-86-SequenceR.patch,Closure-correct,patches_remove_inconsistent/correct/SequenceR/Closure/patch1-Closure-86-SequenceR.patch
1144,Closure,0,"// No charsetEncoder provided - pass straight latin characters // through, and escape the rest.  Doing the explicit character // check is measurably faster than using the CharsetEncoder. -            if (c > 0x1f && c <= 0x7f) { +            if(((c> 31)&&(c<127))&&(c<=127)){ sb.append(c); } else { // Other characters can be misinterpreted by some js parsers,",SequenceR,73,patch2-Closure-73-SequenceR.patch,Closure-correct,patches_remove_inconsistent/correct/SequenceR/Closure/patch2-Closure-73-SequenceR.patch
1145,Closure,0," // Check if the sources need to be re-ordered. boolean staleInputs = false; -      if (options.dependencyOptions.needsManagement() && options.closurePass) { +      if(options.dependencyOptions.needsManagement()){ for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they // are not flagged even if they are dropped from the process.",SequenceR,18,patch1-Closure-18-SequenceR.patch,Closure-correct,patches_remove_inconsistent/correct/SequenceR/Closure/patch1-Closure-18-SequenceR.patch
1146,Closure,0,"// No charsetEncoder provided - pass straight latin characters // through, and escape the rest.  Doing the explicit character // check is measurably faster than using the CharsetEncoder. -            if (c > 0x1f && c <= 0x7f) { +            if((c> 31)&&(c<127)){ sb.append(c); } else { // Other characters can be misinterpreted by some js parsers,",SequenceR,73,patch1-Closure-73-SequenceR.patch,Closure-correct,patches_remove_inconsistent/correct/SequenceR/Closure/patch1-Closure-73-SequenceR.patch
1147,Chart,0,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if ((dataset) == null) { return result; } int seriesCount = dataset.getRowCount(); ,SequenceR,1,patch1-Chart-1-SequenceR.patch,Chart-correct,patches_remove_inconsistent/correct/SequenceR/Chart/patch1-Chart-1-SequenceR.patch
1148,Chart,0,endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1;    // so this is last item BEFORE end } -        if (endIndex < 0) { +        if (endIndex < startIndex) { emptyRange = true; } if (emptyRange) {,SequenceR,9,patch1-Chart-9-SequenceR.patch,Chart-correct,patches_remove_inconsistent/correct/SequenceR/Chart/patch1-Chart-9-SequenceR.patch
1149,Math,0,*/ @Deprecated public double getPct(Object v) { -        return getCumPct((Comparable<?>) v); +        return getPct(((Comparable<?> )(v))); }  /**,SequenceR,75,patch1-Math-75-SequenceR.patch,Math-correct,patches_remove_inconsistent/correct/SequenceR/Math/patch1-Math-75-SequenceR.patch
1150,Math,0,}  if (real == 0.0 && imaginary == 0.0) { -            return NaN; +            return Complex.INF; }  if (isInfinite) {,SequenceR,5,patch1-Math-5-SequenceR.patch,Math-correct,patches_remove_inconsistent/correct/SequenceR/Math/patch1-Math-5-SequenceR.patch
1151,Math,0,"for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { +            if((MathUtils.compareTo(entry,0,epsilon))> 0){ final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio;",SequenceR,82,patch1-Math-82-SequenceR.patch,Math-correct,patches_remove_inconsistent/correct/SequenceR/Math/patch1-Math-82-SequenceR.patch
1152,Math,0,"for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { +            if((MathUtils.compareTo(entry,0,epsilon))>=1){ final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio;",SequenceR,82,patch2-Math-82-SequenceR.patch,Math-correct,patches_remove_inconsistent/correct/SequenceR/Math/patch2-Math-82-SequenceR.patch
