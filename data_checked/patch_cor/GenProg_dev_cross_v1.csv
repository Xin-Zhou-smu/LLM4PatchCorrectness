0,index dd0b00a..d55c25a 100644  if (divisor.isZero) { // return isZero ? NaN : INF; // See MATH-657 -            return isZero ? NaN : INF; +            return NaN; }  if (divisor.isInfinite() && !isInfinite()) { } if (divisor == 0d) { // return isZero ? NaN : INF; // See MATH-657 -            return isZero ? NaN : INF; +            return NaN; } if (Double.isInfinite(divisor)) { return !isInfinite() ? ZERO : NaN;
1,double d = getDenominatorDegreesOfFreedom(); // use mean ret = d / (d - 2.0); -        return ret; +        return d; }  /** 
1,} case 3: { char ch = str.charAt(0); +                if((ch == 'y') == false){ +                	return ch == 'Y'; + +                	} if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&
1,} Range range = (Range) obj; if (!(this.lower == range.lower)) { +            if(((!(1 < org.jfree.data.Range.this.lower)) || (org.jfree.data.Range.this.lower <= -1 + org.jfree.data.Range.this.upper - 1)) && ((!(1 < org.jfree.data.Range.this.lower)) || (org.jfree.data.Range.this.lower <= -1 + org.jfree.data.Range.this.upper - 1))) return false; } if (!(this.upper == range.upper)) {
1,outer: for (int i = startIndex; i < len; i++) { for (int j = 0; j < strLen; j++) { -                if (str.charAt(j) != thisBuf[i + j]) { +            	if (str.charAt(j) != thisBuf[i + j] || (i + j >= length()) == true) { continue outer; } }
0,index 3a91982..0f78330 100644 * @return product of this and x */ public Dfp multiply(final int x) { +        if (x >= 0 && x < RADIX) { return multiplyFast(x); +        } else { +            return multiply(newInstance(x)); +        } }  /** Multiply this by a single digit 0&lt;=x&lt;radix.
0,index 20196bf..a8e92fc 100644 return true; }  +        if (n.isDelProp()) { +          return true; +        }  for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {
0,"String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { -                str.getChars(0, strLen, buffer, size); +                str.getChars(0, width, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); "
1,"parent.replaceChild(node, block); } else { for (Node newChild : replacements) { -        newChild.copyInformationFrom(node); parent.addChildBefore(newChild, node); } parent.removeChild(node);   }  if (parent.isAssign()) { -        return scopes.get(parent); } } "
1,"public Number getMeanValue(int row, int column) { Number result = null; MeanAndStandardDeviation masd -            = (MeanAndStandardDeviation) this.data.getObject(row, column); +            = (MeanAndStandardDeviation) this.data.getObject((int)this.minimumRangeValue, column); if (masd != null) { result = masd.getMean(); } "
1,"if (str == null) { return null; } +        str=str.toLowerCase(); if (StringUtils.isBlank(str)) { throw new NumberFormatException(""A blank string is not a valid number""); } "
1, // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. -      if (n == parent.getLastChild()) { +      if (gramps == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) 
1,public double value(double x) { double r = f[0].value(x); for (int i = 1; i < f.length; i++) { +                    if ((0 < r) || (!(-1 <= r))) { r += f[i].value(x); } +                } return r; } };
1,"try { final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min); final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min); -                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2)); +                optima[i] = optimizer.optimize(f, goal, FastMath.min(min, bound2), FastMath.max(bound1, bound2)); } catch (FunctionEvaluationException fee) { optima[i] = null; } catch (ConvergenceException ce) { "
0,"boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); -            if(Character.isWhitespace(c)) { -                if(!wasWhite) { -                    wasWhite= true; -                    regex.append(""\\s*+""); -                } -                continue; -            } + wasWhite= false; switch(c) { case '\'': "
0,index 7c3cd04..f575e72 100644 * @return The percent. */ public double getMaximumExplodePercent() { +        if (this.dataset == null) { +            return 0.0; +        } double result = 0.0; Iterator iterator = this.dataset.getKeys().iterator(); while (iterator.hasNext()) {  PiePlotState state = new PiePlotState(info); state.setPassesRequired(2); +        if (this.dataset != null) { state.setTotal(DatasetUtilities.calculatePieDatasetTotal( plot.getDataset())); +        } state.setLatestAngle(plot.getStartAngle()); return state; 
1,// charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +          && 0 <= charno && charno < sourceExcerpt.length()|| (charno == sourceExcerpt.length()) == true) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) {
0,"index 4c84735..dfad51b 100644 // is removing globals, then it's OK to remove unused function args. // // See http://code.google.com/p/closure-compiler/issues/detail?id=253 +    if (!removeGlobals) { +      return; +    }  Node function = fnScope.getRootNode(); "
1,"// In ADVANCED mode, goog.getMsg is going to be renamed anyway, // so we might as well inline it. But shut off the i18n warnings, // because the user didn't really ask for i18n. -      options.messageBundle = new EmptyMessageBundle(); + }  return options; "
0, if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); +            if ((null == tree.getCut()) != false && (Boolean)tree.getAttribute()) { -            if ((Boolean) tree.getAttribute()) { // the instance covers the whole space setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN);
0,"index e20d788..14694ce 100644 }  // Clone any remaining params that aren't in the function literal. +      while (oldParams.hasNext()) { +        paramBuilder.newParameterFromNode(oldParams.next()); +      }  parametersNode = paramBuilder.build(); } }  // Copy over any old parameters that aren't in the param list. +    if (!isVarArgs) { +      while (oldParameterType != null && !isVarArgs) { +        builder.newParameterFromNode(oldParameterType); +        oldParameterType = oldParameterType.getNext(); +      } +    }  if (templateTypeName != null && !foundTemplateType) { reportError(TEMPLATE_TYPE_EXPECTED, fnName);"
0,"index ec31907..cf3f52f 100644 * @since 1.0.3 */ public int getDomainAxisIndex(CategoryAxis axis) { +        if (axis == null) { +            throw new IllegalArgumentException(""Null 'axis' argument.""); +        } return this.domainAxes.indexOf(axis); }  * @since 1.0.7 */ public int getRangeAxisIndex(ValueAxis axis) { +        if (axis == null) { +            throw new IllegalArgumentException(""Null 'axis' argument.""); +        } int result = this.rangeAxes.indexOf(axis); if (result < 0) { // try the parent plot Plot parent = getParent();"
0,index ec05941..855cad0 100644 return offsetLocal; } } -        } else if (offsetLocal > 0) { +        } else if (offsetLocal >= 0) { long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev);
1,"case Token.HOOK: { Preconditions.checkState(childCount == 3); int p = NodeUtil.precedence(type); -        Context rhsContext = Context.OTHER; +        CodeGenerator.Context rhsContext=CodeGenerator.Context.IN_FOR_INIT_CLAUSE; addExpr(first, p + 1, context); cc.addOp(""?"", true); addExpr(first.getNext(), 1, rhsContext);"
1,"mant = str.substring(0, decPos); } else { if (expPos > -1) { -                mant = str.substring(0, expPos); -            } else { -                mant = str; +                mant = str;}else {                 mant = str; } dec = null; } "
0,"index 8361ac9..add5c66 100644 }  private boolean hasExceptionHandler(Node cfgNode) { +    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode); +    for (DiGraphEdge<Node, Branch> edge : branchEdges) { +      if (edge.getValue() == Branch.ON_EX) { +        return true; +      } +    } return false; } "
0,"break; case REGULA_FALSI: // Nothing. -                    if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); -                    } break; default: // Should never happen."
0,"index 2116f7c..0c73f42 100644 * * @return the version, for example 131 for Java 1.3.1 */ -    static float toJavaVersionInt(String version) { +    static int toJavaVersionInt(String version) { return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE)); } "
0,index 139d9a7..ceb886e 100644 * @return true if the locale is a known locale */ public static boolean isAvailableLocale(Locale locale) { -        return cAvailableLocaleSet.contains(locale); +        return availableLocaleList().contains(locale); }  //-----------------------------------------------------------------------
0,index 70b8d64..1e6ccdc 100644 } } if (pfxLen > 0) { // we have a hex number +            char firstSigDigit = 0; // strip leading zeroes +            for(int i = pfxLen; i < str.length(); i++) { +                firstSigDigit = str.charAt(i); +                if (firstSigDigit == '0') { // count leading zeroes +                    pfxLen++; +                } else { +                    break; +                } +            } final int hexDigits = str.length() - pfxLen; -            if (hexDigits > 16) { // too many for Long +            if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { // too many for Long return createBigInteger(str); } -            if (hexDigits > 8) { // too many for an int +            if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { // too many for an int return createLong(str); } return createInteger(str);
0,"index 879056f..ef33e4c 100644 Node n, String variable) { if (NodeUtil.isName(n) && variable.equals(n.getString())) { if (NodeUtil.isLhs(n, n.getParent())) { +        Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); // The expression to which the assignment is made is evaluated before // the RHS is evaluated (normal left to right evaluation) but the KILL // occurs after the RHS is evaluated. +        Node rhs = n.getNext(); +        VariableLiveness state = isVariableReadBeforeKill(rhs, variable); +        if (state == VariableLiveness.READ) { +          return state; +        } return VariableLiveness.KILL; } else { return VariableLiveness.READ;"
1,"try { final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min); final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min); -                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2)); +                optima[i] = optimizer.optimize(f, goal, min, FastMath.max(bound1, bound2)); } catch (FunctionEvaluationException fee) { optima[i] = null; } catch (ConvergenceException ce) { "
0,index 420dbc0..5a4f884 100644 // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +          && 0 <= charno && charno <= sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) {
1,"if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { -                minValue = tableau.getEntry(0, i); +                if (false) { +                    minValue = tableau.getEntry(0, i); +                } minPos = i; "
1,if (!(this.lower == range.lower)) { -            return false; +            if ((org.jfree.data.Range.this.lower <= 0) || (29 < org.jfree.data.Range.this.upper)) { +                return false; +            } } 
0,"index 8df302f..a01159b 100644 * @return The <code>StringBuilder</code> */ private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) { -        boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); -            if(Character.isWhitespace(c)) { -                if(!wasWhite) { -                    wasWhite= true; -                    regex.append(""\\s*+""); -                } -                continue; -            } -            wasWhite= false; switch(c) { case '\'': if(unquote) {"
0,"index 0d8f7f4..900e1a8 100644 public void escape(Writer writer, String str) throws IOException { int len = str.length(); for (int i = 0; i < len; i++) { -            char c = str.charAt(i); +            int c = Character.codePointAt(str, i); String entityName = this.entityName(c); if (entityName == null) { -                if (c > 0x7F) { +                if (c >= 0x010000 && i < len - 1) { +                    writer.write(""&#""); +                    writer.write(Integer.toString(c, 10)); +                    writer.write(';'); +                    i++; +                } else if (c > 0x7F) { writer.write(""&#""); writer.write(Integer.toString(c, 10)); writer.write(';');"
0,* @return chromosome iterator */ public Iterator<Chromosome> iterator() { -        return chromosomes.iterator(); +        return getChromosomes().iterator(); } }
0,"index 6c4ee4a..9498fa6 100644 if (n.getType() == Token.BLOCK) { if (n.hasOneChild()) { Node maybeExpr = n.getFirstChild(); +        if (maybeExpr.getType() == Token.EXPR_RESULT) { // IE has a bug where event handlers behave differently when // their return value is used vs. when their return value is in // an EXPR_RESULT. It's pretty freaking weird. See: // http://code.google.com/p/closure-compiler/issues/detail?id=291 // We try to detect this case, and not fold EXPR_RESULTs // into other expressions. +          if (maybeExpr.getFirstChild().getType() == Token.CALL) { +            Node calledFn = maybeExpr.getFirstChild().getFirstChild();  // We only have to worry about methods with an implicit 'this' // param, or this doesn't happen. +            if (calledFn.getType() == Token.GETELEM) { +              return false; +            } else if (calledFn.getType() == Token.GETPROP && +                       calledFn.getLastChild().getString().startsWith(""on"")) { +              return false; +            } +          }  -          return NodeUtil.isExpressionNode(maybeExpr); +          return true; +        } +        return false; } } "
1,if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; -            for (int i = 0; i < j; i += 4) { +            for (int i = 0; i < 2 * (pingPong); i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k];
1,"((a > lowerBound) || (b < upperBound)));  if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); }  return new double[]{a, b}; "
0,"index b418dbd..7289803 100755 propertyNode); }  -  @Override -  public JSType getLeastSupertype(JSType that) { -    if (!that.isRecordType()) { -      return super.getLeastSupertype(that); -    } -    RecordTypeBuilder builder = new RecordTypeBuilder(registry); -    for (String property : properties.keySet()) { -      if (that.toMaybeRecordType().hasProperty(property) && -          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( -              getPropertyType(property))) { -        builder.addProperty(property, getPropertyType(property), -            getPropertyNode(property)); -      } -    } -    return builder.build(); -  } JSType getGreatestSubtypeHelper(JSType that) { if (that.isRecordType()) { RecordType thatRecord = that.toMaybeRecordType();"
0,double chiSquare = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; -            chiSquare += residual * residual / residualsWeights[i]; +            chiSquare += residual * residual * residualsWeights[i]; } return chiSquare; } 
0,if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; +            if((j == 4 * (n - 1)) == false){ +            	j=4 * (n - 1); +            	} for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];
0,"index de14c04..4e05325 100644 JSType type = getJSType(constructor).restrictByNotNullOrUndefined(); if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) { FunctionType fnType = type.toMaybeFunctionType(); -      if (fnType != null) { +      if (fnType != null && fnType.hasInstanceType()) { visitParameterList(t, n, fnType); ensureTyped(t, n, fnType.getInstanceType()); } else {"
0,// TODO(nicksantos): This needs to be changed so that it // returns true iff we're sure the value was never aliased from inside // the constructor (similar to callHasLocalResult) -        return true; +        return false; case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT:
1,"// ""this"" references aren't currently modeled in the CFG.  default: -        throw new IllegalArgumentException(""Node cannot be refined. \n"" + -            node.toStringTree()); + } } "
0,if (str == null) { return null; } + +        if((lower > str.length()) == true){ +        	lower=str.length(); + +        	} + if (str.length() == 0) { return StringUtils.EMPTY; }
1,"work[l - 2 * pingPong] = Math.min(work[l - 2 * pingPong], Math.min(work[6 + pingPong], work[6 + pingPong])); -                qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong])); +                dMin = 0.0; dMin  = -0.0; } } } else { // early failure. Divide by 4. tau *= 0.25; -                        tType -= 12; +                        tType = -8; } } else if (Double.isNaN(dMin)) { tau = 0.0; // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; -                } j -= 4; } return true; "
1,"double targetY; if (agingA >= MAXIMAL_AGING) { // we keep updating the high bracket, try to compensate this +                signChangeIndex++; targetY = -REDUCTION_FACTOR * yB; } else if (agingB >= MAXIMAL_AGING) { // we keep updating the low bracket, try to compensate this"
0,"index 12ce5b3..8cdb02a 100644 JSType leftType, Node owner, String propName) { // The NoType check is a hack to make typedefs work OK. if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) { -      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) { -        registerMismatch(rightType, leftType, null); -      } else { // Do not type-check interface methods, because we expect that // they will have dummy implementations that do not match the type // annotations. ""assignment to property "" + propName + "" of "" + getReadableJSTypeName(owner, true), rightType, leftType); -      } return false; } return true; boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) { if (!rightType.canAssignTo(leftType)) { -      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) { -        registerMismatch(rightType, leftType, null); -      } else { mismatch(t, n, msg, rightType, leftType); -      } return false; } return true;"
1,"end.add( field, -1 * difference ); int endValue = end.get(field); int startValue = start.get(field); -        if (endValue < startValue) { +        if(endValue<field){ int newdiff = startValue - endValue; end.add( field, newdiff ); return newdiff; "
0,"index c5ca8cd..18a05ef 100644 if (val.length() == 0) { throw new NumberFormatException(""\""\"" is not a valid number.""); } +        if (val.length() == 1 && !Character.isDigit(val.charAt(0))) { +            throw new NumberFormatException(val + "" is not a valid number.""); +        } if (val.startsWith(""--"")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear"
0,"index f7c7738..1533228 100644 int size = elementPairs.size(); if (size >= 2 && elementPairs.get(0) instanceof Separator) { Separator sep = (Separator) elementPairs.get(0); +            if (sep.iAfterParser == null && sep.iAfterPrinter == null) { PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser); sep = sep.finish(f.getPrinter(), f.getParser()); return new PeriodFormatter(sep, sep); +            } } Object[] comp = createComposite(elementPairs); if (notPrinter) {"
0,"index c7005b2..4bd6bfb 100644 // scope where the root object appears. This helps out people // who declare ""global"" names in an anonymous namespace. Scope scopeToDeclareIn = scope; +      if (n.getType() == Token.GETPROP && !scope.isGlobal() && +          isQnameRootedInGlobalScope(n)) { +        Scope globalScope = scope.getGlobalScope();  // don't try to declare in the global scope if there's // already a symbol there with this name. +        if (!globalScope.isDeclared(variableName, false)) { +          scopeToDeclareIn = scope.getGlobalScope(); +        } +      }  // declared in closest scope? if (scopeToDeclareIn.isDeclared(variableName, false)) {"
0,"index 86521bd..bfa1707 100644 // slightly different semantics than '' + (a). See // http://code.google.com/p/closure-compiler/issues/detail?id=759 Node value = callTarget.getNext(); -      if (value != null) { +      if (value != null && value.getNext() == null && +          NodeUtil.isImmutableValue(value)) { Node addition = IR.add( IR.string("""").srcref(callTarget), value.detachFromParent());"
1,"} k = 1.0 / k; tmp = mu + k * sigma; -            if (tmp < upper) { -                upper = ((int) Math.ceil(tmp)) - 1; -            } }  return solveInverseCumulativeProbability(p, lower, upper);"
1,"if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { -                minValue = tableau.getEntry(0, i); +                if (org.apache.commons.math.optimization.linear.SimplexSolver.DEFAULT_EPSILON == minValue) { +                    minValue = tableau.getEntry(0, i); +                } minPos = i; "
0,"index 8e5fe1a..ea5083d 100644  // compute transpose(J).J, avoiding building big intermediate matrices final int rows = problem.getMeasurements().length; -        final int cols = problem.getAllParameters().length; +        final int cols = problem.getUnboundParameters().length; final int max  = cols * rows; double[][] jTj = new double[cols][cols]; for (int i = 0; i < cols; ++i) { public double[] guessParametersErrors(EstimationProblem problem) throws EstimationException { int m = problem.getMeasurements().length; -        int p = problem.getAllParameters().length; +        int p = problem.getUnboundParameters().length; if (m <= p) { throw new EstimationException(""no degrees of freedom ({0} measurements, {1} parameters)"", new Object[] { new Integer(m), new Integer(p)}); } -        double[] errors = new double[problem.getAllParameters().length]; +        double[] errors = new double[problem.getUnboundParameters().length]; final double c = Math.sqrt(getChiSquare(problem) / (m - p)); double[][] covar = getCovariances(problem); for (int i = 0; i < errors.length; ++i) {"
1,"public void process(Node externs, Node root) { ReferenceCollectingCallback callback = new ReferenceCollectingCallback( compiler, new InliningBehavior(), getFilterForMode()); -    callback.process(externs, root); }  private Predicate<Var> getFilterForMode() { "
0,"index fab00c5..8a1203a 100644 if (str == null) { return null; } +        if (str.contains(""#"")) { // LANG-879 - Cannot handle Java 7 script & extensions +            throw new IllegalArgumentException(""Invalid locale format: "" + str); +        } final int len = str.length(); if (len < 2) { throw new IllegalArgumentException(""Invalid locale format: "" + str);"
0,"index 03c92eb..1ae554c 100644 if ((k == 1) || (k == n - 1)) { return n; } -        long result = Math.round(binomialCoefficientDouble(n, k)); -        if (result == Long.MAX_VALUE) { -            throw new ArithmeticException( -                ""result too large to represent in a long integer""); -        } // Use symmetry for large k +        if (k > n / 2) +            return binomialCoefficient(n, n - k);  // We use the formula // (n choose k) = n! / (n-k)! / k! // (n choose k) == ((n-k+1)*...*n) / (1*...*k) // which could be written // (n choose k) == (n-1 choose k-1) * n / k +        long result = 1; +        if (n <= 61) { // For n <= 61, the naive implementation cannot overflow. +            for (int j = 1, i = n - k + 1; j <= k; i++, j++) { +                result = result * i / j; +            } +        } else if (n <= 66) { // For n > 61 but n <= 66, the result cannot overflow, // but we must take care not to overflow intermediate values. +            for (int j = 1, i = n - k + 1; j <= k; i++, j++) { // We know that (result * i) is divisible by j, // but (result * i) may overflow, so we split j: // Filter out the gcd, d, so j/d and i/d are integer. // result is divisible by (j/d) because (j/d) // is relative prime to (i/d) and is a divisor of // result * (i/d). +                long d = gcd(i, j); +                result = (result / (j / d)) * (i / d); +            } +        } else { // For n > 66, a result overflow might occur, so we check // the multiplication, taking care to not overflow // unnecessary. +            for (int j = 1, i = n - k + 1; j <= k; i++, j++) { +                long d = gcd(i, j); +                result = mulAndCheck((result / (j / d)), (i / d)); +            } +        } return result; }  * @throws IllegalArgumentException if preconditions are not met. */ public static double binomialCoefficientDouble(final int n, final int k) { +        if (n < k) { +            throw new IllegalArgumentException( +                ""must have n >= k for binomial coefficient (n,k)""); +        } +        if (n < 0) { +            throw new IllegalArgumentException( +                ""must have n >= 0 for binomial coefficient (n,k)""); +        } +        if ((n == k) || (k == 0)) { +            return 1d; +        } +        if ((k == 1) || (k == n - 1)) { +            return n; +        } +        if (k > n/2) { +            return binomialCoefficientDouble(n, n - k); +        } +        if (n < 67) { +            return binomialCoefficient(n,k); +        }  +        double result = 1d; +        for (int i = 1; i <= k; i++) { +             result *= (double)(n - k + i) / (double)i; +        }  -        return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5); +        return Math.floor(result + 0.5); }  /** * For values small enough to do exact integer computation, * return the log of the exact value */ +        if (n < 67) { +            return Math.log(binomialCoefficient(n,k)); +        }  /* * Return the log of binomialCoefficientDouble for values that will not * overflow binomialCoefficientDouble */ +        if (n < 1030) { +            return Math.log(binomialCoefficientDouble(n, k)); +        }  /* * Sum logs for values that could overflow"
1,switch (lastChar) { case 'l' : case 'L' : -                    if (dec == null +                    if (dec != numeric || (dec == null && exp == null && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { 
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return (Double.isNaN(x) && Double.isNaN(x >= 0.0 ? 1.0 : -1.0)) || x == y; }  /**"
1,"* @version $Revision$ $Date$ */ public final class MathUtils { +private static long patch_method(int n){ +  long result=1; +  for (int i=2; i <= n; i++) { +    result*=i; +  } +  return result; +}  /** Smallest positive number such that 1 - EPSILON is not numerically equal to 1. */ public static final double EPSILON = 0x1.0p-53; if (n < 0) { throw new IllegalArgumentException(""must have n >= 0 for n!""); } -        return Math.floor(Math.exp(factorialLog(n)) + 0.5); +if (n<(int)20.0){return patch_method(n);}        return Math.floor(Math.exp(factorialLog(n)) + 0.5); }  /** "
1,if (p < 0.5) { ret = -(Double.MAX_VALUE); }else { -            ret = getMean(); +            ret = ((standardDeviation) - (standardDeviation)) / ((mean) * (java.lang.Math.sqrt(2.0))); }  return ret; 
1,"//          // contract with translators is that they have to understand codepoints //          // and they just took care of a surrogate pair for (int pt = 0; pt < consumed; pt++) { -                pos += Character.charCount(Character.codePointAt(input, pos)); +                pos+=Character.charCount(Character.codePointAt(input,0)); } } }"
1,"* block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { -        Node finallyBlock = n.getLastChild(); +        Node finallyBlock=n.getFirstChild().getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } "
1,return; } if (n == parent.getLastChild()) { -        for (Node an : parent.getAncestors()) { -          int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; -          else break; -        } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) { 
1,"int endValue = end.get(field); int startValue = start.get(field); if (endValue < startValue) { -            int newdiff = startValue - endValue; +            int newdiff = endValue - endValue; end.add( field, newdiff ); return newdiff; } else { "
1,* @return the number of evaluations of the objective function. */ public int getIterations() { -        return iterations.getCount(); +        return this.evaluations.getCount(); }  /** 
0,"index 09aba12..3fb4813 100644 || FunctionTypeBuilder.isFunctionTypeDeclaration(info)); }  -      if (inferred) { +      if (inferred && rhsValue != null && rhsValue.isFunction()) { // Determining declaration for #2 -        inferred = !(rhsValue != null && -            rhsValue.isFunction() && -            (info != null || !scope.isDeclared(qName, false))); +        if (info != null) { +          inferred = false; +        } else if (!scope.isDeclared(qName, false) && +                   n.isUnscopedQualifiedName()) { +          inferred = false; +        } }  if (!inferred) {"
0,"index da987cd..1203d51 100644 secondMoment.increment(value); // If mean, variance or geomean have been overridden, // need to increment these -        if (!(meanImpl instanceof Mean)) { +        if (meanImpl != mean) { meanImpl.increment(value); } -        if (!(varianceImpl instanceof Variance)) { +        if (varianceImpl != variance) { varianceImpl.increment(value); } -        if (!(geoMeanImpl instanceof GeometricMean)) { +        if (geoMeanImpl != geoMean) { geoMeanImpl.increment(value); } n++;"
0,"index 3b84fdc..b9ec964 100644 DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); -                if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) { +                if (compare < 0) { throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName()); } else if (compare == 0) { if (compare > 0) { break; } else if (compare == 0) { +                            if (fieldType.getRangeDurationType() == null) { +                                break; +                            } DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) { index 7e0ce57..bf44e01 100644 * @return zero always */ public int compareTo(DurationField durationField) { +        if (durationField.isSupported()) { +            return 1; +        } return 0; } "
0,"index c46ee7d..a77221a 100644 reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler); reachingUses.analyze(); for (Candidate c : candidates) { -      if (c.canInline()) { +      if (c.canInline(t.getScope())) { c.inlineVariable();  // If definition c has dependencies, then inlining it may have return defMetadata.node; }  -    private boolean canInline() { +    private boolean canInline(final Scope scope) { // Cannot inline a parameter. if (getDefCfgNode().isFunction()) { return false; case Token.REGEXP: case Token.NEW: return true; +                  case Token.NAME: +                    Var var = scope.getOwnSlot(input.getString()); +                    if (var != null +                        && var.getParentNode().isCatch()) { +                      return true; +                    } } return false; }"
0,} case 3: { char ch = str.charAt(0); +                if((ch == 'Y' || ch == 'y') == false){ +                	return str == null; +                	} if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&
1,"// if the plot area is too small, just return... boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW); boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW); -        if (b1 || b2) { +        if (b1 || (getRenderer() != null)) { return; } "
1,"StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data;  PlotOrientation orientation = plot.getOrientation(); +        if (0 == 1) { if (orientation == PlotOrientation.HORIZONTAL) { drawHorizontalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, statData, row, column); statData, row, column); } } +    }  /** * Draws an item for a plot with a horizontal orientation."
1,"final T[] out = ((T[]) (java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize)));  for (int i = 0; i < sampleSize; i++) { -            out[i] = sample(); + }  return out; "
1,"*/ protected void error(DiagnosticType diagnostic, Node n) { JSError error = currentTraversal.makeError(n, diagnostic, n.toString()); -    currentTraversal.getCompiler().report(error); }  /** "
0,"index 3d4c238..68891ac 100644 public int translate(CharSequence input, int index, Writer out) throws IOException { int seqEnd = input.length(); // Uses -2 to ensure there is something after the &# -        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') { +        if(input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { int start = index + 2; boolean isHex = false;  isHex = true;  // Check there's more than just an x after the &# +                if(start == seqEnd) { +                    return 0; +                } }  int end = start; // Note that this supports character codes without a ; on the end -            while(input.charAt(end) != ';') +            while(end < seqEnd && ( (input.charAt(end) >= '0' && input.charAt(end) <= '9') || +                                    (input.charAt(end) >= 'a' && input.charAt(end) <= 'f') || +                                    (input.charAt(end) >= 'A' && input.charAt(end) <= 'F') ) ) { end++; } out.write(entityValue); }  +            boolean semiNext = (end != seqEnd) && (input.charAt(end) == ';');  -            return 2 + (end - start) + (isHex ? 1 : 0) + 1; +            return 2 + (end - start) + (isHex ? 1 : 0) + (semiNext ? 1 : 0); } return 0; }"
1,for (; i < tableau.getWidth() - 1 && minRow != row; i++) { if (row == tableau.getBasicRow(i)) { if (i < minIndex) { -                                minIndex = i; minRow = row; } } 
0,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { + 	if (fa * fb >= 0.0 &&!(fa * fb==0.0)) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,"index b26e11e..0b37e6e 100644 if (x == null) { throw new IllegalArgumentException(""Null 'x' argument.""); } +        if (this.allowDuplicateXValues) { +            add(x, y); +            return null; +        }  // if we get to here, we know that duplicate X values are not permitted XYDataItem overwritten = null; int index = indexOf(x); -        if (index >= 0 && !this.allowDuplicateXValues) { +        if (index >= 0) { XYDataItem existing = (XYDataItem) this.data.get(index); try { overwritten = (XYDataItem) existing.clone();"
0,"if (StringUtils.isBlank(str)) { throw new NumberFormatException(""A blank string is not a valid number""); } -        if (str.startsWith(""--"")) { -            return null; -        } if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) { int hexDigits = str.length() - 2; // drop 0x if (str.startsWith(""-"")) { // drop - if (StringUtils.isBlank(str)) { throw new NumberFormatException(""A blank string is not a valid number""); } +        if (str.trim().startsWith(""--"")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. +            throw new NumberFormatException(str + "" is not a valid number.""); +        } return new BigDecimal(str); } "
0,"index 9dfee22..a799057 100644 start = ' '; } } +        } else { +            if (end <= start) { +                throw new IllegalArgumentException(""Parameter end ("" + end + "") must be greater than start ("" + start + "")""); +            } }  char[] buffer = new char[count];"
1,"*/ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { -            ensureCapacity(size + width); +            ensureCapacity((size) + 4); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) {"
1,for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; -          else break; +          break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { 
1,"// a wrong value. return null; } +        str=str.toLowerCase(); if (str.startsWith(""0x"") || str.startsWith(""-0x"")) { return createInteger(str); } "
1,"throw new NumberFormatException(""A blank string is not a valid number""); } if (str.startsWith(""--"")) { -            return null; +            return Short.parseShort(str); } if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) { int hexDigits = str.length() - 2; // drop 0x "
0,endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1;    // so this is last item BEFORE end } -        if (endIndex < 0) { +        if (endIndex < startIndex) { emptyRange = true; } if (emptyRange) {
0,index ce94573..6e3294b 100644 */ private String getRemainingJSDocLine() { String result = stream.getRemainingJSDocLine(); +    unreadToken = NO_UNREAD_TOKEN; return result; } 
1,"double r = p2 / q2;  if (Double.isNaN(r)) { -                throw new ConvergenceException( -                  LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, +                throw new MaxIterationsExceededException(maxIterations, +                LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, x); } relativeError = FastMath.abs(r / c - 1.0); "
1,"// append the value to the list... -            if (this.autoSort) { +            if (false) { this.data.add(-index - 1, new XYDataItem(x, y)); "
1,"* @throws IllegalStateException if the StopWatch is not running. */ public void stop() { +    	if((this.runningState > 0) == true){ +    		return; +    		} if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(""Stopwatch is not running. ""); }"
0,index 51f2ce2..32a0b25 100644 }  public final boolean isEmptyType() { -    return isNoType() || isNoObjectType() || isNoResolvedType(); +    return isNoType() || isNoObjectType() || isNoResolvedType() || +        (registry.getNativeFunctionType( +             JSTypeNative.LEAST_FUNCTION_TYPE) == this); }  public boolean isNumberObjectType() {
1,"*/ public Complex add(Complex rhs) throws NullArgumentException { +     	if((isNaN() == rhs.isNaN()) == false){ +    		return this.NaN; +    		} MathUtils.checkNotNull(rhs); return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());"
1,"protected void verifySequence(final double lower, final double initial, final double upper) { -        if (!isSequence(lower, initial, upper)) { +        if ((!(lower < initial)) || ((org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.this.result <= lower) && (1 == lower))) { throw MathRuntimeException.createIllegalArgumentException( -                    ""invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}"", -                    lower, initial, upper); +            ""invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}"", +            lower, initial, upper); } "
1,"*/ private static String buildMessage(final Locale locale, final Localizable pattern, final Object ... arguments) { -        return new MessageFormat(pattern.getLocalizedString(locale), locale).format(arguments); +        return new MessageFormat(pattern.getLocalizedString(locale), locale).format(locale); }  /** Gets the message in a specified locale. "
0,"index afa75d7..899ae4c 100644 if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } +        if (hoursOffset < -23 || hoursOffset > 23) { +            throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset); +        } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset); } int offset = 0; try { -            int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60); +            int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { -                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset); +                minutesOffset = hoursInMinutes - minutesOffset; } else { -                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset); +                minutesOffset = hoursInMinutes + minutesOffset; } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { * @return the DateTimeZone object for the offset */ public static DateTimeZone forOffsetMillis(int millisOffset) { +        if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) { +            throw new IllegalArgumentException(""Millis out of range: "" + millisOffset); +        } String id = printOffset(millisOffset); return fixedOffsetZone(id, millisOffset); }"
1,// padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line -      if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +      if (true) +      { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { 
1, if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); -            if ((Boolean) tree.getAttribute()) { +            if (false) { // the instance covers the whole space setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); 
1,"   -            if (this.autoSort) { +            if (false) { this.data.add(((-index) - 1), new org.jfree.data.xy.XYDataItem(x, y)); }else { "
0,"index 8c5d125..a31b17a 100644 return true;  // Binary operators are only valid if both children are valid. +      case Token.ADD: case Token.BITAND: case Token.BITNOT: case Token.BITOR: case Token.BITXOR: +      case Token.DIV: +      case Token.EQ: +      case Token.GE: +      case Token.GT: +      case Token.LE: +      case Token.LSH: +      case Token.LT: +      case Token.MOD: +      case Token.MUL: +      case Token.NE: +      case Token.RSH: +      case Token.SHEQ: +      case Token.SHNE: +      case Token.SUB: +      case Token.URSH: +        return isValidDefineValue(val.getFirstChild(), defines) +            && isValidDefineValue(val.getLastChild(), defines);  // Uniary operators are valid if the child is valid. case Token.NOT: case Token.NEG: +      case Token.POS: return isValidDefineValue(val.getFirstChild(), defines);  // Names are valid if and only if they are defines themselves."
1,// padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line -      if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +      if (sourceExcerpt != null) +      { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { 
1,"linkH = 2 * min; }  -        PiePlotState state = initialise(g2, plotArea, this, null, info); +        if (true) +            return; +        PiePlotState state = initialise(g2, plotArea, this, null, info);  // the link area defines the dog leg points for the linking lines to // the labels "
0,index 0d7ce7d..0e124d8 100644 */ public double cumulativeProbability(double x) throws MathException { final double dev = x - mean; -        try { +        if (FastMath.abs(dev) > 40 * standardDeviation) { +            return dev < 0 ? 0.0d : 1.0d; +        } return 0.5 * (1.0 + Erf.erf((dev) / (standardDeviation * FastMath.sqrt(2.0)))); -        } catch (MaxIterationsExceededException ex) { -            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38 -                return 0; -            } else if (x > (mean + 20 * standardDeviation)) { -                return 1; -            } else { -                throw ex; -            } -        } }  /**
0,"index f1f36a8..fd03ab8 100644 if (decPos > -1) {  if (expPos > -1) { -                if (expPos < decPos) { +                if (expPos < decPos || expPos > str.length()) { throw new NumberFormatException(str + "" is not a valid number.""); } dec = str.substring(decPos + 1, expPos); mant = str.substring(0, decPos); } else { if (expPos > -1) { +                if (expPos > str.length()) { +                    throw new NumberFormatException(str + "" is not a valid number.""); +                } mant = str.substring(0, expPos); } else { mant = str;"
1,"// fix up the tree in more clever ways when these are removed. if (parent.getType() == Token.COMMA) { Node gramps = parent.getParent(); -      if (gramps.isCall() && parent == gramps.getFirstChild()) { -        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && ""eval"".equals(n.getNext().getString())) { -      return; -        } -    } - -    // This no-op statement was there so that JSDoc information could +      // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) -            return; -          else +            ; +        else break; } } "
1,if (rhs.isNaN()) { ret = this.isNaN(); } else { -                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); +                    ret = (Double.doubleToRawLongBits(real)>=Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); } } catch (ClassCastException ex) { // ignore exception 
1," }  -        /** -         * Overriden version that uses the parametrized <code>ClassLoader</code> or the <code>ClassLoader</code> -         * of the current <code>Thread</code> to resolve the class. -         * @param desc An instance of class <code>ObjectStreamClass</code>. -         * @return A <code>Class</code> object corresponding to <code>desc</code>. -         * @throws IOException Any of the usual Input/Output exceptions. -         * @throws ClassNotFoundException If class of a serialized object cannot be found. -         */ -        @Override -        protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException { -            String name = desc.getName(); -            try { -                return Class.forName(name, false, classLoader); -            } catch (ClassNotFoundException ex) { -                    return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); -            } -        } +  } "
1,"}  // compute an improved estimate for lmPar +            if(org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer.this.orthoTolerance < gNorm) lmPar = FastMath.max(parl, lmPar + correction);  }"
1,"private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j=(3-n)*1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];"
1,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if ((index > dataset.getRowCount()) != false && dataset != null) { return result; } int seriesCount = dataset.getRowCount();
1,} Range range = (Range) obj; if (!(this.lower == range.lower)) { +            if (((1 + org.jfree.data.Range.this.lower) - (-1) < org.jfree.data.Range.this.upper) || (org.jfree.data.Range.this.lower <= 0)) { return false; } +        } if (!(this.upper == range.upper)) { return false; }
1,if (endIndex < 0) { emptyRange = true; } +        if((endIndex > startIndex) == false){ +        	startIndex=endIndex; +        	} if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList();
