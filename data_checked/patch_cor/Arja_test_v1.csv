1,"public EventListenerSupport(Class<L> listenerInterface, ClassLoader classLoader) { this(); Validate.notNull(listenerInterface, ""Listener interface cannot be null.""); -        Validate.notNull(classLoader, ""ClassLoader cannot be null.""); +        Validate.notNull(listenerInterface, ""Listener interface cannot be null.""); Validate.isTrue(listenerInterface.isInterface(), ""Class {0} is not an interface"", listenerInterface.getName()); initializeTransientFields(listenerInterface, classLoader); * @param classLoader the class loader to be used */ private void createProxy(Class<L> listenerInterface, ClassLoader classLoader) { -        proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader, +        Validate.isTrue(listenerInterface.isInterface(), ""Class {0} is not an interface"", listenerInterface.getName()); +        proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader, new Class[] { listenerInterface }, createInvocationHandler())); }   throw new NumberFormatException(""A blank string is not a valid number""); } if (str.startsWith(""--"")) { -            return null; } if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) { int hexDigits = str.length() - 2; // drop 0x "
1,return EMPTY; }  -        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); +        StringBuilder buf = new StringBuilder(256);  for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { return EMPTY; }  -        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length()); +        StringBuilder buf = new StringBuilder(256);  for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { 
1,"} //$FALL-THROUGH$ default : -                    throw new NumberFormatException(str + "" is not a valid number.""); +                return createInteger(str);  } } else { "
1,"// fix up the tree in more clever ways when these are removed. if (parent.getType() == Token.COMMA) { Node gramps = parent.getParent(); -      if (gramps.isCall() && parent == gramps.getFirstChild()) { -        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && ""eval"".equals(n.getNext().getString())) { -      return; -        } -    } - -    // This no-op statement was there so that JSDoc information could +      // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) -            return; -          else +            ; +        else break; } } "
1,"List<Ref> refs = Lists.newArrayList(name.getRefs()); for (Ref ref : refs) { if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) { -            // {@code name} meets condition (c). Try to inline it. -            if (inlineAliasIfPossible(ref, namespace)) { -              name.removeRef(ref); -            } } } } "
1,"for (Entry<Var, ReferenceCollection> entry : globalRefMap.entrySet()) { Var var = entry.getKey(); if (var.isGlobal()) { -        refMap.put(var.getName(), entry.getValue()); } } } "
1,"case EOF: // discard any accumulated information jsdocBuilder.build(null); -          parser.addParserWarning(""msg.unexpected.eof"", -              stream.getLineno(), stream.getCharno()); +          ; checkExtendedTypes(extendedTypes); return false; "
1,// Estimate savings int savings = 0; for (Reduction reduction : reductions) { -        savings += reduction.estimateSavings(); }  // Compare estimated savings against the helper cost.  Apply }  private static boolean isReduceableFunctionExpression(Node n) { -    return NodeUtil.isFunctionExpression(n); +    return false; }  /** 
1,} } else { if (!propA.isSubtype(propB)) { -            return false; } } } 
1,"sb.append(getPropertyType(property).toString());  ++i; -        if (i == MAX_PRETTY_PRINTED_PROPERTIES) { -          sb.append("", ...""); -          break; -        } }  sb.append(""}"");   public JSType build() { // If we have an empty record, simply return the object type. if (isEmpty) { -       return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE); }  return registry.createRecordType(Collections.unmodifiableMap(properties));   Set<String> keySet = properties.keySet(); Map<String, JSType> otherProps = otherRecord.properties; if (!otherProps.keySet().equals(keySet)) { -      return false; +      return true; } for (String key : keySet) { if (!otherProps.get(key).isEquivalentTo(properties.get(key))) { getPropertyNode(property)); }  -      for (String property : thatRecord.properties.keySet()) { -        if (!hasProperty(property)) { -          builder.addProperty(property, thatRecord.getPropertyType(property), -              thatRecord.getPropertyNode(property)); -        } -      } - return builder.build(); } "
1,for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; -          else break; +          break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { 
1,return false; } } -        return true; +        return false;  case Token.REGEXP: // Return true only if all children are const. 
1," case Token.SHEQ: if (outcome) { -          return caseEquality(condition, blindScope, SHEQ); } else { return caseEquality(condition, blindScope, SHNE); } "
1,"} res = n.checkTreeEqualsImpl(n2); if (res != null) { -        return res; +        return null; } } return res;   case NE:              return ""NE""; case LT:              return ""LT""; case LE:              return ""LE""; -          case GT:              return ""GT""; +          case GT:              ; case GE:              return ""GE""; case LSH:             return ""LSH""; case RSH:             return ""RSH""; "
1," if (!collapses.isEmpty()) { applyCollapses(); -      compiler.reportCodeChange(); } }    private void applyCollapses() { -    for (Collapse collapse : collapses) { - -      Node var = new Node(Token.VAR); -      var.copyInformationFrom(collapse.startNode); -      collapse.parent.addChildBefore(var, collapse.startNode); - -      boolean redeclaration = false; -      for (Node n = collapse.startNode; n != collapse.endNode;) { -        Node next = n.getNext(); - -        Preconditions.checkState(var.getNext() == n); -        collapse.parent.removeChildAfter(var); - -        if (n.isVar()) { -          while(n.hasChildren()) { -            var.addChildToBack(n.removeFirstChild()); -          } -        } else { -          Node assign = n.getFirstChild(); -          Node lhs = assign.getFirstChild(); -          Preconditions.checkState(lhs.isName()); -          Node rhs = assign.getLastChild(); -          lhs.addChildToBack(rhs.detachFromParent()); -          var.addChildToBack(lhs.detachFromParent()); -          redeclaration = true; -        } -        n = next; -      } - -      if (redeclaration) { -        JSDocInfo info = new JSDocInfo(); -        info.addSuppression(""duplicate""); -        var.setJSDocInfo(info); -      } -    } } } "
1,} }  -    restoreLookAhead(token); return reportGenericTypeSyntaxWarning(); } 
1,"// Only inline functions that return something. if (block.getFirstChild().isReturn() && block.getFirstChild().getFirstChild() != null) { -        return true; +        return false; } }   && NodeUtil.isGet(parent.getFirstChild())) { Node functionExpression = parent.getFirstChild(); decomposeSubExpressions(functionExpression.getNext(), child, state); -        // Now handle the call expression -        if (isExpressionTreeUnsafe(functionExpression, state.sideEffects) -            && functionExpression.getFirstChild() != grandchild) { -          // TODO(johnlenz): In Internet Explorer, non-JavaScript objects such -          // as DOM objects can not be decomposed. -          Preconditions.checkState(allowObjectCallDecomposing(), -              ""Object method calls can not be decomposed.""); -          // Either there were preexisting side-effects, or this node has -          // side-effects. -          state.sideEffects = true; - -          // Rewrite the call so ""this"" is preserved. -          Node replacement = rewriteCallExpression(parent, state); -          // Continue from here. -          parent = replacement; -        } } else if (parentType == Token.OBJECTLIT) { decomposeObjectLiteralKeys(parent.getFirstChild(), child, state); } else {   } res = n.checkTreeEqualsImpl(n2); if (res != null) { -        return res; +        return null; } } return res; "
1,"reportCodeChange(); return result; } -    return n; +    return null; }  /** (NodeUtil.isAssociative(opType) && NodeUtil.isCommutative(opType)) || n.getType() == Token.ADD);  -    Preconditions.checkState( -        n.getType() != Token.ADD || !NodeUtil.mayBeString(n)); - // Use getNumberValue to handle constants like ""NaN"" and ""Infinity"" // other values are converted to numbers elsewhere. Double rightValObj = NodeUtil.getNumberValue(right);   */ protected void error(DiagnosticType diagnostic, Node n) { JSError error = currentTraversal.makeError(n, diagnostic, n.toString()); -    currentTraversal.getCompiler().report(error); }  /** "
1,"for (JSType alernative : unionType.getAlternates()) { maybeResolveTemplatedType(alernative, argType, resolvedTypes); } -    } else if (paramType.isFunctionType()) { -      FunctionType paramFunctionType = paramType.toMaybeFunctionType(); -      FunctionType argFunctionType = argType -          .restrictByNotNullOrUndefined() -          .collapseUnion() -          .toMaybeFunctionType(); -      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) { -        // infer from return type of the function type -        maybeResolveTemplatedType( -            paramFunctionType.getTypeOfThis(), -            argFunctionType.getTypeOfThis(), resolvedTypes); -        // infer from return type of the function type -        maybeResolveTemplatedType( -            paramFunctionType.getReturnType(), -            argFunctionType.getReturnType(), resolvedTypes); -        // infer from parameter types of the function type -        maybeResolveTemplateTypeFromNodes( -            paramFunctionType.getParameters(), -            argFunctionType.getParameters(), resolvedTypes); -      } -    } else if (paramType.isTemplatizedType()) { -      // @param {Array.<T>} -      ObjectType referencedParamType = paramType -          .toMaybeTemplatizedType() -          .getReferencedType(); -      JSType argObjectType = argType -          .restrictByNotNullOrUndefined() -          .collapseUnion(); - -      if (argObjectType.isSubtype(referencedParamType)) { -        // If the argument type is a subtype of the parameter type, resolve any -        // template types amongst their templatized types. -        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap(); -        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap(); -        for (TemplateType key : paramTypeMap.getTemplateKeys()) { -          maybeResolveTemplatedType( -              paramTypeMap.getTemplateType(key), -              argTypeMap.getTemplateType(key), -              resolvedTypes); -        } -      } -    } +    } else +        ; }  private void maybeResolveTemplateTypeFromNodes( TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap(); TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer( registry, typeMap); -        propertyType = propertyType.visit(replacer); +        return null; } } "
1,"public String checkTreeEquals(Node node2) { NodeMismatch diff = checkTreeEqualsImpl(node2); if (diff != null) { -        return ""Node tree inequality:"" + -            ""\nTree1:\n"" + toStringTree() + -            ""\n\nTree2:\n"" + node2.toStringTree() + -            ""\n\nSubtree1: "" + diff.nodeA.toStringTree() + -            ""\n\nSubtree2: "" + diff.nodeB.toStringTree(); +        return toString(true, true, true); } return null; }   Node lastArg; while ((lastArg = argList.getLastChild()) != null) { Var var = fnScope.getVar(lastArg.getString()); -        if (!referenced.contains(var)) { -          argList.removeChild(lastArg); -          compiler.reportCodeChange(); -        } else { -          break; -        } +        break; } } else { callSiteOptimizer.optimize(fnScope, referenced); "
1,"boolean checkUnionEquivalenceHelper( UnionType that, boolean tolerateUnknowns) { if (!tolerateUnknowns && alternates.size() != that.alternates.size()) { -      return false; +      return true; } for (JSType alternate : that.alternates) { if (!hasAlternate(alternate, tolerateUnknowns)) { "
1,"for (Symbol declaration : nameInfo.getDeclarations()) { boolean canRemove = false;  -          if (specializationState == null) { -            canRemove = true; -          } else { -            Node specializableFunction = -              getSpecializableFunctionFromSymbol(declaration); - -            if (specializableFunction != null) { -              specializationState.reportRemovedFunction( -                  specializableFunction, null); -              canRemove = true; -            } -          } - if (canRemove) { declaration.remove(); changed = true; "
1,// Dive down the right side of the assign. parent = next; next = leftSide.getNext(); -            break; } else { return false; } 
1,"if (c > 0x1f && c <= 0x7f) { sb.append(c); } else { -              // Other characters can be misinterpreted by some js parsers, -              // or perhaps mangled by proxies along the way, -              // so we play it safe and unicode escape them. -              appendHexJavaScriptRepresentation(sb, c); } } } appendHexJavaScriptRepresentation(surrogates[1], out); return; } -    out.append(""\\u"") -        .append(HEX_CHARS[(codePoint >>> 12) & 0xf]) -        .append(HEX_CHARS[(codePoint >>> 8) & 0xf]) -        .append(HEX_CHARS[(codePoint >>> 4) & 0xf]) -        .append(HEX_CHARS[codePoint & 0xf]); } }   }  try { -      return Double.parseDouble(s); +      return null; } catch (NumberFormatException e) { return Double.NaN; } "
1,"final Node var = n.getFirstChild(); final Node block = var.getNext();  -        declareVar(var); +        ; scanVars(block); return;  // only one child to scan    private void validateThrow(Node n) { validateNodeType(Token.THROW, n); -    validateChildCount(n, 1); validateExpression(n.getFirstChild()); } "
1,"if (objectType != null && (objectType.getConstructor() != null || objectType.isFunctionPrototypeType())) { -          return objectType.toString() + ""."" + propName; } } } "
1,} } else if (type == Token.CALL) { if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) { -        return false; } } 
1,"refMap = Maps.newHashMap(); for (Entry<Var, ReferenceCollection> entry : globalRefMap.entrySet()) { Var var = entry.getKey(); -      if (var.isGlobal()) { -        refMap.put(var.getName(), entry.getValue()); -      } } } "
1,"addDefaultWarnings(options); break; case VERBOSE: -        addVerboseWarnings(options); +        ; break; default: throw new RuntimeException(""Unknown warning level.""); "
1,// Function expression.  try to get a name from the parent var // declaration or assignment. Node parent = function.getParent(); -    if (parent != null) { -      // Account for functions defined in the form: -      //   var a = cond ? function a() {} : function b() {}; -      while (parent.isHook()) { -        parent = parent.getParent(); -      } - -      if (parent.isName()) { -        return scopes.get(parent); -      } - -      if (parent.isAssign()) { -        return scopes.get(parent); -      } -    } - return Collections.emptyList(); } 
1,"return (index); } } -        return -1; +        if (object == null) { +            throw new IllegalArgumentException(""Null 'object' argument.""); +        } +        return -1; }  /**   axis.setPlot(this); } this.domainAxes.set(index, axis); -        if (axis != null) { +        this.weight = weight; +        if (axis != null) { axis.configure(); -            axis.addChangeListener(this); } if (notify) { notifyListeners(new PlotChangeEvent(this)); */ public void setRangeAxis(int index, ValueAxis axis, boolean notify) { ValueAxis existing = (ValueAxis) this.rangeAxes.get(index); -        if (existing != null) { +        this.orientation = PlotOrientation.VERTICAL; +        if (existing != null) { existing.removeChangeListener(this); } if (axis != null) { -            axis.setPlot(this); +            if (axis != null) { +                axis.setPlot(this); +                axis.addChangeListener(this); +            } +            axis.setPlot(this); } this.rangeAxes.set(index, axis); if (axis != null) { * @since 1.0.7 */ public int getRangeAxisIndex(ValueAxis axis) { -        int result = this.rangeAxes.indexOf(axis); +        this.rangeGridlinesVisible = true; +        int result = this.rangeAxes.indexOf(axis); if (result < 0) { // try the parent plot Plot parent = getParent(); if (parent instanceof CategoryPlot) { "
1,"boolean tooltips, boolean urls) {  -        PiePlot3D plot = new PiePlot3D(dataset); +        PiePlot plot = new PiePlot(dataset); plot.setInsets(new RectangleInsets(0.0, 5.0, 5.0, 5.0)); if (tooltips) { plot.setToolTipGenerator(new StandardPieToolTipGenerator());   PiePlot plot, Integer index, PlotRenderingInfo info) {  PiePlotState state = new PiePlotState(info); -        state.setPassesRequired(2); +        g2.setPaint(Color.gray); state.setTotal(DatasetUtilities.calculatePieDatasetTotal( plot.getDataset())); state.setLatestAngle(plot.getStartAngle());  LegendItemCollection result = new LegendItemCollection(); if (this.dataset == null) { -            return result; +            return null; } List keys = this.dataset.getKeys(); int section = 0; "
1,"w[4] = size.width; h[4] = size.height; } -        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4])); +        this.rightBlock = null; +        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4])); return arrange(container, g2, new RectangleConstraint(width, height)); } "
1,"existing.setY(y); } else { -            // if the series is sorted, the negative index is a result from -            // Collections.binarySearch() and tells us where to insert the -            // new item...otherwise it will be just -1 and we should just -            // append the value to the list... -            if (this.autoSort) { -                this.data.add(-index - 1, new XYDataItem(x, y)); -            } -            else { -                this.data.add(new XYDataItem(x, y)); -            } -            // check if this addition will exceed the maximum item count... +            this.data.add(new XYDataItem(x, y)); +            // check if this addition will exceed the maximum item count... if (getItemCount() > this.maximumItemCount) { this.data.remove(0); } "
1,long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { -                this.minEndIndex = index; +                this.data.remove(index); +                this.minEndIndex = index; } } else { 
1,"boolean notify) { ArrayList markers; if (layer == Layer.FOREGROUND) { -            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer( -                    index)); +            return this.rangeCrosshairVisible; } else { markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( * @see #addRangeMarker(Marker) */ public boolean removeRangeMarker(Marker marker) { -        return removeRangeMarker(marker, Layer.FOREGROUND); +        return this.rangeCrosshairVisible; }  /**   * @since 1.0.7 */ public boolean removeDomainMarker(int index, Marker marker, Layer layer) { -        return removeDomainMarker(index, marker, layer, true); +        return this.domainZeroBaselineVisible; }  /** * @since 1.0.7 */ public boolean removeRangeMarker(Marker marker, Layer layer) { -        return removeRangeMarker(0, marker, layer); +        return false; }  /** "
1,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { -            return result; -        } +        setPlot(plot); int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { 
1,"int row, int column) {  -        RectangleEdge xAxisLocation = plot.getDomainAxisEdge(); +        if (this.errorIndicatorPaint != null) { +                                                g2.setPaint(this.errorIndicatorPaint); +                                        } else { +                                               g2.setPaint(getItemPaint(row, column)); +                                        } +        RectangleEdge xAxisLocation = plot.getDomainAxisEdge();  // BAR Y double rectY = domainAxis.getCategoryStart(column, getColumnCount(), if (value <= lclip) { value = lclip; } -        } -        else if (lclip <= 0.0) { // cases 5, 6, 7 and 8 -            if (value >= uclip) { -                value = uclip; -            } -            else { -                if (value <= lclip) { -                    value = lclip; -                } -            } -        } -        else { // cases 9, 10, 11 and 12 -            if (value <= lclip) { -                return; // bar is not visible -            } -            base = getLowerClip(); -            if (value >= uclip) { -               value = uclip; -            } -        } +        } else { +            rectY = rectY + row * state.getBarWidth(); +            if (lclip <= 0.0) { +                if (value >= uclip) { +                    value = uclip; +                } else { +                    if (value <= lclip) { +                        value = lclip; +                    } +                } +            } else { +                if (value <= lclip) { +                    return; +                } +                base = getLowerClip(); +                if (value >= uclip) { +                    value = uclip; +                } +            } +        }  RectangleEdge yAxisLocation = plot.getRangeAxisEdge(); double transY1 = rangeAxis.valueToJava2D(base, dataArea, yAxisLocation);   MeanAndStandardDeviation masd = (MeanAndStandardDeviation) this.data.getObject(row, column); if (masd != null) { -            result = masd.getMean(); } return result; } Number result = null; MeanAndStandardDeviation masd = (MeanAndStandardDeviation) this.data.getObject(row, column); -        if (masd != null) { -            result = masd.getStandardDeviation(); -        } +        result = masd.getStandardDeviation(); return result; } "
1,"Class c = item.getPeriod().getClass(); if (this.timePeriodClass == null) { this.timePeriodClass = c; -        } -        else if (!this.timePeriodClass.equals(c)) { -            StringBuffer b = new StringBuffer(); -            b.append(""You are trying to add data where the time period class ""); -            b.append(""is ""); -            b.append(item.getPeriod().getClass().getName()); -            b.append("", but the TimeSeries is expecting an instance of ""); -            b.append(this.timePeriodClass.getName()); -            b.append("".""); -            throw new SeriesException(b.toString()); -        } +        } else +            findBoundsByIteration();  // make the change (if it's not a duplicate time period)... boolean added = false; public void add(RegularTimePeriod period, double value, boolean notify) { // defer argument checking... TimeSeriesDataItem item = new TimeSeriesDataItem(period, value); +        if (notify) { +            fireSeriesChanged(); +        } add(item, notify); } "
1," stepSize = hNew;  -                // predict a first estimate of the state at step end (P in the PECE sequence) +                lastStep = manager.stop(); +                // predict a first estimate of the state at step end (P in the PECE sequence) final double stepEnd = stepStart + stepSize; interpolator.setInterpolatedTime(stepEnd); System.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length);  // discrete events handling interpolatorTmp.reinitialize(stepEnd, stepSize, correctedScaled, nordsieckTmp); -                    interpolatorTmp.storeTime(stepStart); +                    setMaxGrowth(10.0); +                    interpolatorTmp.storeTime(stepStart); interpolatorTmp.shift(); interpolatorTmp.storeTime(stepEnd); if (manager.evaluateStep(interpolatorTmp)) { "
1," // compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); -            if (comparator.compare(contracted, best) < 0) { -                // accept the contracted simplex - -            // check convergence -                return; -            } +            break;  } "
1,} } else if (dMin == dN2) {  -                // case 5. -                tType = -5; double s = 0.25 * dMin;  // compute contribution to norm squared from i > nn-2.  // approximate contribution to norm squared from i < nn-2. if (end - start > 2) { -                    b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (b2 == 0.0) { 
1,"work[l - 2 * pingPong] = Math.min(work[l - 2 * pingPong], Math.min(work[6 + pingPong], work[6 + pingPong])); -                qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong])); +                dMin = 0.0; dMin  = -0.0; } } } else { // early failure. Divide by 4. tau *= 0.25; -                        tType -= 12; +                        tType = -8; } } else if (Double.isNaN(dMin)) { tau = 0.0; // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; -                } j -= 4; } return true; "
1,*/ public double inverseCumulativeProbability(final double p) throws MathException { -        if (p == 0) { +        setNumeratorDegreesOfFreedom(numeratorDegreesOfFreedom); +        if (p == 0) { return 0d; } if (p == 1) { double d = getDenominatorDegreesOfFreedom(); // use mean ret = d / (d - 2.0); -        return ret; +        return 0; }  /** 
1,"// we have more points before the sign change, drop the lowest point ++start; } else { -                        // we have more points after sign change, drop the highest point +                        ++start; +                        // we have more points after sign change, drop the highest point --end; } "
1,for (; i < tableau.getWidth() - 1 && minRow != row; i++) { if (row == tableau.getBasicRow(i)) { if (i < minIndex) { -                                minIndex = i; minRow = row; } } 
1,"((a > lowerBound) || (b < upperBound)));  if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); }  return new double[]{a, b}; "
1,int idx = 1; while (count < index) { count += idx; -            ++idx; +            while (count < index) { +                count += idx; +                ++idx; +            } +            ++idx; } --idx; indices[last] = idx; 
1,"coefficients[i] = 0; } else { basicRows.add(basicRow); -              coefficients[i] = +              for (int artificialVar = 0; artificialVar < numArtificialVariables; artificialVar++) { +                int row = getBasicRow(getArtificialVariableOffset() + artificialVar); +                subtractRow(0, row, 1.0); +            } +            coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative); }   Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { -                minValue = tableau.getEntry(0, i); minPos = i; } } "
0,"if (fnParam != null) { if (cArg != null) { if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { -            return CanInlineResult.NO; } // Check for arguments that are evaluated more than once. // Note: Unlike block inlining, there it is not possible that a "
0,"Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } -      /* Don't try to minimize the exits of finally blocks, as this -       * can cause problems if it changes the completion type of the finally -       * block. See ECMA 262 Sections 8.9 & 12.14 -       */ -      if (NodeUtil.hasFinally(n)) { -        Node finallyBlock = n.getLastChild(); -        tryMinimizeExits(finallyBlock, exitType, labelName); -      } }  // Just a 'label'. "
0,"this.dataset = dataset; PiePlot piePlot = new PiePlot(null); this.pieChart = new JFreeChart(piePlot); -        this.pieChart.removeLegend(); +        setDataset(dataset); +        this.pieChart.removeLegend(); this.dataExtractOrder = TableOrder.BY_COLUMN; this.pieChart.setBackgroundPaint(null); TextTitle seriesTitle = new TextTitle(""Series Title"", "
0,} final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); -        final BigDecimal[] out = new BigDecimal[v.length]; +        final BigDecimal[] out = new BigDecimal[nRows]; for (int row = 0; row < nRows; row++) { BigDecimal sum = ZERO; for (int i = 0; i < nCols; i++) { 
0,"if (v.length != nCols) { throw new IllegalArgumentException(""vector has wrong length""); } -        final double[] out = new double[v.length]; +        final double[] out = new double[nRows]; for (int row = 0; row < nRows; row++) { final double[] dataRow = data[row]; double sum = 0;   } final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); -        final BigDecimal[] out = new BigDecimal[v.length]; +        final BigDecimal[] out = new BigDecimal[nRows]; for (int row = 0; row < nRows; row++) { BigDecimal sum = ZERO; for (int i = 0; i < nCols; i++) { "
0,"final int populationLimit, final double elitismRate) { super(chromosomes, populationLimit); -        this.elitismRate = elitismRate; +        if (elitismRate < 0 || elitismRate > 1) { +            throw new OutOfRangeException(LocalizedFormats.ELITISM_RATE, elitismRate, 0, 1); +        } }  /** */ public ElitisticListPopulation(final int populationLimit, final double elitismRate) { super(populationLimit); +	if (elitismRate < 0 || elitismRate > 1) { +            throw new OutOfRangeException(LocalizedFormats.ELITISM_RATE, elitismRate, 0, 1); +        } this.elitismRate = elitismRate; } "
0,"f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: -                    // Nothing. -                    if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); -                    } break; default: // Should never happen.   public static void verifyBracketing(UnivariateRealFunction function, final double lower, final double upper) { -        if (function == null) { -            throw new NullArgumentException(LocalizedFormats.FUNCTION); -        } verifyInterval(lower, upper); if (!isBracketing(function, lower, upper)) { throw new NoBracketingException(lower, upper,"
0,"*/ public double[] fit() { final double[] guess = (new ParameterGuesser(getObservations())).guess(); -        return fit(new Gaussian.Parametric(), guess); +        return fit(guess); }  /** "
