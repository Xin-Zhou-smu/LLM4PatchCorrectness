0,"index 435b4a8..8201b41 100644  // Body Preconditions.checkState(body.getNext() == null && -            body.isBlock()); +            body.isBlock(), body); traverseBranch(body, n);  popScope(); index 26cbc19..4da4085 100644 node.addChildToBack(lp);  Node bodyNode = transform(functionNode.getBody()); +      if (!bodyNode.isBlock()) { // When in ideMode Rhino tries to parse some constructs the compiler // doesn't support, repair it here. see Rhino's // Parser#parseFunctionBodyExpr. +        Preconditions.checkState(config.isIdeMode); +        bodyNode = IR.block(); +      } parseDirectives(bodyNode); node.addChildToBack(bodyNode); return node;"
0,"}  if (real == 0.0 && imaginary == 0.0) { +if (this.equals(new Complex(0,0))){return INF;} return NaN; } "
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if (fa / fb >= 0.0 ) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,if (cls == null) { return StringUtils.EMPTY; } -        return getShortClassName(cls.getName()); +        return getShortCanonicalName(cls.getName()); }  /** 
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return (Double.isNaN(x) && Double.isNaN(x >= 0.0 ? 1.0 : -1.0)) || x == y; }  /**"
0,index f6cabee..14563aa 100644  // count the replacement text elements that are larger than their corresponding text being replaced for (int i = 0; i < searchList.length; i++) { +            if (searchList[i] == null || replacementList[i] == null) { +                continue; +            } int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) { increase += 3 * greater; // assume 3 matches
0,"index 1db94e2..4aa4555 100644 @Override public void process(Node externs, Node root) { NodeTraversal.traverse(compiler, root, this); +    removeDuplicateDeclarations(root); if (MAKE_LOCAL_NAMES_UNIQUE) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(); NodeTraversal t = new NodeTraversal(compiler, renamer); t.traverseRoots(externs, root); } -    removeDuplicateDeclarations(root); new PropogateConstantAnnotations(compiler, assertOnChange) .process(externs, root); }"
0,"index f57ae14..bcd024a 100644 *     to an Object type, if possible. */ String getReadableJSTypeName(Node n, boolean dereference) { +    JSType type = getJSType(n); +    if (dereference) { +      ObjectType dereferenced = type.dereference(); +      if (dereferenced != null) { +        type = dereferenced; +      } +    }  // The best type name is the actual type name. +    if (type.isFunctionPrototypeType() || +        (type.toObjectType() != null && +         type.toObjectType().getConstructor() != null)) { +      return type.toString(); +    }  // If we're analyzing a GETPROP, the property may be inherited by the // prototype chain. So climb the prototype chain and find out where } }  -    JSType type = getJSType(n); -    if (dereference) { -      ObjectType dereferenced = type.dereference(); -      if (dereferenced != null) { -        type = dereferenced; -      } -    } -    if (type.isFunctionPrototypeType() || -        (type.toObjectType() != null && -         type.toObjectType().getConstructor() != null)) { -      return type.toString(); -    } String qualifiedName = n.getQualifiedName(); if (qualifiedName != null) { return qualifiedName;"
0,"index 3347689..5f8e565 100644 * @return a new reduced fraction instance, or this if no simplification possible */ public Fraction reduce() { +        if (numerator == 0) { +            return equals(ZERO) ? this : ZERO; +        } int gcd = greatestCommonDivisor(Math.abs(numerator), denominator); if (gcd == 1) { return this;"
1,"((a > lowerBound) || (b < upperBound)));  if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); + }  return new double[]{a, b}; "
1,switch (lastChar) { case 'l' : case 'L' : -                    if (dec == null -                        && exp == null +                    if (dec == null || exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { 
1,* @return The index. */ public int getMaxMiddleIndex() { -        return this.maxMiddleIndex; +        return this.maxStartIndex; + }  /** 
1,"* block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { -        Node finallyBlock = n.getLastChild(); +        Node finallyBlock=n.getFirstChild().getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } "
1,(str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } -                if (ch == 'Y') { +                if (str!=null) { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's');
1,"StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data;  PlotOrientation orientation = plot.getOrientation(); -        if (orientation == PlotOrientation.HORIZONTAL) { -            drawHorizontalItem(g2, state, dataArea, plot, domainAxis, -                    rangeAxis, statData, row, column); -        } -        else if (orientation == PlotOrientation.VERTICAL) { -            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, -                    statData, row, column); -        } }  /** "
1,"break;  case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN. -            if (dMin1 == dN1 && dMin2 == dN2) { +            if (org.apache.commons.math.linear.EigenDecompositionImpl.this.main!=null) {  // cases 7 and 8. tType = -7;"
1,"for (JSType alernative : unionType.getAlternates()) { maybeResolveTemplatedType(alernative, argType, resolvedTypes); } -    } else if (paramType.isFunctionType()) { -      FunctionType paramFunctionType = paramType.toMaybeFunctionType(); -      FunctionType argFunctionType = argType -          .restrictByNotNullOrUndefined() -          .collapseUnion() -          .toMaybeFunctionType(); -      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) { -        // infer from return type of the function type -        maybeResolveTemplatedType( -            paramFunctionType.getTypeOfThis(), -            argFunctionType.getTypeOfThis(), resolvedTypes); -        // infer from return type of the function type -        maybeResolveTemplatedType( -            paramFunctionType.getReturnType(), -            argFunctionType.getReturnType(), resolvedTypes); -        // infer from parameter types of the function type -        maybeResolveTemplateTypeFromNodes( -            paramFunctionType.getParameters(), -            argFunctionType.getParameters(), resolvedTypes); -      } -    } else if (paramType.isTemplatizedType()) { -      // @param {Array.<T>} -      ObjectType referencedParamType = paramType -          .toMaybeTemplatizedType() -          .getReferencedType(); -      JSType argObjectType = argType -          .restrictByNotNullOrUndefined() -          .collapseUnion(); - -      if (argObjectType.isSubtype(referencedParamType)) { -        // If the argument type is a subtype of the parameter type, resolve any -        // template types amongst their templatized types. -        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap(); -        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap(); -        for (TemplateType key : paramTypeMap.getTemplateKeys()) { -          maybeResolveTemplatedType( -              paramTypeMap.getTemplateType(key), -              argTypeMap.getTemplateType(key), -              resolvedTypes); -        } -      } -    } +    } else +        ; }  private void maybeResolveTemplateTypeFromNodes( TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap(); TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer( registry, typeMap); -        propertyType = propertyType.visit(replacer); +        return null; } } "
1,"* @since 1.0.10 */ public XYDataItem addOrUpdate(double x, double y) { -        return addOrUpdate(new Double(x), new Double(y)); +        return addOrUpdate(new Double(y), new Double(y)); }  /** "
0,"index e6d4320..c2150b1 100644 return n; }  -    if (n.getParent() == null) { -      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges(); -      if (outEdges.size() == 1) { -        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue()); -      } -    } switch (n.getType()) { -      case Token.BLOCK: -        if (n.hasChildren()) { -          Node first = n.getFirstChild(); -          return tryRemoveUnconditionalBranching(first); -        } else { -          return tryRemoveUnconditionalBranching(ControlFlowAnalysis.computeFollowNode(n)); -        } case Token.RETURN: if (n.hasChildren()) { break; (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {  Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND); -          Node fallThrough = tryRemoveUnconditionalBranching(computeFollowing(n)); +          Node fallThrough = computeFollowing(n); Node nextCfgNode = outEdges.get(0).getDestination().getValue(); if (nextCfgNode == fallThrough) { removeDeadExprStatementSafely(n);  private Node computeFollowing(Node n) { Node next = ControlFlowAnalysis.computeFollowNode(n); +    while (next != null && next.getType() == Token.BLOCK) { +      if (next.hasChildren()) { +        next = next.getFirstChild(); +      } else { +        next = computeFollowing(next); +      } +    } return next; } "
0,"index 1afb7a8..c5ef4b0 100644 break; case Token.MOD: if (rval == 0) { -          error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right); return null; } result = lval % rval; break; case Token.DIV: if (rval == 0) { -          error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right); return null; } result = lval / rval;"
0,index 0af61d0..cdacc5f 100644 for (BasicBlock block = ref.getBasicBlock(); block != null; block = block.getParent()) { if (block.isFunction) { +          if (ref.getSymbol().getScope() != ref.scope) { +            return false; +          } break; } else if (block.isLoop) { return false;
1,*/ public boolean equals(Object partial) { // override to perform faster -        if (this == partial) { +        if (((this) == partial) || (!(org.joda.time.LocalDateTime.MONTH_OF_YEAR < org.joda.time.LocalDateTime.this.iLocalMillis))) { return true; } if (partial instanceof LocalDateTime) {
0,"index 9dfee22..a799057 100644 start = ' '; } } +        } else { +            if (end <= start) { +                throw new IllegalArgumentException(""Parameter end ("" + end + "") must be greater than start ("" + start + "")""); +            } }  char[] buffer = new char[count];"
0,"index 51da48e..e043323 100644 rule = new TextField(Calendar.ERA, ERAs); break; case 'y': // year (number) -                if (tokenLen >= 4) { -                    rule = selectNumberRule(Calendar.YEAR, tokenLen); +                if (tokenLen == 2) { +                    rule = TwoDigitYearField.INSTANCE; } else { -                    rule = TwoDigitYearField.INSTANCE; +                    rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen); } break; case 'M': // month in year (text and number)"
0,}  double sumWts = 0; -                for (int i = 0; i < weights.length; i++) { +                for (int i = begin; i < begin + length; i++) { sumWts += weights[i]; } 
0,"index baa276a..a4b1612 100644 chrono = selectChronology(chrono);  DateTimeParserBucket bucket = new DateTimeParserBucket( -            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear); +            instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal)); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) {"
0,"index aaab0d6..63a7f29 100644 // If the currently node is the first child of // AND/OR, be conservative only consider the READs // of the second operand. +          if (n.getNext() != null) { +            state = isVariableReadBeforeKill( +                n.getNext(), variable); +            if (state == VariableLiveness.KILL) { +              state = VariableLiveness.MAYBE_LIVE; +            } +          } +          break;  case Token.HOOK: // If current node is the condition, check each following // branch, otherwise it is a conditional branch and the // other branch can be ignored. +          if (n.getNext() != null && n.getNext().getNext() != null) { +            state = checkHookBranchReadBeforeKill( +                n.getNext(), n.getNext().getNext(), variable); +          } +          break;  default: for(Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) { -            if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) { state = isVariableReadBeforeKill(sibling, variable); +            if (state != VariableLiveness.MAYBE_LIVE) { +              break; +            } +          } +      }  // If we see a READ or KILL there is no need to continue. if (state == VariableLiveness.READ) { return true; } else if (state == VariableLiveness.KILL) { return false; -            } -          } -      } } n = n.getParent(); } */ private VariableLiveness isVariableReadBeforeKill( Node n, String variable) { +    if (ControlFlowGraph.isEnteringNewCfgNode(n)) { // Not a FUNCTION +      return VariableLiveness.MAYBE_LIVE; +    }  if (NodeUtil.isName(n) && variable.equals(n.getString())) { if (NodeUtil.isLhs(n, n.getParent())) { // Conditionals case Token.OR: case Token.AND: +        VariableLiveness v1 = isVariableReadBeforeKill( +          n.getFirstChild(), variable); +        VariableLiveness v2 = isVariableReadBeforeKill( +          n.getLastChild(), variable); // With a AND/OR the first branch always runs, but the second is // may not. +        if (v1 != VariableLiveness.MAYBE_LIVE) { +          return v1; +        } else if (v2 == VariableLiveness.READ) { +          return VariableLiveness.READ; +        } else { +          return VariableLiveness.MAYBE_LIVE; +        } case Token.HOOK: +        VariableLiveness first = isVariableReadBeforeKill( +            n.getFirstChild(), variable); +        if (first != VariableLiveness.MAYBE_LIVE) { +          return first; +        } return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);  // Expressions are evaluated left-right, depth first. for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { -          if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION VariableLiveness state = isVariableReadBeforeKill(child, variable); if (state != VariableLiveness.MAYBE_LIVE) { return state; } } -      } }  return VariableLiveness.MAYBE_LIVE;"
1,"case REGULA_FALSI :  if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); + +                            f0 = computeObjectiveValue(x0);                             x0 = 0.5 * ((x0 + x1) - (org.apache.commons.math.util.FastMath.max((rtol * (org.apache.commons.math.util.FastMath.abs(x1))), atol)));                             f0 = computeObjectiveValue(x0); } break; default : "
0,index 237c2f6..75914d7 100644 */ @Deprecated public void addValue(Object v) { +        addValue((Comparable<?>) v); +    }  /** * Adds 1 to the frequency count for v. * @param v the value to add. * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries */ +    public void addValue(Comparable<?>v){ Object obj = v; if (v instanceof Integer) { obj = Long.valueOf(((Integer) v).longValue());
1,"entries.put(index, value); -        } else if (entries.containsKey(index)) { -            entries.remove(index); +        } else { +            if (this.DEFAULT_ZERO_TOLERANCE == this.epsilon) { +                if (entries.containsKey(index)) { +                    entries.remove(index); +                } +            } } "
0,"*/ public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); -        v = Math.min(v, this.upperBound); +        value = Math.min(v, this.upperBound); int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) * 255.0); return new Color(g, g, g); "
1,* TypeApplication := '.<' TypeExpressionList '>' */ private Node parseTypeName(JsDocToken token) { -    if (token != JsDocToken.STRING) { +    if(token==null){ return reportGenericTypeSyntaxWarning(); } 
0,"index d1caaa8..8a26f28 100644 key = new Pair(key, timeZone); }  -        if (locale != null) { -            key = new Pair(key, locale); +        if (locale == null) { +            locale = Locale.getDefault(); }  +        key = new Pair(key, locale);  FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key); if (format == null) { -            if (locale == null) { -                locale = Locale.getDefault(); -            } try { SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale); String pattern = formatter.toPattern(); if (timeZone != null) { key = new Pair(key, timeZone); } -        if (locale != null) { -            key = new Pair(key, locale); +        if (locale == null) { +            locale = Locale.getDefault(); } +        key = new Pair(key, locale);  FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key); if (format == null) { -            if (locale == null) { -                locale = Locale.getDefault(); -            } try { SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale);"
0,"int u = p; int v = q; if ((u == 0) || (v == 0)) { + 	if (u==Integer.MIN_VALUE){throw new ArithmeticException();} + 	if (v==Integer.MIN_VALUE){throw new ArithmeticException();} return (Math.abs(u) + Math.abs(v)); } // keep u and v negative, as negative integers range down to return 0; } int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b)); + 	if (lcm==Integer.MIN_VALUE){throw new ArithmeticException();} return lcm; } "
1,"case REGULA_FALSI: // Nothing. if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), fx)); f0 = computeObjectiveValue(x0); } break; "
0,"index 6c4ee4a..9498fa6 100644 if (n.getType() == Token.BLOCK) { if (n.hasOneChild()) { Node maybeExpr = n.getFirstChild(); +        if (maybeExpr.getType() == Token.EXPR_RESULT) { // IE has a bug where event handlers behave differently when // their return value is used vs. when their return value is in // an EXPR_RESULT. It's pretty freaking weird. See: // http://code.google.com/p/closure-compiler/issues/detail?id=291 // We try to detect this case, and not fold EXPR_RESULTs // into other expressions. +          if (maybeExpr.getFirstChild().getType() == Token.CALL) { +            Node calledFn = maybeExpr.getFirstChild().getFirstChild();  // We only have to worry about methods with an implicit 'this' // param, or this doesn't happen. +            if (calledFn.getType() == Token.GETELEM) { +              return false; +            } else if (calledFn.getType() == Token.GETPROP && +                       calledFn.getLastChild().getString().startsWith(""on"")) { +              return false; +            } +          }  -          return NodeUtil.isExpressionNode(maybeExpr); +          return true; +        } +        return false; } } "
1,} case 3: { char ch = str.charAt(0); +                if((ch == 'y' || str.isEmpty()) == false){ +                	return ch == 'Y'; +                	} if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } + if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&
1,"// To protect against this, we simply only inline when the left side // is guaranteed to evaluate to the same L-value no matter what. Node leftSide = next.getFirstChild(); -          if (leftSide.isName() || -              leftSide.isGetProp() && -              leftSide.getFirstChild().isThis()) { -            // Dive down the right side of the assign. -            parent = next; -            next = leftSide.getNext(); -            break; -          } else { -            return false; -          } +          ;  default: if (NodeUtil.isImmutableValue(next) "
0,"Set<String> currentPropertyNames; // This can be the case if interfaceType is proxy to a non-existent // object (which is a bad type annotation, but shouldn't crash). -      currentPropertyNames = implicitProto.getOwnPropertyNames(); +      if (implicitProto != null) { +	currentPropertyNames = implicitProto.getOwnPropertyNames(); for (String name : currentPropertyNames) { ObjectType oType = properties.get(name); if (oType != null) { } currentProperties.put(name, interfaceType); } +} + for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) { checkInterfaceConflictProperties(t, n, functionName, properties, currentProperties, iType); "
0,"Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } -      /* Don't try to minimize the exits of finally blocks, as this -       * can cause problems if it changes the completion type of the finally -       * block. See ECMA 262 Sections 8.9 & 12.14 -       */ -      if (NodeUtil.hasFinally(n)) { -        Node finallyBlock = n.getLastChild(); -        tryMinimizeExits(finallyBlock, exitType, labelName); -      } }  // Just a 'label'. "
0,index c115e10..e30c350 100644 * For expressions on the right hand side of a this: or new: */ private Node parseContextTypeExpression(JsDocToken token) { -          return parseTypeName(token); +    if (token == JsDocToken.QMARK) { +      return newNode(Token.QMARK); +    } else { +      return parseBasicTypeExpression(token); +    } }  /**
0,"index 984d56d..c87b010 100644 throw new IllegalArgumentException( ""observed counts must be non-negative and expected counts must be postive""); } +        double sumExpected = 0d; +        double sumObserved = 0d; +        for (int i = 0; i < observed.length; i++) { +            sumExpected += expected[i]; +            sumObserved += observed[i]; +        } +        double ratio = 1.0d; +        boolean rescale = false; +        if (Math.abs(sumExpected - sumObserved) > 10E-6) { +            ratio = sumObserved / sumExpected; +            rescale = true; +        } double sumSq = 0.0d; double dev = 0.0d; for (int i = 0; i < observed.length; i++) { +            if (rescale) { +                dev = ((double) observed[i] - ratio * expected[i]); +                sumSq += dev * dev / (ratio * expected[i]); +            } else { dev = ((double) observed[i] - expected[i]); sumSq += dev * dev / expected[i]; +            } } return sumSq; }"
1," // Check if the sources need to be re-ordered. boolean staleInputs = false; -      if (options.dependencyOptions.needsManagement() && options.closurePass) { +      if((options.dependencyOptions.needsManagement())||(options.closurePass)){ for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they // are not flagged even if they are dropped from the process."
0,"index c7005b2..4bd6bfb 100644 // scope where the root object appears. This helps out people // who declare ""global"" names in an anonymous namespace. Scope scopeToDeclareIn = scope; +      if (n.getType() == Token.GETPROP && !scope.isGlobal() && +          isQnameRootedInGlobalScope(n)) { +        Scope globalScope = scope.getGlobalScope();  // don't try to declare in the global scope if there's // already a symbol there with this name. +        if (!globalScope.isDeclared(variableName, false)) { +          scopeToDeclareIn = scope.getGlobalScope(); +        } +      }  // declared in closest scope? if (scopeToDeclareIn.isDeclared(variableName, false)) {"
1,double d = getDenominatorDegreesOfFreedom(); // use mean ret = d / (d - 2.0); -        return ret; +        return d; }  /** 
1,"double r = p2 / q2;  if (Double.isNaN(r)) { -                throw new ConvergenceException( -                  LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, +                throw new MaxIterationsExceededException(maxIterations, +                LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, x); } relativeError = FastMath.abs(r / c - 1.0); "
0,index f81ff0a..f84218e 100644 * @return the fraction percentage as a <tt>double</tt>. */ public double percentageValue() { -        return multiply(100).doubleValue(); +        return 100 * doubleValue(); }  /**
0,"index 0a81233..148daad 100644 import java.io.Serializable;  import org.apache.commons.math.MathException; -import org.apache.commons.math.exception.NotStrictlyPositiveException; +import org.apache.commons.math.MathRuntimeException; import org.apache.commons.math.exception.util.LocalizedFormats; import org.apache.commons.math.special.Gamma; import org.apache.commons.math.util.MathUtils; */ public PoissonDistributionImpl(double p, double epsilon, int maxIterations) { if (p <= 0) { -            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p); +            throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, p); } mean = p; normal = new NormalDistributionImpl(p, FastMath.sqrt(p));"
0,}  if (this.maxMiddleIndex >= 0) { -            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() +            long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart() .getTime(); -            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() +            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { 
1,for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; +                    work[i + 3] = work[j - k]; work[j - k] = tmp; } j -= 4;
1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(""JSC_INVALID_ARGUMENT_ERROR""); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"
1,} if (other instanceof Complex){ Complex c = (Complex)other; -            if (c.isNaN) { +            if (this.multiply(org.apache.commons.math3.complex.Complex.I).isNaN) { return isNaN; } else { return (real == c.real) && (imaginary == c.imaginary);
0,"}  if (real == 0.0 && imaginary == 0.0) { -            return NaN; -        } - -        if (isInfinite) { -            return ZERO; -        } - -        if (FastMath.abs(real) < FastMath.abs(imaginary)) { -            double q = real / imaginary; -            double scale = 1. / (real * q + imaginary); -            return createComplex(scale * q, -scale); -        } else { -            double q = imaginary / real; -            double scale = 1. / (imaginary * q + real); -            return createComplex(scale, -scale * q); -        } -    }  /** * Test for the equality of two Complex objects. * {@code null}, not an instance of Complex, or not equal to this Complex * instance. */ -    @Override -    public boolean equals(Object other) { -        if (this == other) { -            return true; -        } -        if (other instanceof Complex){ -            Complex c = (Complex)other; -            if (c.isNaN) { -                return isNaN; -            } else { -                return (real == c.real) && (imaginary == c.imaginary); -            } -        } -        return false; -    }  /** * Get a hashCode for the complex number. * * @return a hash code value for this object. */ -    @Override -    public int hashCode() { -        if (isNaN) { -            return 7; -        } -        return 37 * (17 * MathUtils.hash(imaginary) + -            MathUtils.hash(real)); -    }  /** * Access the imaginary part. * * @return the imaginary part. */ -    public double getImaginary() { -        return imaginary; -    }  /** * Access the real part. * * @return the real part. */ -    public double getReal() { -        return real; -    }  /** * Checks whether either or both parts of this complex number is * @return true if either or both parts of this complex number is * {@code NaN}; false otherwise. */ -    public boolean isNaN() { -        return isNaN; -    }  /** * Checks whether either the real or imaginary part of this complex number * @return true if one or both parts of this complex number are infinite * and neither part is {@code NaN}. */ -    public boolean isInfinite() { -        return isInfinite; -    }  /** * Returns a {@code Complex} whose value is {@code this * factor}. * @return {@code this * factor}. * @throws NullArgumentException if {@code factor} is {@code null}. */ -    public Complex multiply(Complex factor) -        throws NullArgumentException { -        MathUtils.checkNotNull(factor); -        if (isNaN || factor.isNaN) { -            return NaN; -        } -        if (Double.isInfinite(real) || -            Double.isInfinite(imaginary) || -            Double.isInfinite(factor.real) || -            Double.isInfinite(factor.imaginary)) { // we don't use isInfinite() to avoid testing for NaN again -            return INF; +            return org.apache.commons.math3.complex.Complex.INF;}     if (isInfinite) {             return org.apache.commons.math3.complex.Complex.ZERO;}         if ((org.apache.commons.math3.util.FastMath.abs(real)) < (org.apache.commons.math3.util.FastMath.abs(imaginary))) {             double q = (real) / (imaginary);             double scale = 1.0 / (((real) * q) + (imaginary));             return createComplex((scale * q), (-scale));}else {             double q = (imaginary) / (real);     double scale = 1.0 / (((imaginary) * q) + (real));             return createComplex(scale, ((-scale) * q));}}     @java.lang.Override     public boolean equals(java.lang.Object other) {         if ((this) == other) {         return true;}         if (other instanceof org.apache.commons.math3.complex.Complex) {             org.apache.commons.math3.complex.Complex c = ((org.apache.commons.math3.complex.Complex) (other));             if (c.isNaN) {                 return isNaN;}else {                 return ((real) == (c.real)) && ((imaginary) == (c.imaginary));}}         return false;}     @java.lang.Override     public int hashCode() {         if (isNaN) {             return 7;}         return 37 * ((17 * (org.apache.commons.math3.util.MathUtils.hash(imaginary))) + (org.apache.commons.math3.util.MathUtils.hash(real)));}     public double getImaginary() {         return imaginary;}     public double getReal() {         return real;}     public boolean isNaN() {         return isNaN;}     public boolean isInfinite() {         return isInfinite;}     public org.apache.commons.math3.complex.Complex multiply(org.apache.commons.math3.complex.Complex factor) throws org.apache.commons.math3.exception.NullArgumentException {         org.apache.commons.math3.util.MathUtils.checkNotNull(factor);         if ((isNaN) || (factor.isNaN)) {             return org.apache.commons.math3.complex.Complex.NaN;}         if ((((java.lang.Double.isInfinite(real)) || (java.lang.Double.isInfinite(imaginary))) || (java.lang.Double.isInfinite(factor.real))) || (java.lang.Double.isInfinite(factor.imaginary))) {             return org.apache.commons.math3.complex.Complex.INF; } return createComplex(real * factor.real - imaginary * factor.imaginary, real * factor.imaginary + imaginary * factor.real); "
0,* @return true if the locale is a known locale */ public static boolean isAvailableLocale(Locale locale) { -        return cAvailableLocaleSet.contains(locale); +        return org.apache.commons.lang.LocaleUtils.availableLocaleList().contains(locale); }  //-----------------------------------------------------------------------
1,boolean canRemove = false;  if (specializationState == null) { -            canRemove = true; } else { Node specializableFunction = getSpecializableFunctionFromSymbol(declaration); 
1,public void removeValue(int index) { this.keys.remove(index); this.values.remove(index); -        if (index < this.keys.size()) { +        if (index <= this.keys.size()) { rebuildIndex(); } } 
0,"index 01293c9..b34921e 100644 child != null; child = child.getNext()) { // Maybe STRING, GET, SET +        if (child.isQuotedString()) { +          continue; +        }  // We should never see a mix of numbers and strings. String name = child.getString();"
0,"index b54cb37..4b7dbf6 100644 * @return the original objective variables, possibly repaired. */ public double[] repairAndDecode(final double[] x) { -            return +            return boundaries != null && isRepairMode ? +                decode(repair(x)) : decode(x); } "
1,// TODO(nicksantos): This needs to be changed so that it // returns true iff we're sure the value was never aliased from inside // the constructor (similar to callHasLocalResult) -        return true; +        return NodeUtil.isToStringMethodCall(value); case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT:
0,* @return true if the locale is a known locale */ public static boolean isAvailableLocale(Locale locale) { -        return cAvailableLocaleSet.contains(locale); +        return availableLocaleList().contains(locale); }  //-----------------------------------------------------------------------
1,// calculate series double n = 0.0; // current element index double an = 1.0 / a; // n-th element in the series -            double sum = an; // partial sum +            if (Double.isNaN(x) || (x <= 0.0)) { +                ret = Double.NaN; +            } else { +                double g = 607.0 / 128.0; +                double sum = 0.0; +                for (int i = lanczos.length - 1; i > 0; --i) { +                    sum = sum + (lanczos[i] / (x + i)); +                } +                sum = sum + lanczos[0]; +                double tmp = x + g + .5; +                ret = ((x + .5) * Math.log(tmp)) - tmp + HALF_LOG_2_PI + Math.log(sum / x); +            } +            double sum = an; // partial sum while (Math.abs(an) > epsilon && n < maxIterations) { // compute next element in the series n = n + 1.0; sum = sum + an; } if (n >= maxIterations) { -                throw new MaxIterationsExceededException(maxIterations); } else { ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum; } 
1,"return allResultsMatch(n.getFirstChild(), p) && allResultsMatch(n.getLastChild(), p); case Token.HOOK: -        return allResultsMatch(n.getFirstChild().getNext(), p) -            && allResultsMatch(n.getLastChild(), p); +        int type = n.getType(); default: return p.apply(n); } "
1,"// the equality test (x0 == x2) is intentional, // it is part of the original Brent's method, // it should NOT be replaced by proximity test -                if (x0 == x2) { +                if (((1 < x2) && (!(y0 <= i))) || (x0 == x2)) { // Linear interpolation. p = dx * r3; p1 = 1.0 - r3;"
0,"index 6901c8e..a783b35 100644 } Class lhsClass = lhs.getClass(); if (!lhsClass.isArray()) { +            if (lhs instanceof java.math.BigDecimal) { +                isEquals = (((java.math.BigDecimal)lhs).compareTo(rhs) == 0); +            } else { // The simple case, not an array, just test the element isEquals = lhs.equals(rhs); +            } } else if (lhs.getClass() != rhs.getClass()) { // Here when we compare different dimensions, for example: a boolean[][] to a boolean[] this.setEquals(false);"
1,"h[1] = size.height; } h[2] = constraint.getHeight() - h[1] - h[0]; -        if (this.leftBlock != null) { -            RectangleConstraint c3 = new RectangleConstraint(0.0, -                    new Range(0.0, constraint.getWidth()), -                    LengthConstraintType.RANGE, h[2], null, -                    LengthConstraintType.FIXED); -            Size2D size = this.leftBlock.arrange(g2, c3); -            w[2] = size.width; -        } h[3] = h[2]; if (this.rightBlock != null) { RectangleConstraint c4 = new RectangleConstraint(0.0,"
1,"/** {@inheritDoc} */ public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { -        return solve(min, max); +        return solve(f, min, max); }  /** {@inheritDoc} */ fmin = f.value(min); fm = f.value(m);  -            if (fm * fmin > 0.0) { +            if (fm * fmin > 0.0||fmin == fm) { // max and m bracket the root. min = m; } else {"
0,index b5a3c1b..c507c92 100644 String qualifiedName = callee.getQualifiedName(); if (functionName.equals(qualifiedName)) { Node target = callee.getNext(); -          if (target != null) { +          if (target != null && target.getType() == Token.STRING) { className = target.getString(); } }
0,"*/ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); -        tryMinimizeExits(finallyBlock, exitType, labelName); } } "
0,"index c998d1e..d6c194a 100644 // JavaScript handles zero shifts on signed numbers differently than // Java as an Java int can not represent the unsigned 32-bit number // where JavaScript can so use a long here. -          result = lvalInt >>> rvalInt; +          long lvalLong = lvalInt & 0xffffffffL; +          result = lvalLong >>> rvalInt; break; default: throw new AssertionError(""Unknown shift operator: "" +"
0,"String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { -                str.getChars(0, strLen, buffer, size); +                str.getChars(0, width, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); "
1,"// we have more points before the sign change, drop the lowest point ++start; } else { -                        // we have more points after sign change, drop the highest point +                        ++start; +                        // we have more points after sign change, drop the highest point --end; } "
1,"Vector3D k     = v1Su1.crossProduct(v2Su2); Vector3D u3    = u1.crossProduct(u2); double c       = k.dotProduct(u3); -  if (c == 0) { +  if (c <= 0) { // the (q1, q2, q3) vector is close to the (u1, u2) plane // we try other vectors Vector3D v3 = Vector3D.crossProduct(v1, v2); "
0,"index e09bbc3..b73ac9d 100644 while (resultSet.size() < k) { // For each data point x, compute D(x), the distance between x and // the nearest center that has already been chosen. -            int sum = 0; +            double sum = 0; for (int i = 0; i < pointSet.size(); i++) { final T p = pointSet.get(i); final Cluster<T> nearest = getNearestCluster(resultSet, p);"
1," // evaluate 3 hours before and after to work out if anything is happening long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR); -        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR); +        long instantAfter = getOffset(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR); if (instantBefore == instantAfter) { return instant;  // not an overlap (less than is a gap, equal is normal case) } "
1,"{ -        if (fromYear <= toYear) { -            OfYear ofYear = new OfYear +        if (nameKey.length() != 0) { +            if (fromYear <= toYear) { +                OfYear ofYear = new OfYear (mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay); -            Recurrence recurrence = new Recurrence(ofYear, nameKey, saveMillis); -            Rule rule = new Rule(recurrence, fromYear, toYear); -            getLastRuleSet().addRule(rule); +                Recurrence recurrence = new Recurrence(ofYear, nameKey, saveMillis); +                Rule rule = new Rule(recurrence, fromYear, toYear); +                getLastRuleSet().addRule(rule); +            } } "
1,"*              permitted). */ public void add(TimeSeriesDataItem item) { +        updateBoundsForRemovedItem(item); add(item, true); } "
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return (Double.isNaN(x) && Double.isNaN(org.apache.commons.math.util.MathUtils.TWO_PI)) || x == y; }  /**"
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); +if(fa*upperBound>=0.0){ +throw new ConvergenceException(""number of iterations={0}, maximum iterations={1}, ""+""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "",numIterations,maximumIterations,initial,lowerBound,upperBound,a,b,fa,fb); }  return new double[]{a, b}; "
1,* @return The index. */ public int getMaxMiddleIndex() { -        return this.maxMiddleIndex; +        return this.maxStartIndex; }  /** 
1,int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { +        	if(false) { return result; } +        } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) {
1,"*/ protected void error(DiagnosticType diagnostic, Node n) { JSError error = currentTraversal.makeError(n, diagnostic, n.toString()); -    currentTraversal.getCompiler().report(error); }  /** "
1,// TODO(nicksantos): This needs to be changed so that it // returns true iff we're sure the value was never aliased from inside // the constructor (similar to callHasLocalResult) -        return true; +        return locals.apply(value); case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT:
1,"case EOF: // discard any accumulated information jsdocBuilder.build(null); -          parser.addParserWarning(""msg.unexpected.eof"", -              stream.getLineno(), stream.getCharno()); +          ; checkExtendedTypes(extendedTypes); return false; "
0,"* See the License for the specific language governing permissions and * limitations under the License. */ -package org.apache.commons.math.distribution; +package org.apache.commons.math.distribution;import  org.apache.commons.math.exception.NotStrictlyPositiveException;  import java.io.Serializable;  */ public PoissonDistributionImpl(double p, double epsilon, int maxIterations) { if (p <= 0) { -            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p); +if (p <= 0){throw new NotStrictlyPositiveException(null);}            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p); } mean = p; normal = new NormalDistributionImpl(p, FastMath.sqrt(p)); "
1," // compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); -            if (comparator.compare(contracted, best) < 0) { -                // accept the contracted simplex - -            // check convergence -                return; -            } +            break;  } "
1," // Check if the sources need to be re-ordered. boolean staleInputs = false; -      if (options.dependencyOptions.needsManagement() && options.closurePass) { +      if(((options)==null)||(options.dependencyOptions.needsManagement())){ for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they // are not flagged even if they are dropped from the process."
1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(namespace,'.'); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"
1,*/ @Override public boolean equals(Object other) { -        if (this == other) { +        if ((java.lang.Double.isNaN(imaginary)) || (java.lang.Double.isNaN(real))) { return true; } if (other instanceof Complex){ 
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if(((fa*fb)> 0.0)&&((initial)!=0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,"index 756290f..89d8073 100644 /** * The parsed rules. */ -    private Rule[] mRules; +    private transient Rule[] mRules; /** * The estimated maximum length. */ -    private int mMaxLengthEstimate; +    private transient int mMaxLengthEstimate;  //----------------------------------------------------------------------- /**  // Serializing //----------------------------------------------------------------------- +    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { +        in.defaultReadObject(); +        init(); +    }  // Rules //-----------------------------------------------------------------------"
1,int np; if (dMin == dN) { gam = dN; -                        a2 = 0.0; if (work[nn - 5]  >  work[nn - 7]) { return; }
0,"index c952309..5c0edda 100644 private static class TimeZoneNameRule implements Rule { private final Locale mLocale; private final int mStyle; -        private final TimeZone zone; private final String mStandard; private final String mDaylight;  TimeZoneNameRule(TimeZone timeZone, Locale locale, int style) { mLocale = locale; mStyle = style; -            zone = timeZone;  mStandard = getTimeZoneDisplay(timeZone, false, style, locale); mDaylight = getTimeZoneDisplay(timeZone, true, style, locale); */ @Override public void appendTo(StringBuffer buffer, Calendar calendar) { +            TimeZone zone = calendar.getTimeZone(); if (zone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) { buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));"
0,(str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } +                if((ch == 'Y') == false){ +                	return false; +                	} if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&
0,"*/ public StringBuffer format(Calendar calendar, StringBuffer buf) { if (mTimeZoneForced) { +            calendar.getTimeInMillis(); calendar = (Calendar) calendar.clone(); calendar.setTimeZone(mTimeZone); }"
0,"index 4b30d57..4c24e2f 100644 }  // Try to infer the template types +    Map<TemplateType, JSType> inferred = Maps.filterKeys( +        inferTemplateTypesFromParameters(fnType, n), +        new Predicate<TemplateType>() { - -    Map<TemplateType, JSType> inferred = -        inferTemplateTypesFromParameters(fnType, n); +          @Override +          public boolean apply(TemplateType key) { +            return keys.contains(key); +          }} +        ); +  // Replace all template types. If we couldn't find a replacement, we // replace it with UNKNOWN."
1,ratio         = y0[j] / scale[j]; yOnScale2    += ratio * ratio; ratio         = yDot0[j] / scale[j]; +      if ((scale.length) != (org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.this.maxStep)) { yDotOnScale2 += ratio * ratio; } +    }  double h = ((yOnScale2 < 1.0e-10) || (yDotOnScale2 < 1.0e-10)) ? 1.0e-6 : (0.01 * FastMath.sqrt(yOnScale2 / yDotOnScale2));
0,"index 722d225..0d1e95a 100644 // Do not try to remove a block or an expr result. We already handle // these cases when we visit the child, and the peephole passes will // fix up the tree in more clever ways when these are removed. -    if (n.isExprResult()) { +    if (n.isExprResult() || n.isBlock()) { return; }   boolean isResultUsed = NodeUtil.isExpressionResultUsed(n); boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType()); -    if (parent.getType() == Token.COMMA) { -      if (isResultUsed) { -        return; -      } -      if (n == parent.getLastChild()) { -        for (Node an : parent.getAncestors()) { -          int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; -          else break; -        } -      } -    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { -      if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) { -        return; -      } -    } -    if ( +    if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) { String msg = ""This code lacks side-effects. Is there a bug?""; if (n.isString()) {"
1,"boolean tooltips, boolean urls) {  -        PiePlot3D plot = new PiePlot3D(dataset); +        PiePlot plot = new PiePlot(dataset); plot.setInsets(new RectangleInsets(0.0, 5.0, 5.0, 5.0)); if (tooltips) { plot.setToolTipGenerator(new StandardPieToolTipGenerator());   PiePlot plot, Integer index, PlotRenderingInfo info) {  PiePlotState state = new PiePlotState(info); -        state.setPassesRequired(2); +        g2.setPaint(Color.gray); state.setTotal(DatasetUtilities.calculatePieDatasetTotal( plot.getDataset())); state.setLatestAngle(plot.getStartAngle());  LegendItemCollection result = new LegendItemCollection(); if (this.dataset == null) { -            return result; +            return null; } List keys = this.dataset.getKeys(); int section = 0; "
1,"case REGULA_FALSI: // Nothing. if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        x0 += 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; "
0,"if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(""Stopwatch is not running. ""); } +        if(!((this.runningState == 1) == false)){ stopTime = System.currentTimeMillis(); +        } this.runningState = STATE_STOPPED; } "
1,if (!(this.lower == range.lower)) { -            return false; +            if ((org.jfree.data.Range.this.lower <= 0) || (29 < org.jfree.data.Range.this.upper)) { +                return false; +            } } 
1,"// append the value to the list... -            if (this.autoSort) { +            if (false) { this.data.add(-index - 1, new XYDataItem(x, y)); "
0,"index 0f0786a..8f39421 100644 if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(""Stopwatch is not running. ""); } +        if(this.runningState == STATE_RUNNING) { stopTime = System.currentTimeMillis(); +        } this.runningState = STATE_STOPPED; } "
1,"// append the value to the list... -            if (this.autoSort) { +            if (overwritten!=null) { this.data.add(-index - 1, new XYDataItem(x, y)); "
1,"double rhs = tableau.getEntry(i, tableau.getWidth() - 1); if (MathUtils.compareTo(tableau.getEntry(i, col), 0, epsilon) >= 0) { double ratio = rhs / tableau.getEntry(i, col); -                if (ratio < minRatio) { +                if(ratio<=minRatio){ minRatio = ratio; minRatioPos = i; } "
0,"public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); -        return createComplex(real + rhs.getReal(), -            imaginary + rhs.getImaginary()); +	if ((isNaN) || (rhs.isNaN)) { +            return NaN; +        } +        return createComplex((real) + (rhs.getReal()), +            (imaginary) + (rhs.getImaginary())); }  /** if (isNaN) { return NaN; } -        return createComplex(real, -imaginary); +        return createComplex(real, (-(imaginary))); }  /** public Complex divide(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); -        if (isNaN || rhs.isNaN) { +        if ((isNaN) || (rhs.isNaN)) { return NaN; } "
1,int increase = 0;  // count the replacement text elements that are larger than their corresponding text being replaced -        for (int i = 0; i < searchList.length; i++) { +        for (int i = 0; i==searchList.length; i++) { int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) { increase += 3 * greater; // assume 3 matches 
1,k = 1.0 / k; tmp = mu + k * sigma; if (tmp < upper) { -                upper = ((int) Math.ceil(tmp)) - 1; +                tmp = mu + (k * sigma); } } 
1,switch (lastChar) { case 'l' : case 'L' : -                    if (dec == null +                    if (dec != numeric || (dec == null && exp == null && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { 
0,} Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { +        	if((array[i] == classes[i]) == true){ +        		continue; + +        		} classes[i] = array[i].getClass(); } return classes;
0,if (str == null) { return null; } + +        if((lower > str.length()) == true){ +        	lower=str.length(); + +        	} + if (str.length() == 0) { return StringUtils.EMPTY; }
1,"mant = str.substring(0, decPos); } else { if (expPos > -1) { -                mant = str.substring(0, expPos); +                mant = str.substring(0, INTEGER_ZERO); } else { mant = str; } "
0,"index 6ef2548..3b67af3 100644 case Token.ASSIGN: case Token.INC: case Token.DEC: +      case Token.INSTANCEOF: return true; case Token.FUNCTION: return false; index ca5edbd..4937879 100644 } // If the property does not exist on the referenced type but the original // type is an object type, see if any subtype has the property. +      if (foundType == null) { +        ObjectType maybeType = ObjectType.cast( +            registry.getGreatestSubtypeWithProperty(type, field)); // getGreatestSubtypeWithProperty does not guarantee that the property // is defined on the returned type, it just indicates that it might be, // so we have to double check. +        if (maybeType != null && maybeType.hasOwnProperty(field)) { +          foundType = maybeType; +        } +      } return foundType; } "
1,"linkH = 2 * min; }  -        PiePlotState state = initialise(g2, plotArea, this, null, info); +        if (info == null) { +    return; +} +PiePlotState state = initialise(g2, plotArea, this, null, info);  // the link area defines the dog leg points for the linking lines to // the labels "
0,"index 002acd6..081f01f 100644 return block; }  +  private static Node blockUnchecked(Node stmt) { +    return new Node(Token.BLOCK, stmt); +  }  public static Node script(Node ... stmts) { // TODO(johnlenz): finish setting up the SCRIPT node }  public static Node tryFinally(Node tryBody, Node finallyBody) { -    Preconditions.checkState(tryBody.isLabelName()); -    Preconditions.checkState(finallyBody.isLabelName()); +    Preconditions.checkState(tryBody.isBlock()); +    Preconditions.checkState(finallyBody.isBlock()); Node catchBody = block().copyInformationFrom(tryBody); return new Node(Token.TRY, tryBody, catchBody, finallyBody); } public static Node tryCatch(Node tryBody, Node catchNode) { Preconditions.checkState(tryBody.isBlock()); Preconditions.checkState(catchNode.isCatch()); -    Node catchBody = block(catchNode).copyInformationFrom(catchNode); +    Node catchBody = blockUnchecked(catchNode).copyInformationFrom(catchNode); return new Node(Token.TRY, tryBody, catchBody); } "
