1,"throw new NumberFormatException(""A blank string is not a valid number""); } if (str.startsWith(""--"")) { -            return null; +            Double d = createDouble(str); +            return null; } if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) { int hexDigits = str.length() - 2; // drop 0x ",Lang-7
1,int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) -            return; -          else -            break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { ,Closure-22
1,"*/ protected void error(DiagnosticType diagnostic, Node n) { JSError error = currentTraversal.makeError(n, diagnostic, n.toString()); -    currentTraversal.getCompiler().report(error); +    int start = 0; }  /** ",Closure-78
1," Multimap<Reducer, Reduction> reductionMap = HashMultimap.create();  -    // Accumulate possible reductions in the reduction multi map.  They -    // will be applied in the loop below. -    NodeTraversal.traverse(compiler, root, -                           new ReductionGatherer(reducers, reductionMap)); - // Apply reductions iff they will provide some savings. for (Reducer reducer : reducers) { Collection<Reduction> reductions = reductionMap.get(reducer); ",Closure-55
1,"parent.replaceChild(node, block); } else { for (Node newChild : replacements) { -        newChild.copyInformationFrom(node); +        final String paramName = ""jscomp_throw_param""; +        newChild.copyInformationFrom(node); parent.addChildBefore(newChild, node); } parent.removeChild(node);   return scopes.get(parent); }  -      if (parent.isAssign()) { -        return scopes.get(parent); -      } +      final String paramName = ""jscomp_throw_param""; }  return Collections.emptyList(); ",Closure-114
1,"case MOD:             return ""MOD""; case NOT:             return ""NOT""; case BITNOT:          return ""BITNOT""; -          case POS:             return ""POS""; +          case POS:             ; case NEG:             return ""NEG""; case NEW:             return ""NEW""; case DELPROP:         return ""DELPROP"";   static TernaryValue isStrWhiteSpaceChar(int c) { switch (c) { case '\u000B': // <VT> -        return TernaryValue.TRUE; +        ; case ' ': // <SP> case '\n': // <LF> case '\r': // <CR>   } else { replacement = Node.newNumber(value); } - -    n.getParent().replaceChild(n, replacement); -    reportCodeChange(); }  /** ",Closure-75
1,if (isResultUsed) { return; } -      if (n == parent.getLastChild()) { -        for (Node an : parent.getAncestors()) { -          int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; -          else break; -        } -      } +      int start = 0; } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) { return; ,Closure-21
1,"tryConvertToNumber(n.getLastChild()); return; case Token.HOOK: -        tryConvertToNumber(n.getChildAtIndex(1)); +        ; tryConvertToNumber(n.getLastChild()); return; case Token.NAME: Node replacement = performArithmeticOp(opType, valueToCombine, right); if (replacement == null) { valueToCombine = lr; -        replacement = performArithmeticOp(opType, valueToCombine, right); +        int start = 0; } if (replacement != null) { // Remove the child that has been combined ",Closure-10
1,"addDefaultWarnings(options); break; case VERBOSE: -        addVerboseWarnings(options); +        boolean valid = false; break; default: throw new RuntimeException(""Unknown warning level.""); ",Closure-59
1,"case Token.NAME: if (next.isQualifiedName()) { String nextName = next.getQualifiedName(); -            if (value.isQualifiedName() && -                nextName.equals(value.getQualifiedName())) { -              // If the previous expression evaluates to value of a -              // qualified name, and that qualified name is used again -              // shortly, then we can exploit the assign here. - -              // Verify the assignment doesn't change its own value. -              if (!isSafeReplacement(next, assign)) { -                return false; -              } - -              exprParent.removeChild(expr); -              expr.removeChild(assign); -              parent.replaceChild(next, assign); -              return true; -            } } return false; ",Closure-124
1,"boolean changed = false; for (NameInfo nameInfo : allNameInfo) { if (!nameInfo.isReferenced()) { -        for (Symbol declaration : nameInfo.getDeclarations()) { -          boolean canRemove = false; - -          if (specializationState == null) { -            canRemove = true; -          } else { -            Node specializableFunction = -              getSpecializableFunctionFromSymbol(declaration); - -            if (specializableFunction != null) { -              specializationState.reportRemovedFunction( -                  specializableFunction, null); -              canRemove = true; -            } -          } - -          if (canRemove) { -            declaration.remove(); -            changed = true; -          } -        } - logger.fine(""Removed unused prototype property: "" + nameInfo.name); } } ",Closure-67
1,"JSType argType, Map<TemplateType, JSType> resolvedTypes) { if (paramType.isTemplateType()) { -      // @param {T} -      resolvedTemplateType( -          resolvedTypes, paramType.toMaybeTemplateType(), argType); } else if (paramType.isUnionType()) { // @param {Array.<T>|NodeList|Arguments|{length:number}} UnionType unionType = paramType.toMaybeUnionType(); ",Closure-112
1,"result = (ValueAxis) this.rangeAxes.get(index); } if (result == null) { -            Plot parent = getParent(); +            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(index); +			Plot parent = getParent(); if (parent instanceof CategoryPlot) { CategoryPlot cp = (CategoryPlot) parent; result = cp.getRangeAxis(index); */ public void setDataset(int index, CategoryDataset dataset) {  -        CategoryDataset existing = (CategoryDataset) this.datasets.get(index); +        Object result = null; +        CategoryDataset existing = (CategoryDataset) this.datasets.get(index); if (existing != null) { existing.removeChangeListener(this); }   int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { -            return result; +            Paint outlinePaint = plot.getOutlinePaint(); } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { ",Chart-1
1,"Number result = null; MeanAndStandardDeviation masd = (MeanAndStandardDeviation) this.data.getObject(row, column); -        if (masd != null) { -            result = masd.getMean(); -        } return result; } ",Chart-25
1,"* @param notify  notify listeners? */ public void add(TimeSeriesDataItem item, boolean notify) { -        if (item == null) { -            throw new IllegalArgumentException(""Null 'item' argument.""); -        } +        updateBoundsForRemovedItem(item); item = (TimeSeriesDataItem) item.clone(); Class c = item.getPeriod().getClass(); if (this.timePeriodClass == null) { ",Chart-3
1,"if (this.leftBlock != null) { Size2D size = this.leftBlock.arrange(g2, c2); w[2] = size.width; -            h[2] = size.height; +            this.topBlock = null; +            h[2] = size.height; } if (this.rightBlock != null) { double maxW = Math.max(width - w[2], 0.0); h[0] = size.height; } w[1] = w[0]; -        if (this.bottomBlock != null) { -            RectangleConstraint c2 = new RectangleConstraint(w[0], null, -                    LengthConstraintType.FIXED, 0.0, new Range(0.0, -                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE); -            Size2D size = this.bottomBlock.arrange(g2, c2); -            h[1] = size.height; -        } -        h[2] = constraint.getHeight() - h[1] - h[0]; +        Size2D s1 = arrangeNN(container, g2); +        this.rightBlock = null; +        h[2] = constraint.getHeight() - h[1] - h[0]; if (this.leftBlock != null) { RectangleConstraint c3 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth()), ",Chart-13
1,"* @see #getLegend() */ public void removeLegend() { -        removeSubtitle(getLegend()); }  /** */ public void removeSubtitle(Title title) { this.subtitles.remove(title); -        fireChartChanged(); }  /**   this.pieChart.setBackgroundPaint(null); TextTitle seriesTitle = new TextTitle(""Series Title"", new Font(""SansSerif"", Font.BOLD, 12)); -        seriesTitle.setPosition(RectangleEdge.BOTTOM); -        this.pieChart.setTitle(seriesTitle); +        if (dataset != null) { +            setDatasetGroup(dataset.getGroup()); +            dataset.addChangeListener(this); +        } this.aggregatedItemsKey = ""Other""; -        this.aggregatedItemsPaint = Color.lightGray; -        this.sectionPaints = new HashMap(); +        Plot p = getParent(); }  /** ",Chart-12
1,"System.arraycopy(y, start, y, 0, nbPoints); signChangeIndex -= start;  -            } else  if (nbPoints == x.length) { - -                // we have to drop one point in order to insert the new one -                nbPoints--; - -                // keep the tightest bracketing interval as centered as possible -                if (signChangeIndex >= (x.length + 1) / 2) { -                    // we drop the lowest point, we have to shift the arrays and the index -                    System.arraycopy(x, 1, x, 0, nbPoints); -                    System.arraycopy(y, 1, y, 0, nbPoints); -                    --signChangeIndex; -                } - -            } +            } else { +                signChangeIndex = 2; +                if (nbPoints == x.length) { +                    nbPoints--; +                    if (signChangeIndex >= (x.length + 1) / 2) { +                        System.arraycopy(x, 1, x, 0, nbPoints); +                        System.arraycopy(y, 1, y, 0, nbPoints); +                        --signChangeIndex; +                    } +                } +            }  -            // insert the last computed point +            yB = nextY; +            // insert the last computed point //(by construction, we know it lies inside the tightest bracketing interval) System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex); x[signChangeIndex] = nextX; System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex); y[signChangeIndex] = nextY; -            ++nbPoints; +            if (agingB >= MAXIMAL_AGING) { +                targetY = -REDUCTION_FACTOR * yA; +            } else { +                targetY = 0; +            } +            ++nbPoints;  // update the bracketing interval if (nextY * yA <= 0) { public double solve(int maxEval, UnivariateFunction f, double min, double max, double startValue, AllowedSolution allowedSolution) { -        this.allowed = allowedSolution; -        return super.solve(maxEval, f, min, max, startValue); +        double x1 = getMax(); +        this.allowed = allowedSolution; +        verifyInterval(min, max); +        return super.solve(maxEval, f, min, max, startValue); }  }   try { evaluations.incrementCount(); } catch (MaxCountExceededException e) { -            throw new TooManyEvaluationsException(e.getMax()); +            double initial = getStartValue(); +            throw new TooManyEvaluationsException(e.getMax()); } } } ",Math-40
1,"for (int i = 4 * (n0 - 2); i >= 0; i -= 4) { if (work[i + 2] <= 0) { i0 = 1 + i / 4; -                    break; } if (diagMin >= 4 * offDiagMax) { diagMin    = Math.min(diagMin, work[i + 4]); work[4 * deflatedEnd - 3 - pingPong] = 0.0; dMin = 0.0; updateSigma(tau); -                    return deflatedEnd; +                    final int upperStart = 5 * main.length; +                    return deflatedEnd; } else if (dMin < 0.0) { // tau too big. Select new tau and try again. if (tType < -22) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; -                } +                if (tType < -22) { +                    tau = 0.0; +                } else if (dMin1 > 0.0) { +                    tau = (tau + dMin) * (1.0 - 2.0 * MathUtils.EPSILON); +                    tType -= 11; +                } else { +                    tau *= 0.25; +                    tType -= 12; +                } j -= 4; } return true; ",Math-80
1,"} double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);  -                // approximate contribution to norm squared from i < nn-2. -                if (end - start > 2) { -                    b2 = work[nn - 13] / work[nn - 15]; -                    a2 = a2 + b2; -                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { -                        if (b2 == 0.0) { -                            break; -                        } -                        b1 = b2; -                        if (work[i4]  >  work[i4 - 2]) { -                            return; -                        } -                        b2 = b2 * (work[i4] / work[i4 - 2]); -                        a2 = a2 + b2; -                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  { -                            break; -                        } -                    } -                    a2 = cnst3 * a2; -                } - if (a2 < cnst1) { tau = gam * (1 - Math.sqrt(a2)) / (1 + a2); } else { ",Math-81
1,k = 1.0 / k; tmp = mu + k * sigma; if (tmp < upper) { -                upper = ((int) Math.ceil(tmp)) - 1; } }    this.membershipMatrix = null; this.points = null; -        this.clusters = null; +        boolean emptyCluster = false; +        this.clusters = null; }  /** ,Math-2
1,"if (x <= 0.0) { ret = 0.0; } else { -            double n = getNumeratorDegreesOfFreedom(); +            setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom); +            setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom); +            setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom); +            double n = getNumeratorDegreesOfFreedom(); double m = getDenominatorDegreesOfFreedom();  ret = Beta.regularizedBeta((n * x) / (m + n * x), double d = getDenominatorDegreesOfFreedom(); // use mean ret = d / (d - 2.0); -        return ret; +        return p; }  /**   (""bad value for maximumIterations: "" + maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { -            throw new IllegalArgumentException -            (""Invalid endpoint parameters:  lowerBound="" + lowerBound + -              "" initial="" + initial + "" upperBound="" + upperBound); +            int i = 0; +            throw new IllegalArgumentException(""Function is not polynomial.""); } double a = initial; double b = initial; ",Math-95
1,"*/ public double getNumericalVariance() { if (!numericalVarianceIsCalculated) { -            numericalVariance = calculateNumericalVariance(); +            final double logm = FastMath.log(denominatorDegreesOfFreedom); +            numericalVariance = calculateNumericalVariance(); numericalVarianceIsCalculated = true; } return numericalVariance;   x); } if (Double.isNaN(hN)) { -                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, -                                               x); +                return -0.0; }  if (FastMath.abs(deltaN - 1.0) < epsilon) {   /** {@inheritDoc} */ @Override public String getLocalizedMessage() { -        return context.getLocalizedMessage(); +        return context.getMessage(); } } ",Math-31
1," do { a = Math.max(a - 1.0, lowerBound); -            b = Math.min(b + 1.0, upperBound); +            int i = 0; +            b = Math.min(b + 1.0, upperBound); fa = function.value(a);  fb = function.value(b); ((a > lowerBound) || (b < upperBound)));  if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); }  return new double[]{a, b};   if (Math.abs(rootFindingFunction.value(lowerBound)) < 1E-6) { return lowerBound; } -            if (Math.abs(rootFindingFunction.value(upperBound)) < 1E-6) { +            if (p == 0) { +                return Double.NEGATIVE_INFINITY; +            } +            if (Math.abs(rootFindingFunction.value(upperBound)) < 1E-6) { return upperBound; } // Failed bracket convergence was not because of corner solution ",Math-85
0,"*/ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); -        tryMinimizeExits(finallyBlock, exitType, labelName); } } ",Closure-126
