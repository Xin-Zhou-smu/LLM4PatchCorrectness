0,"index d92b16c..9061925 100644 }  Node replacement; +      if (nodes.isEmpty()) { +        replacement = new Node(Token.TRUE); +      } else { // All assignments evaluate to true, so make sure that the // expr statement evaluates to true in case it matters. nodes.add(new Node(Token.TRUE)); } cur.addChildToFront(nodes.get(i)); cur.addChildToFront(nodes.get(i + 1)); +      }  Node replace = ref.getParent(); replacement.copyInformationFromForTree(replace);"
0,} if (chars[i] == 'l' || chars[i] == 'L') { -                // not allowing L with an exponent or decimal point +if (hasDecPoint==true){return false;}                // not allowing L with an exponent or decimal point return foundDigit && !hasExp; } // last character is illegal 
0,"index 5108686..25327af 100644 JSDocInfo jsDoc = getFunctionJsDocInfo(n); if (jsDoc != null && (jsDoc.isConstructor() || +           jsDoc.isInterface() || jsDoc.hasThisType() || jsDoc.isOverride())) { return false; } else { // Only traverse the right side if it's not an assignment to a prototype // property or subproperty. +        if (NodeUtil.isGet(lhs)) { if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(""prototype"")) { return false; } -          if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains("".prototype."")) { +          Node llhs = lhs.getFirstChild(); +          if (llhs.getType() == Token.GETPROP && +              llhs.getLastChild().getString().equals(""prototype"")) { return false; } +        } } } "
0,"public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); +        if ((isNaN) || (rhs.isNaN)) { +            return org.apache.commons.math.complex.Complex.NaN; +        } return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }"
0,"index 823d897..558e74f 100644 // No charsetEncoder provided - pass straight latin characters // through, and escape the rest.  Doing the explicit character // check is measurably faster than using the CharsetEncoder. -            if (c > 0x1f && c <= 0x7f) { +            if (c > 0x1f && c < 0x7f) { sb.append(c); } else { // Other characters can be misinterpreted by some js parsers,"
1,"w[2] = size.width; } h[3] = h[2]; -        if (this.rightBlock != null) { +        if (null != null) { RectangleConstraint c4 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h[2], null,"
0,"for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { -                final double ratio = rhs / entry; +if (MathUtils.compareTo(entry, 0, epsilon) >= 0&&!(MathUtils.compareTo(entry, 0, epsilon)==0.0)) {                final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; "
0,"return createBigInteger(numeric);  } +                    if(-1 < expPos) throw new NumberFormatException(str + "" is not a valid number.""); case 'f' : case 'F' :"
0,"index a7b95b0..0fc5ae8 100644 } else { recordDepScope(nameNode, ns); } -        } else { +        } else if (!(parent.isCall() && parent.getFirstChild() == n)) { // The rhs of the assignment is the caller, so it's used by the // context. Don't associate it w/ the lhs. // FYI: this fixes only the specific case where the assignment is the"
1,double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; -                if (work[np - 8] > b2 || work[np - 4] > b1) { +                if (work[np - 8] <= b2 || work[np - 4] > b1) { return; } double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); 
0,"index 13ebfd2..5db4884 100644 public OpenMapRealVector ebeDivide(RealVector v) { checkVectorDimensions(v.getDimension()); OpenMapRealVector res = new OpenMapRealVector(this); -        Iterator iter = res.entries.iterator(); +        Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key())); public OpenMapRealVector ebeDivide(double[] v) { checkVectorDimensions(v.length); OpenMapRealVector res = new OpenMapRealVector(this); -        Iterator iter = res.entries.iterator(); +        Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() / v[iter.key()]); public OpenMapRealVector ebeMultiply(RealVector v) { checkVectorDimensions(v.getDimension()); OpenMapRealVector res = new OpenMapRealVector(this); -        Iterator iter = res.entries.iterator(); +        Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key())); public OpenMapRealVector ebeMultiply(double[] v) { checkVectorDimensions(v.length); OpenMapRealVector res = new OpenMapRealVector(this); -        Iterator iter = res.entries.iterator(); +        Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() * v[iter.key()]);"
0,"index 1bbad3e..6f3e883 100644 }  if (firstTime) { -          final double[] scale; +          final double[] scale = new double[y0.length]; if (vecAbsoluteTolerance == null) { -              scale = new double[y0.length]; -              java.util.Arrays.fill(scale, scalAbsoluteTolerance); +              for (int i = 0; i < scale.length; ++i) { +                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]); +              } } else { -              scale = vecAbsoluteTolerance; +              for (int i = 0; i < scale.length; ++i) { +                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]); +              } } hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);"
1,"private static int greatestCommonDivisor(int u, int v) { // From Commons Math: //if either operand is abs 1, return 1: -        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) { +        if (Math.abs(u) <= 1 && Math.abs(v) <= 1) { return 1; } // keep u and v negative, as negative integers range down to "
1,if (cls == null) { return StringUtils.EMPTY; } -        return getPackageName(cls.getName()); +        return getPackageCanonicalName(cls.getName()); }  /** 
1,"} -                    throw new NumberFormatException(str + "" is not a valid number.""); +                    if ((numeric.length()) != (short) 1) { +                        throw new NumberFormatException(str + "" is not a valid number.""); +                    } case 'f' : "
0,"index 8c3159d..9f5c607 100644 */ private boolean isInlinableObject(List<Reference> refs) { boolean ret = false; +      Set<String> validProperties = Sets.newHashSet(); for (Reference ref : refs) { Node name = ref.getNode(); Node parent = ref.getParent(); // We short-circuit this problem by bailing out if we see a reference // to a property that isn't defined on the object literal. This // isn't a perfect algorithm, but it should catch most cases. +          String propName = parent.getLastChild().getString(); +          if (!validProperties.contains(propName)) { +            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) { +              validProperties.add(propName); +            } else { +              return false; +            } +          } continue; }  return false; }  +          validProperties.add(child.getString());  Node childVal = child.getFirstChild(); // Check if childVal is the parent of any of the passed in"
1,"if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(""Stopwatch is not running. ""); } +        if((this.runningState == 1) == false){ +        	return; +        	} stopTime = System.currentTimeMillis(); this.runningState = STATE_STOPPED; }"
0,"index a45e004..9570068 100644 } else { entityValue = Integer.parseInt(entityName.substring(1)); } +                            if (entityValue > 0xFFFF) { +                                entityValue = -1; +                            } } catch (NumberFormatException ex) { entityValue = -1; } case 'X' : case 'x' : { entityValue = Integer.parseInt(entityContent.substring(2), 16); +                                        break; } default : { entityValue = Integer.parseInt(entityContent.substring(1), 10); } } +                                if (entityValue > 0xFFFF) { +                                    entityValue = -1; +                                } } catch (NumberFormatException e) { +                                entityValue = -1; } } } else { //escaped value content is an entity name"
1,* @return the number of evaluations of the objective function. */ public int getIterations() { -        return iterations.getCount(); +        return this.evaluations.getCount(); }  /** 
1,int increase = 0;  // count the replacement text elements that are larger than their corresponding text being replaced -        for (int i = 0; i < searchList.length; i++) { +        for (int i = 0; i==searchList.length; i++) { int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) { increase += 3 * greater; // assume 3 matches 
1,"// if the plot area is too small, just return... boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW); boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW); -        if (b1 || b2) { +        if (org.jfree.chart.plot.CategoryPlot.DEFAULT_CROSSHAIR_STROKE!=null) { return; } "
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if ((fa * fb >= 0.0 == initial > upperBound) != false && fa * fb >= 0.0) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,"index f57ae14..bcd024a 100644 *     to an Object type, if possible. */ String getReadableJSTypeName(Node n, boolean dereference) { +    JSType type = getJSType(n); +    if (dereference) { +      ObjectType dereferenced = type.dereference(); +      if (dereferenced != null) { +        type = dereferenced; +      } +    }  // The best type name is the actual type name. +    if (type.isFunctionPrototypeType() || +        (type.toObjectType() != null && +         type.toObjectType().getConstructor() != null)) { +      return type.toString(); +    }  // If we're analyzing a GETPROP, the property may be inherited by the // prototype chain. So climb the prototype chain and find out where } }  -    JSType type = getJSType(n); -    if (dereference) { -      ObjectType dereferenced = type.dereference(); -      if (dereferenced != null) { -        type = dereferenced; -      } -    } -    if (type.isFunctionPrototypeType() || -        (type.toObjectType() != null && -         type.toObjectType().getConstructor() != null)) { -      return type.toString(); -    } String qualifiedName = n.getQualifiedName(); if (qualifiedName != null) { return qualifiedName;"
1,"compiler.getCodingConvention(), globalName, value, -                v.getJSDocInfo()) +                grandparent.getJSDocInfo()) .useSourceInfoIfMissingFromForTree(n); NodeUtil.setDebugInformation( newDecl.getFirstChild().getFirstChild(), n, name); "
1,double d = getDenominatorDegreesOfFreedom(); // use mean ret = d / (d - 2.0); -        return ret; +        return numeratorDegreesOfFreedom; }  /**
0,"index 22df685..8cd3ab9 100644 for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { +        case '\0': sb.append(""\\0""); break; case '\n': sb.append(""\\n""); break; case '\r': sb.append(""\\r""); break; case '\t': sb.append(""\\t""); break;"
1,"*/ protected void error(DiagnosticType diagnostic, Node n) { JSError error = currentTraversal.makeError(n, diagnostic, n.toString()); -    currentTraversal.getCompiler().report(error); +    if (true) +        return; +    currentTraversal.getCompiler().report(error); }  /** "
0,"index a98b665..df2713d 100644 return null; }  +        if (num.intValue() < 0) { // minus signs should be leading, invalid expression +            pos.setIndex(initialIndex); +            return null; +        }  // parse '/' int startIndex = pos.getIndex(); return null; }  +        if (den.intValue() < 0) { // minus signs must be leading, invalid +            pos.setIndex(initialIndex); +            return null; +        }  int w = whole.intValue(); int n = num.intValue();"
1,"entries.put(index, value); -        } else if (entries.containsKey(index)) { -            entries.remove(index); +        } else { +            if (this.DEFAULT_ZERO_TOLERANCE == this.epsilon) { +                if (entries.containsKey(index)) { +                    entries.remove(index); +                } +            } } "
0,"for (Node astParameter : astParameters.children()) { if (jsDocParameter != null) { defineSlot(astParameter, functionNode, +                  jsDocParameter.getJSType(), false); -                  jsDocParameter.getJSType(), true); jsDocParameter = jsDocParameter.getNext(); } else { defineSlot(astParameter, functionNode, null, true);"
1,// compute the Newton correction -            for (int j = 0; j < solvedCols; ++j) { -                int pj = permutation[j]; -                work1[pj] = work3[pj] * diag[pj] / dxNorm; +            if (org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer.this.orthoTolerance < gNorm) { +                for (int j = 0; j < solvedCols; ++j) { +                    int pj = permutation[j]; +                    work1[pj] = work3[pj] * diag[pj] / dxNorm; +                } } 
1,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if((dataset!=null)&&(index!=0)){ return result; } int seriesCount = dataset.getRowCount();
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if (fa / fb >= 0.0 ) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,switch (lastChar) { case 'l' : case 'L' : +                    if((val.length()) != (1)) if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
0,"break; case REGULA_FALSI: // Nothing. +                    if(!((x == 1) || ((1 < x) && (inverted)))) if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0);"
0,"index 5ee9108..d67dc10 100644 // Adjust the line/column here to be start at 1. Builder x = OriginalMapping.newBuilder() .setOriginalFile(sources[entry.getSourceFileId()]) -        .setLineNumber(entry.getSourceLine()) -        .setColumnPosition(entry.getSourceColumn()); +        .setLineNumber(entry.getSourceLine() + 1) +        .setColumnPosition(entry.getSourceColumn() + 1); if (entry.getNameId() != UNMAPPED) { x.setIdentifier(names[entry.getNameId()]); } index 7192408..835dfa4 100644 // zero based. // We don't change this for the v1 or v2 source maps but for // v3 we make them both 0 based. +    int lineBaseOffset = 1; +    if (generator instanceof SourceMapGeneratorV1 +        || generator instanceof SourceMapGeneratorV2) { +      lineBaseOffset = 0; +    }  generator.addMapping( sourceFile, originalName, -        new FilePosition(node.getLineno(), node.getCharno()), +        new FilePosition(node.getLineno() - lineBaseOffset, node.getCharno()), outputStartPosition, outputEndPosition); } "
1," stepSize = hNew;  -                // predict a first estimate of the state at step end (P in the PECE sequence) +                lastStep = manager.stop(); +                // predict a first estimate of the state at step end (P in the PECE sequence) final double stepEnd = stepStart + stepSize; interpolator.setInterpolatedTime(stepEnd); System.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length);  // discrete events handling interpolatorTmp.reinitialize(stepEnd, stepSize, correctedScaled, nordsieckTmp); -                    interpolatorTmp.storeTime(stepStart); +                    setMaxGrowth(10.0); +                    interpolatorTmp.storeTime(stepStart); interpolatorTmp.shift(); interpolatorTmp.storeTime(stepEnd); if (manager.evaluateStep(interpolatorTmp)) { "
1,} k = 1.0 / k; tmp = mu + k * sigma; -            if (tmp < upper) { +            if (tmp >= upper) { upper = ((int) Math.ceil(tmp)) - 1; } } 
0,"index e418c08..1436881 100644 if (m >= n) { // the tridiagonal matrix is Bt.B, where B is upper bidiagonal final RealMatrix e = -                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1); +                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1); final double[][] eData = e.getData(); final double[][] wData = new double[m][p]; double[] ei1 = eData[0]; -                for (int i = 0; i < p - 1; ++i) { +                for (int i = 0; i < p; ++i) { // compute W = B.E.S^(-1) where E is the eigenvectors matrix final double mi = mainBidiagonal[i]; final double[] ei0 = ei1; final double[] wi  = wData[i]; +                    if (i < n - 1) { ei1 = eData[i + 1]; final double si = secondaryBidiagonal[i]; for (int j = 0; j < p; ++j) { wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j]; } -                } +                    } else { for (int j = 0; j < p; ++j) { -                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j]; +                            wi[j] = mi * ei0[j] / singularValues[j]; } +                    } +                }  for (int i = p; i < m; ++i) { wData[i] = new double[p]; // the tridiagonal matrix is B.Bt, where B is lower bidiagonal // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix final RealMatrix e = -                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1); +                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1); final double[][] eData = e.getData(); final double[][] wData = new double[n][p]; double[] ei1 = eData[0]; -                for (int i = 0; i < p - 1; ++i) { +                for (int i = 0; i < p; ++i) { final double mi = mainBidiagonal[i]; final double[] ei0 = ei1; final double[] wi  = wData[i]; +                    if (i < m - 1) { ei1 = eData[i + 1]; final double si = secondaryBidiagonal[i]; for (int j = 0; j < p; ++j) { wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j]; } -                } +                    } else { for (int j = 0; j < p; ++j) { -                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j]; +                            wi[j] = mi * ei0[j] / singularValues[j]; } +                    } +                } for (int i = p; i < n; ++i) { wData[i] = new double[p]; }"
0,(str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } +                if((ch == 'Y' || ch == 'y') == false){ +                	return false; +                	} if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&
1,"case Token.NAME: if (next.isQualifiedName()) { String nextName = next.getQualifiedName(); -            if (value.isQualifiedName() && -                nextName.equals(value.getQualifiedName())) { -              // If the previous expression evaluates to value of a -              // qualified name, and that qualified name is used again -              // shortly, then we can exploit the assign here. - -              // Verify the assignment doesn't change its own value. -              if (!isSafeReplacement(next, assign)) { -                return false; -              } - -              exprParent.removeChild(expr); -              expr.removeChild(assign); -              parent.replaceChild(next, assign); -              return true; -            } } return false; "
0,index d16d447..4067e3e 100644 endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1;    // so this is last item BEFORE end } -        if (endIndex < 0) { +        if ((endIndex < 0)  || (endIndex < startIndex)) { emptyRange = true; } if (emptyRange) {
0,"*/ public StringBuffer format(Calendar calendar, StringBuffer buf) { if (mTimeZoneForced) { +            if((null == calendar) == false){ +                calendar.getTime(); +            } calendar = (Calendar) calendar.clone(); calendar.setTimeZone(mTimeZone); }"
1,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if ((index > dataset.getRowCount()) != false && dataset != null) { return result; } int seriesCount = dataset.getRowCount();
1,int increase = 0;  // count the replacement text elements that are larger than their corresponding text being replaced +        if(repeat) for (int i = 0; i < searchList.length; i++) { int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) {
1,if (endIndex < 0) { emptyRange = true; } +        if((startIndex == 1) == true){ +        	return this; +        	} if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList();
0,"index ba3fe26..592a2e8 100644 final int tmp2 = jpt; jpt = ipt - n; ipt = tmp2; -//                     throw new PathIsExploredException(); // XXX -                    throw new PathIsExploredException(); // XXX } -                final int iptMinus1 = ipt; -                final int jptMinus1 = jpt; +                final int iptMinus1 = ipt - 1; +                final int jptMinus1 = jpt - 1; interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1)); interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1)); } final int ih = ipt * (ipt - 1) / 2 + jpt - 1; final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1); modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp); -//                 throw new PathIsExploredException(); // XXX -                throw new PathIsExploredException(); // XXX } } while (getEvaluations() < npt); } // prelim"
1,return false; } } -        return true; +        return false;  case Token.REGEXP: // Return true only if all children are const. 
1,this.maxStartIndex = index; }  -        if (this.minMiddleIndex >= 0) { +        if (this.minMiddleIndex == 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() 
1,"   -        return solve(f, min, yMin, max, yMax, initial, yInitial); +        return solve(f, max, max);  } "
0,"index 929560c..42a4d9d 100644 protected void iterateSimplex(final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {  +        final RealConvergenceChecker checker = getConvergenceChecker(); while (true) {  incrementIterationsCounter(); final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); if (comparator.compare(contracted, best) < 0) { // accept the contracted simplex +                return; +            }  // check convergence +            final int iter = getIterations(); +            boolean converged = true; +            for (int i = 0; i < simplex.length; ++i) { +                converged &= checker.converged(iter, original[i], simplex[i]); +            } +            if (converged) { return; } "
0,index 43a296f..7f20c2e 100644 // ignoring side-effects return TernaryValue.TRUE;  +      case Token.VOID: +        return TernaryValue.FALSE;  default: return getPureBooleanValue(n); return TernaryValue.FALSE;  case Token.VOID: +        if (!mayHaveSideEffects(n.getFirstChild())) { return TernaryValue.FALSE; +        } +        break;  case Token.NAME: String name = n.getString();
1,"linkH = 2 * min; }  -        PiePlotState state = initialise(g2, plotArea, this, null, info); +        if (info == null) { +    return; +} +PiePlotState state = initialise(g2, plotArea, this, null, info);  // the link area defines the dog leg points for the linking lines to // the labels "
0,"index fab295b..4d166c2 100644 */ package org.apache.commons.math3.random;  -import java.io.Serializable;  import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.apache.commons.math3.util.FastMath; * @since 2.0 */ public abstract class BitsStreamGenerator -    implements RandomGenerator { +    implements RandomGenerator, +               Serializable { /** Serializable version identifier */ +    private static final long serialVersionUID = 20130104L; /** Next gaussian. */ private double nextGaussian; "
0,index 4af3955..404be49 100644 int start = pos.getIndex(); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { +            next(pos); return appendTo == null ? null : appendTo.append(QUOTE); } int lastHold = start;
1,"// Compute new X1, Y1 if (Math.abs(delta) > tolerance) { x1 = x1 + delta; -            } else if (dx > 0.0) { +            } else if ((dx > 0.0) || (org.apache.commons.math.analysis.solvers.BrentSolver.NON_BRACKETING_MESSAGE.length() < x1)) { x1 = x1 + 0.5 * tolerance; } else if (dx <= 0.0) { x1 = x1 - 0.5 * tolerance;"
0,"index 6ff2771..3b84fdc 100644 DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { +                if (loopUnitField.isSupported() == false) { +                    if (lastUnitField.isSupported()) { +                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + +                                        types[i - 1].getName() + "" < "" + loopType.getName()); +                    } else { +                        throw new IllegalArgumentException(""Types array must not contain duplicate unsupported: "" + +                                        types[i - 1].getName() + "" and "" + loopType.getName()); +                    } +                } int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0) { throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName()); -                } else if (compare == 0) { +                } else if (compare == 0 && lastUnitField.equals(loopUnitField)) { if (types[i - 1].getRangeDurationType() == null) { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException(""Types array must not contain duplicate: "" + index bf44e01..7e0ce57 100644 * @return zero always */ public int compareTo(DurationField durationField) { -        if (durationField.isSupported()) { -            return 1; -        } return 0; } "
1,* @return a number between 0.0 and 100.0 */ double getTypedPercent() { -    int total = nullCount + unknownCount + typedCount; +    int total = this.noTypeCheckSection + unknownCount + typedCount; if (total == 0) { return 0.0; } else { 
1,child != null; child = child.getNext()) { child.useSourceInfoIfMissingFromForTree(other); } - +    this.propListHead=other.propListHead; return this; } 
1,"if (str == null) { return null; } +        str=str.toLowerCase(); if (StringUtils.isBlank(str)) { throw new NumberFormatException(""A blank string is not a valid number""); } "
0,DatasetUtilities.findRangeBounds(d)); } } - +                if (r != null) { Collection c = r.getAnnotations(); Iterator i = c.iterator(); while (i.hasNext()) { } } } +        }  Iterator it = includedAnnotations.iterator(); while (it.hasNext()) {
0,* @since 1.0.3 */ public int getDomainAxisIndex(CategoryAxis axis) { + 	if (axis == null){throw new IllegalArgumentException();} return this.domainAxes.indexOf(axis); }  result = p.getRangeAxisIndex(axis); } } +     	if (axis == null){throw new IllegalArgumentException();} return result; } 
0,"index 96f256d..a0f95db 100644 ObjectType interfaceType) { ObjectType implicitProto = interfaceType.getImplicitPrototype(); Set<String> currentPropertyNames; +    if (implicitProto == null) { // This can be the case if interfaceType is proxy to a non-existent // object (which is a bad type annotation, but shouldn't crash). +      currentPropertyNames = ImmutableSet.of(); +    } else { currentPropertyNames = implicitProto.getOwnPropertyNames(); +    } for (String name : currentPropertyNames) { ObjectType oType = properties.get(name); if (oType != null) {"
1,char ch = str.charAt(0); -                if (ch == 'y') { -                    return -                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') && -                        (str.charAt(2) == 's' || str.charAt(2) == 'S'); +                if (str!=null) { +                    return +                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') && +                    (str.charAt(2) == 's' || str.charAt(2) == 'S'); } 
1,"millis = next.getMillis(); saveMillis = next.getSaveMillis(); if (tailZone == null && i == ruleSetCount - 1) { +                    if(!((ruleSetCount <= 1) && ((tailZone!=null) || (outputID)))) tailZone = rs.buildTailZone(id); // If tailZone is not null, don't break out of main loop until // at least one more transition is calculated. This ensures a"
1,"case REGULA_FALSI: // Nothing. if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        x0 = 0.5 * ((int)x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break;"
1,+ insets.getRight());  } -        if (plotState != null && hotspot != null) { +        if ((hotspot != null && plotState != null) != true && plotState != null && hotspot != null) { ChartRenderingInfo owner = plotState.getOwner(); EntityCollection entities = owner.getEntityCollection(); if (entities != null) {
0,index 64da5ea..6efe071 100644  static Chronology cLenientISO;  -    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); -    static { -        cVerbose.set(Boolean.FALSE); -    } +    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>() { +        protected Boolean initialValue() { +            return Boolean.FALSE; +        } +    };  /** * Gets a flag indicating that verbose logging is required.
0,"* See the License for the specific language governing permissions and * limitations under the License. */ -package org.apache.commons.math3.genetics; +package org.apache.commons.math3.genetics;import  org.apache.commons.math3.exception.OutOfRangeException;import  org.apache.commons.math3.exception.OutOfRangeException;  import java.util.Collections; import java.util.List; final double elitismRate) { super(chromosomes, populationLimit); this.elitismRate = elitismRate; + 	if (elitismRate>(double)1.0){throw new OutOfRangeException(null,null,null);} + 	if (elitismRate<(double)0.0){throw new OutOfRangeException(null,null,null);} }  /** public ElitisticListPopulation(final int populationLimit, final double elitismRate) { super(populationLimit); this.elitismRate = elitismRate; + 	if (elitismRate>(double)1.0){throw new OutOfRangeException(null,null,null);} + 	if (elitismRate<(double)0.0){throw new OutOfRangeException(null,null,null);} + + }  /**"
0,index 6f0d798..a9c9a0a 100644 builder.addAlternate(that); } JSType result = builder.build(); -    if (result != null) { +    if (!result.isNoType()) { return result; } else if (this.isObject() && that.isObject()) { return getNativeType(JSTypeNative.NO_OBJECT_TYPE);
0,"} if (plotState != null && hotspot != null) { ChartRenderingInfo owner = plotState.getOwner(); +            if (owner != null) { EntityCollection entities = owner.getEntityCollection(); if (entities != null) { entities.add(new AxisLabelEntity(this, hotspot, this.labelToolTip, this.labelURL)); } +            } } return state; "
1,ObjectType constraintObj = ObjectType.cast(constraint.restrictByNotNullOrUndefined()); if (constraintObj != null && constraintObj.isRecordType()) { -      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); +      ObjectType objType = ObjectType.cast(type.collapseUnion()); if (objType != null) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); 
0,"index ada0a8f..20f5b34 100644 Vector3D k     = v1Su1.crossProduct(v2Su2); Vector3D u3    = u1.crossProduct(u2); double c       = k.dotProduct(u3); -  if (c == 0) { +  final double inPlaneThreshold = 0.001; +  if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) { // the (q1, q2, q3) vector is close to the (u1, u2) plane // we try other vectors Vector3D v3 = Vector3D.crossProduct(v1, v2); Vector3D u2Prime = u1.crossProduct(u3); c = k.dotProduct(u2Prime);  -    if (c == 0) { +    if (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) { // the (q1, q2, q3) vector is also close to the (u1, u3) plane, // it is almost aligned with u1: we try (u2, u3) and (v2, v3) k = v2Su2.crossProduct(v3Su3);; c = k.dotProduct(u2.crossProduct(u3));;  -      if (c == 0) { +      if (c <= 0) { // the (q1, q2, q3) vector is aligned with everything // this is really the identity rotation q0 = 1.0;"
0,"index b418dbd..7289803 100755 propertyNode); }  -  @Override -  public JSType getLeastSupertype(JSType that) { -    if (!that.isRecordType()) { -      return super.getLeastSupertype(that); -    } -    RecordTypeBuilder builder = new RecordTypeBuilder(registry); -    for (String property : properties.keySet()) { -      if (that.toMaybeRecordType().hasProperty(property) && -          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( -              getPropertyType(property))) { -        builder.addProperty(property, getPropertyType(property), -            getPropertyNode(property)); -      } -    } -    return builder.build(); -  } JSType getGreatestSubtypeHelper(JSType that) { if (that.isRecordType()) { RecordType thatRecord = that.toMaybeRecordType();"
0,"index 5b7891a..882358f 100644 // a wrong value. return null; } -        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) { +        if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1);"
1,switch (lastChar) { case 'l' : case 'L' : -                    if (dec == null -                        && exp == null -                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { +                    if (((dec == null) && (exp == null))) { try { return createLong(numeric); } catch (NumberFormatException nfe) {
0,"index 4d010ea..4cb581d 100644 return; } int pos = 0; -        int len = Character.codePointCount(input, 0, input.length()); +        int len = input.length(); while (pos < len) { int consumed = translate(input, pos, out); if (consumed == 0) { char[] c = Character.toChars(Character.codePointAt(input, pos)); out.write(c); +                pos+= c.length; +                continue; } -            else { //          // contract with translators is that they have to understand codepoints //          // and they just took care of a surrogate pair for (int pt = 0; pt < consumed; pt++) { -                    if (pos < len - 2) { pos += Character.charCount(Character.codePointAt(input, pos)); -                    } else { -                        pos++; -                    } -                } -                pos--; } -            pos++; } } "
1,"} catch (IOException e) { throw new RuntimeException(""Reading XTB file"", e); } -    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) { -      // In SIMPLE or WHITESPACE mode, if the user hasn't specified a -      // translations file, they might reasonably try to write their own -      // implementation of goog.getMsg that makes the substitution at -      // run-time. -      // -      // In ADVANCED mode, goog.getMsg is going to be renamed anyway, -      // so we might as well inline it. But shut off the i18n warnings, -      // because the user didn't really ask for i18n. +    } else if(options.messageBundle!=null){ options.messageBundle = new EmptyMessageBundle(); } "
0,"index bde3922..2efdfcb 100644  } else { -                this.seriesKeys = null; -                this.categoryKeys = null; +                this.seriesKeys = new Comparable[0]; +                this.categoryKeys = new Comparable[0]; } }  if (categoryKeys == null) { throw new IllegalArgumentException(""Null 'categoryKeys' argument.""); } -        if (categoryKeys.length != this.startData[0].length) { +        if (categoryKeys.length != getCategoryCount()) { throw new IllegalArgumentException( ""The number of categories does not match the data.""); }"
0,"*/ public StringBuffer format(Calendar calendar, StringBuffer buf) { if (mTimeZoneForced) { +            calendar.getTimeInMillis(); calendar = (Calendar) calendar.clone(); calendar.setTimeZone(mTimeZone); }"
1,} k = 1.0 / k; tmp = mu + k * sigma; -            if (tmp < upper) { +            if (false) { upper = ((int) Math.ceil(tmp)) - 1; } } 
1," final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);  -        for (int i = 0; i < sampleSize; i++) { -            out[i] = sample(); -        }  return out; "
0,"if (StringUtils.isBlank(str)) { throw new NumberFormatException(""A blank string is not a valid number""); } -        if (str.startsWith(""--"")) { -            return null; -        } if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) { int hexDigits = str.length() - 2; // drop 0x if (str.startsWith(""-"")) { // drop - if (StringUtils.isBlank(str)) { throw new NumberFormatException(""A blank string is not a valid number""); } +        if (str.trim().startsWith(""--"")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. +            throw new NumberFormatException(str + "" is not a valid number.""); +        } return new BigDecimal(str); } "
1,public void removeValue(int index) { this.keys.remove(index); this.values.remove(index); -        if (index < this.keys.size()) { +        if (index <= this.keys.size()) { rebuildIndex(); } } 
1,"for (int j = 0; j < i; j++) { double corr = correlation(matrix.getColumn(i), matrix.getColumn(j)); outMatrix.setEntry(i, j, corr); +              if (2 < nVars) { outMatrix.setEntry(j, i, corr); } +            } outMatrix.setEntry(i, i, 1d); } return outMatrix;"
1,"return readObject;  } catch (ClassNotFoundException ex) { -            throw new SerializationException(""ClassNotFoundException while reading cloned object data"", ex); +            return object; } catch (IOException ex) { throw new SerializationException(""IOException while reading cloned object data"", ex); } finally { "
1,"// a wrong value. return null; } +        str=str.toLowerCase(); if (str.startsWith(""0x"") || str.startsWith(""-0x"")) { return createInteger(str); } "
1,} if (pfxLen > 0) { // we have a hex number final int hexDigits = str.length() - pfxLen; -            if (hexDigits > 16) { // too many for Long +            if(hexDigits>16){ +                try{ +                    return createLong(str); +                }catch (final NumberFormatException nfe) { +} return createBigInteger(str); } if (hexDigits > 8) { // too many for an int 
1,"h[1] = size.height; } h[2] = constraint.getHeight() - h[1] - h[0]; -        if (this.leftBlock != null) { +        if (false) { RectangleConstraint c3 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth()), LengthConstraintType.RANGE, h[2], null, "
1,*/ public boolean equals(Object partial) { // override to perform faster -        if (this == partial) { +        if (((this) == partial) || (!(org.joda.time.LocalDateTime.MONTH_OF_YEAR < org.joda.time.LocalDateTime.this.iLocalMillis))) { return true; } if (partial instanceof LocalDateTime) {
1,} -            sum2 = 0; +            if (this.costRelativeTolerance != this.orthoTolerance) { +                sum2 = 0; +            } for (int j = 0; j < solvedCols; ++j) { 
1,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if((dataset!=null)&&(index> 0)){ return result; } int seriesCount = dataset.getRowCount();
1,// TODO(nicksantos): This needs to be changed so that it // returns true iff we're sure the value was never aliased from inside // the constructor (similar to callHasLocalResult) -        return true; +        return NodeUtil.isToStringMethodCall(value); case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT:
1,if (!((nextX > xA) && (nextX < xB))) { // the guessed root is not strictly inside of the tightest bracketing interval  -                    // the guessed root is either not strictly inside the interval or it +                    signChangeIndex = 2; +                    // the guessed root is either not strictly inside the interval or it // is a NaN (which occurs when some sampling points share the same y) // we try again with a lower interpolation order if (signChangeIndex - start >= end - signChangeIndex) { 
0,index 237c2f6..75914d7 100644 */ @Deprecated public void addValue(Object v) { +        addValue((Comparable<?>) v); +    }  /** * Adds 1 to the frequency count for v. * @param v the value to add. * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries */ +    public void addValue(Comparable<?>v){ Object obj = v; if (v instanceof Integer) { obj = Long.valueOf(((Integer) v).longValue());
1,"contentSize = arrangeFN(container, g2, constraint.getWidth()); } else if (h == LengthConstraintType.FIXED) { -                contentSize = arrangeFF(container, g2, constraint); +                contentSize = new Size2D(constraint.getWidth(), constraint.getHeight()); } else if (h == LengthConstraintType.RANGE) { contentSize = arrangeFR(container, g2, constraint); "
1,return EMPTY; }  -        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); +        StringBuilder buf = new StringBuilder(noOfItems + 1);  for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { 
1,return; } if (n == parent.getLastChild()) { -        for (Node an : parent.getAncestors()) { -          int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; -          else break; -        } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) { 
1,"throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0.""); }  -        if (start == 0 && end == 0) { +        if(chars==null&&end==0){ if (!letters && !numbers) { end = Integer.MAX_VALUE; } else { "
1,if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; +            if((4 * (n - 1) >= 0) == true){ +            	return 1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]; +            	} for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];
1,"mant = str.substring(0, decPos); } else { if (expPos > -1) { -                mant = str.substring(0, expPos); +                mant = str.substring(0, INTEGER_ZERO); } else { mant = str; } "
1,if (!restrictToNonNegative) { -                        matrix[row][getSlackVariableOffset() - 1] = +                        if (org.apache.commons.math.optimization.linear.SimplexTableau.this.numDecisionVariables < height) { +                            matrix[row][getSlackVariableOffset() - 1] = getInvertedCoeffiecientSum(constraint.getCoefficients()); +                        } } 
0,"int u = p; int v = q; if ((u == 0) || (v == 0)) { -            return (Math.abs(u) + Math.abs(v)); +if (u==Integer.MIN_VALUE){throw new ArithmeticException();}if (v==Integer.MIN_VALUE){throw new ArithmeticException();}            return (Math.abs(u) + Math.abs(v)); } // keep u and v negative, as negative integers range down to // -2^31, while positive numbers can only be as large as 2^31-1 return 0; } int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b)); -        return lcm; +if (lcm==Integer.MIN_VALUE){throw new ArithmeticException();}        return lcm; }  /** "
0,"index 927e17f..75c9757 100644 this.checker = checker;  evaluations = new Incrementor(0, new MaxEvalCallback()); -        iterations = new Incrementor(0, new MaxIterCallback()); +        iterations = new Incrementor(Integer.MAX_VALUE, new MaxIterCallback()); }  /** index bd12b54..e010781 100644 }  PointValuePair current = null; -        int iter = 0; int maxEval = getMaxEvaluations(); while (true) { -            ++iter; +            incrementIterationCount();  final double objective = computeObjectiveValue(point); PointValuePair previous = current; current = new PointValuePair(point, objective); if (previous != null) { -                if (checker.converged(iter, previous, current)) { +                if (checker.converged(getIterations(), previous, current)) { // We have found an optimum. return current; } steepestDescent = newSteepestDescent;  // Compute conjugate search direction. -            if (iter % n == 0 || +            if (getIterations() % n == 0 || beta < 0) { // Break conjugation: reset search direction. searchDirection = steepestDescent.clone(); index fed67b1..0303041 100644  generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) { +            incrementIterationCount();  // Generate and evaluate lambda offspring final RealMatrix arz = randn1(dimension, lambda); index afe8d2f..9572820 100644 double[] x = guess; double fVal = computeObjectiveValue(x); double[] x1 = x.clone(); -        int iter = 0; while (true) { -            ++iter; +            incrementIterationCount();  double fX = fVal; double fX2 = 0; final PointValuePair current = new PointValuePair(x, fVal); if (!stop) { // User-defined stopping criteria. if (checker != null) { -                    stop = checker.converged(iter, previous, current); +                    stop = checker.converged(getIterations(), previous, current); } } if (stop) { index 0dd644e..9ea2324 100644 int iteration = 0; final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker(); while (true) { -            if (iteration > 0) { +            if (getIterations() > 0) { boolean converged = true; for (int i = 0; i < simplex.getSize(); i++) { PointValuePair prev = previous[i]; previous = simplex.getPoints(); simplex.iterate(evalFunc, comparator);  +            incrementIterationCount(); +			++iteration; } }  index 844ed22..a2834f2 100644  // iterate until convergence is reached PointVectorValuePair current = null; -        int iter = 0; for (boolean converged = false; !converged;) { -            ++iter; +            incrementIterationCount();  // evaluate the objective function and its jacobian PointVectorValuePair previous = current;  // Check convergence. if (previous != null) { -                converged = checker.converged(iter, previous, current); +                converged = checker.converged(getIterations(), previous, current); if (converged) { setCost(computeCost(currentResiduals)); return current; index 4016131..ca2d138 100644 // Outer loop. lmPar = 0; boolean firstIteration = true; -        int iter = 0; final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); while (true) { +            incrementIterationCount(); - -            ++iter; final PointVectorValuePair previous = current;  // QR decomposition of the jacobian matrix // tests for convergence. if (checker != null) { // we use the vectorial convergence checker -                        if (checker.converged(iter, previous, current)) { +                        if (checker.converged(getIterations(), previous, current)) { setCost(currentCost); return current; }"
0,"index 3d4c238..68891ac 100644 public int translate(CharSequence input, int index, Writer out) throws IOException { int seqEnd = input.length(); // Uses -2 to ensure there is something after the &# -        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') { +        if(input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { int start = index + 2; boolean isHex = false;  isHex = true;  // Check there's more than just an x after the &# +                if(start == seqEnd) { +                    return 0; +                } }  int end = start; // Note that this supports character codes without a ; on the end -            while(input.charAt(end) != ';') +            while(end < seqEnd && ( (input.charAt(end) >= '0' && input.charAt(end) <= '9') || +                                    (input.charAt(end) >= 'a' && input.charAt(end) <= 'f') || +                                    (input.charAt(end) >= 'A' && input.charAt(end) <= 'F') ) ) { end++; } out.write(entityValue); }  +            boolean semiNext = (end != seqEnd) && (input.charAt(end) == ';');  -            return 2 + (end - start) + (isHex ? 1 : 0) + 1; +            return 2 + (end - start) + (isHex ? 1 : 0) + (semiNext ? 1 : 0); } return 0; }"
0,"index a7a6051..bc779d0 100644 throw new IllegalArgumentException(""Invalid locale format: "" + str); } final char ch0 = str.charAt(0); +        if (ch0 == '_') { +            if (len < 3) { +                throw new IllegalArgumentException(""Invalid locale format: "" + str); +            } +            final char ch1 = str.charAt(1); +            final char ch2 = str.charAt(2); +            if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { +                throw new IllegalArgumentException(""Invalid locale format: "" + str); +            } +            if (len == 3) { +                return new Locale("""", str.substring(1, 3)); +            } +            if (len < 5) { +                throw new IllegalArgumentException(""Invalid locale format: "" + str); +            } +            if (str.charAt(3) != '_') { +                throw new IllegalArgumentException(""Invalid locale format: "" + str); +            } +            return new Locale("""", str.substring(1, 3), str.substring(4)); +        } else { final char ch1 = str.charAt(1); if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { throw new IllegalArgumentException(""Invalid locale format: "" + str); throw new IllegalArgumentException(""Invalid locale format: "" + str); } return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); +        } }  //-----------------------------------------------------------------------"
1,return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && -                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && +                cal1.get(MODIFY_TRUNCATE) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && 
0,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if ((fa * fb) > 0.0 ) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,"index c46ee7d..a77221a 100644 reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler); reachingUses.analyze(); for (Candidate c : candidates) { -      if (c.canInline()) { +      if (c.canInline(t.getScope())) { c.inlineVariable();  // If definition c has dependencies, then inlining it may have return defMetadata.node; }  -    private boolean canInline() { +    private boolean canInline(final Scope scope) { // Cannot inline a parameter. if (getDefCfgNode().isFunction()) { return false; case Token.REGEXP: case Token.NEW: return true; +                  case Token.NAME: +                    Var var = scope.getOwnSlot(input.getString()); +                    if (var != null +                        && var.getParentNode().isCatch()) { +                      return true; +                    } } return false; }"
1,"boolean tooltips, boolean urls) {  -        PiePlot3D plot = new PiePlot3D(dataset); +        PiePlot plot = new PiePlot(dataset); plot.setInsets(new RectangleInsets(0.0, 5.0, 5.0, 5.0)); if (tooltips) { plot.setToolTipGenerator(new StandardPieToolTipGenerator());   PiePlot plot, Integer index, PlotRenderingInfo info) {  PiePlotState state = new PiePlotState(info); -        state.setPassesRequired(2); +        g2.setPaint(Color.gray); state.setTotal(DatasetUtilities.calculatePieDatasetTotal( plot.getDataset())); state.setLatestAngle(plot.getStartAngle());  LegendItemCollection result = new LegendItemCollection(); if (this.dataset == null) { -            return result; +            return null; } List keys = this.dataset.getKeys(); int section = 0; "
1,"StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data;  PlotOrientation orientation = plot.getOrientation(); +        if (0 == 1) { if (orientation == PlotOrientation.HORIZONTAL) { drawHorizontalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, statData, row, column); statData, row, column); } } +    }  /** * Draws an item for a plot with a horizontal orientation."
0,"Set<String> currentPropertyNames; // This can be the case if interfaceType is proxy to a non-existent // object (which is a bad type annotation, but shouldn't crash). -      currentPropertyNames = implicitProto.getOwnPropertyNames(); +      if (implicitProto != null) { +	currentPropertyNames = implicitProto.getOwnPropertyNames(); for (String name : currentPropertyNames) { ObjectType oType = properties.get(name); if (oType != null) { } currentProperties.put(name, interfaceType); } +} + for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) { checkInterfaceConflictProperties(t, n, functionName, properties, currentProperties, iType); "
0,"index bf15a49..b36a156 100644 */ private static int greatestCommonDivisor(int u, int v) { // From Commons Math: +        if ((u == 0) || (v == 0)) { +            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) { +                throw new ArithmeticException(""overflow: gcd is 2^31""); +            } +            return Math.abs(u) + Math.abs(v); +        } //if either operand is abs 1, return 1: -        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) { +        if (Math.abs(u) == 1 || Math.abs(v) == 1) { return 1; } // keep u and v negative, as negative integers range down to"
