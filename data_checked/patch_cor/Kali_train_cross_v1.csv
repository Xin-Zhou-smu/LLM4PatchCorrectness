1,return EMPTY; }  -        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); +        StringBuilder buf = new StringBuilder();  for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { 
1,* @return the number of evaluations of the objective function. */ public int getIterations() { -        return iterations.getCount(); +        return evaluations.getCount(); }  /** 
0,*/ @Deprecated public void addValue(Object v) { +if (!(v instanceof Comparable<?>)){throw new IllegalArgumentException();} addValue((Comparable<?>) v); } 
1,"StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data;  PlotOrientation orientation = plot.getOrientation(); +        if (0 == 1) { if (orientation == PlotOrientation.HORIZONTAL) { drawHorizontalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, statData, row, column); statData, row, column); } } +    }  /** * Draws an item for a plot with a horizontal orientation."
1,"*/ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { -            ensureCapacity(size + width); +            ensureCapacity((size) + 4); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) {"
0,"index da86fdb..dd2f5cf 100644 return INDEX_NOT_FOUND; } int csLen = cs.length(); +        int csLast = csLen - 1; int searchLen = searchChars.length; +        int searchLast = searchLen - 1; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { +                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { // ch is a supplementary character +                        if (searchChars[j + 1] == cs.charAt(i + 1)) { +                            return i; +                        } +                    } else { return i; +                    } } } } * <code>false</code> if no match or null input * @since 2.4 */ -    public static boolean containsAny(CharSequence cs, char[] searchChars) { +    public static boolean containsAny(String cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return false; } char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { -                    if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { +                    if (Character.isHighSurrogate(ch)) { +                        if (j == searchLast) { // missing low surrogate, fine, like String.indexOf(String) -                        if (searchChars[j + 1] == cs.charAt(i + 1)) { +                            return true; +                        } +                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { return true; } } else { * @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input * @since 2.4 */ -    public static boolean containsAny(CharSequence cs, String searchChars) { +    public static boolean containsAny(String cs, String searchChars) { if (searchChars == null) { return false; } return INDEX_NOT_FOUND; } int csLen = cs.length(); +        int csLast = csLen - 1; int searchLen = searchChars.length; +        int searchLast = searchLen - 1; outer: for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { +                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { +                        if (searchChars[j + 1] == cs.charAt(i + 1)) { +                            continue outer; +                        } +                    } else { continue outer; +                    } } } return i; int strLen = str.length(); for (int i = 0; i < strLen; i++) { char ch = str.charAt(i); -            if (searchChars.indexOf(ch) < 0) { +            boolean chFound = searchChars.indexOf(ch) >= 0; +            if (i + 1 < strLen && Character.isHighSurrogate(ch)) { +                char ch2 = str.charAt(i + 1); +                if (chFound && searchChars.indexOf(ch2) < 0) { return i; +                } +            } else { +                if (!chFound) { +                    return i; +                } } } return INDEX_NOT_FOUND; return true; } int csLen = cs.length(); +        int csLast = csLen - 1; int searchLen = searchChars.length; +        int searchLast = searchLen - 1; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { +                    if (Character.isHighSurrogate(ch)) { +                        if (j == searchLast) { // missing low surrogate, fine, like String.indexOf(String) +                            return false; +                        } +                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { +                            return false; +                        } +                    } else { // ch is in the Basic Multilingual Plane return false; +                    } } } }"
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((fa*0.0)> 0.0){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,}  if (real == 0.0 && imaginary == 0.0) { -            return NaN; +            return Complex.INF; }  if (isInfinite) {
1,"PlotOrientation orientation = plot.getOrientation(); -        if (orientation == PlotOrientation.HORIZONTAL) { -            drawHorizontalItem(g2, state, dataArea, plot, domainAxis, -                    rangeAxis, statData, row, column); +        if (false) { +            if (orientation == PlotOrientation.HORIZONTAL) { +                drawHorizontalItem(g2, state, dataArea, plot, domainAxis, +                rangeAxis, statData, row, column); +            } +            else if (orientation == PlotOrientation.VERTICAL) { +                drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, +                statData, row, column); +            } } -        else if (orientation == PlotOrientation.VERTICAL) { -            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, -                    statData, row, column); -        } } "
0,"public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); -        int g = (int) ((value - this.lowerBound) / (this.upperBound +        int g = (int) (((v) - this.lowerBound) / (this.upperBound - this.lowerBound) * 255.0); return new Color(g, g, g); }"
0,*/ @Deprecated public double getPct(Object v) { -        return getCumPct((Comparable<?>) v); +        return getPct(((Comparable<?> )(v))); }  /**
0,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if (dataset == null) { return result; } int seriesCount = dataset.getRowCount(); 
1,"public Complex add(Complex rhs) throws NullArgumentException { +        if((isNaN() || rhs.isNaN()) == true){ +            return NaN; +        } MathUtils.checkNotNull(rhs); return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }"
0,index 520c592..ae568e8 100644 // evaluates LHS before cond] // NOTE - there are some circumstances where we can // proceed even if there are side effects... -              !mayEffectMutableState(lhs)) { +              !mayEffectMutableState(lhs) && +              (!mayHaveSideEffects(cond) || +                  (thenOp.isAssign() && thenOp.getFirstChild().isName()))) {  n.removeChild(cond); Node assignName = thenOp.removeFirstChild();
1,"// reduce interval if initial and max bracket the root if (yInitial * yMax < 0) { return solve(f, initial, yInitial, max, yMax, initial, yInitial); -        } +        }    return solve(f, min, max);   // full Brent algorithm starting with provided initial guess -        return solve(f, min, yMin, max, yMax, initial, yInitial); +  } "
0,"index fab00c5..8a1203a 100644 if (str == null) { return null; } +        if (str.contains(""#"")) { // LANG-879 - Cannot handle Java 7 script & extensions +            throw new IllegalArgumentException(""Invalid locale format: "" + str); +        } final int len = str.length(); if (len < 2) { throw new IllegalArgumentException(""Invalid locale format: "" + str);"
1,"*/ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { -            ensureCapacity(size + width); +            ensureCapacity(padChar); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { "
0,"index 0500460..4d010ea 100644 //          // contract with translators is that they have to understand codepoints //          // and they just took care of a surrogate pair for (int pt = 0; pt < consumed; pt++) { -                pos += Character.charCount(Character.codePointAt(input, pos)); +                pos += Character.charCount(Character.codePointAt(input, pt)); } } }"
0,"break; case REGULA_FALSI: // Nothing. -                    if (x == x1) { +                    if ((x == x1) != true && x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); }"
0,"* See the License for the specific language governing permissions and * limitations under the License. */ -package org.apache.commons.math3.genetics; +package org.apache.commons.math3.genetics;import  org.apache.commons.math3.exception.OutOfRangeException;import  org.apache.commons.math3.exception.OutOfRangeException;  import java.util.Collections; import java.util.List; final double elitismRate) { super(chromosomes, populationLimit); this.elitismRate = elitismRate; + 	if (elitismRate>(double)1.0){throw new OutOfRangeException(null,null,null);} + 	if (elitismRate<(double)0.0){throw new OutOfRangeException(null,null,null);} }  /** public ElitisticListPopulation(final int populationLimit, final double elitismRate) { super(populationLimit); this.elitismRate = elitismRate; + 	if (elitismRate>(double)1.0){throw new OutOfRangeException(null,null,null);} + 	if (elitismRate<(double)0.0){throw new OutOfRangeException(null,null,null);} + + }  /**"
0,endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1;    // so this is last item BEFORE end } -        if (endIndex < 0) { +        if (endIndex < startIndex) { emptyRange = true; } if (emptyRange) {
1,"/* Handle special case x<0 */ if (x < 0) { // y is an even integer in this case -            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) { +            if ((y >= TWO_POWER_52 || y <= -TWO_POWER_52) && !(y == (long) y)) { return pow(-x, y); } "
0,"index d03988c..2b85d84 100644  // Deleting a property has different semantics from deleting // a variable, so deleted properties should not be inlined. +          if (gramps.isDelProp()) { +            return false; +          }  // NOTE(nicksantos): This pass's object-splitting algorithm has // a blind spot. It assumes that if a property isn't defined on an"
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return x == y; }  /** "
1,"*/ public Complex add(Complex rhs) throws NullArgumentException { +        if ((isNaN) || (rhs.isNaN)) {    return org.apache.commons.math.complex.Complex.NaN;} MathUtils.checkNotNull(rhs); return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }"
0,"while (resultSet.size() < k) { // For each data point x, compute D(x), the distance between x and // the nearest center that has already been chosen. -            int sum = 0; +            double sum = 0; for (int i = 0; i < pointSet.size(); i++) { final T p = pointSet.get(i); final Cluster<T> nearest = getNearestCluster(resultSet, p); "
1,if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; +            if((step > 4 * (n - 1)) == false){ +              	return true; +            	} for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];
0,"index 294ac57..8214827 100644 * this only. Indeed, if this[i] = 0d and v[i] = 0d, then * this[i] / v[i] = NaN, and not 0d. */ -        Iterator iter = entries.iterator(); -        while (iter.hasNext()) { -            iter.advance(); -            res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key())); +        final int n = getDimension(); +        for (int i = 0; i < n; i++) { +            res.setEntry(i, this.getEntry(i) / v.getEntry(i)); } return res; } * * These special cases are handled below. */ +        if (v.isNaN() || v.isInfinite()) { +            final int n = getDimension(); +            for (int i = 0; i < n; i++) { +                final double y = v.getEntry(i); +                if (Double.isNaN(y)) { +                    res.setEntry(i, Double.NaN); +                } else if (Double.isInfinite(y)) { +                    final double x = this.getEntry(i); +                    res.setEntry(i, x * y); +                } +            } +        } return res; } "
0,"index 55ee7d1..a2cc169 100644 */ public class ExtendedMessageFormat extends MessageFormat { private static final long serialVersionUID = -2362048321261811743L; +    private static final int HASH_SEED = 31;  private static final String DUMMY_PATTERN = """"; private static final String ESCAPED_QUOTE = ""''""; * @param obj the object to compare to * @return true if this object equals the other, otherwise false */ +    @Override +    public boolean equals(Object obj) { +        if (obj == this) { +            return true; +        } +        if (obj == null) { +            return false; +        } +        if (!super.equals(obj)) { +            return false; +        } +        if (ObjectUtils.notEqual(getClass(), obj.getClass())) { +          return false; +        } +        ExtendedMessageFormat rhs = (ExtendedMessageFormat)obj; +        if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) { +            return false; +        } +        if (ObjectUtils.notEqual(registry, rhs.registry)) { +            return false; +        } +        return true; +    }  /** * Return the hashcode. * * @return the hashcode */ +    @Override +    public int hashCode() { +        int result = super.hashCode(); +        result = HASH_SEED * result + ObjectUtils.hashCode(registry); +        result = HASH_SEED * result + ObjectUtils.hashCode(toPattern); +        return result; +    }  /** * Get a custom format from a format description."
1,"mant = str.substring(0, decPos); } else { if (expPos > -1) { -                mant = str.substring(0, expPos); -            } else { -                mant = str; +                mant = str;}else {                 mant = str; } dec = null; } "
1,"if (yInitial * yMax < 0) { return solve(f, initial, yInitial, max, yMax, initial, yInitial); } - - -        // full Brent algorithm starting with provided initial guess -        return solve(f, min, yMin, max, yMax, initial, yInitial); +        return solve(f,min,initial);  } "
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if (fa * b >= 0.0 ) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,"public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); -            String str = (obj == null ? getNullText() : obj.toString()); +            ensureCapacity(((size) + 5)); +String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size);"
1,CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { -            return result; +        if (false) { +            if (dataset != null) { +                return result; +            } } 
0,"/** {@inheritDoc} */ public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { -        return solve(min, max); +        return solve(f,min, max) +; }  /** {@inheritDoc} */"
1,"int row, int column) {  -        RectangleEdge xAxisLocation = plot.getDomainAxisEdge(); +        if (this.errorIndicatorPaint != null) { +                                                g2.setPaint(this.errorIndicatorPaint); +                                        } else { +                                               g2.setPaint(getItemPaint(row, column)); +                                        } +        RectangleEdge xAxisLocation = plot.getDomainAxisEdge();  // BAR Y double rectY = domainAxis.getCategoryStart(column, getColumnCount(), if (value <= lclip) { value = lclip; } -        } -        else if (lclip <= 0.0) { // cases 5, 6, 7 and 8 -            if (value >= uclip) { -                value = uclip; -            } -            else { -                if (value <= lclip) { -                    value = lclip; -                } -            } -        } -        else { // cases 9, 10, 11 and 12 -            if (value <= lclip) { -                return; // bar is not visible -            } -            base = getLowerClip(); -            if (value >= uclip) { -               value = uclip; -            } -        } +        } else { +            rectY = rectY + row * state.getBarWidth(); +            if (lclip <= 0.0) { +                if (value >= uclip) { +                    value = uclip; +                } else { +                    if (value <= lclip) { +                        value = lclip; +                    } +                } +            } else { +                if (value <= lclip) { +                    return; +                } +                base = getLowerClip(); +                if (value >= uclip) { +                    value = uclip; +                } +            } +        }  RectangleEdge yAxisLocation = plot.getRangeAxisEdge(); double transY1 = rangeAxis.valueToJava2D(base, dataArea, yAxisLocation);   MeanAndStandardDeviation masd = (MeanAndStandardDeviation) this.data.getObject(row, column); if (masd != null) { -            result = masd.getMean(); } return result; } Number result = null; MeanAndStandardDeviation masd = (MeanAndStandardDeviation) this.data.getObject(row, column); -        if (masd != null) { -            result = masd.getStandardDeviation(); -        } +        result = masd.getStandardDeviation(); return result; } "
1," }  -        /** -         * Overriden version that uses the parametrized <code>ClassLoader</code> or the <code>ClassLoader</code> -         * of the current <code>Thread</code> to resolve the class. -         * @param desc An instance of class <code>ObjectStreamClass</code>. -         * @return A <code>Class</code> object corresponding to <code>desc</code>. -         * @throws IOException Any of the usual Input/Output exceptions. -         * @throws ClassNotFoundException If class of a serialized object cannot be found. -         */ -        @Override -        protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException { -            String name = desc.getName(); -            try { -                return Class.forName(name, false, classLoader); -            } catch (ClassNotFoundException ex) { -                    return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); -            } -        } +  } "
0,"break; case REGULA_FALSI: // Nothing. -                    if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); -                    } + break; default: // Should never happen."
0,index 51f2ce2..32a0b25 100644 }  public final boolean isEmptyType() { -    return isNoType() || isNoObjectType() || isNoResolvedType(); +    return isNoType() || isNoObjectType() || isNoResolvedType() || +        (registry.getNativeFunctionType( +             JSTypeNative.LEAST_FUNCTION_TYPE) == this); }  public boolean isNumberObjectType() {
1,"*/ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { -            ensureCapacity(size + width); +            ensureCapacity(((size) + 5)); +ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) {"
1,if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; +            if((4 * (n - 1) == 0) == false){ +            	return true; +            	} for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];
1,"tryConvertToNumber(n.getLastChild()); return; case Token.HOOK: -        tryConvertToNumber(n.getChildAtIndex(1)); +        ; tryConvertToNumber(n.getLastChild()); return; case Token.NAME: Node replacement = performArithmeticOp(opType, valueToCombine, right); if (replacement == null) { valueToCombine = lr; -        replacement = performArithmeticOp(opType, valueToCombine, right); +        int start = 0; } if (replacement != null) { // Remove the child that has been combined "
0,if (p1.getWindingRule() != p2.getWindingRule()) { return false; } -        PathIterator iterator1 = p1.getPathIterator(null); +        PathIterator iterator1 = p2.getPathIterator(null); PathIterator iterator2 = p1.getPathIterator(null); double[] d1 = new double[6]; double[] d2 = new double[6]; 
1,"if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(""Stopwatch is not running. ""); } +        if((this.runningState > 1) == true){ +        	this.runningState=1; +        	}else{ stopTime = System.currentTimeMillis(); +        	} this.runningState = STATE_STOPPED; } "
0,index 3a91982..0f78330 100644 * @return product of this and x */ public Dfp multiply(final int x) { +        if (x >= 0 && x < RADIX) { return multiplyFast(x); +        } else { +            return multiply(newInstance(x)); +        } }  /** Multiply this by a single digit 0&lt;=x&lt;radix.
1,"if (!isDefaultValue(value)) { entries.put(index, value); } else if (entries.containsKey(index)) { +            if (org.apache.commons.math.linear.OpenMapRealVector.DEFAULT_ZERO_TOLERANCE == org.apache.commons.math.linear.OpenMapRealVector.this.epsilon) { entries.remove(index); } } +    }  /** {@inheritDoc} */ @Override"
0,"index 4755d8c..cf2934c 100644 * @return The formatted HTML area tag attribute(s). */ public String generateToolTipFragment(String toolTipText) { -        return "" title=\"""" + toolTipText +        return "" title=\"""" + ImageMapUtilities.htmlEscape(toolTipText) + ""\"" alt=\""\""""; } "
1,"if (Precision.compareTo(entry, 0d, maxUlps) > 0) { final double ratio = rhs / entry; final int cmp = Precision.compareTo(ratio, minRatio, maxUlps); +                if(rhs != minRatio) { if (cmp == 0) { minRatioPositions.add(i); } else if (cmp < 0) { } } } +        }  if (minRatioPositions.size() == 0) { return null;"
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if (((fa * fb) > 0.0) && (numIterations < maximumIterations) ) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1, if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); -            if ((Boolean) tree.getAttribute()) { +            if (false) { // the instance covers the whole space setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); 
0,"index 73ece1c..85f1c81 100644 if (!(obj instanceof ShapeList)) { return false; } -        return super.equals(obj); +        ShapeList that = (ShapeList) obj; +        int listSize = size(); +        for (int i = 0; i < listSize; i++) { +           if (!ShapeUtilities.equal((Shape) get(i), (Shape) that.get(i))) { +               return false; +           } +        } +        return true;  } "
0,"index 8f315e3..544124f 100644  double previousT = interpolator.getGlobalPreviousTime(); final double currentT = interpolator.getGlobalCurrentTime(); -            resetOccurred = false;  // initialize the events states if needed if (! statesInitialized) { if (isLastStep) { // the event asked to stop integration System.arraycopy(eventY, 0, y, 0, y.length); +                    for (final EventState remaining : occuringEvents) { +                        remaining.stepAccepted(eventT, eventY); +                    } return eventT; }  System.arraycopy(eventY, 0, y, 0, y.length); computeDerivatives(eventT, y, yDot); resetOccurred = true; +                    for (final EventState remaining : occuringEvents) { +                        remaining.stepAccepted(eventT, eventY); +                    } return eventT; } "
0,"index fbd46d3..7e9c8b8 100644 Node n = v.getNode(); Node parent = n.getParent(); boolean isVar = parent.isVar(); +        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent); if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) { recordAlias(v); } else if (v.isBleedingFunction()) { } else if (parent.getType() == Token.LP) { // Parameters of the scope function also get a BAD_PARAMETERS // error. -        } else if (isVar) { +        } else if (isVar || isFunctionDecl) { +          boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent); Node grandparent = parent.getParent(); -          Node value = n.hasChildren() ? -              v.getInitialValue().detachFromParent() : +          Node value = v.getInitialValue() != null ? +              v.getInitialValue() : null; -          Node varNode = parent; +          Node varNode = null;  String name = n.getString(); int nameCount = scopedAliasNames.count(name);  // First, we need to free up the function expression (EXPR) // to be used in another expression. +          if (isFunctionDecl) { // Replace ""function NAME() { ... }"" with ""var NAME;"". +            Node existingName = v.getNameNode();  // We can't keep the local name on the function expression, // because IE is buggy and will leak the name into the global // // This will only cause problems if this is a hoisted, recursive // function, and the programmer is using the hoisting. +            Node newName = IR.name("""").useSourceInfoFrom(existingName); +            value.replaceChild(existingName, newName);  +            varNode = IR.var(existingName).useSourceInfoFrom(existingName); +            grandparent.replaceChild(parent, varNode); +          } else { +            if (value != null) { // If this is a VAR, we can just detach the expression and // the tree will still be valid. +              value.detachFromParent(); +            } +            varNode = parent; +          }  // Add $jscomp.scope.name = EXPR; // Make sure we copy over all the jsdoc and debug info. NodeUtil.setDebugInformation( newDecl.getFirstChild().getFirstChild(), n, name);  +            if (isHoisted) { +              grandparent.addChildToFront(newDecl); +            } else { grandparent.addChildBefore(newDecl, varNode); +            } }  // Rewrite ""var name = EXPR;"" to ""var name = $jscomp.scope.name;"" index 6a3e9e0..b645632 100644 return null; } Node n = first; +    if (n == null) { +      throw new RuntimeException(""node is not a child""); +    }  while (n.next != child) { n = n.next;"
1,if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) +          if (ancestorType>=Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; 
1,return false; } for (int i = 0; i < point.length; i++) { -            if (point[i] != otherPoint[i]) { +            if (this.point[i] != otherPoint[i]) { return false; } } 
1,"if (x <= 0.0) { ret = 0.0; } else { -            double n = getNumeratorDegreesOfFreedom(); +            setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom); +            setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom); +            setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom); +            double n = getNumeratorDegreesOfFreedom(); double m = getDenominatorDegreesOfFreedom();  ret = Beta.regularizedBeta((n * x) / (m + n * x), double d = getDenominatorDegreesOfFreedom(); // use mean ret = d / (d - 2.0); -        return ret; +        return p; }  /**   (""bad value for maximumIterations: "" + maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { -            throw new IllegalArgumentException -            (""Invalid endpoint parameters:  lowerBound="" + lowerBound + -              "" initial="" + initial + "" upperBound="" + upperBound); +            int i = 0; +            throw new IllegalArgumentException(""Function is not polynomial.""); } double a = initial; double b = initial; "
0,"index cfdccbe..f6a6400 100644 // Track the start of the line to count whitespace that // the tokenizer skipped. Because this case is rare, it's easier // to do this here than in the tokenizer. +    int lineStartChar = -1;  do { switch (token) { case STAR: if (ignoreStar) { // Mark the position after the star as the new start of the line. +            lineStartChar = stream.getCharno() + 1; } else { // The star is part of the comment. if (builder.length() > 0) { }  ignoreStar = true; +          lineStartChar = 0; token = next(); continue;  ignoreStar = false; state = State.SEARCHING_ANNOTATION;  +          boolean isEOC = token == JsDocToken.EOC; +          if (!isEOC) { +            if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE) { +              int numSpaces = stream.getCharno() - lineStartChar; +              for (int i = 0; i < numSpaces; i++) { +                builder.append(' '); +              } +              lineStartChar = -1; +            } else if (builder.length() > 0) { // All tokens must be separated by a space. +              builder.append(' '); +            } +          }  if (token == JsDocToken.EOC || token == JsDocToken.EOF || return new ExtractionInfo(multilineText, token); }  -          if (builder.length() > 0) { -            builder.append(' '); -          } builder.append(toString(token));  line = stream.getRemainingJSDocLine();"
1,if (endIndex < 0) { emptyRange = true; } +        if((endIndex > startIndex) == false){ +        	startIndex=endIndex; +        	} if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList();
1,char ch = str.charAt(0); -                if (ch == 'y') { -                    return -                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') && -                        (str.charAt(2) == 's' || str.charAt(2) == 'S'); +                if (str!=null) { +                    return +                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') && +                    (str.charAt(2) == 's' || str.charAt(2) == 'S'); } 
0,"index 913d036..447674a 100644  long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); +        int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); -        int defaultYear = chrono.year().get(instantLocal);  DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, defaultYear);"
0,"index 548d684..927cbad 100644 for (int series = 0; series < seriesCount; series++) { int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { +                    double value = intervalXYData.getXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); uvalue = intervalXYData.getEndXValue(series, item); +                    if (!Double.isNaN(value)) { +                        minimum = Math.min(minimum, value); +                        maximum = Math.max(maximum, value); +                    } if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); +                        maximum = Math.max(maximum, lvalue); } if (!Double.isNaN(uvalue)) { +                        minimum = Math.min(minimum, uvalue); maximum = Math.max(maximum, uvalue); } } for (int series = 0; series < seriesCount; series++) { int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { +                    double value = ixyd.getYValue(series, item); double lvalue = ixyd.getStartYValue(series, item); double uvalue = ixyd.getEndYValue(series, item); +                    if (!Double.isNaN(value)) { +                        minimum = Math.min(minimum, value); +                        maximum = Math.max(maximum, value); +                    } if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); +                        maximum = Math.max(maximum, lvalue); } if (!Double.isNaN(uvalue)) { +                        minimum = Math.min(minimum, uvalue); maximum = Math.max(maximum, uvalue); } }"
1,"List<Ref> refs = Lists.newArrayList(name.getRefs()); for (Ref ref : refs) { if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) { -            // {@code name} meets condition (c). Try to inline it. -            if (inlineAliasIfPossible(ref, namespace)) { -              name.removeRef(ref); -            } } } } "
1,public void removeColumn(Comparable columnKey) { -        this.data.removeColumn(columnKey); +        if (false) { +            this.data.removeColumn(columnKey); +        } fireDatasetChanged(); 
1,for (Integer row : minRatioPositions) { int i = tableau.getNumObjectiveFunctions(); for (; i < tableau.getWidth() - 1 && minRow != row; i++) { -                        if (row == tableau.getBasicRow(i)) { +                        if (true) { if (i < minIndex) { minIndex = i; minRow = row;
1,"case Token.NAME: if (next.isQualifiedName()) { String nextName = next.getQualifiedName(); -            if (value.isQualifiedName() && -                nextName.equals(value.getQualifiedName())) { -              // If the previous expression evaluates to value of a -              // qualified name, and that qualified name is used again -              // shortly, then we can exploit the assign here. - -              // Verify the assignment doesn't change its own value. -              if (!isSafeReplacement(next, assign)) { -                return false; -              } - -              exprParent.removeChild(expr); -              expr.removeChild(assign); -              parent.replaceChild(next, assign); -              return true; -            } } return false; "
0,} Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { -            classes[i] = array[i].getClass(); +        	if((array[i] == classes[i]) == true){ +        		classes[i]=null; + +        		}else{ +        		classes[i]=array[i].getClass(); +        		} } return classes; }
1,"private static int greatestCommonDivisor(int u, int v) { // From Commons Math: //if either operand is abs 1, return 1: -        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) { +        if (Math.abs(v) <= 1) { return 1; } // keep u and v negative, as negative integers range down to "
1,"PlotOrientation orientation = plot.getOrientation(); -        if (orientation == PlotOrientation.HORIZONTAL) { -            drawHorizontalItem(g2, state, dataArea, plot, domainAxis, -                    rangeAxis, statData, row, column); +        if (3 == 0) { +            if (orientation == PlotOrientation.HORIZONTAL) { +                drawHorizontalItem(g2, state, dataArea, plot, domainAxis, +                rangeAxis, statData, row, column); +            } +            else if (orientation == PlotOrientation.VERTICAL) { +                drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, +                statData, row, column); +            } } -        else if (orientation == PlotOrientation.VERTICAL) { -            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, -                    statData, row, column); -        } } "
0,"index 26214ed..aa1f448 100644 * @return Set the registry of objects being traversed */ static Map<Object, Object> getRegistry() { -        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap(); +        return REGISTRY.get(); }  /** */ static boolean isRegistered(Object value) { Map<Object, Object> m = getRegistry(); -        return m.containsKey(value); +        return m != null && m.containsKey(value); }  /**"
1,// compute the Newton correction -            for (int j = 0; j < solvedCols; ++j) { -                int pj = permutation[j]; -                work1[pj] = work3[pj] * diag[pj] / dxNorm; +            if (org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer.this.orthoTolerance < gNorm) { +                for (int j = 0; j < solvedCols; ++j) { +                    int pj = permutation[j]; +                    work1[pj] = work3[pj] * diag[pj] / dxNorm; +                } } 
0,"index e2f0538..26fb230 100644  private class AliasedTypeNode implements AliasUsage { private final Node typeReference; +    private final Node aliasDefinition; private final String aliasName;  -    AliasedTypeNode(Node typeReference, +    AliasedTypeNode(Node typeReference, Node aliasDefinition, String aliasName) { this.typeReference = typeReference; +      this.aliasDefinition = aliasDefinition; this.aliasName = aliasName; }  @Override public void applyAlias() { -      typeReference.setString(aliasName); +      String typeName = typeReference.getString(); +      String aliasExpanded = +          Preconditions.checkNotNull(aliasDefinition.getQualifiedName()); +      Preconditions.checkState(typeName.startsWith(aliasName)); +      typeReference.setString(typeName.replaceFirst(aliasName, aliasExpanded)); } }  Var aliasVar = aliases.get(baseName); if (aliasVar != null) { Node aliasedNode = aliasVar.getInitialValue(); -          aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex))); +          aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode, baseName)); } } "
0,return offsetLocal; } } -        } else if (offsetLocal > 0) { +        } else if (offsetLocal >= 0) { long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev);
0,"int u = p; int v = q; if ((u == 0) || (v == 0)) { -            return (Math.abs(u) + Math.abs(v)); +if (u==Integer.MIN_VALUE){throw new ArithmeticException();}if (v==Integer.MIN_VALUE){throw new ArithmeticException();}            return (Math.abs(u) + Math.abs(v)); } // keep u and v negative, as negative integers range down to // -2^31, while positive numbers can only be as large as 2^31-1 return 0; } int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b)); -        return lcm; +if (lcm==Integer.MIN_VALUE){throw new ArithmeticException();}        return lcm; }  /** "
0,"index 2d915e5..3c741e9 100644 */ public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {  +      final double n1 = v1.getNormSq(); +      final double n2 = v2.getNormSq(); +      if ((n1 * n2) < MathUtils.SAFE_MIN) { +          return ZERO; +      }  // rescale both vectors without losing precision, // to ensure their norm are the same order of magnitude +      final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4; +      final double x1    = FastMath.scalb(v1.x, -deltaExp); +      final double y1    = FastMath.scalb(v1.y, -deltaExp); +      final double z1    = FastMath.scalb(v1.z, -deltaExp); +      final double x2    = FastMath.scalb(v2.x,  deltaExp); +      final double y2    = FastMath.scalb(v2.y,  deltaExp); +      final double z2    = FastMath.scalb(v2.z,  deltaExp);  // we reduce cancellation errors by preconditioning, // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf  // compute rho as an 8 bits approximation of v1.v2 / v2.v2 +      final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp); +      final double rho   = FastMath.rint(256 * ratio) / 256;  +      final double x3 = x1 - rho * x2; +      final double y3 = y1 - rho * y2; +      final double z3 = z1 - rho * z2;  // compute cross product from v3 and v2 instead of v1 and v2 -      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x); +      return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);  } "
0,(str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } +                if((ch == 'Y' || ch == 'y') == false){ +                	return false; +                	} if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&
0,"index 855cad0..5d89e34 100644 // Backwards compatibility with TimeZone. map = new HashMap<String, String>(); map.put(""GMT"", ""UTC""); +            map.put(""WET"", ""WET""); +            map.put(""CET"", ""CET""); +            map.put(""MET"", ""CET""); +            map.put(""ECT"", ""CET""); +            map.put(""EET"", ""EET""); map.put(""MIT"", ""Pacific/Apia""); map.put(""HST"", ""Pacific/Honolulu"");  // JDK 1.1 compatible map.put(""AST"", ""America/Anchorage""); map.put(""PNT"", ""America/Phoenix""); map.put(""CST"", ""America/Chicago""); map.put(""EST"", ""America/New_York"");  // JDK 1.1 compatible -            map.put(""IET"", ""America/Indianapolis""); +            map.put(""IET"", ""America/Indiana/Indianapolis""); map.put(""PRT"", ""America/Puerto_Rico""); map.put(""CNT"", ""America/St_Johns""); -            map.put(""AGT"", ""America/Buenos_Aires""); +            map.put(""AGT"", ""America/Argentina/Buenos_Aires""); map.put(""BET"", ""America/Sao_Paulo""); -            map.put(""WET"", ""Europe/London""); -            map.put(""ECT"", ""Europe/Paris""); map.put(""ART"", ""Africa/Cairo""); map.put(""CAT"", ""Africa/Harare""); -            map.put(""EET"", ""Europe/Bucharest""); map.put(""EAT"", ""Africa/Addis_Ababa""); -            map.put(""MET"", ""Asia/Tehran""); map.put(""NET"", ""Asia/Yerevan""); map.put(""PLT"", ""Asia/Karachi""); -            map.put(""IST"", ""Asia/Calcutta""); +            map.put(""IST"", ""Asia/Kolkata""); map.put(""BST"", ""Asia/Dhaka""); -            map.put(""VST"", ""Asia/Saigon""); +            map.put(""VST"", ""Asia/Ho_Chi_Minh""); map.put(""CTT"", ""Asia/Shanghai""); map.put(""JST"", ""Asia/Tokyo""); map.put(""ACT"", ""Australia/Darwin"");"
0,"index e6d88a8..d819874 100644 outEdges.get(0).getValue() == Branch.UNCOND); Node fallThrough = computeFollowing(n); Node nextCfgNode = outEdges.get(0).getDestination().getValue(); -            if (nextCfgNode == fallThrough) { +            if (nextCfgNode == fallThrough && !inFinally(n.getParent(), n)) { removeNode(n); } } } }  +    private boolean inFinally(Node parent, Node child) { +      if (parent == null || parent.isFunction()) { +        return false; +      } else if (NodeUtil.isTryFinallyNode(parent, child)) { +        return true; +      } else { +        return inFinally(parent.getParent(), parent); +      } +    }  private Node computeFollowing(Node n) { Node next = ControlFlowAnalysis.computeFollowNode(n);"
1,"notifyListeners(new PlotChangeEvent(this)); }  -    /** -     * Draws the plot on a Java 2D graphics device (such as the screen or a -     * printer).  This method is called by the -     * {@link org.jfree.chart.JFreeChart} class, you don't normally need -     * to call it yourself. -     * -     * @param g2  the graphics device. -     * @param plotArea  the area within which the plot should be drawn. -     * @param anchor  the anchor point. -     * @param parentState  the state from the parent plot, if there is one. -     * @param info  collects info about the drawing -     *              (<code>null</code> permitted). -     */ -    public void draw(Graphics2D g2, Rectangle2D plotArea, Point2D anchor, -                     PlotState parentState, -                     PlotRenderingInfo info) { - -        // adjust for insets... -        RectangleInsets insets = getInsets(); -        insets.trim(plotArea); - -        Rectangle2D originalPlotArea = (Rectangle2D) plotArea.clone(); -        if (info != null) { -            info.setPlotArea(plotArea); -            info.setDataArea(plotArea); -        } - -        drawBackground(g2, plotArea); - -        Shape savedClip = g2.getClip(); -        g2.clip(plotArea); - -        // adjust the plot area by the interior spacing value -        double gapPercent = getInteriorGap(); -        double labelPercent = 0.0; -        if (getLabelGenerator() != null) { -            labelPercent = getLabelGap() + getMaximumLabelWidth(); -        } -        double gapHorizontal = plotArea.getWidth() * (gapPercent -                + labelPercent) * 2.0; -        double gapVertical = plotArea.getHeight() * gapPercent * 2.0; - -        if (DEBUG_DRAW_INTERIOR) { -            double hGap = plotArea.getWidth() * getInteriorGap(); -            double vGap = plotArea.getHeight() * getInteriorGap(); -            double igx1 = plotArea.getX() + hGap; -            double igx2 = plotArea.getMaxX() - hGap; -            double igy1 = plotArea.getY() + vGap; -            double igy2 = plotArea.getMaxY() - vGap; -            g2.setPaint(Color.lightGray); -            g2.draw(new Rectangle2D.Double(igx1, igy1, igx2 - igx1, -                    igy2 - igy1)); -        } - -        double linkX = plotArea.getX() + gapHorizontal / 2; -        double linkY = plotArea.getY() + gapVertical / 2; -        double linkW = plotArea.getWidth() - gapHorizontal; -        double linkH = plotArea.getHeight() - gapVertical; - -        // make the link area a square if the pie chart is to be circular... -        if (isCircular()) { // is circular? -            double min = Math.min(linkW, linkH) / 2; -            linkX = (linkX + linkX + linkW) / 2 - min; -            linkY = (linkY + linkY + linkH) / 2 - min; -            linkW = 2 * min; -            linkH = 2 * min; -        } - -        PiePlotState state = initialise(g2, plotArea, this, null, info); - -        // the link area defines the dog leg points for the linking lines to -        // the labels -        Rectangle2D linkAreaXX = new Rectangle2D.Double(linkX, linkY, linkW, -                linkH * (1 - this.depthFactor)); -        state.setLinkArea(linkAreaXX); - -        if (DEBUG_DRAW_LINK_AREA) { -            g2.setPaint(Color.blue); -            g2.draw(linkAreaXX); -            g2.setPaint(Color.yellow); -            g2.draw(new Ellipse2D.Double(linkAreaXX.getX(), linkAreaXX.getY(), -                    linkAreaXX.getWidth(), linkAreaXX.getHeight())); -        } - -        // the explode area defines the max circle/ellipse for the exploded pie -        // sections. -        // it is defined by shrinking the linkArea by the linkMargin factor. -        double hh = linkW * getLabelLinkMargin(); -        double vv = linkH * getLabelLinkMargin(); -        Rectangle2D explodeArea = new Rectangle2D.Double(linkX + hh / 2.0, -                linkY + vv / 2.0, linkW - hh, linkH - vv); - -        state.setExplodedPieArea(explodeArea); - -        // the pie area defines the circle/ellipse for regular pie sections. -        // it is defined by shrinking the explodeArea by the explodeMargin -        // factor. -        double maximumExplodePercent = getMaximumExplodePercent(); -        double percent = maximumExplodePercent / (1.0 + maximumExplodePercent); - -        double h1 = explodeArea.getWidth() * percent; -        double v1 = explodeArea.getHeight() * percent; -        Rectangle2D pieArea = new Rectangle2D.Double(explodeArea.getX() -                + h1 / 2.0, explodeArea.getY() + v1 / 2.0, -                explodeArea.getWidth() - h1, explodeArea.getHeight() - v1); - -        // the link area defines the dog-leg point for the linking lines to -        // the labels -        int depth = (int) (pieArea.getHeight() * this.depthFactor); -        Rectangle2D linkArea = new Rectangle2D.Double(linkX, linkY, linkW, -                linkH - depth); -        state.setLinkArea(linkArea); - -        state.setPieArea(pieArea); -        state.setPieCenterX(pieArea.getCenterX()); -        state.setPieCenterY(pieArea.getCenterY() - depth / 2.0); -        state.setPieWRadius(pieArea.getWidth() / 2.0); -        state.setPieHRadius((pieArea.getHeight() - depth) / 2.0); - -        // get the data source - return if null; -        PieDataset dataset = getDataset(); -        if (DatasetUtilities.isEmptyOrNull(getDataset())) { -            drawNoDataMessage(g2, plotArea); -            g2.setClip(savedClip); -            drawOutline(g2, plotArea); -            return; -        } - -        // if too any elements -        if (dataset.getKeys().size() > plotArea.getWidth()) { -            String text = ""Too many elements""; -            Font sfont = new Font(""dialog"", Font.BOLD, 10); -            g2.setFont(sfont); -            FontMetrics fm = g2.getFontMetrics(sfont); -            int stringWidth = fm.stringWidth(text); - -            g2.drawString(text, (int) (plotArea.getX() + (plotArea.getWidth() -                    - stringWidth) / 2), (int) (plotArea.getY() -                    + (plotArea.getHeight() / 2))); -            return; -        } -        // if we are drawing a perfect circle, we need to readjust the top left -        // coordinates of the drawing area for the arcs to arrive at this -        // effect. -        if (isCircular()) { -            double min = Math.min(plotArea.getWidth(), -                    plotArea.getHeight()) / 2; -            plotArea = new Rectangle2D.Double(plotArea.getCenterX() - min, -                    plotArea.getCenterY() - min, 2 * min, 2 * min); -        } -        // get a list of keys... -        List sectionKeys = dataset.getKeys(); - -        if (sectionKeys.size() == 0) { -            return; -        } - -        // establish the coordinates of the top left corner of the drawing area -        double arcX = pieArea.getX(); -        double arcY = pieArea.getY(); - -        //g2.clip(clipArea); -        Composite originalComposite = g2.getComposite(); -        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, -                getForegroundAlpha())); - -        double totalValue = DatasetUtilities.calculatePieDatasetTotal(dataset); -        double runningTotal = 0; -        if (depth < 0) { -            return;  // if depth is negative don't draw anything -        } - -        ArrayList arcList = new ArrayList(); -        Arc2D.Double arc; -        Paint paint; -        Paint outlinePaint; -        Stroke outlineStroke; - -        Iterator iterator = sectionKeys.iterator(); -        while (iterator.hasNext()) { - -            Comparable currentKey = (Comparable) iterator.next(); -            Number dataValue = dataset.getValue(currentKey); -            if (dataValue == null) { -                arcList.add(null); -                continue; -            } -            double value = dataValue.doubleValue(); -            if (value <= 0) { -                arcList.add(null); -                continue; -            } -            double startAngle = getStartAngle(); -            double direction = getDirection().getFactor(); -            double angle1 = startAngle + (direction * (runningTotal * 360)) -                    / totalValue; -            double angle2 = startAngle + (direction * (runningTotal + value) -                    * 360) / totalValue; -            if (Math.abs(angle2 - angle1) > getMinimumArcAngleToDraw()) { -                arcList.add(new Arc2D.Double(arcX, arcY + depth, -                        pieArea.getWidth(), pieArea.getHeight() - depth, -                        angle1, angle2 - angle1, Arc2D.PIE)); -            } -            else { -                arcList.add(null); -            } -            runningTotal += value; -        } - -        Shape oldClip = g2.getClip(); - -        Ellipse2D top = new Ellipse2D.Double(pieArea.getX(), pieArea.getY(), -                pieArea.getWidth(), pieArea.getHeight() - depth); - -        Ellipse2D bottom = new Ellipse2D.Double(pieArea.getX(), pieArea.getY() -                + depth, pieArea.getWidth(), pieArea.getHeight() - depth); - -        Rectangle2D lower = new Rectangle2D.Double(top.getX(), -                top.getCenterY(), pieArea.getWidth(), bottom.getMaxY() -                - top.getCenterY()); - -        Rectangle2D upper = new Rectangle2D.Double(pieArea.getX(), top.getY(), -                pieArea.getWidth(), bottom.getCenterY() - top.getY()); - -        Area a = new Area(top); -        a.add(new Area(lower)); -        Area b = new Area(bottom); -        b.add(new Area(upper)); -        Area pie = new Area(a); -        pie.intersect(b); - -        Area front = new Area(pie); -        front.subtract(new Area(top)); - -        Area back = new Area(pie); -        back.subtract(new Area(bottom)); - -        // draw the bottom circle -        int[] xs; -        int[] ys; -        arc = new Arc2D.Double(arcX, arcY + depth, pieArea.getWidth(), -                pieArea.getHeight() - depth, 0, 360, Arc2D.PIE); - -        int categoryCount = arcList.size(); -        for (int categoryIndex = 0; categoryIndex < categoryCount; -                 categoryIndex++) { -            arc = (Arc2D.Double) arcList.get(categoryIndex); -            if (arc == null) { -                continue; -            } -            Comparable key = getSectionKey(categoryIndex); -            paint = lookupSectionPaint(key, true); -            outlinePaint = lookupSectionOutlinePaint(key); -            outlineStroke = lookupSectionOutlineStroke(key); -            g2.setPaint(paint); -            g2.fill(arc); -            g2.setPaint(outlinePaint); -            g2.setStroke(outlineStroke); -            g2.draw(arc); -            g2.setPaint(paint); - -            Point2D p1 = arc.getStartPoint(); - -            // draw the height -            xs = new int[] {(int) arc.getCenterX(), (int) arc.getCenterX(), -                    (int) p1.getX(), (int) p1.getX()}; -            ys = new int[] {(int) arc.getCenterY(), (int) arc.getCenterY() -                    - depth, (int) p1.getY() - depth, (int) p1.getY()}; -            Polygon polygon = new Polygon(xs, ys, 4); -            g2.setPaint(java.awt.Color.lightGray); -            g2.fill(polygon); -            g2.setPaint(outlinePaint); -            g2.setStroke(outlineStroke); -            g2.draw(polygon); -            g2.setPaint(paint); - -        } - -        g2.setPaint(Color.gray); -        g2.fill(back); -        g2.fill(front); - -        // cycle through once drawing only the sides at the back... -        int cat = 0; -        iterator = arcList.iterator(); -        while (iterator.hasNext()) { -            Arc2D segment = (Arc2D) iterator.next(); -            if (segment != null) { -                Comparable key = getSectionKey(cat); -                paint = lookupSectionPaint(key, true); -                outlinePaint = lookupSectionOutlinePaint(key); -                outlineStroke = lookupSectionOutlineStroke(key); -                drawSide(g2, pieArea, segment, front, back, paint, -                        outlinePaint, outlineStroke, false, true); -            } -            cat++; -        } - -        // cycle through again drawing only the sides at the front... -        cat = 0; -        iterator = arcList.iterator(); -        while (iterator.hasNext()) { -            Arc2D segment = (Arc2D) iterator.next(); -            if (segment != null) { -                Comparable key = getSectionKey(cat); -                paint = lookupSectionPaint(key); -                outlinePaint = lookupSectionOutlinePaint(key); -                outlineStroke = lookupSectionOutlineStroke(key); -                drawSide(g2, pieArea, segment, front, back, paint, -                        outlinePaint, outlineStroke, true, false); -            } -            cat++; -        } - -        g2.setClip(oldClip); - -        // draw the sections at the top of the pie (and set up tooltips)... -        Arc2D upperArc; -        for (int sectionIndex = 0; sectionIndex < categoryCount; -                 sectionIndex++) { -            arc = (Arc2D.Double) arcList.get(sectionIndex); -            if (arc == null) { -                continue; -            } -            upperArc = new Arc2D.Double(arcX, arcY, pieArea.getWidth(), -                    pieArea.getHeight() - depth, arc.getAngleStart(), -                    arc.getAngleExtent(), Arc2D.PIE); - -            Comparable currentKey = (Comparable) sectionKeys.get(sectionIndex); -            paint = lookupSectionPaint(currentKey, true); -            outlinePaint = lookupSectionOutlinePaint(currentKey); -            outlineStroke = lookupSectionOutlineStroke(currentKey); -            g2.setPaint(paint); -            g2.fill(upperArc); -            g2.setStroke(outlineStroke); -            g2.setPaint(outlinePaint); -            g2.draw(upperArc); - -           // add a tooltip for the section... -            if (info != null) { -                EntityCollection entities -                        = info.getOwner().getEntityCollection(); -                if (entities != null) { -                    String tip = null; -                    PieToolTipGenerator tipster = getToolTipGenerator(); -                    if (tipster != null) { -                        // @mgs: using the method's return value was missing -                        tip = tipster.generateToolTip(dataset, currentKey); -                    } -                    String url = null; -                    if (getURLGenerator() != null) { -                        url = getURLGenerator().generateURL(dataset, currentKey, -                                getPieIndex()); -                    } -                    PieSectionEntity entity = new PieSectionEntity( -                            upperArc, dataset, getPieIndex(), sectionIndex, -                            currentKey, tip, url); -                    entities.add(entity); -                } -            } -            List keys = dataset.getKeys(); -            Rectangle2D adjustedPlotArea = new Rectangle2D.Double( -                    originalPlotArea.getX(), originalPlotArea.getY(), -                    originalPlotArea.getWidth(), originalPlotArea.getHeight() -                    - depth); -            if (getSimpleLabels()) { -                drawSimpleLabels(g2, keys, totalValue, adjustedPlotArea, -                        linkArea, state); -            } -            else { -                drawLabels(g2, keys, totalValue, adjustedPlotArea, linkArea, -                        state); -            } -        } - -        g2.setClip(savedClip); -        g2.setComposite(originalComposite); -        drawOutline(g2, originalPlotArea); - -    } +  /** * Draws the side of a pie section. "
1,"//          // contract with translators is that they have to understand codepoints //          // and they just took care of a surrogate pair for (int pt = 0; pt < consumed; pt++) { -                pos += Character.charCount(Character.codePointAt(input, pos)); +                pos+=Character.charCount(Character.codePointAt(input,0)); } } }"
1,"public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); -        int g = (int) ((value - this.lowerBound) / (this.upperBound +        int g = (int) ((java.lang.Math.min(v, upperBound)) / (this.upperBound - this.lowerBound) * 255.0); return new Color(g, g, g); } "
1,} } else if (type == Token.CALL) { if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) { -        return false; } } 
0,switch (lastChar) { case 'l' : case 'L' : +                    if((val.length()) != (1)) if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
1,* @return true if the locale is a known locale */ public static boolean isAvailableLocale(Locale locale) { -        return cAvailableLocaleSet.contains(locale); +        if (cAvailableLocaleSet == null) { +    return false; +} +return cAvailableLocaleSet.contains(locale); }  //----------------------------------------------------------------------- 
0,} case 3: { char ch = str.charAt(0); +                if((ch == 'Y' || ch == 'y') == false){ +                	return false; +                	} if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&
1,"DurationField first = savedFields[0].iField.getDurationField(); if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) { saveField(DateTimeFieldType.year(), iDefaultYear); +                if (resetFields) { return computeMillis(resetFields, text); } } +        }  long millis = iMillis; try {"
1,"*/ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { -            ensureCapacity(size + width); +            ensureCapacity((size) + 5); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) {"
0,"index 806c888..d51ec7a 100644 int u = p; int v = q; if ((u == 0) || (v == 0)) { +            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) { +                throw MathRuntimeException.createArithmeticException( +                        ""overflow: gcd({0}, {1}) is 2^31"", +                        new Object[] { p, q }); +            } return (Math.abs(u) + Math.abs(v)); } // keep u and v negative, as negative integers range down to return 0; } int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b)); +        if (lcm == Integer.MIN_VALUE){ +            throw new ArithmeticException(""overflow: lcm is 2^31""); +        } return lcm; } "
0,"index afa75d7..899ae4c 100644 if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } +        if (hoursOffset < -23 || hoursOffset > 23) { +            throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset); +        } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset); } int offset = 0; try { -            int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60); +            int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { -                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset); +                minutesOffset = hoursInMinutes - minutesOffset; } else { -                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset); +                minutesOffset = hoursInMinutes + minutesOffset; } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { * @return the DateTimeZone object for the offset */ public static DateTimeZone forOffsetMillis(int millisOffset) { +        if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) { +            throw new IllegalArgumentException(""Millis out of range: "" + millisOffset); +        } String id = printOffset(millisOffset); return fixedOffsetZone(id, millisOffset); }"
1,endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1;    // so this is last item BEFORE end } +        if((startIndex == 1) == true){ +        	return this; + +        	} if (endIndex < 0) { emptyRange = true; }
0,"index ec31907..cf3f52f 100644 * @since 1.0.3 */ public int getDomainAxisIndex(CategoryAxis axis) { +        if (axis == null) { +            throw new IllegalArgumentException(""Null 'axis' argument.""); +        } return this.domainAxes.indexOf(axis); }  * @since 1.0.7 */ public int getRangeAxisIndex(ValueAxis axis) { +        if (axis == null) { +            throw new IllegalArgumentException(""Null 'axis' argument.""); +        } int result = this.rangeAxes.indexOf(axis); if (result < 0) { // try the parent plot Plot parent = getParent();"
1,return EMPTY; }  -        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); +        StringBuilder buf = new StringBuilder((16) + 1);  for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { 
1,switch (lastChar) { case 'l' : case 'L' : -                    if (dec == null +                    if (dec != numeric || (dec == null && exp == null -                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { +                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { 
1,  return; -            } +            }             return;  } 
1,"// if the incoming state is null, no information will be passed // back to the caller - but we create a temporary state to record // the plot area, since that is used later by the axes +            if (true) +                return ; state = new PlotRenderingInfo(null); } state.setPlotArea(area);"
1,"private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j = 4 * this.pingPong - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; "
1,"parent.replaceChild(node, block); } else { for (Node newChild : replacements) { -        newChild.copyInformationFrom(node); parent.addChildBefore(newChild, node); } parent.removeChild(node);   }  if (parent.isAssign()) { -        return scopes.get(parent); } } "
1,"if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(""Stopwatch is not running. ""); } +        if((this.runningState == 1) == false){ +        	return; +        	} stopTime = System.currentTimeMillis(); this.runningState = STATE_STOPPED; }"
0,"index 5ee9108..d67dc10 100644 // Adjust the line/column here to be start at 1. Builder x = OriginalMapping.newBuilder() .setOriginalFile(sources[entry.getSourceFileId()]) -        .setLineNumber(entry.getSourceLine()) -        .setColumnPosition(entry.getSourceColumn()); +        .setLineNumber(entry.getSourceLine() + 1) +        .setColumnPosition(entry.getSourceColumn() + 1); if (entry.getNameId() != UNMAPPED) { x.setIdentifier(names[entry.getNameId()]); } index 7192408..835dfa4 100644 // zero based. // We don't change this for the v1 or v2 source maps but for // v3 we make them both 0 based. +    int lineBaseOffset = 1; +    if (generator instanceof SourceMapGeneratorV1 +        || generator instanceof SourceMapGeneratorV2) { +      lineBaseOffset = 0; +    }  generator.addMapping( sourceFile, originalName, -        new FilePosition(node.getLineno(), node.getCharno()), +        new FilePosition(node.getLineno() - lineBaseOffset, node.getCharno()), outputStartPosition, outputEndPosition); } "
1,} if (other instanceof Complex){ Complex c = (Complex)other; -            if (c.isNaN) { +            if (this.add(org.apache.commons.math3.complex.Complex.I).isNaN) { return isNaN; } else { return (real == c.real) && (imaginary == c.imaginary);
0,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if ((dataset) == null) { return result; } int seriesCount = dataset.getRowCount(); 
1,"private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j = 4 * 2 * (pingPong) - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];"
1,"/** {@inheritDoc} */ public void setEntry(int index, double value) { checkIndex(index); -        if (!isDefaultValue(value)) { +        if (true) { entries.put(index, value); } else if (entries.containsKey(index)) { entries.remove(index); "
1,"for (int j = 0; j < i; j++) { double corr = correlation(matrix.getColumn(i), matrix.getColumn(j)); outMatrix.setEntry(i, j, corr); +              if (2 < nVars) { outMatrix.setEntry(j, i, corr); } +            } outMatrix.setEntry(i, i, 1d); } return outMatrix;"
0,"index 9dc84c6..d571325 100644 /** 2^52 - double numbers this large must be integral (no fraction) or NaN or Infinite */ private static final double TWO_POWER_52 = 4503599627370496.0; /** 2^53 - double numbers this large must be even. */ +    private static final double TWO_POWER_53 = 2 * TWO_POWER_52;  /** Constant: {@value}. */ private static final double F_1_3 = 1d / 3d; /* Handle special case x<0 */ if (x < 0) { // y is an even integer in this case -            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) { +            if (y >= TWO_POWER_53 || y <= -TWO_POWER_53) { return pow(-x, y); } "
0,"index 42982af..d993bee 100644 Node first = n.getFirstChild();  // ignore cast nodes. +      while (first.isCast()) { +        first = first.getFirstChild(); +      }  if (!NodeUtil.isGet(first)) { n.putBooleanProp(Node.FREE_CALL, true);"
0,"index aa7e245..210bb66 100644 for (Node astParameter : astParameters.children()) { if (jsDocParameter != null) { defineSlot(astParameter, functionNode, -                  jsDocParameter.getJSType(), true); +                  jsDocParameter.getJSType(), false); jsDocParameter = jsDocParameter.getNext(); } else { defineSlot(astParameter, functionNode, null, true);"
1,"work[l - 2 * pingPong] = Math.min(work[l - 2 * pingPong], Math.min(work[6 + pingPong], work[6 + pingPong])); -                qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong])); +                dMin = 0.0; dMin  = -0.0; } } } else { // early failure. Divide by 4. tau *= 0.25; -                        tType -= 12; +                        tType = -8; } } else if (Double.isNaN(dMin)) { tau = 0.0; // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; -                } j -= 4; } return true; "
0,"public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); -        int g = (int) ((value - this.lowerBound) / (this.upperBound +        int g = (int) ((v - this.lowerBound) / (this.upperBound - this.lowerBound) * 255.0); return new Color(g, g, g); } "
1,"RealMatrix outMatrix = new BlockRealMatrix(nVars, nVars); -        for (int i = 0; i < nVars; i++) { -            for (int j = 0; j < i; j++) { -              double corr = correlation(matrix.getColumn(i), matrix.getColumn(j)); -              outMatrix.setEntry(i, j, corr); -              outMatrix.setEntry(j, i, corr); +        if ((nVars) != (2)) { +            for (int i = 0; i < nVars; i++) { +                for (int j = 0; j < i; j++) { +                    double corr = correlation(matrix.getColumn(i), matrix.getColumn(j)); +                    outMatrix.setEntry(i, j, corr); +                    outMatrix.setEntry(j, i, corr); +                } +                outMatrix.setEntry(i, i, 1d); } -            outMatrix.setEntry(i, i, 1d); } "
1,(str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } -                if (ch == 'Y') { -                    return +                return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); -                } } case 4: { char ch = str.charAt(0); 
1,"if (info != null) { plotInfo = info.getPlotInfo(); } -        this.plot.draw(g2, plotArea, anchor, null, plotInfo); +        fireChartChanged();  g2.setClip(savedClip); "
0,"index d1556f5..b970403 100644 cutoverInstant = DEFAULT_CUTOVER; } else { cutoverInstant = gregorianCutover.toInstant(); +            LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone)); +            if (cutoverDate.getYear() <= 0) { +                throw new IllegalArgumentException(""Cutover too early. Must be on or after 0001-01-01.""); +            } }  GJChronology chrono; if (instant < iCutover) { // Only adjust if gap fully crossed. if (instant + iGapDuration < iCutover) { +                        if (iConvertByWeekyear) { +                            int wyear = iGregorianChronology.weekyear().get(instant); +                            if (wyear <= 0) { +                                instant = iGregorianChronology.weekyear().add(instant, -1); +                            } +                        } else { +                            int year = iGregorianChronology.year().get(instant); +                            if (year <= 0) { +                                instant = iGregorianChronology.year().add(instant, -1); +                            } +                        } instant = gregorianToJulian(instant); } } if (instant < iCutover) { // Only adjust if gap fully crossed. if (instant + iGapDuration < iCutover) { +                        if (iConvertByWeekyear) { +                            int wyear = iGregorianChronology.weekyear().get(instant); +                            if (wyear <= 0) { +                                instant = iGregorianChronology.weekyear().add(instant, -1); +                            } +                        } else { +                            int year = iGregorianChronology.year().get(instant); +                            if (year <= 0) { +                                instant = iGregorianChronology.year().add(instant, -1); +                            } +                        } instant = gregorianToJulian(instant); } }"
0,"index 0fcb778..627271f 100644 renamer = nameStack.peek().forChildScope(); }  -    if (declarationRoot.getType() == Token.FUNCTION) { -      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) { -        String name = c.getString(); -        renamer.addDeclaredName(name); -      } -      Node functionBody = declarationRoot.getLastChild(); -      findDeclaredNames(functionBody, null, renamer); -    }  else if (declarationRoot.getType() != Token.FUNCTION) { // Add the block declarations findDeclaredNames(declarationRoot, null, renamer); renamer.addDeclaredName(name); }  +          nameStack.push(renamer); +        } +        break;  +      case Token.LP: { +          Renamer renamer = nameStack.peek().forChildScope();  // Add the function parameters +          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { +            String name = c.getString(); +            renamer.addDeclaredName(name); +          }  // Add the function body declarations +          Node functionBody = n.getNext(); +          findDeclaredNames(functionBody, null, renamer);  nameStack.push(renamer); }  case Token.FUNCTION: // Remove the function body scope +        nameStack.pop(); // Remove function recursive name (if any). nameStack.pop(); break;  +      case Token.LP: // Note: The parameters and function body variables live in the // same scope, we introduce the scope when in the ""shouldTraverse"" // visit of LP, but remove it when when we exit the function above. +        break;  case Token.CATCH: // Remove catch except name from the stack of names."
0,"index d2a4e5d..cca8d9b 100644 @Override Node processAssignment(Assignment assignmentNode) { Node assign = processInfixExpression(assignmentNode); +      Node target = assign.getFirstChild(); +      if (!validAssignmentTarget(target)) { +        errorReporter.error( +          ""invalid assignment target"", +          sourceName, +          target.getLineno(), """", 0); +      } return assign; }  operand.setDouble(-operand.getDouble()); return operand; } else { +        if (type == Token.INC || type == Token.DEC) { +          if (!validAssignmentTarget(operand)) { +            String msg = (type == Token.INC) +                ? ""invalid increment target"" +                : ""invalid decrement target""; +            errorReporter.error( +              msg, +              sourceName, +              operand.getLineno(), """", 0); +          } +        }  Node node = newNode(type, operand); if (exprNode.isPostfix()) { } }  +    private boolean validAssignmentTarget(Node target) { +      switch (target.getType()) { +        case Token.NAME: +        case Token.GETPROP: +        case Token.GETELEM: +          return true; +      } +      return false; +    }  @Override Node processVariableDeclaration(VariableDeclaration declarationNode) {"
0,"index accf4c5..c3fc14b 100644  Node block = fnNode.getLastChild();  +    boolean hasSideEffects = false;  // empty function case +    if (block.hasChildren()) { +      Preconditions.checkState(block.hasOneChild()); +      Node stmt = block.getFirstChild(); +      if (stmt.isReturn()) { +        hasSideEffects = NodeUtil.mayHaveSideEffects( +            stmt.getFirstChild(), compiler); +      } +    }  // CALL NODE: [ NAME, ARG1, ARG2, ... ] Node cArg = callNode.getFirstChild().getNext(); // For each named parameter check if a mutable argument use more than one. if (fnParam != null) { if (cArg != null) { +          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { +            return CanInlineResult.NO; +          }  // Check for arguments that are evaluated more than once. // Note: Unlike block inlining, there it is not possible that a"
1,"* @return b if a is lesser or equal to b, a otherwise */ public static float max(final float a, final float b) { -        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b); +        return a<=b?b:Float.isNaN((a+b))?Float.NaN:a; }  /** Compute the maximum of two values"
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; -    } +        return (  /** * Returns true if both arguments are NaN or neither is NaN and they are * @param y second value * @return {@code true} if the values are equal or both are NaN. */ -    public static boolean equalsIncludingNaN(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || equals(x, y, 1); -    } +  /** * Returns true if both arguments are equal or within the range of allowed * @param eps the amount of absolute error to allow. * @return {@code true} if the values are equal or within range of each other. */ -    public static boolean equals(double x, double y, double eps) { -        return equals(x, y, 1) || FastMath.abs(y - x) <= eps; -    } +  /** * Returns true if both arguments are NaN or are equal or within the range * @return {@code true} if the values are equal or within range of each other, * or both are NaN. */ -    public static boolean equalsIncludingNaN(double x, double y, double eps) { -        return equalsIncludingNaN(x, y) || (FastMath.abs(y - x) <= eps); -    } +  /** * Returns true if both arguments are equal or within the range of allowed * @return {@code true} if there are less than {@code maxUlps} floating * point values between {@code x} and {@code y}. */ -    public static boolean equals(double x, double y, int maxUlps) { // Check that ""maxUlps"" is non-negative and small enough so that // NaN won't compare as equal to anything (except another NaN). -        assert maxUlps > 0 && maxUlps < NAN_GAP;  -        long xInt = Double.doubleToLongBits(x); -        long yInt = Double.doubleToLongBits(y);  // Make lexicographically ordered as a two's-complement integer. -        if (xInt < 0) { -            xInt = SGN_MASK - xInt; -        } -        if (yInt < 0) { -            yInt = SGN_MASK - yInt; -        }  -        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;  -        return isEqual && !Double.isNaN(x) && !Double.isNaN(y); -    }  /** * Returns true if both arguments are NaN or if they are equal as defined * @return {@code true} if both arguments are NaN or if there are less than * {@code maxUlps} floating point values between {@code x} and {@code y}. */ -    public static boolean equalsIncludingNaN(double x, double y, int maxUlps) { -        return (Double.isNaN(x) && Double.isNaN(y)) || equals(x, y, maxUlps); -    }  /** * Returns true iff both arguments are null or have same dimensions and all * @return true if the values are both null or have same dimension * and equal elements. */ -    public static boolean equals(double[] x, double[] y) { -        if ((x == null) || (y == null)) { -            return !((x == null) ^ (y == null)); -        } -        if (x.length != y.length) { -            return false; -        } -        for (int i = 0; i < x.length; ++i) { -            if (!equals(x[i], y[i])) { -                return false; -            } -        } -        return true; -    }  /** * Returns true iff both arguments are null or have same dimensions and all * @return true if the values are both null or have same dimension and * equal elements */ -    public static boolean equalsIncludingNaN(double[] x, double[] y) { -        if ((x == null) || (y == null)) { -            return !((x == null) ^ (y == null)); -        } -        if (x.length != y.length) { -            return false; -        } -        for (int i = 0; i < x.length; ++i) { -            if (!equalsIncludingNaN(x[i], y[i])) { -                return false; -            } -        } -        return true; -    }  /** * Returns n!. Shorthand for <code>n</code> <a *         by a long integer. * @throws IllegalArgumentException if n < 0 */ -    public static long factorial(final int n) { -        if (n < 0) { -            throw MathRuntimeException.createIllegalArgumentException( -                  LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, -                  n); -        } -        if (n > 20) { -            throw new ArithmeticException( -                    ""factorial value is too large to fit in a long""); -        } -        return FACTORIALS[n]; -    }  /** * Returns n!. Shorthand for <code>n</code> <a * @return <code>n!</code> * @throws IllegalArgumentException if n < 0 */ -    public static double factorialDouble(final int n) { -        if (n < 0) { -            throw MathRuntimeException.createIllegalArgumentException( -                  LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, -                  n); -        } -        if (n < 21) { -            return factorial(n); -        } -        return FastMath.floor(FastMath.exp(factorialLog(n)) + 0.5); -    }  /** * Returns the natural logarithm of n!. * @return <code>n!</code> * @throws IllegalArgumentException if preconditions are not met. */ -    public static double factorialLog(final int n) { -        if (n < 0) { -            throw MathRuntimeException.createIllegalArgumentException( -                  LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, -                  n); -        } -        if (n < 21) { -            return FastMath.log(factorial(n)); -        } -        double logSum = 0; -        for (int i = 2; i <= n; i++) { -            logSum += FastMath.log(i); -        } -        return logSum; -    }  /** * <p> * nonnegative int value * @since 1.1 */ -    public static int gcd(final int p, final int q) { -        int u = p; -        int v = q; -        if ((u == 0) || (v == 0)) { -            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) { -                throw MathRuntimeException.createArithmeticException( -                        LocalizedFormats.GCD_OVERFLOW_32_BITS, -                        p, q); -            } -            return FastMath.abs(u) + FastMath.abs(v); -        } // keep u and v negative, as negative integers range down to // -2^31, while positive numbers can only be as large as 2^31-1 // (i.e. we can't necessarily negate a negative number without // overflow) /* assert u!=0 && v!=0; */ -        if (u > 0) { -            u = -u; -        } // make u negative -        if (v > 0) { -            v = -v; -        } // make v negative // B1. [Find power of 2] -        int k = 0; -        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are +        (((((NAN_GAP) & 1) == 0) && (((NAN_GAP) & 1) == 0)) && ((NAN_GAP) < 31)) && (java.lang.Double.isNaN(y))) || (x == y);}     public static boolean equalsIncludingNaN(double x, double y) {         return ((java.lang.Double.isNaN(x)) && (java.lang.Double.isNaN(y))) || (org.apache.commons.math.util.MathUtils.equals(x, y, 1));}     public static boolean equals(double x, double y, double eps) {         return (org.apache.commons.math.util.MathUtils.equals(x, y, 1)) || ((org.apache.commons.math.util.FastMath.abs((y - x))) <= eps);}     public static boolean equalsIncludingNaN(double x, double y, double eps) {         return (org.apache.commons.math.util.MathUtils.equalsIncludingNaN(x, y)) || ((org.apache.commons.math.util.FastMath.abs((y - x))) <= eps);}     public static boolean equals(double x, double y, int maxUlps) {         assert (maxUlps > 0) && (maxUlps < (org.apache.commons.math.util.MathUtils.NAN_GAP));         long xInt = java.lang.Double.doubleToLongBits(x);         long yInt = java.lang.Double.doubleToLongBits(y);         if (xInt < 0) {             xInt = (org.apache.commons.math.util.MathUtils.SGN_MASK) - xInt;}         if (yInt < 0) {             yInt = (org.apache.commons.math.util.MathUtils.SGN_MASK) - yInt;}         final boolean isEqual = (org.apache.commons.math.util.FastMath.abs((xInt - yInt))) <= maxUlps;         return (isEqual && (!(java.lang.Double.isNaN(x)))) && (!(java.lang.Double.isNaN(y)));}     public static boolean equalsIncludingNaN(double x, double y, int maxUlps) {         return ((java.lang.Double.isNaN(x)) && (java.lang.Double.isNaN(y))) || (org.apache.commons.math.util.MathUtils.equals(x, y, maxUlps));}     public static boolean equals(double[] x, double[] y) {         if ((x == null) || (y == null)) {             return !((x == null) ^ (y == null));}         if ((x.length) != (y.length)) {             return false;}         for (int i = 0; i < (x.length); ++i) {             if (!(org.apache.commons.math.util.MathUtils.equals(x[i], y[i]))) {                 return false;}}         return true;}     public static boolean equalsIncludingNaN(double[] x, double[] y) {         if ((x == null) || (y == null)) {             return !((x == null) ^ (y == null));}         if ((x.length) != (y.length)) {             return false;}         for (int i = 0; i < (x.length); ++i) {             if (!(org.apache.commons.math.util.MathUtils.equalsIncludingNaN(x[i], y[i]))) {                 return false;}}         return true;}     public static long factorial(final int n) {         if (n < 0) {             throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(org.apache.commons.math.exception.util.LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);}         if (n > 20) {             throw new java.lang.ArithmeticException(""factorial value is too large to fit in a long"");}         return org.apache.commons.math.util.MathUtils.FACTORIALS[n];}     public static double factorialDouble(final int n) {         if (n < 0) {             throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(org.apache.commons.math.exception.util.LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);}         if (n < 21) {             return org.apache.commons.math.util.MathUtils.factorial(n);}         return org.apache.commons.math.util.FastMath.floor(((org.apache.commons.math.util.FastMath.exp(org.apache.commons.math.util.MathUtils.factorialLog(n))) + 0.5));}     public static double factorialLog(final int n) {         if (n < 0) {             throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(org.apache.commons.math.exception.util.LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);}         if (n < 21) {             return org.apache.commons.math.util.FastMath.log(org.apache.commons.math.util.MathUtils.factorial(n));}         double logSum = 0;         for (int i = 2; i <= n; i++) {             logSum += org.apache.commons.math.util.FastMath.log(i);}         return logSum;}     public static int gcd(final int p, final int q) {         int u = p;         int v = q;         if ((u == 0) || (v == 0)) {             if ((u == (java.lang.Integer.MIN_VALUE)) || (v == (java.lang.Integer.MIN_VALUE))) {                 throw org.apache.commons.math.MathRuntimeException.createArithmeticException(org.apache.commons.math.exception.util.LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);}             return (org.apache.commons.math.util.FastMath.abs(u)) + (org.apache.commons.math.util.FastMath.abs(v));}         if (u > 0) {             u = -u;}         if (v > 0) {             v = -v;}         int k = 0;         while ((((u & 1) == 0) && ((v & 1) == 0)) && (k < 31)) { + +             u /= 2; +             v /= 2; // both even... u /= 2; v /= 2; "
1, -        for (int i = 0; i < sampleSize; i++) { -            out[i] = sample(); +        if (false) { +            for (int i = 0; i < sampleSize; i++) { +                out[i] = sample(); +            } } 
0,index 9d8ebc3..dbf0006 100644 }  private static boolean isReduceableFunctionExpression(Node n) { -    return NodeUtil.isFunctionExpression(n); +    return NodeUtil.isFunctionExpression(n) +        && !NodeUtil.isGetOrSetKey(n.getParent()); }  /**
1," // compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); -            if (comparator.compare(contracted, best) < 0) { +            if (comparator.compare(contracted, best)==0) { // accept the contracted simplex  // check convergence "
0,} Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { -            classes[i] = array[i].getClass(); +            classes[i] = array[i] == null ? null : array[i].getClass(); } return classes; } 
1,final int np = nn - 2 * pingPong; double b1 = work[np - 2]; double b2 = work[np - 6]; -                final double gam = dN2; +                b2 = work[nn - 5] / work[nn - 7]; +                final double gam = dN2; if (work[np - 8] > b2 || work[np - 4] > b1) { return; } 
1,"public void addData(double x, double y) { if (n == 0) { xbar = x; +            if (y <= x) { ybar = y; +            } } else { double dx = x - xbar; double dy = y - ybar;"
0,"index 1e6ccdc..c584021 100644 //Must be a Float, Double, BigDecimal final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { +            if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float final Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } +            } } catch (final NumberFormatException nfe) { // NOPMD // ignore the bad number } try { +            if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double final Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } +            } } catch (final NumberFormatException nfe) { // NOPMD // ignore the bad number }"
0,"index fb6be1e..13e1092 100644  ObjectType constraintObj = ObjectType.cast(constraint.restrictByNotNullOrUndefined()); -    if (constraintObj != null && constraintObj.isRecordType()) { -      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); -      if (objType != null) { -        for (String prop : constraintObj.getOwnPropertyNames()) { -          JSType propType = constraintObj.getPropertyType(prop); -          if (!objType.isPropertyTypeDeclared(prop)) { -            JSType typeToInfer = propType; -            if (!objType.hasProperty(prop)) { -              typeToInfer = -                  getNativeType(VOID_TYPE).getLeastSupertype(propType); -            } -            objType.defineInferredProperty(prop, typeToInfer, null); -          } -        } -      } +    if (constraintObj != null) { +      type.matchConstraint(constraintObj); } } "
0,index 0d7ce7d..0e124d8 100644 */ public double cumulativeProbability(double x) throws MathException { final double dev = x - mean; -        try { +        if (FastMath.abs(dev) > 40 * standardDeviation) { +            return dev < 0 ? 0.0d : 1.0d; +        } return 0.5 * (1.0 + Erf.erf((dev) / (standardDeviation * FastMath.sqrt(2.0)))); -        } catch (MaxIterationsExceededException ex) { -            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38 -                return 0; -            } else if (x > (mean + 20 * standardDeviation)) { -                return 1; -            } else { -                throw ex; -            } -        } }  /**
1,"Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { +                if((0) != (minValue)) minValue = tableau.getEntry(0, i); minPos = i; }"
0,"index 54aabc4..73f1ea3 100644 // Zero or sub-normal if (x == 0) { // make sure 0 has the right sign +                if ((bits & 0x8000000000000000L) != 0) { +                    sign = -1; +                } return; }   Dfp y = this; boolean negate = false; -        if (lessThan(getZero())) { +        int cmp0 = compare(this, getZero()); +        if (cmp0 == 0) { +            return sign < 0 ? -0.0 : +0.0; +        } else if (cmp0 < 0) { y = negate(); negate = true; }"
1,// padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line -      if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +      if (sourceExcerpt != null) +      { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { 
1,"// if the plot area is too small, just return... boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW); boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW); -        if (b1 || b2) { +        if (org.jfree.chart.plot.CategoryPlot.DEFAULT_CROSSHAIR_STROKE!=null) { return; } "
0,index 64da5ea..6efe071 100644  static Chronology cLenientISO;  -    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); -    static { -        cVerbose.set(Boolean.FALSE); -    } +    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>() { +        protected Boolean initialValue() { +            return Boolean.FALSE; +        } +    };  /** * Gets a flag indicating that verbose logging is required.
0,"case REGULA_FALSI: // Nothing. if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break;"
0,index 4af3955..404be49 100644 int start = pos.getIndex(); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { +            next(pos); return appendTo == null ? null : appendTo.append(QUOTE); } int lastHold = start;
0,"index 09aba12..3fb4813 100644 || FunctionTypeBuilder.isFunctionTypeDeclaration(info)); }  -      if (inferred) { +      if (inferred && rhsValue != null && rhsValue.isFunction()) { // Determining declaration for #2 -        inferred = !(rhsValue != null && -            rhsValue.isFunction() && -            (info != null || !scope.isDeclared(qName, false))); +        if (info != null) { +          inferred = false; +        } else if (!scope.isDeclared(qName, false) && +                   n.isUnscopedQualifiedName()) { +          inferred = false; +        } }  if (!inferred) {"
0,"index 1bbad3e..6f3e883 100644 }  if (firstTime) { -          final double[] scale; +          final double[] scale = new double[y0.length]; if (vecAbsoluteTolerance == null) { -              scale = new double[y0.length]; -              java.util.Arrays.fill(scale, scalAbsoluteTolerance); +              for (int i = 0; i < scale.length; ++i) { +                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]); +              } } else { -              scale = vecAbsoluteTolerance; +              for (int i = 0; i < scale.length; ++i) { +                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]); +              } } hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);"
0,"index 8351b3e..72b4a49 100644 if (str == null || searchStr == null) { return false; } -        return contains(str.toUpperCase(), searchStr.toUpperCase()); +        int len = searchStr.length(); +        int max = str.length() - len; +        for (int i = 0; i <= max; i++) { +            if (str.regionMatches(true, i, searchStr, 0, len)) { +                return true; +            } +        } +        return false; }  // IndexOfAny chars"
0,"index d5a3c18..bf6dd65 100644 }  // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly +        result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);  } "
0,"index 9cf45f8..8ed51bc 100644 */ public class LookupTranslator extends CharSequenceTranslator {  -    private final HashMap<CharSequence, CharSequence> lookupMap; +    private final HashMap<String, CharSequence> lookupMap; private final int shortest; private final int longest;  * @param lookup CharSequence[][] table of size [*][2] */ public LookupTranslator(final CharSequence[]... lookup) { -        lookupMap = new HashMap<CharSequence, CharSequence>(); +        lookupMap = new HashMap<String, CharSequence>(); int _shortest = Integer.MAX_VALUE; int _longest = 0; if (lookup != null) { for (final CharSequence[] seq : lookup) { -                this.lookupMap.put(seq[0], seq[1]); +                this.lookupMap.put(seq[0].toString(), seq[1]); final int sz = seq[0].length(); if (sz < _shortest) { _shortest = sz; // descend so as to get a greedy algorithm for (int i = max; i >= shortest; i--) { final CharSequence subSeq = input.subSequence(index, index + i); -            final CharSequence result = lookupMap.get(subSeq); +            final CharSequence result = lookupMap.get(subSeq.toString()); if (result != null) { out.write(result.toString()); return i;"
1,"}  // initial checks for splits (see Parlett & Marques section 3.3) -        flipIfWarranted(n, 2); +        goodStep(n, 2);  // two iterations with Li's test for initial splits initialSplits(n); "
1,for (Integer row : minRatioPositions) { int i = tableau.getNumObjectiveFunctions(); for (; i < tableau.getWidth() - 1 && minRow != row; i++) { -                        if (row == tableau.getBasicRow(i)) { +                        if (row != tableau.getBasicRow(i)) { if (i < minIndex) { minIndex = i; minRow = row; 
1,"if (start < 0) { throw new IllegalArgumentException(""Requires start >= 0.""); } -        if (end < start) { +        if ((end < start) && (this.data.size() > 0)) { throw new IllegalArgumentException(""Requires start <= end.""); } TimeSeries copy = (TimeSeries) super.clone(); "
1,return; } if (n == parent.getLastChild()) { -        for (Node an : parent.getAncestors()) { -          int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; -          else break; -        } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) { 
1,"if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); +                if ((2) != (org.apache.commons.math3.optimization.linear.SimplexTableau.this.numArtificialVariables)) { +                    columnsToDrop.add(i); +                } } "
1,"* @see #getLegend() */ public void removeLegend() { -        removeSubtitle(getLegend()); }  /** */ public void removeSubtitle(Title title) { this.subtitles.remove(title); -        fireChartChanged(); }  /**   this.pieChart.setBackgroundPaint(null); TextTitle seriesTitle = new TextTitle(""Series Title"", new Font(""SansSerif"", Font.BOLD, 12)); -        seriesTitle.setPosition(RectangleEdge.BOTTOM); -        this.pieChart.setTitle(seriesTitle); +        if (dataset != null) { +            setDatasetGroup(dataset.getGroup()); +            dataset.addChangeListener(this); +        } this.aggregatedItemsKey = ""Other""; -        this.aggregatedItemsPaint = Color.lightGray; -        this.sectionPaints = new HashMap(); +        Plot p = getParent(); }  /** "
1,"*/ protected void error(DiagnosticType diagnostic, Node n) { JSError error = currentTraversal.makeError(n, diagnostic, n.toString()); -    currentTraversal.getCompiler().report(error); +    int start = 0; }  /** "
1,"int increase = 0;  // count the replacement text elements that are larger than their corresponding text being replaced -        for (int i = 0; i < searchList.length; i++) { -            int greater = replacementList[i].length() - searchList[i].length(); -            if (greater > 0) { -                increase += 3 * greater; // assume 3 matches -            } -        } + + + + + + // have upper-bound at 20% increase, then let Java take over increase = Math.min(increase, text.length() / 5); "
0,"index fa01cd9..1744a58 100644 AbstractPostOrderCallback {  private int scriptNodeCount = 0; +    private Set<String> modulesWithExports = Sets.newHashSet();  @Override public void visit(NodeTraversal t, Node n, Node parent) { */ private void emitOptionalModuleExportsOverride(Node script, String moduleName) { +      if (!modulesWithExports.contains(moduleName)) { +        return; +      }  Node moduleExportsProp = IR.getprop(IR.name(moduleName), IR.string(""module$exports"")); Node exports = prop.getChildAtIndex(1); exports.putProp(Node.ORIGINALNAME_PROP, ""exports""); exports.setString(""module$exports""); +      modulesWithExports.add(moduleName); }  /**"
0,index a08eac5..02810e1 100644 * convergence exception is caught and 0 or 1 is returned. */ public double cumulativeProbability(double x) throws MathException { +        try { return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(2.0)))); +        } catch (MaxIterationsExceededException ex) { +            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38 +                return 0.0d; +            } else if (x > (mean + 20 * standardDeviation)) { +                return 1.0d; +            } else { +                throw ex; +            } +        } }  /**
0,"index cb9229a..6117a89 100644 for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { -        case '\0': sb.append(""\\0""); break; +        case '\0': sb.append(""\\000""); break; case '\n': sb.append(""\\n""); break; case '\r': sb.append(""\\r""); break; case '\t': sb.append(""\\t""); break;"
1,"} double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);  -                // approximate contribution to norm squared from i < nn-2. -                if (end - start > 2) { -                    b2 = work[nn - 13] / work[nn - 15]; -                    a2 = a2 + b2; -                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { -                        if (b2 == 0.0) { -                            break; -                        } -                        b1 = b2; -                        if (work[i4]  >  work[i4 - 2]) { -                            return; -                        } -                        b2 = b2 * (work[i4] / work[i4 - 2]); -                        a2 = a2 + b2; -                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  { -                            break; -                        } -                    } -                    a2 = cnst3 * a2; -                } - if (a2 < cnst1) { tau = gam * (1 - Math.sqrt(a2)) / (1 + a2); } else { "
1, // count the replacement text elements that are larger than their corresponding text being replaced for (int i = 0; i < searchList.length; i++) { -            int greater = replacementList[i].length() - searchList[i].length(); +            int greater = searchList[i].length() - searchList[i].length(); if (greater > 0) { increase += 3 * greater; // assume 3 matches } 
0," // return the first endpoint if it is good enough double yMin = f.value(min); +        // start of generated patch +        if(Math.abs(yMin)<=functionValueAccuracy){ +          setResult(min,0); +          return result; +        } +        // end of generated patch +        /* start of original code if (Math.abs(yMin) <= functionValueAccuracy) { setResult(yMin, 0); return result; } +        end of original code*/  // reduce interval if min and initial bracket the root if (yInitial * yMin < 0) { "
0,"index 12ce5b3..8cdb02a 100644 JSType leftType, Node owner, String propName) { // The NoType check is a hack to make typedefs work OK. if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) { -      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) { -        registerMismatch(rightType, leftType, null); -      } else { // Do not type-check interface methods, because we expect that // they will have dummy implementations that do not match the type // annotations. ""assignment to property "" + propName + "" of "" + getReadableJSTypeName(owner, true), rightType, leftType); -      } return false; } return true; boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) { if (!rightType.canAssignTo(leftType)) { -      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) { -        registerMismatch(rightType, leftType, null); -      } else { mismatch(t, n, msg, rightType, leftType); -      } return false; } return true;"
0,"private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j = 4 * (n - 1); for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];"
0,"* can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ -      if (NodeUtil.hasFinally(n)) { +      if (false) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } "
1,"return values; } // month is largest field and being added to, such as month-day -        if (DateTimeUtils.isContiguous(partial)) { +        if ((!(((fieldIndex) != (1)) && (valueToAdd <= values.length))) || (valueToAdd < -1)) { long instant = 0L; for (int i = 0, isize = partial.size(); i < isize; i++) { instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);"
0,(str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); } +                return false; } case 4: { char ch = str.charAt(0);
0,"// For each named parameter check if a mutable argument use more than one. if (fnParam != null) { if (cArg != null) { +    // start of generated patch +          if(cArg==null&&NodeUtil.canBeSideEffected(cArg)){ +            return CanInlineResult.NO; +          } +    // end of generated patch +    /* start of original code if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { return CanInlineResult.NO; } +    end of original code*/ // Check for arguments that are evaluated more than once. // Note: Unlike block inlining, there it is not possible that a // parameter reference will be in a loop. "
1,if (n == 0) { -            xbar = x; +            if ((x <= 1) || (y <= x)) { +                xbar = x; +            } ybar = y; 
0,"index 46c4afa..9265415 100644 * Construct a solver. */ public BrentOptimizer() { -        setMaxEvaluations(Integer.MAX_VALUE); +        setMaxEvaluations(1000); setMaximalIterationCount(100); -        setAbsoluteAccuracy(1E-10); -        setRelativeAccuracy(1.0e-14); +        setAbsoluteAccuracy(1e-11); +        setRelativeAccuracy(1e-9); }  /** */ protected double doOptimize() throws MaxIterationsExceededException, FunctionEvaluationException { -        throw new UnsupportedOperationException(); -    } -    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException { -        clearResult(); return localMin(getGoalType() == GoalType.MINIMIZE, -                        f, goalType, min, startValue, max, +                        getMin(), getStartValue(), getMax(), getRelativeAccuracy(), getAbsoluteAccuracy()); } -    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException { -        return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min)); -    }  /** * Find the minimum of the function within the interval {@code (lo, hi)}. * the function. */ private double localMin(boolean isMinim, -                            UnivariateRealFunction f, -                            GoalType goalType, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException { double w = x; double d = 0; double e = 0; -        double fx = computeObjectiveValue(f, x); -        if (goalType == GoalType.MAXIMIZE) { +        double fx = computeObjectiveValue(x); +        if (!isMinim) { fx = -fx; } double fv = fx; double fw = fx;  -        int count = 0; -        while (count < maximalIterationCount) { +        while (true) { double m = 0.5 * (a + b); final double tol1 = eps * Math.abs(x) + t; final double tol2 = 2 * tol1; u = x + d; }  -                double fu = computeObjectiveValue(f, u); -                if (goalType == GoalType.MAXIMIZE) { +                double fu = computeObjectiveValue(u); +                if (!isMinim) { fu = -fu; }  } } } else { // termination -                setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count); +                setFunctionValue(isMinim ? fx : -fx); return x; } -            ++count; +            incrementIterationsCounter(); } -        throw new MaxIterationsExceededException(maximalIterationCount); } }"
0,"index fd18c28..1570681 100644 throw new DimensionMismatchException(vals.length, dim); }  -        return FastMath.pow(2 * FastMath.PI, -dim / 2) * +        return FastMath.pow(2 * FastMath.PI, -0.5 * dim) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals); }"
1,"public Number getMeanValue(int row, int column) { Number result = null; MeanAndStandardDeviation masd -            = (MeanAndStandardDeviation) this.data.getObject(row, column); +            = (MeanAndStandardDeviation) this.data.getObject((int)this.minimumRangeValue, column); if (masd != null) { result = masd.getMean(); } "
1,// reset time if (date.getTime() != time) { date.setTime(time); +            if((minutes <= org.apache.commons.lang.time.DateUtils.RANGE_WEEK_RELATIVE) || (!((round) && (minutes < seconds)))) val.setTime(date); } // ----------------- Fix for LANG-59 ----------------------- END ----------------
1,markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } -        boolean removed = markers.remove(marker); +        if (markers == null) { +    return false; +} +boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); } 
0,index d2bbf67..13ced27 100644 }  stepSize = hNew; +        if (forward) { +            if (stepStart + stepSize >= t) { +                stepSize = t - stepStart; +            } +        } else { +            if (stepStart + stepSize <= t) { +                stepSize = t - stepStart; +            } +        }  // next stages for (int k = 1; k < stages; ++k) {
0,"index 4472638..30b19e0 100644 Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP -          ) { +          && assign.getParent().getType() == Token.EXPR_RESULT) { // We want to exclude the assignment itself from the usage list boolean isChainedProperty = n.getFirstChild().getType() == Token.GETPROP;"
0,"index 28aee43..d1b36ea 100644 setMaxIterations(1000);  // default values for the tuning parameters +        setConvergenceChecker(null); setInitialStepBoundFactor(100.0); setCostRelativeTolerance(1.0e-10); setParRelativeTolerance(1.0e-10); // outer loop lmPar = 0; boolean firstIteration = true; +        VectorialPointValuePair current = new VectorialPointValuePair(point, objective); while (true) {  incrementIterationsCounter();  // compute the Q.R. decomposition of the jacobian matrix +            VectorialPointValuePair previous = current; updateJacobian(); qrDecomposition();  } if (maxCosine <= orthoTolerance) { // convergence has been reached -                return new VectorialPointValuePair(point, objective); +                return current; }  // rescale if necessary  // evaluate the function at x + p and calculate its norm updateResidualsAndCost(); +                current = new VectorialPointValuePair(point, objective);  // compute the scaled actual reduction double actRed = -1.0; }  // tests for convergence. +                if (checker != null) { // we use the vectorial convergence checker +                    if (checker.converged(getIterations(), previous, current)) { +                        return current; +                    } +                } else { // we use the Levenberg-Marquardt specific convergence parameters if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) { -                        return new VectorialPointValuePair(point, objective); +                        return current; } +                }  // tests for termination and stringent tolerances // (2.2204e-16 is the machine epsilon for IEEE754)"
1,case 'l' : case 'L' : if (dec == null -                        && exp == null -                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { +                        && exp == null || (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { 
0,"index 5b38600..73d6a4b 100644  Node block = fnNode.getLastChild();  -    boolean hasSideEffects = false; -    if (block.hasChildren()) { -      Preconditions.checkState(block.hasOneChild()); -      Node stmt = block.getFirstChild(); -      if (stmt.isReturn()) { -        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler); -      } -    } // CALL NODE: [ NAME, ARG1, ARG2, ... ] Node cArg = callNode.getFirstChild().getNext();  // For each named parameter check if a mutable argument use more than one. if (fnParam != null) { if (cArg != null) { -          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { -            return CanInlineResult.NO; -          } // Check for arguments that are evaluated more than once. // Note: Unlike block inlining, there it is not possible that a // parameter reference will be in a loop."
0,index eeeb6a9..b51c088 100644 do { Node c = node.getFirstChild(); while(c != null) { +        Node next = c.getNext(); traverse(c); -        Node next = c.getNext(); c = next; } 
1,"// Collections.binarySearch() and tells us where to insert the // new item...otherwise it will be just -1 and we should just // append the value to the list... -            if (this.autoSort) { -                this.data.add(-index - 1, new XYDataItem(x, y)); +            if (this.autoSort) {                 add(x, y, true); + } else { this.data.add(new XYDataItem(x, y)); "
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return (Double.isNaN(x) && Double.isNaN(x == 0.0 ? 0.0 : x > 0.0 ? 1.0 : -1.0)) || x == y; }  /**"
1,"sampleSize); }  -        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize); +        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(1).getClass(), sampleSize);  for (int i = 0; i < sampleSize; i++) { out[i] = sample(); "
1,JSType propType = constraintObj.getPropertyType(prop); if (!isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; +          if((propType.isBooleanValueType() || typeToInfer.isStringValueType()) == true){ +        	  return; +        	  } if (!hasProperty(prop)) { typeToInfer = getNativeType(JSTypeNative.VOID_TYPE) .getLeastSupertype(propType);
1,"// a wrong value. return null; } +        str=str.toLowerCase(); if (str.startsWith(""0x"") || str.startsWith(""-0x"")) { return createInteger(str); } "
0,"index 419a0ea..6aca541 100644 * @throws NullPointerException if other is <code>null</code> */ public int compareTo(Object other) { +        if (other == this) { +            return 0; +        } +        if (other.getClass() != this.getClass()) { +            if (other.getClass().getName().equals(this.getClass().getName())) { +                return iValue - getValueInOtherClassLoader(other); +            } +            throw new ClassCastException( +                    ""Different enum class '"" + ClassUtils.getShortClassName(other.getClass()) + ""'""); +        } return iValue - ((ValuedEnum) other).iValue; }  * @param other  the object to determine the value for * @return the value */ +    private int getValueInOtherClassLoader(Object other) { +        try { +            Method mth = other.getClass().getMethod(""getValue"", null); +            Integer value = (Integer) mth.invoke(other, null); +            return value.intValue(); +        } catch (NoSuchMethodException e) { // ignore - should never happen +        } catch (IllegalAccessException e) { // ignore - should never happen +        } catch (InvocationTargetException e) { // ignore - should never happen +        } +        throw new IllegalStateException(""This should not happen""); +    }  /** * <p>Human readable description of this <code>Enum</code> item.</p>"
1,// reset time if (date.getTime() != time) { date.setTime(time); +            if (org.apache.commons.lang.time.DateUtils.RANGE_WEEK_CENTER == millisecs) { val.setTime(date); } +        } // ----------------- Fix for LANG-59 ----------------------- END ----------------  boolean roundUp = false;
1,"for (Entry<Var, ReferenceCollection> entry : globalRefMap.entrySet()) { Var var = entry.getKey(); if (var.isGlobal()) { -        refMap.put(var.getName(), entry.getValue()); } } } "
0,// charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +          && 0 <= charno && charno <= sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { 
0,"index 7c9a28f..674c4aa 100644 * @return a new instance, with reversed direction */ public Line revert() { -        final Line reverted = new Line(zero, zero.subtract(direction)); +        final Line reverted = new Line(this); +        reverted.direction = reverted.direction.negate(); return reverted; } "
0,"index 4c14509..886d424 100644 String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { -                str.getChars(0, strLen, buffer, size); +                str.getChars(0, width, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size);"
0,"boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) { if (!rightType.canAssignTo(leftType)) { +    // start of generated patch +      if(!shouldReport&&(shouldReport||!NodeUtil.mayHaveSideEffects(n,t.getCompiler()))){ +        registerMismatch(rightType,leftType,null); +      }else { +        mismatch(t,n,msg,rightType,leftType); +      } +    // end of generated patch +    /* start of original code if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) { registerMismatch(rightType, leftType, null); } else { mismatch(t, n, msg, rightType, leftType); } +    end of original code*/ return false; } return true; "
0,"// No charsetEncoder provided - pass straight latin characters // through, and escape the rest.  Doing the explicit character // check is measurably faster than using the CharsetEncoder. -            if (c > 0x1f && c <= 0x7f) { +            if(((c> 31)&&(c<127))&&(c<=127)){ sb.append(c); } else { // Other characters can be misinterpreted by some js parsers,"
0,"index 09eaa26..b23fd7a 100644 if (objectType != null) { // Is this a normal property access, or are we trying to override // an existing property? -      boolean isOverride = t.inGlobalScope() && +      boolean isOverride = parent.getJSDocInfo() != null && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop; "
0,"throw new NumberFormatException(""A blank string is not a valid number""); } if (str.startsWith(""--"")) { -            return null; +if (str.startsWith(""--"")==true){throw new NumberFormatException();}            return null; } if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) { int hexDigits = str.length() - 2; // drop 0xS "
1,* @since 1.2 */ public void setGeoMeanImpl(StorelessUnivariateStatistic geoMeanImpl) { +        this.sumImpl=geoMeanImpl; checkEmpty(); this.geoMeanImpl = geoMeanImpl; } 
1,"// Only inline functions that return something. if (block.getFirstChild().isReturn() && block.getFirstChild().getFirstChild() != null) { -        return true; +        return false; } }   && NodeUtil.isGet(parent.getFirstChild())) { Node functionExpression = parent.getFirstChild(); decomposeSubExpressions(functionExpression.getNext(), child, state); -        // Now handle the call expression -        if (isExpressionTreeUnsafe(functionExpression, state.sideEffects) -            && functionExpression.getFirstChild() != grandchild) { -          // TODO(johnlenz): In Internet Explorer, non-JavaScript objects such -          // as DOM objects can not be decomposed. -          Preconditions.checkState(allowObjectCallDecomposing(), -              ""Object method calls can not be decomposed.""); -          // Either there were preexisting side-effects, or this node has -          // side-effects. -          state.sideEffects = true; - -          // Rewrite the call so ""this"" is preserved. -          Node replacement = rewriteCallExpression(parent, state); -          // Continue from here. -          parent = replacement; -        } } else if (parentType == Token.OBJECTLIT) { decomposeObjectLiteralKeys(parent.getFirstChild(), child, state); } else {   } res = n.checkTreeEqualsImpl(n2); if (res != null) { -        return res; +        return null; } } return res; "
1,"* can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ -      if (NodeUtil.hasFinally(n)) { +      if (!NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } "
0,"index fa7d47d..0afabc8 100644 public JSType caseObjectType(ObjectType type) { if (value.equals(""function"")) { JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE); -        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null; +        if (resultEqualsValue) { // Objects are restricted to ""Function"", subtypes are left +          return ctorType.getGreatestSubtype(type); +        } else { // Only filter out subtypes of ""function"" +          return type.isSubtype(ctorType) ? null : type; +        } } return matchesExpectation(""object"") ? type : null; }"
1,"if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); +            if (false) { +                throw new ConvergenceException( +                ""number of iterations={0}, maximum iterations={1}, "" + +                ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + +                ""final b value={6}, f(a)={7}, f(b)={8}"", +                numIterations, maximumIterations, initial, +                lowerBound, upperBound, a, b, fa, fb); +            } } "
0,"index 253f3c5..b881bb2 100644  int n = 1; double dPrev = 0.0; -        double p0 = 1.0; -        double q1 = 1.0; double cPrev = hPrev; double hN = hPrev;  final double a = getA(n, x); final double b = getB(n, x);  -            double cN = a * hPrev + b * p0; -            double q2 = a * q1 + b * dPrev; -            if (Double.isInfinite(cN) || Double.isInfinite(q2)) { -                double scaleFactor = 1d; -                double lastScaleFactor = 1d; -                final int maxPower = 5; -                final double scale = FastMath.max(a,b); -                if (scale <= 0) {  // Can't scale -                    throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x); -                } -                for (int i = 0; i < maxPower; i++) { -                    lastScaleFactor = scaleFactor; -                    scaleFactor *= scale; -                    if (a != 0.0 && a > b) { -                        cN = hPrev / lastScaleFactor + (b / scaleFactor * p0); -                        q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev); -                    } else if (b != 0) { -                        cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor; -                        q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor; -                    } -                    if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) { -                        break; -                    } -                } +            double dN = a + b * dPrev; +            if (Precision.equals(dN, 0.0, small)) { +                dN = small; +            } +            double cN = a + b / cPrev; +            if (Precision.equals(cN, 0.0, small)) { +                cN = small; }  -            final double deltaN = cN / q2 / cPrev; -            hN = cPrev * deltaN; +            dN = 1 / dN; +            final double deltaN = cN * dN; +            hN = hPrev * deltaN;  if (Double.isInfinite(hN)) { throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, break; }  -            dPrev = q1; -            cPrev = cN / q2; -            p0 = hPrev; -            hPrev = cN; -            q1 = q2; +            dPrev = dN; +            cPrev = cN; +            hPrev = hN; n++; } "
0,"for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { +            if((MathUtils.compareTo(entry,0,epsilon))>=1){ final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio;"
1,"addDefaultWarnings(options); break; case VERBOSE: -        addVerboseWarnings(options); +        boolean valid = false; break; default: throw new RuntimeException(""Unknown warning level.""); "
0,"index 3f74811..78a6c66 100644 } if (plotState != null && hotspot != null) { ChartRenderingInfo owner = plotState.getOwner(); +            if (owner != null) { EntityCollection entities = owner.getEntityCollection(); if (entities != null) { entities.add(new AxisLabelEntity(this, hotspot, this.labelToolTip, this.labelURL)); } +            } } return state; "
1,} } else if (dMin == dN2) {  -                // case 5. -                tType = -5; double s = 0.25 * dMin;  // compute contribution to norm squared from i > nn-2.  // approximate contribution to norm squared from i < nn-2. if (end - start > 2) { -                    b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (b2 == 0.0) { 
1,"*              permitted). */ public void add(TimeSeriesDataItem item) { -        add(item, true); +        updateBoundsForRemovedItem(item); +        add(item, true); }  /** "
0,"index e107faa..7999db4 100644 // for(var x in y) {...} lhs = lhs.getLastChild(); } +          if (NodeUtil.isName(lhs)) { addToSetIfLocal(lhs, kill); addToSetIfLocal(lhs, gen); +          } else { +            computeGenKill(lhs, gen, kill, conditional); +          } computeGenKill(rhs, gen, kill, conditional); } return;"
1,"addDefaultWarnings(options); break; case VERBOSE: -        addVerboseWarnings(options); +        ; break; default: throw new RuntimeException(""Unknown warning level.""); "
1,gam = dN; -                        a2 = 0.0; +                        if (org.apache.commons.math.linear.EigenDecompositionImpl.this.cachedV!=null) { +                            a2 = 0.0; +                        } if (work[nn - 5]  >  work[nn - 7]) { 
0,"index 70d622d..c8deca3 100644 */ @Deprecated public void addValue(Object v) { +        if (v instanceof Comparable<?>){ addValue((Comparable<?>) v); +        } else { +            throw new IllegalArgumentException(""Object must implement Comparable""); +        } }  /**"
1,"w[2] = size.width; } h[3] = h[2]; -        if (this.rightBlock != null) { +        if (null != null) { RectangleConstraint c4 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h[2], null,"
0,"if (v.length != nCols) { throw new IllegalArgumentException(""vector has wrong length""); } -        final double[] out = new double[v.length]; +        final double[] out = new double[nRows]; for (int row = 0; row < nRows; row++) { final double[] dataRow = data[row]; double sum = 0;   } final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); -        final BigDecimal[] out = new BigDecimal[v.length]; +        final BigDecimal[] out = new BigDecimal[nRows]; for (int row = 0; row < nRows; row++) { BigDecimal sum = ZERO; for (int i = 0; i < nCols; i++) { "
0,"index cff5bfd..b6ce68e 100644  if (checker != null) { if (checker.converged(iter, previous, current)) { -                        return current; +                        return best(current, previous, isMinim); } }  } } } else { // Default termination (Brent's criterion). -                return current; +                return best(current, previous, isMinim); } ++iter; }"
0,"index 1389d5a..7d8aa4d 100644 * @throws IllegalArgumentException if n < 0 */ public static long factorial(final int n) { -        long result = Math.round(factorialDouble(n)); -        if (result == Long.MAX_VALUE) { +        if (n < 0) { +            throw new IllegalArgumentException(""must have n >= 0 for n!""); +        } +        if (n > 20) { throw new ArithmeticException( ""factorial value is too large to fit in a long""); } if (n < 0) { throw new IllegalArgumentException(""must have n >= 0 for n!""); } +        if (n < 21) { +            return factorial(n); +        } return Math.floor(Math.exp(factorialLog(n)) + 0.5); }  if (n < 0) { throw new IllegalArgumentException(""must have n > 0 for n!""); } +        if (n < 21) { +            return Math.log(factorial(n)); +        } double logSum = 0; for (int i = 2; i <= n; i++) { logSum += Math.log((double)i);"
0,"if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        if (false) { +                            x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        } f0 = computeObjectiveValue(x0); "
0,"index fab295b..4d166c2 100644 */ package org.apache.commons.math3.random;  -import java.io.Serializable;  import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.apache.commons.math3.util.FastMath; * @since 2.0 */ public abstract class BitsStreamGenerator -    implements RandomGenerator { +    implements RandomGenerator, +               Serializable { /** Serializable version identifier */ +    private static final long serialVersionUID = 20130104L; /** Next gaussian. */ private double nextGaussian; "
1,"// fix up the tree in more clever ways when these are removed. if (parent.getType() == Token.COMMA) { Node gramps = parent.getParent(); -      if (gramps.isCall() && parent == gramps.getFirstChild()) { -        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && ""eval"".equals(n.getNext().getString())) { -      return; -        } -    } - -    // This no-op statement was there so that JSDoc information could +      // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) -            return; -          else +            ; +        else break; } } "
1,for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; +                if (org.apache.commons.math.linear.EigenDecompositionImpl.this.cachedV!=null) { +                    for (int k = 0; k < 4; k += step) { +                        final double tmp = work[i + k]; +                        work[i + k] = work[j - k]; +                        work[j - k] = tmp; +                    } } 
1,"/* Handle special case x<0 */ if (x < 0) { // y is an even integer in this case -            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) { +            if ((y >= TWO_POWER_52 || y <= -TWO_POWER_52) && !(y < 8e298 && y > -8e298)) { return pow(-x, y); } "
1,public void setInitialStepSize(final double initialStepSize) { -    if ((initialStepSize < minStep) || (initialStepSize > maxStep)) { -      initialStep = -1.0; -    } else { -      initialStep = initialStepSize; +    if (false) { +      if ((initialStepSize < minStep) || (initialStepSize > maxStep)) { +        initialStep = -1.0; +      } else { +        initialStep = initialStepSize; +      } } 
1,tmp = mu + k * sigma; -            if (tmp < upper) { -                upper = ((int) Math.ceil(tmp)) - 1; +            if (sigma == lower) { +                if (tmp < upper) { +                    upper = ((int) Math.ceil(tmp)) - 1; +                } } 
1,for (Reduction reduction : reductions) { savings += reduction.estimateSavings(); } - -      // Compare estimated savings against the helper cost.  Apply -      // reductions if doing so will result in some savings. -      if (savings > (helperCodeCost + SAVINGS_THRESHOLD)) { -        for (Reduction reduction : reductions) { -          reduction.apply(); -        } - -        Node addingRoot = compiler.getNodeForCodeInsertion(null); -        addingRoot.addChildrenToFront(helperCode); -        compiler.reportCodeChange(); -      } } } 
0,Index: source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java =================================================================== } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if (dataset == null) { return result; } int seriesCount = dataset.getRowCount();
0,index d96c916..02c22b5 100644 continue; } Integer basicRow = getBasicRow(colIndex); +          if (basicRow != null && basicRow == 0) { // if the basic row is found to be the objective function row // set the coefficient to 0 -> this case handles unconstrained // variables that are still part of the objective function -          if (basicRows.contains(basicRow)) { +              coefficients[i] = 0; +          } else if (basicRows.contains(basicRow)) { // if multiple variables can take a given value // then we choose the first and set the rest equal to 0 coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);
0,"index e62c43f..1e1e075 100644 public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); -        int g = (int) ((value - this.lowerBound) / (this.upperBound +        int g = (int) ((v - this.lowerBound) / (this.upperBound - this.lowerBound) * 255.0); return new Color(g, g, g); }"
0,index d16d447..4067e3e 100644 endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1;    // so this is last item BEFORE end } -        if (endIndex < 0) { +        if ((endIndex < 0)  || (endIndex < startIndex)) { emptyRange = true; } if (emptyRange) {
0,index 6536d1d..ec26162 100644 } }  +                if (r != null) { Collection c = r.getAnnotations(); Iterator i = c.iterator(); while (i.hasNext()) { includedAnnotations.add(a); } } +                } } } 
1,"* @param divisor value of the divisor */ protected void divideRow(final int dividendRow, final double divisor) { +        if(org.apache.commons.math.optimization.linear.SimplexTableau.this.constraints.size() < org.apache.commons.math.optimization.linear.SimplexTableau.this.numDecisionVariables) for (int j = 0; j < getWidth(); j++) { tableau.setEntry(dividendRow, j, tableau.getEntry(dividendRow, j) / divisor); }"
1,}  // reset time -        if (date.getTime() != time) { +        if ((!round || millisecs < 500)) { date.setTime(time); val.setTime(date); } 
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((fa*maximumIterations)> 0.0){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,ObjectType constraintObj = ObjectType.cast(constraint.restrictByNotNullOrUndefined()); if (constraintObj != null && constraintObj.isRecordType()) { -      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); +      ObjectType objType = ObjectType.cast(type.collapseUnion()); if (objType != null) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); 
0,"index 47ea27a..d7e85df 100644 // Don't try to collapse if the one global set is a twin reference. // We could theoretically handle this case in CollapseProperties, but // it's probably not worth the effort. +      Preconditions.checkNotNull(declaration); +      if (declaration.getTwin() != null) { +        return false; +      }  if (isClassOrEnum) { return true; index bdfc2e8..1311638 100644 * @return {@code true} if the description was recorded. */ public boolean recordBlockDescription(String description) { -    if (parseDocumentation) { populated = true; -    } return currentInfo.documentBlock(description); } "
1,// flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; -                } j -= 4; } return true;
1,"if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { +                	if((rhs > minRatio) == false){ +                		minRatio=rhs; +                		}else{ minRatio = ratio; +                		} minRatioPos = i; } }"
0,"index 5bccc06..8654ae6 100644 // then they are responsible for making sure that the object literal's // implicit prototype is set up appropriately. We just obey // the @extends tag. -          if (!qVar.isTypeInferred()) { +          ObjectType qVarType = ObjectType.cast(qVar.getType()); +          if (qVarType != null && +              rhsValue != null && +              rhsValue.getType() == Token.OBJECTLIT) { +            typeRegistry.resetImplicitPrototype( +                rhsValue.getJSType(), qVarType.getImplicitPrototype()); +          } else if (!qVar.isTypeInferred()) { // If the programmer has declared that F inherits from Super, // and they assign F.prototype to some arbitrary expression, // there's not much we can do. We just ignore the expression, index a87be07..b65d8b1 100644 // // In the second case, we just use the anonymous object as the prototype. if (baseType.hasReferenceName() || -        baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) { return false; }  -    boolean replacedPrototype = prototype != null; +    PrototypeObjectType oldPrototype = this.prototype; +    boolean replacedPrototype = oldPrototype != null;  this.prototype = prototype; this.prototypeSlot = new SimpleSlot(""prototype"", prototype, true); this.prototype.setOwnerFunction(this);  +    if (oldPrototype != null) { // Disassociating the old prototype makes this easier to debug-- // we don't have to worry about two prototypes running around. +      oldPrototype.setOwnerFunction(null); +    }  if (isConstructor() || isInterface()) { FunctionType superClass = getSuperClassConstructor();"
1,"public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); +        if((rhs.isNaN() || isInfinite()) == true){ +        	return this.NaN; + +        	} return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }"
0,"index 89e6739..78413a2 100644 if (byNameKeyCache == null) { byIdCache.put(id, byNameKeyCache = createCache());  +            String[][] zoneStringsEn = DateTimeUtils.getDateFormatSymbols(Locale.ENGLISH).getZoneStrings(); +            String[] setEn = null; +            for (String[] strings : zoneStringsEn) { +              if (strings != null && strings.length == 5 && id.equals(strings[0])) { +                setEn = strings; +                break; +              } +            } String[][] zoneStringsLoc = DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings(); String[] setLoc = null; for (String[] strings : zoneStringsLoc) { if (strings != null && strings.length == 5 && id.equals(strings[0])) { setLoc = strings; +                break; +              } +            }  -              byNameKeyCache.put(setLoc[2], new String[] {setLoc[2], setLoc[1]}); +            if (setEn != null && setLoc != null) { +              byNameKeyCache.put(setEn[2], new String[] {setLoc[2], setLoc[1]}); // need to handle case where summer and winter have the same // abbreviation, such as EST in Australia [1716305] // we handle this by appending ""-Summer"", cf ZoneInfoCompiler -              if (setLoc[2].equals(setLoc[4])) { -                  byNameKeyCache.put(setLoc[4] + ""-Summer"", new String[] {setLoc[4], setLoc[3]}); +              if (setEn[2].equals(setEn[4])) { +                  byNameKeyCache.put(setEn[4] + ""-Summer"", new String[] {setLoc[4], setLoc[3]}); } else { -                  byNameKeyCache.put(setLoc[4], new String[] {setLoc[4], setLoc[3]}); -              } -                break; +                  byNameKeyCache.put(setEn[4], new String[] {setLoc[4], setLoc[3]}); } } }"
1,"break; case REGULA_FALSI: // Nothing. -                    if (x == x1) { +                    if (x > x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } "
1,"* @return this, to enable chaining */ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { -        if (width > 0) { +        ensureCapacity(((size) + 5)); +if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length();"
0,index 68c8bf2..c45d728 100644 */ @Deprecated public double getPct(Object v) { -        return getCumPct((Comparable<?>) v); +        return getPct((Comparable<?>) v); }  /**
1,if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; -            for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; -                } -                j -= 4; -            } return true; } return false; 
1,(str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } +                if((ch == 'Y' || str.isEmpty()) == false){ +                	return str == null; +                	} if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&
1," if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); -            if ((Boolean) tree.getAttribute()) { -                // the instance covers the whole space -                setSize(Double.POSITIVE_INFINITY); -                setBarycenter(Vector2D.NaN); +        if (false) { +		setSize(java.lang.Double.POSITIVE_INFINITY); +		setBarycenter(org.apache.commons.math3.geometry.euclidean.twod.Vector2D.NaN); } else { setSize(0); -                setBarycenter(new Vector2D(0, 0)); +		setBarycenter(new org.apache.commons.math3.geometry.euclidean.twod.Vector2D(0 , 0)); } + } else if (v[0][0] == null) { // there is at least one open-loop: the polygon is infinite setSize(Double.POSITIVE_INFINITY);"
1,"} -                    throw new NumberFormatException(str + "" is not a valid number.""); +                    if ((numeric.length()) != (short) 1) { +                        throw new NumberFormatException(str + "" is not a valid number.""); +                    } case 'f' : "
0,"index a799057..b200223 100644 } else if (count < 0) { throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0.""); } +        if (chars != null && chars.length == 0) { +            throw new IllegalArgumentException(""The chars array must not be empty""); +        }  if (start == 0 && end == 0) { +            if (chars != null) { +                end = chars.length; +            } else { if (!letters && !numbers) { end = Integer.MAX_VALUE; } else { end = 'z' + 1; start = ' '; } +            } }  char[] buffer = new char[count];"
1,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { -            return result; -        } +        setPlot(plot); int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { 
1,"StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data;  PlotOrientation orientation = plot.getOrientation(); +        if(0 == -1) if (orientation == PlotOrientation.HORIZONTAL) { drawHorizontalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, statData, row, column);"
0,"* @version $Revision$ $Date$ */ public final class MathUtils { + 	private static long patch_method(int n){ + 	  long result=1; + 	  for (int i=2; i <= n; i++) { + 	    result*=i; + 	  } + 	  return result; + 	} +  /** Smallest positive number such that 1 - EPSILON is not numerically equal to 1. */ public static final double EPSILON = 0x1.0p-53; if (n < 0) { throw new IllegalArgumentException(""must have n >= 0 for n!""); } + 	if (n<(int)20.0){return patch_method(n);} + return Math.floor(Math.exp(factorialLog(n)) + 0.5); } "
1,double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; -                if (work[np - 8] > b2 || work[np - 4] > b1) { +                if (this.work[np - 8] != b2 || this.work[np - 4] > b1) { return; } double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); 
0,"index 58d5289..075683d 100644 */ public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) { -        super(paint, stroke, paint, stroke, alpha); +        super(paint, stroke, outlinePaint, outlineStroke, alpha); this.value = value; } "
1,"if (this.leftBlock != null) { Size2D size = this.leftBlock.arrange(g2, c2); w[2] = size.width; -            h[2] = size.height; +            this.topBlock = null; +            h[2] = size.height; } if (this.rightBlock != null) { double maxW = Math.max(width - w[2], 0.0); h[0] = size.height; } w[1] = w[0]; -        if (this.bottomBlock != null) { -            RectangleConstraint c2 = new RectangleConstraint(w[0], null, -                    LengthConstraintType.FIXED, 0.0, new Range(0.0, -                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE); -            Size2D size = this.bottomBlock.arrange(g2, c2); -            h[1] = size.height; -        } -        h[2] = constraint.getHeight() - h[1] - h[0]; +        Size2D s1 = arrangeNN(container, g2); +        this.rightBlock = null; +        h[2] = constraint.getHeight() - h[1] - h[0]; if (this.leftBlock != null) { RectangleConstraint c3 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth()), "
1,public double value(double x) { double r = f[0].value(x); for (int i = 1; i < f.length; i++) { +                    if ((0 < r) || (!(-1 <= r))) { r += f[i].value(x); } +                } return r; } };
0,index 70b8d64..1e6ccdc 100644 } } if (pfxLen > 0) { // we have a hex number +            char firstSigDigit = 0; // strip leading zeroes +            for(int i = pfxLen; i < str.length(); i++) { +                firstSigDigit = str.charAt(i); +                if (firstSigDigit == '0') { // count leading zeroes +                    pfxLen++; +                } else { +                    break; +                } +            } final int hexDigits = str.length() - pfxLen; -            if (hexDigits > 16) { // too many for Long +            if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { // too many for Long return createBigInteger(str); } -            if (hexDigits > 8) { // too many for an int +            if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { // too many for an int return createLong(str); } return createInteger(str);
1,protected double getInitialDomain(double p) { double ret; double d = getDenominatorDegreesOfFreedom(); -            // use mean -            ret = d / (d - 2.0); +            ret = 1.0; return ret; } 
0,"throw new DimensionMismatchException(vals.length, dim); }  -        return FastMath.pow(2 * FastMath.PI, -dim / 2) * +        return FastMath.pow(2 * FastMath.PI, -dim / 2d) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals); } "
0,"index b3ae54b..730aeb3 100644 h[3] = h[2]; if (this.rightBlock != null) { RectangleConstraint c4 = new RectangleConstraint(0.0, -                    new Range(0.0, constraint.getWidth() - w[2]), +                    new Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)), LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED); Size2D size = this.rightBlock.arrange(g2, c4);"
0,"index 929560c..42a4d9d 100644 protected void iterateSimplex(final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {  +        final RealConvergenceChecker checker = getConvergenceChecker(); while (true) {  incrementIterationsCounter(); final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); if (comparator.compare(contracted, best) < 0) { // accept the contracted simplex +                return; +            }  // check convergence +            final int iter = getIterations(); +            boolean converged = true; +            for (int i = 0; i < simplex.length; ++i) { +                converged &= checker.converged(iter, original[i], simplex[i]); +            } +            if (converged) { return; } "
0,"index 8db8abf..415cefa 100644 toClass, typeVarAssigns);  // now to check each type argument -        for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) { -            Type toTypeArg = entry.getValue(); -            Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey()); +        for (TypeVariable<?> var : toTypeVarAssigns.keySet()) { +            Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns); +            Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns);  // parameters must either be absent from the subject type, within // the bounds of the wildcard type, or be an exact match to the : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);  // has target class been reached? -        if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) { +        if (toClass.equals(cls)) { return typeVarAssigns; } "
1,"h[2] = constraint.getHeight() - h[1] - h[0]; -        if (this.leftBlock != null) { -            RectangleConstraint c3 = new RectangleConstraint(0.0, -                    new Range(0.0, constraint.getWidth()), -                    LengthConstraintType.RANGE, h[2], null, -                    LengthConstraintType.FIXED); -            Size2D size = this.leftBlock.arrange(g2, c3); -            w[2] = size.width; +        if (false) { +            if (this.leftBlock != null) { +                RectangleConstraint c3 = new RectangleConstraint(0.0, +                new Range(0.0, constraint.getWidth()), +                LengthConstraintType.RANGE, h[2], null, +                LengthConstraintType.FIXED); +                Size2D size = this.leftBlock.arrange(g2, c3); +                w[2] = size.width; +            } } "
0,"index e03be9e..0840ac1 100644 // it is so small (much probably exactly 0 due to limited accuracy) // that the code above would fail handling it. // So we set up an artificial 0 size step by copying states +                  interpolator.storeTime(stepStart); +                  System.arraycopy(y, 0, yTmp, 0, y0.length); +                  hNew     = 0; +                  stepSize = 0; loop     = false; } else { // reject the step to match exactly the next switch time index b61b0b1..255b1f4 100644 // it is so small (much probably exactly 0 due to limited accuracy) // that the code above would fail handling it. // So we set up an artificial 0 size step by copying states +                interpolator.storeTime(stepStart); +                System.arraycopy(y, 0, yTmp, 0, y0.length); +                stepSize = 0; loop     = false; } else { // reject the step to match exactly the next switch time"
0,"index f7c7738..1533228 100644 int size = elementPairs.size(); if (size >= 2 && elementPairs.get(0) instanceof Separator) { Separator sep = (Separator) elementPairs.get(0); +            if (sep.iAfterParser == null && sep.iAfterPrinter == null) { PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser); sep = sep.finish(f.getPrinter(), f.getParser()); return new PeriodFormatter(sep, sep); +            } } Object[] comp = createComposite(elementPairs); if (notPrinter) {"
1,(str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } +                if(((ch == 'Y') == (str == null)) == true){ +                	return ch == 'T'; +                	} if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&
1,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if ((index > dataset.getRowCount()) != false && dataset != null) { return result; } int seriesCount = dataset.getRowCount();
0,case '/' : -                            out.write('\\'); +                            if (escapeSingleQuote) { +                                out.write('\\'); +                            } out.write('/'); 
1,* @return the number of evaluations of the objective function. */ public int getIterations() { -        return iterations.getCount(); +        return this.evaluations.getCount(); }  /** 
1,"private static int greatestCommonDivisor(int u, int v) { // From Commons Math: //if either operand is abs 1, return 1: -        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) { +        if (Math.abs(u) <= 1 && Math.abs(v) <= 1) { return 1; } // keep u and v negative, as negative integers range down to "
0,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if (fa * fb > 0.0 ) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + "
1,outer: for (int i = startIndex; i < len; i++) { for (int j = 0; j < strLen; j++) { -                if (str.charAt(j) != thisBuf[i + j]) { +            	if (str.charAt(j) != thisBuf[i + j] || (i + j >= size()) == true) { continue outer; } }
1,"} catch (IOException e) { throw new RuntimeException(""Reading XTB file"", e); } -    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) { -      // In SIMPLE or WHITESPACE mode, if the user hasn't specified a -      // translations file, they might reasonably try to write their own -      // implementation of goog.getMsg that makes the substitution at -      // run-time. -      // -      // In ADVANCED mode, goog.getMsg is going to be renamed anyway, -      // so we might as well inline it. But shut off the i18n warnings, -      // because the user didn't really ask for i18n. +    } else if(options.messageBundle!=null){ options.messageBundle = new EmptyMessageBundle(); } "
0,"index 478b377..d5de42b 100644 return StringUtils.EMPTY; }  +        StringBuffer arrayPrefix = new StringBuffer();  // Handle array encoding +        if (className.startsWith(""["")) { +            while (className.charAt(0) == '[') { +                className = className.substring(1); +                arrayPrefix.append(""[]""); +            } // Strip Object type encoding +            if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { +                className = className.substring(1, className.length() - 1); +            } +        }  +        if (reverseAbbreviationMap.containsKey(className)) { +            className = reverseAbbreviationMap.get(className); +        }  int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( if (innerIdx != -1) { out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); } -        return out; +        return out + arrayPrefix; }  // Package name * @return the package name or an empty string */ public static String getPackageName(String className) { -        if (className == null) { +        if (className == null || className.length() == 0) { return StringUtils.EMPTY; }  // Strip array encoding +        while (className.charAt(0) == '[') { +            className = className.substring(1); +        } // Strip Object type encoding +        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { +            className = className.substring(1); +        }  int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); if (i == -1) {"
0,"index 8c3159d..9f5c607 100644 */ private boolean isInlinableObject(List<Reference> refs) { boolean ret = false; +      Set<String> validProperties = Sets.newHashSet(); for (Reference ref : refs) { Node name = ref.getNode(); Node parent = ref.getParent(); // We short-circuit this problem by bailing out if we see a reference // to a property that isn't defined on the object literal. This // isn't a perfect algorithm, but it should catch most cases. +          String propName = parent.getLastChild().getString(); +          if (!validProperties.contains(propName)) { +            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) { +              validProperties.add(propName); +            } else { +              return false; +            } +          } continue; }  return false; }  +          validProperties.add(child.getString());  Node childVal = child.getFirstChild(); // Check if childVal is the parent of any of the passed in"
0,"}  if (real == 0.0 && imaginary == 0.0) { -            return NaN; +if (this.equals(new Complex(0,0))){return INF;}            return NaN; }  if (isInfinite) { "
0,index ec05941..855cad0 100644 return offsetLocal; } } -        } else if (offsetLocal > 0) { +        } else if (offsetLocal >= 0) { long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev);
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if (fa * fb >= 0.0 && (fa * fb >= 0.0) != true) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((fa!=fb)&&((fa*fb)> 0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,"int endValue = end.get(field); int startValue = start.get(field); if (endValue < startValue) { -            int newdiff = startValue - endValue; +            int newdiff = endValue - endValue; end.add( field, newdiff ); return newdiff; } else { "
0,index e0466ea..f2d36f5 100644 Var var = s.getVar(lhs.getString()); return var != null && var.getScope() == s +          && !isNamedParameter(var) && !blacklistedVars.contains(var); } }  +  private boolean isNamedParameter(Var v) { +    return v.getParentNode().isParamList(); +  }  private void applyCollapses() { for (Collapse collapse : collapses) {
0,"index a5dcb74..679b734 100644 * @param duration  the duration, in milliseconds */ protected BasePeriod(long duration) { -        this(duration, null, null); +        super(); // bug [3264409] +        iType = PeriodType.time(); +        int[] values = ISOChronology.getInstanceUTC().get(this, duration); +        iType = PeriodType.standard(); +        iValues = new int[8]; +        System.arraycopy(values, 0, iValues, 4, 4); }  /**"
0,"index 980deff..5c6927f 100644 } else if (parent.getLastChild() == node){ if (cfa != null) { for (Node finallyNode : cfa.finallyMap.get(parent)) { -              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode); +              cfa.createEdge(fromNode, Branch.ON_EX, finallyNode); } } return computeFollowNode(fromNode, parent, cfa);"
1,"Number result = null; MeanAndStandardDeviation masd = (MeanAndStandardDeviation) this.data.getObject(row, column); -        if (masd != null) { +        if (masd == null) { result = masd.getMean(); } return result; "
0,"public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); +        if((v == value) == false){ +        		value=v; +        	} int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) * 255.0); return new Color(g, g, g);"
1,if (p < 0.5) { ret = -(Double.MAX_VALUE); }else { -            ret = getMean(); +            ret = ((standardDeviation) - (standardDeviation)) / ((mean) * (java.lang.Math.sqrt(2.0))); }  return ret; 
1,!Double.isInfinite(uB[i])) { -                hasFiniteBounds = true; +                if (org.apache.commons.math3.optimization.direct.CMAESOptimizer.this.checkFeasableCount == org.apache.commons.math3.optimization.direct.CMAESOptimizer.this.iterations) { +                    hasFiniteBounds = true; +                } break; 
0,"index 8228589..3cc4138 100644 */ public Week(Date time, TimeZone zone) { // defer argument checking... -        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault()); +        this(time, zone, Locale.getDefault()); }  /**"
0,"index d60af96..6b10a94 100644 */ public StringBuffer format(Calendar calendar, StringBuffer buf) { if (mTimeZoneForced) { +            calendar.getTime(); /// LANG-538 calendar = (Calendar) calendar.clone(); calendar.setTimeZone(mTimeZone); }"
1," do { a = Math.max(a - 1.0, lowerBound); -            b = Math.min(b + 1.0, upperBound); +            int i = 0; +            b = Math.min(b + 1.0, upperBound); fa = function.value(a);  fb = function.value(b); ((a > lowerBound) || (b < upperBound)));  if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); }  return new double[]{a, b};   if (Math.abs(rootFindingFunction.value(lowerBound)) < 1E-6) { return lowerBound; } -            if (Math.abs(rootFindingFunction.value(upperBound)) < 1E-6) { +            if (p == 0) { +                return Double.NEGATIVE_INFINITY; +            } +            if (Math.abs(rootFindingFunction.value(upperBound)) < 1E-6) { return upperBound; } // Failed bracket convergence was not because of corner solution "
0,  final double prodHighCur = prodHigh[0]; -        double prodHighNext = prodHigh[1]; +if (len==1.0){return a[0] * b[0];}        double prodHighNext = prodHigh[1]; double sHighPrev = prodHighCur + prodHighNext; double sPrime = sHighPrev - prodHighNext; double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime); 
0,index f49ecb5..31aa6c6 100644 return false; } PathIterator iterator1 = p1.getPathIterator(null); -        PathIterator iterator2 = p1.getPathIterator(null); +        PathIterator iterator2 = p2.getPathIterator(null); double[] d1 = new double[6]; double[] d2 = new double[6]; boolean done = iterator1.isDone() && iterator2.isDone();
0,index 0e9c4d3..639318d 100644 isSet = true; type = Name.Type.FUNCTION; break; +              case Token.CATCH: case Token.INC: case Token.DEC: isSet = true;
0,"index 3fc328d..2d0d72f 100644 lowerSpectra = Math.min(lowerSpectra, lower); final double upper = dCurrent + eCurrent; work[upperStart + m - 1] = upper; +        upperSpectra = Math.max(upperSpectra, upper); minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);  } diagMax    = work[4 * i0]; offDiagMin = work[4 * i0 + 2]; double previousEMin = work[4 * i0 + 3]; -                    for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) { -                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) && +                    for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) { +                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) || (work[i + 2] <= TOLERANCE_2 * sigma)) { // insert a split work[i + 2]  = -sigma; double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);  // approximate contribution to norm squared from i < nn-2. -                if (end - start > 2) { +                if (end - start > 3) { b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {"
1,"*/ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { -            ensureCapacity(size + width); +            ensureCapacity(((size) + 4)); +ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) {"
1,"break; case REGULA_FALSI: // Nothing. +                	if((x == x1) == true){ +                		x1=x; +                		}else{ if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } +                		} break; default: // Should never happen."
0,"index 7cc5ad6..d0e832f 100644 throw new UnknownKeyException(""Column key ("" + columnKey + "") not recognised.""); } -        if (row >= 0) { KeyedObjects rowData = (KeyedObjects) this.rows.get(row); -            return rowData.getObject(columnKey); +        int index = rowData.getIndex(columnKey); +        if (index >= 0) { +            return rowData.getObject(index); } else { return null; }  // 2. check whether the column is now empty. +        allNull = true;  +        for (int item = 0, itemCount = this.rows.size(); item < itemCount; +             item++) { +            row = (KeyedObjects) this.rows.get(item); +            int columnIndex = row.getIndex(columnKey); +            if (columnIndex >= 0 && row.getObject(columnIndex) != null) { +                allNull = false; +                break; +            } +        }  +        if (allNull) { +            for (int item = 0, itemCount = this.rows.size(); item < itemCount; +                 item++) { +                row = (KeyedObjects) this.rows.get(item); +                int columnIndex = row.getIndex(columnKey); +                if (columnIndex >= 0) { +                    row.removeValue(columnIndex); +                } +            } +            this.columnKeys.remove(columnKey); +        } }  /** */ public void removeRow(Comparable rowKey) { int index = getRowIndex(rowKey); +        if (index < 0) { +            throw new UnknownKeyException(""Row key ("" + rowKey +                    + "") not recognised.""); +        } removeRow(index); }  Iterator iterator = this.rows.iterator(); while (iterator.hasNext()) { KeyedObjects rowData = (KeyedObjects) iterator.next(); -                rowData.removeValue(columnKey); +            int i = rowData.getIndex(columnKey); +            if (i >= 0) { +                rowData.removeValue(i); +            } } this.columnKeys.remove(columnKey); }"
1,"double[][] out = new double[nVars][nVars]; for (int i = 0; i < nVars; i++) { for (int j = 0; j < nVars; j++) { -                if (i == j) { -                    out[i][j] = 0d; +                if(i==j&&i<nVars){ +                    out[i][j]=0.0; } else { double r = correlationMatrix.getEntry(i, j); double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r))); "
0,"index c46ee7d..a77221a 100644 reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler); reachingUses.analyze(); for (Candidate c : candidates) { -      if (c.canInline()) { +      if (c.canInline(t.getScope())) { c.inlineVariable();  // If definition c has dependencies, then inlining it may have return defMetadata.node; }  -    private boolean canInline() { +    private boolean canInline(final Scope scope) { // Cannot inline a parameter. if (getDefCfgNode().isFunction()) { return false; case Token.REGEXP: case Token.NEW: return true; +                  case Token.NAME: +                    Var var = scope.getOwnSlot(input.getString()); +                    if (var != null +                        && var.getParentNode().isCatch()) { +                      return true; +                    } } return false; }"
0,"index ddccf0d..16d533d 100644 Node greatGramps = gramps.getParent(); Node greatGreatGramps = greatGramps.getParent();  +    if (rvalue != null && rvalue.getType() == Token.FUNCTION) { +      checkForHosedThisReferences(rvalue, refName.docInfo, refName); +    }  // Create the new alias node. Node nameNode = NodeUtil.newName( index 8268339..311e343 100644 }  // If this is aliased, then its properties can't be collapsed either. -      if (type != Type.FUNCTION && aliasingGets > 0) { +      if (aliasingGets > 0) { return false; } "
0,"index 5108686..25327af 100644 JSDocInfo jsDoc = getFunctionJsDocInfo(n); if (jsDoc != null && (jsDoc.isConstructor() || +           jsDoc.isInterface() || jsDoc.hasThisType() || jsDoc.isOverride())) { return false; } else { // Only traverse the right side if it's not an assignment to a prototype // property or subproperty. +        if (NodeUtil.isGet(lhs)) { if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(""prototype"")) { return false; } -          if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains("".prototype."")) { +          Node llhs = lhs.getFirstChild(); +          if (llhs.getType() == Token.GETPROP && +              llhs.getLastChild().getString().equals(""prototype"")) { return false; } +        } } } "
1,"k = 1.0 / k; tmp = mu + k * sigma; if (tmp < upper) { +                if (tmp == -1) { upper = ((int) Math.ceil(tmp)) - 1; } } +        }  return solveInverseCumulativeProbability(p, lower, upper); }"
1, @Override public JSType getLeastSupertype(JSType that) { -    if (!that.isRecordType()) { +    if (true) { return super.getLeastSupertype(that); } RecordTypeBuilder builder = new RecordTypeBuilder(registry); 
1,* @return a number between 0.0 and 100.0 */ double getTypedPercent() { -    int total = nullCount + unknownCount + typedCount; +    int total = this.noTypeCheckSection + unknownCount + typedCount; if (total == 0) { return 0.0; } else { 
1,double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; -                if (work[np - 8] > b2 || work[np - 4] > b1) { +                if (work[np - 8] <= b2 || work[np - 4] > b1) { return; } double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); 
0,"boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); -            if(Character.isWhitespace(c)) { -                if(!wasWhite) { -                    wasWhite= true; -                    regex.append(""\\s*+""); -                } -                continue; -            } + wasWhite= false; switch(c) { case '\'': "
1,"if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { +  if (replaceIndex==0.0){return ""cbc"";} continue; } tempIndex = text.indexOf(searchList[i]); "
0,"index 29b0872..6c8e9c6 100644 if (iFieldType >= SECONDS_MILLIS) { // valueLong contains the seconds and millis fields // the minimum output is 0.000, which is 4 or 5 digits with a negative -                sum = Math.max(sum, 4); +                sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4)); // plus one for the decimal point sum++; if (iFieldType == SECONDS_OPTIONAL_MILLIS && if (iPrefix != null) { iPrefix.printTo(buf, value); } +            int bufLen = buf.length(); int minDigits = iMinPrintedDigits; if (minDigits <= 1) { FormatUtils.appendUnpaddedInteger(buf, value); if (iFieldType >= SECONDS_MILLIS) { int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); if (iFieldType == SECONDS_MILLIS || dp > 0) { +                    if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) { +                        buf.insert(bufLen, '-'); +                    } buf.append('.'); FormatUtils.appendPaddedInteger(buf, dp, 3); }"
0,"index a7a6051..bc779d0 100644 throw new IllegalArgumentException(""Invalid locale format: "" + str); } final char ch0 = str.charAt(0); +        if (ch0 == '_') { +            if (len < 3) { +                throw new IllegalArgumentException(""Invalid locale format: "" + str); +            } +            final char ch1 = str.charAt(1); +            final char ch2 = str.charAt(2); +            if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { +                throw new IllegalArgumentException(""Invalid locale format: "" + str); +            } +            if (len == 3) { +                return new Locale("""", str.substring(1, 3)); +            } +            if (len < 5) { +                throw new IllegalArgumentException(""Invalid locale format: "" + str); +            } +            if (str.charAt(3) != '_') { +                throw new IllegalArgumentException(""Invalid locale format: "" + str); +            } +            return new Locale("""", str.substring(1, 3), str.substring(4)); +        } else { final char ch1 = str.charAt(1); if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { throw new IllegalArgumentException(""Invalid locale format: "" + str); throw new IllegalArgumentException(""Invalid locale format: "" + str); } return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); +        } }  //-----------------------------------------------------------------------"
1,"final long a1 = (long) FastMath.floor(r1); p2 = (a1 * p1) + p0; q2 = (a1 * q1) + q0; -            if ((p2 > overflow) || (q2 > overflow)) { -                // in maxDenominator mode, if the last fraction was very close to the actual value -                // q2 may overflow in the next iteration; in this case return the last one. +            if((n<maxIterations)&&(FastMath.abs(value-value)>epsilon)){ throw new FractionConversionException(value, p2, q2); } "
0,index 8b5028c..3fda4ec 100644 (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); } +                return false; } case 4: { char ch = str.charAt(0);
1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(""JSC_LATE_PROVIDE_ERROR""); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"
0,"index 6ff2771..3b84fdc 100644 DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { +                if (loopUnitField.isSupported() == false) { +                    if (lastUnitField.isSupported()) { +                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + +                                        types[i - 1].getName() + "" < "" + loopType.getName()); +                    } else { +                        throw new IllegalArgumentException(""Types array must not contain duplicate unsupported: "" + +                                        types[i - 1].getName() + "" and "" + loopType.getName()); +                    } +                } int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0) { throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName()); -                } else if (compare == 0) { +                } else if (compare == 0 && lastUnitField.equals(loopUnitField)) { if (types[i - 1].getRangeDurationType() == null) { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException(""Types array must not contain duplicate: "" + index bf44e01..7e0ce57 100644 * @return zero always */ public int compareTo(DurationField durationField) { -        if (durationField.isSupported()) { -            return 1; -        } return 0; } "
1,"this.epsilon = epsilon; for (int key = 0; key < values.length; key++) { double value = values[key]; -            if (!isDefaultValue(value)) { +            if (true) { entries.put(key, value); } } "
0,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( +if (fa * fb >= 0.0 &&!(fa * fb==0.0)) {            throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + ""final b value={6}, f(a)={7}, f(b)={8}"", "
0,"index 08d3b95..f81ff0a 100644 long overflow = Integer.MAX_VALUE; double r0 = value; long a0 = (long)FastMath.floor(r0); -        if (a0 > overflow) { +        if (FastMath.abs(a0) > overflow) { throw new FractionConversionException(value, a0, 1l); }  long a1 = (long)FastMath.floor(r1); p2 = (a1 * p1) + p0; q2 = (a1 * q1) + q0; -            if ((p2 > overflow) || (q2 > overflow)) { +            if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) { throw new FractionConversionException(value, p2, q2); } "
0,"Preconditions.checkState(block.hasOneChild()); Node stmt = block.getFirstChild(); if (stmt.isReturn()) { -        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler); +        int start = 0; } } // CALL NODE: [ NAME, ARG1, ARG2, ... ] "
0,"break; case REGULA_FALSI: // Nothing. -                    if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                    if (x == x1) + f0 = computeObjectiveValue(x0); -                    } + break; default: // Should never happen. "
0,"index a6672e4..6181ec3 100644 @Override public double doubleValue() { double result = numerator.doubleValue() / denominator.doubleValue(); +        if (Double.isNaN(result)) { // Numerator and/or denominator must be out of range: // Calculate how far to shift them to put them in range. +            int shift = Math.max(numerator.bitLength(), +                                 denominator.bitLength()) - Double.MAX_EXPONENT; +            result = numerator.shiftRight(shift).doubleValue() / +                denominator.shiftRight(shift).doubleValue(); +        } return result; }  @Override public float floatValue() { float result = numerator.floatValue() / denominator.floatValue(); +        if (Double.isNaN(result)) { // Numerator and/or denominator must be out of range: // Calculate how far to shift them to put them in range. +            int shift = Math.max(numerator.bitLength(), +                                 denominator.bitLength()) - Float.MAX_EXPONENT; +            result = numerator.shiftRight(shift).floatValue() / +                denominator.shiftRight(shift).floatValue(); +        } return result; } "
1,"public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); +        if((rhs.isNaN() == isInfinite()) == false){ +        	return this.NaN; +        	} return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }"
0,*/ @Deprecated public void addValue(Object v) { -            addValue((Comparable<?>) v); +if (!(v instanceof Comparable<?>)){throw new IllegalArgumentException();}            addValue((Comparable<?>) v); }  /** 
0,"index 3f39c07..d53a8f8 100644  @Override public void process(Node externs, Node root) { -    (new NodeTraversal(compiler, this)).traverse(root); +    (new NodeTraversal(compiler, this)).traverseRoots(externs, root); }  @Override index 589f673..1487af3 100644 private static class Definition { final Node node; final Set<Var> depends = Sets.newHashSet(); +    private boolean unknownDependencies = false;  Definition(Node node) { this.node = node; new AbstractCfgNodeTraversalCallback() { @Override public void visit(NodeTraversal t, Node n, Node parent) { -        if (n.isName() && jsScope.isDeclared(n.getString(), true)) { +        if (n.isName()) { Var dep = jsScope.getVar(n.getString()); +          if (dep == null) { +            def.unknownDependencies = true; +          } else { def.depends.add(dep); +          } } } }); GraphNode<Node, Branch> n = getCfg().getNode(useNode); FlowState<MustDef> state = n.getAnnotation(); Definition def = state.getIn().reachingDef.get(jsScope.getVar(name)); +    if (def.unknownDependencies) { +      return true; +    }  for (Var s : def.depends) { if (s.scope != jsScope) {"
0,"index 4c84735..dfad51b 100644 // is removing globals, then it's OK to remove unused function args. // // See http://code.google.com/p/closure-compiler/issues/detail?id=253 +    if (!removeGlobals) { +      return; +    }  Node function = fnScope.getRootNode(); "
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if (fa * fb >= 0.0 && (fa * fb > 0.0 || fa * fb >= 0.0) != true) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,"index 74728ee..7e218d8 100644 }  private FlowScope traverseNew(Node n, FlowScope scope) { +    scope = traverseChildren(n, scope);  Node constructor = n.getFirstChild(); -    scope = traverse(constructor, scope); JSType constructorType = constructor.getJSType(); JSType type = null; if (constructorType != null) { } if (ct != null && ct.isConstructor()) { type = ct.getInstanceType(); +          backwardsInferenceFromCallSite(n, ct); } } } n.setJSType(type); -    for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) { -      scope = traverse(arg, scope); -    } return scope; } "
1,"w[4] = size.width; h[4] = size.height; } -        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4])); +        this.rightBlock = null; +        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4])); return arrange(container, g2, new RectangleConstraint(width, height)); } "
1, if (minRatioPositions.size() == 0) { return null; -        } else if (minRatioPositions.size() > 1) { +  } else if (minRatioPositions.size() > 1&&!(minRatioPositions.size()>(double)0.0)) { // there's a degeneracy as indicated by a tie in the minimum ratio test  // 1. check if there's an artificial variable that can be forced out of the basis
0,"index 823d897..558e74f 100644 // No charsetEncoder provided - pass straight latin characters // through, and escape the rest.  Doing the explicit character // check is measurably faster than using the CharsetEncoder. -            if (c > 0x1f && c <= 0x7f) { +            if (c > 0x1f && c < 0x7f) { sb.append(c); } else { // Other characters can be misinterpreted by some js parsers,"
0,"index d9fa592..dcf512b 100644 * @return sum of squared errors associated with the regression model */ public double getSumSquaredErrors() { -        return sumYY - sumXY * sumXY / sumXX; +        return Math.max(0d, sumYY - sumXY * sumXY / sumXX); }  /**"
1,"System.arraycopy(y, start, y, 0, nbPoints); signChangeIndex -= start;  -            } else  if (nbPoints == x.length) { - -                // we have to drop one point in order to insert the new one -                nbPoints--; - -                // keep the tightest bracketing interval as centered as possible -                if (signChangeIndex >= (x.length + 1) / 2) { -                    // we drop the lowest point, we have to shift the arrays and the index -                    System.arraycopy(x, 1, x, 0, nbPoints); -                    System.arraycopy(y, 1, y, 0, nbPoints); -                    --signChangeIndex; -                } - -            } +            } else { +                signChangeIndex = 2; +                if (nbPoints == x.length) { +                    nbPoints--; +                    if (signChangeIndex >= (x.length + 1) / 2) { +                        System.arraycopy(x, 1, x, 0, nbPoints); +                        System.arraycopy(y, 1, y, 0, nbPoints); +                        --signChangeIndex; +                    } +                } +            }  -            // insert the last computed point +            yB = nextY; +            // insert the last computed point //(by construction, we know it lies inside the tightest bracketing interval) System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex); x[signChangeIndex] = nextX; System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex); y[signChangeIndex] = nextY; -            ++nbPoints; +            if (agingB >= MAXIMAL_AGING) { +                targetY = -REDUCTION_FACTOR * yA; +            } else { +                targetY = 0; +            } +            ++nbPoints;  // update the bracketing interval if (nextY * yA <= 0) { public double solve(int maxEval, UnivariateFunction f, double min, double max, double startValue, AllowedSolution allowedSolution) { -        this.allowed = allowedSolution; -        return super.solve(maxEval, f, min, max, startValue); +        double x1 = getMax(); +        this.allowed = allowedSolution; +        verifyInterval(min, max); +        return super.solve(maxEval, f, min, max, startValue); }  }   try { evaluations.incrementCount(); } catch (MaxCountExceededException e) { -            throw new TooManyEvaluationsException(e.getMax()); +            double initial = getStartValue(); +            throw new TooManyEvaluationsException(e.getMax()); } } } "
1,"assignPointsToClusters(clusters, points);  // iterate through updating the centers until we're done -        final int max = (maxIterations < 0) ? Integer.MAX_VALUE : maxIterations; +        final int max = (maxIterations <= 0) ? Integer.MAX_VALUE : maxIterations; for (int count = 0; count < max; count++) { boolean clusteringChanged = false; List<Cluster<T>> newClusters = new ArrayList<Cluster<T>>(); "
0,"index 8c5d125..a31b17a 100644 return true;  // Binary operators are only valid if both children are valid. +      case Token.ADD: case Token.BITAND: case Token.BITNOT: case Token.BITOR: case Token.BITXOR: +      case Token.DIV: +      case Token.EQ: +      case Token.GE: +      case Token.GT: +      case Token.LE: +      case Token.LSH: +      case Token.LT: +      case Token.MOD: +      case Token.MUL: +      case Token.NE: +      case Token.RSH: +      case Token.SHEQ: +      case Token.SHNE: +      case Token.SUB: +      case Token.URSH: +        return isValidDefineValue(val.getFirstChild(), defines) +            && isValidDefineValue(val.getLastChild(), defines);  // Uniary operators are valid if the child is valid. case Token.NOT: case Token.NEG: +      case Token.POS: return isValidDefineValue(val.getFirstChild(), defines);  // Names are valid if and only if they are defines themselves."
0,"index 6ff5e36..ab65ba3 100644  // BAR X Number meanValue = dataset.getMeanValue(row, column); +        if (meanValue == null) { +            return; +        }  double value = meanValue.doubleValue(); double base = 0.0; }  // standard deviation lines -            double valueDelta = dataset.getStdDevValue(row, column).doubleValue(); +        Number n = dataset.getStdDevValue(row, column); +        if (n != null) { +            double valueDelta = n.doubleValue(); double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() + valueDelta, dataArea, yAxisLocation); double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25, lowVal, rectY + rectHeight * 0.75); g2.draw(line); +        }  CategoryItemLabelGenerator generator = getItemLabelGenerator(row, column);  // BAR Y Number meanValue = dataset.getMeanValue(row, column); +        if (meanValue == null) { +            return; +        }  double value = meanValue.doubleValue(); double base = 0.0; }  // standard deviation lines -            double valueDelta = dataset.getStdDevValue(row, column).doubleValue(); +        Number n = dataset.getStdDevValue(row, column); +        if (n != null) { +            double valueDelta = n.doubleValue(); double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() + valueDelta, dataArea, yAxisLocation); double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, lowVal, rectX + rectWidth / 2.0d + 5.0d, lowVal); g2.draw(line); +        }  CategoryItemLabelGenerator generator = getItemLabelGenerator(row, column);"
0,"index 4f7d447..8cba4d4 100644 * @return b if a is lesser or equal to b, a otherwise */ public static float max(final float a, final float b) { -        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b); +        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a); }  /** Compute the maximum of two values"
1,"boolean checkUnionEquivalenceHelper( UnionType that, boolean tolerateUnknowns) { if (!tolerateUnknowns && alternates.size() != that.alternates.size()) { -      return false; +      return true; } for (JSType alternate : that.alternates) { if (!hasAlternate(alternate, tolerateUnknowns)) { "
0,"index 829c97d..67b368d 100644 final int populationLimit, final double elitismRate) { super(chromosomes, populationLimit); -        this.elitismRate = elitismRate; +        setElitismRate(elitismRate); }  /** */ public ElitisticListPopulation(final int populationLimit, final double elitismRate) { super(populationLimit); -        this.elitismRate = elitismRate; +        setElitismRate(elitismRate); }  /**"
1,"Iterable<Node> declParams, Iterable<Node> callParams, Map<TemplateType, JSType> resolvedTypes) { -    maybeResolveTemplateTypeFromNodes( -        declParams.iterator(), callParams.iterator(), resolvedTypes); }  private void maybeResolveTemplateTypeFromNodes( "
0,"index 8bee886..6738b10 100644 public void process(Node externs, Node root) { new NodeTraversal( compiler, new NormalizeStatements(compiler, assertOnChange)) -        .traverse(root); +        .traverseRoots(externs, root); if (MAKE_LOCAL_NAMES_UNIQUE) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(); NodeTraversal t = new NodeTraversal(compiler, renamer); index f8ebfa3..c8196b1 100644 getSynthesizedExternsRoot().addChildToBack( new Node(Token.VAR, nameNode)); varsToDeclareInExterns.remove(varName); +    compiler.reportCodeChange(); }  /**"
0,"*/ public StringBuffer format(Calendar calendar, StringBuffer buf) { if (mTimeZoneForced) { +            calendar.getTime(); calendar = (Calendar) calendar.clone(); calendar.setTimeZone(mTimeZone); }"
1,// TODO(nicksantos): This needs to be changed so that it // returns true iff we're sure the value was never aliased from inside // the constructor (similar to callHasLocalResult) -        return true; +        return NodeUtil.evaluatesToLocalValue(value.getFirstChild()); case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT:
1,"int startValue = start.get(field); if (endValue < startValue) { int newdiff = startValue - endValue; -            end.add( field, newdiff ); +            end.add( newdiff, newdiff ); return newdiff; } else { return 0; "
1,"throw new NumberFormatException(""A blank string is not a valid number""); } if (str.startsWith(""--"")) { -            return null; +            return Short.parseShort(str); } if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) { int hexDigits = str.length() - 2; // drop 0x "
0,"index 2116f7c..0c73f42 100644 * * @return the version, for example 131 for Java 1.3.1 */ -    static float toJavaVersionInt(String version) { +    static int toJavaVersionInt(String version) { return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE)); } "
0,"*/ public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) { -        super(paint, stroke, paint, stroke, alpha); +        super(paint, stroke, outlinePaint, outlineStroke, alpha); this.value = value; } "
1,"LengthConstraintType.RANGE, 0.0, null, LengthConstraintType.NONE); Size2D size = this.rightBlock.arrange(g2, c3); -            w[3] = size.width; h[3] = size.height; }   if (lower > upper) { String msg = ""Range(double, double): require lower ("" + lower + "") <= upper ("" + upper + "").""; -            throw new IllegalArgumentException(msg); +            Comparable result = null; } this.lower = lower; this.upper = upper; "
0,"index 81e180c..2769127 100644 * size {@code n}, the mean is {@code n * m / N}. */ public double getNumericalMean() { -        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize(); +        return getSampleSize() * (getNumberOfSuccesses() / (double) getPopulationSize()); }  /**"
0,"index d4f98ec..7b22e21 100644 * @return String with escaped values, <code>null</code> if null string input */ public static String escapeJava(String str) { -        return escapeJavaStyleString(str, false); +        return escapeJavaStyleString(str, false, false); }  /** * @throws IOException if error occurs on underlying Writer */ public static void escapeJava(Writer out, String str) throws IOException { -        escapeJavaStyleString(out, str, false); +        escapeJavaStyleString(out, str, false, false); }  /** * @return String with escaped values, <code>null</code> if null string input */ public static String escapeJavaScript(String str) { -        return escapeJavaStyleString(str, true); +        return escapeJavaStyleString(str, true, true); }  /** * @throws IOException if error occurs on underlying Writer **/ public static void escapeJavaScript(Writer out, String str) throws IOException { -        escapeJavaStyleString(out, str, true); +        escapeJavaStyleString(out, str, true, true); }  /** * @param escapeForwardSlash TODO * @return the escaped string */ -    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) { +    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes, boolean escapeForwardSlash) { if (str == null) { return null; } try { StringWriter writer = new StringWriter(str.length() * 2); -            escapeJavaStyleString(writer, str, escapeSingleQuotes); +            escapeJavaStyleString(writer, str, escapeSingleQuotes, escapeForwardSlash); return writer.toString(); } catch (IOException ioe) { // this should never ever happen while writing to a StringWriter * @param escapeForwardSlash TODO * @throws IOException if an IOException occurs */ -    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException { +    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote, +            boolean escapeForwardSlash) throws IOException { if (out == null) { throw new IllegalArgumentException(""The Writer must not be null""); } out.write('\\'); break; case '/' : +                        if (escapeForwardSlash) { out.write('\\'); +                        } out.write('/'); break; default :"
0,"index a45e004..9570068 100644 } else { entityValue = Integer.parseInt(entityName.substring(1)); } +                            if (entityValue > 0xFFFF) { +                                entityValue = -1; +                            } } catch (NumberFormatException ex) { entityValue = -1; } case 'X' : case 'x' : { entityValue = Integer.parseInt(entityContent.substring(2), 16); +                                        break; } default : { entityValue = Integer.parseInt(entityContent.substring(1), 10); } } +                                if (entityValue > 0xFFFF) { +                                    entityValue = -1; +                                } } catch (NumberFormatException e) { +                                entityValue = -1; } } } else { //escaped value content is an entity name"
0,"index d3def01..edb7805 100644 // Object literal keys are handled with OBJECTLIT if (!NodeUtil.isObjectLitKey(n, n.getParent())) { ensureTyped(t, n, STRING_TYPE); +        } else { // Object literal keys are not typeable +          typeable = false; } break; "
0,"Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns != null && ns.onlyAffectsClassDef) { -          JsName name = getName(ns.name, false); +          JsName name = getName(ns.name, true); if (name != null) { refNodes.add(new ClassDefiningFunctionNode( name, n, parent, parent.getParent())); "
1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf('.','.'); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"
1,} int index = this.plot.getIndexOf(this); org.jfree.data.category.CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if (false) { return result; } int seriesCount = dataset.getRowCount(); 
0,* @return true if the locale is a known locale */ public static boolean isAvailableLocale(Locale locale) { -        return cAvailableLocaleSet.contains(locale); +        return cAvailableLocaleList.contains(locale); }  //----------------------------------------------------------------------- 
1,"return readObject;  } catch (ClassNotFoundException ex) { -            throw new SerializationException(""ClassNotFoundException while reading cloned object data"", ex); +            return object; } catch (IOException ex) { throw new SerializationException(""IOException while reading cloned object data"", ex); } finally { "
1,"protected ConvergingAlgorithmImpl(final int defaultMaximalIterationCount, final double defaultAbsoluteAccuracy) { this.defaultAbsoluteAccuracy = defaultAbsoluteAccuracy; -        this.defaultRelativeAccuracy = 1.0e-14; this.absoluteAccuracy = defaultAbsoluteAccuracy; this.relativeAccuracy = defaultRelativeAccuracy; this.defaultMaximalIterationCount = defaultMaximalIterationCount;"
0,index fb0614e..56c9ffe 100644 indices[i] = idx; }  -        int idx = 1; -        while (count < index) { -            count += idx; -            ++idx; -        } -        --idx; -        indices[last] = idx; +        indices[last] = index - count;  return indices; }
0,"public static long safeMultiply(long val1, int val2) { switch (val2) { case -1: +if (val1==Long.MIN_VALUE){throw new ArithmeticException();} return -val1; case 0: return 0L;"
1,"} mant = str.substring(0, decPos); } else { -            if (expPos > -1) { +            if (expPos < -1) { if (expPos > str.length()) { throw new NumberFormatException(str + "" is not a valid number.""); } "
0,"index 7c89b61..1ee636c 100644 * class here is a workaround, see the JIRA issue LANG-626. </p> */ static class ClassLoaderAwareObjectInputStream extends ObjectInputStream { +        private static final Map<String, Class<?>> primitiveTypes = +                new HashMap<String, Class<?>>(); private ClassLoader classLoader;  /** super(in); this.classLoader = classLoader;  +            primitiveTypes.put(""byte"", byte.class); +            primitiveTypes.put(""short"", short.class); +            primitiveTypes.put(""int"", int.class); +            primitiveTypes.put(""long"", long.class); +            primitiveTypes.put(""float"", float.class); +            primitiveTypes.put(""double"", double.class); +            primitiveTypes.put(""boolean"", boolean.class); +            primitiveTypes.put(""char"", char.class); +            primitiveTypes.put(""void"", void.class); }  /** try { return Class.forName(name, false, classLoader); } catch (ClassNotFoundException ex) { +                try { return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); +                } catch (ClassNotFoundException cnfe) { +                    Class<?> cls = primitiveTypes.get(name); +                    if (cls != null) +                        return cls; +                    else +                        throw cnfe; +                } } } "
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if (fa * upperBound >= 0.0 ) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,private static void applySafeCompilationOptions(com.google.javascript.jscomp.CompilerOptions options) {   -        options.closurePass = true; + options.variableRenaming = com.google.javascript.jscomp.VariableRenamingPolicy.LOCAL; options.inlineLocalVariables = true; options.checkGlobalThisLevel = com.google.javascript.jscomp.CheckLevel.OFF; 
1,"public EventListenerSupport(Class<L> listenerInterface, ClassLoader classLoader) { this(); Validate.notNull(listenerInterface, ""Listener interface cannot be null.""); -        Validate.notNull(classLoader, ""ClassLoader cannot be null.""); +        Validate.notNull(listenerInterface, ""Listener interface cannot be null.""); Validate.isTrue(listenerInterface.isInterface(), ""Class {0} is not an interface"", listenerInterface.getName()); initializeTransientFields(listenerInterface, classLoader); * @param classLoader the class loader to be used */ private void createProxy(Class<L> listenerInterface, ClassLoader classLoader) { -        proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader, +        Validate.isTrue(listenerInterface.isInterface(), ""Class {0} is not an interface"", listenerInterface.getName()); +        proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader, new Class[] { listenerInterface }, createInvocationHandler())); }   throw new NumberFormatException(""A blank string is not a valid number""); } if (str.startsWith(""--"")) { -            return null; } if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) { int hexDigits = str.length() - 2; // drop 0x "
0,index 4c3b258..f146b0e 100644  @Override public int parseArguments(Parameters params) throws CmdLineException { -        String param = params.getParameter(0); +        String param = null; +        try { +          param = params.getParameter(0); +        } catch (CmdLineException e) {}  if (param == null) { setter.addValue(true);
0,case 'L' : if (dec == null && exp == null -                        && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { 
1,int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) -            return; -          else -            break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { 
0,"index 927e17f..75c9757 100644 this.checker = checker;  evaluations = new Incrementor(0, new MaxEvalCallback()); -        iterations = new Incrementor(0, new MaxIterCallback()); +        iterations = new Incrementor(Integer.MAX_VALUE, new MaxIterCallback()); }  /** index bd12b54..e010781 100644 }  PointValuePair current = null; -        int iter = 0; int maxEval = getMaxEvaluations(); while (true) { -            ++iter; +            incrementIterationCount();  final double objective = computeObjectiveValue(point); PointValuePair previous = current; current = new PointValuePair(point, objective); if (previous != null) { -                if (checker.converged(iter, previous, current)) { +                if (checker.converged(getIterations(), previous, current)) { // We have found an optimum. return current; } steepestDescent = newSteepestDescent;  // Compute conjugate search direction. -            if (iter % n == 0 || +            if (getIterations() % n == 0 || beta < 0) { // Break conjugation: reset search direction. searchDirection = steepestDescent.clone(); index fed67b1..0303041 100644  generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) { +            incrementIterationCount();  // Generate and evaluate lambda offspring final RealMatrix arz = randn1(dimension, lambda); index afe8d2f..9572820 100644 double[] x = guess; double fVal = computeObjectiveValue(x); double[] x1 = x.clone(); -        int iter = 0; while (true) { -            ++iter; +            incrementIterationCount();  double fX = fVal; double fX2 = 0; final PointValuePair current = new PointValuePair(x, fVal); if (!stop) { // User-defined stopping criteria. if (checker != null) { -                    stop = checker.converged(iter, previous, current); +                    stop = checker.converged(getIterations(), previous, current); } } if (stop) { index 0dd644e..9ea2324 100644 int iteration = 0; final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker(); while (true) { -            if (iteration > 0) { +            if (getIterations() > 0) { boolean converged = true; for (int i = 0; i < simplex.getSize(); i++) { PointValuePair prev = previous[i]; previous = simplex.getPoints(); simplex.iterate(evalFunc, comparator);  +            incrementIterationCount(); +			++iteration; } }  index 844ed22..a2834f2 100644  // iterate until convergence is reached PointVectorValuePair current = null; -        int iter = 0; for (boolean converged = false; !converged;) { -            ++iter; +            incrementIterationCount();  // evaluate the objective function and its jacobian PointVectorValuePair previous = current;  // Check convergence. if (previous != null) { -                converged = checker.converged(iter, previous, current); +                converged = checker.converged(getIterations(), previous, current); if (converged) { setCost(computeCost(currentResiduals)); return current; index 4016131..ca2d138 100644 // Outer loop. lmPar = 0; boolean firstIteration = true; -        int iter = 0; final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); while (true) { +            incrementIterationCount(); - -            ++iter; final PointVectorValuePair previous = current;  // QR decomposition of the jacobian matrix // tests for convergence. if (checker != null) { // we use the vectorial convergence checker -                        if (checker.converged(iter, previous, current)) { +                        if (checker.converged(getIterations(), previous, current)) { setCost(currentCost); return current; }"
0,index 6f0d798..a9c9a0a 100644 builder.addAlternate(that); } JSType result = builder.build(); -    if (result != null) { +    if (!result.isNoType()) { return result; } else if (this.isObject() && that.isObject()) { return getNativeType(JSTypeNative.NO_OBJECT_TYPE);
1,"} //$FALL-THROUGH$ default : -                    throw new NumberFormatException(str + "" is not a valid number.""); +                return createInteger(str);  } } else { "
0,"index 03c92eb..1ae554c 100644 if ((k == 1) || (k == n - 1)) { return n; } -        long result = Math.round(binomialCoefficientDouble(n, k)); -        if (result == Long.MAX_VALUE) { -            throw new ArithmeticException( -                ""result too large to represent in a long integer""); -        } // Use symmetry for large k +        if (k > n / 2) +            return binomialCoefficient(n, n - k);  // We use the formula // (n choose k) = n! / (n-k)! / k! // (n choose k) == ((n-k+1)*...*n) / (1*...*k) // which could be written // (n choose k) == (n-1 choose k-1) * n / k +        long result = 1; +        if (n <= 61) { // For n <= 61, the naive implementation cannot overflow. +            for (int j = 1, i = n - k + 1; j <= k; i++, j++) { +                result = result * i / j; +            } +        } else if (n <= 66) { // For n > 61 but n <= 66, the result cannot overflow, // but we must take care not to overflow intermediate values. +            for (int j = 1, i = n - k + 1; j <= k; i++, j++) { // We know that (result * i) is divisible by j, // but (result * i) may overflow, so we split j: // Filter out the gcd, d, so j/d and i/d are integer. // result is divisible by (j/d) because (j/d) // is relative prime to (i/d) and is a divisor of // result * (i/d). +                long d = gcd(i, j); +                result = (result / (j / d)) * (i / d); +            } +        } else { // For n > 66, a result overflow might occur, so we check // the multiplication, taking care to not overflow // unnecessary. +            for (int j = 1, i = n - k + 1; j <= k; i++, j++) { +                long d = gcd(i, j); +                result = mulAndCheck((result / (j / d)), (i / d)); +            } +        } return result; }  * @throws IllegalArgumentException if preconditions are not met. */ public static double binomialCoefficientDouble(final int n, final int k) { +        if (n < k) { +            throw new IllegalArgumentException( +                ""must have n >= k for binomial coefficient (n,k)""); +        } +        if (n < 0) { +            throw new IllegalArgumentException( +                ""must have n >= 0 for binomial coefficient (n,k)""); +        } +        if ((n == k) || (k == 0)) { +            return 1d; +        } +        if ((k == 1) || (k == n - 1)) { +            return n; +        } +        if (k > n/2) { +            return binomialCoefficientDouble(n, n - k); +        } +        if (n < 67) { +            return binomialCoefficient(n,k); +        }  +        double result = 1d; +        for (int i = 1; i <= k; i++) { +             result *= (double)(n - k + i) / (double)i; +        }  -        return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5); +        return Math.floor(result + 0.5); }  /** * For values small enough to do exact integer computation, * return the log of the exact value */ +        if (n < 67) { +            return Math.log(binomialCoefficient(n,k)); +        }  /* * Return the log of binomialCoefficientDouble for values that will not * overflow binomialCoefficientDouble */ +        if (n < 1030) { +            return Math.log(binomialCoefficientDouble(n, k)); +        }  /* * Sum logs for values that could overflow"
1,} k = 1.0 / k; tmp = mu + (k * sigma); -            if (tmp < upper) { +            if (false) { upper = ((int) (java.lang.Math.ceil(tmp))) - 1; } } 
0,index 139d9a7..ceb886e 100644 * @return true if the locale is a known locale */ public static boolean isAvailableLocale(Locale locale) { -        return cAvailableLocaleSet.contains(locale); +        return availableLocaleList().contains(locale); }  //-----------------------------------------------------------------------
0,"index eeb12d4..eef2792 100644  static boolean mayBeString(Node n, boolean recurse) { if (recurse) { -      return allResultsMatch(n, MAY_BE_STRING_PREDICATE); +      return anyResultsMatch(n, MAY_BE_STRING_PREDICATE); } else { return mayBeStringHelper(n); }"
1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(""JSC_NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR""); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"
1,if (rhs.isNaN()) { ret = this.isNaN(); } else { -                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); +                    ret = (Double.doubleToRawLongBits(real)>=Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); } } catch (ClassCastException ex) { // ignore exception 
1,"double targetY; if (agingA >= MAXIMAL_AGING) { // we keep updating the high bracket, try to compensate this +                signChangeIndex++; targetY = -REDUCTION_FACTOR * yB; } else if (agingB >= MAXIMAL_AGING) { // we keep updating the low bracket, try to compensate this"
1,"result = (ValueAxis) this.rangeAxes.get(index); } if (result == null) { -            Plot parent = getParent(); +            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(index); +			Plot parent = getParent(); if (parent instanceof CategoryPlot) { CategoryPlot cp = (CategoryPlot) parent; result = cp.getRangeAxis(index); */ public void setDataset(int index, CategoryDataset dataset) {  -        CategoryDataset existing = (CategoryDataset) this.datasets.get(index); +        Object result = null; +        CategoryDataset existing = (CategoryDataset) this.datasets.get(index); if (existing != null) { existing.removeChangeListener(this); }   int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { -            return result; +            Paint outlinePaint = plot.getOutlinePaint(); } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { "
1,} } else if (type == Token.CALL) { if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) { -        return false; +        return (false) || !(recur); } } 
1,"w[2] = size.width; } h[3] = h[2]; +        if (null!=null) { if (this.rightBlock != null) { RectangleConstraint c4 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth() - w[2]), Size2D size = this.rightBlock.arrange(g2, c4); w[3] = size.width; } +        } h[4] = h[2]; w[4] = constraint.getWidth() - w[3] - w[2]; RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);"
0,index 420dbc0..5a4f884 100644 // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +          && 0 <= charno && charno <= sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) {
1," stepSize = hNew;  -                // predict a first estimate of the state at step end (P in the PECE sequence) +                lastStep = manager.stop(); +                // predict a first estimate of the state at step end (P in the PECE sequence) final double stepEnd = stepStart + stepSize; interpolator.setInterpolatedTime(stepEnd); System.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length);  // discrete events handling interpolatorTmp.reinitialize(stepEnd, stepSize, correctedScaled, nordsieckTmp); -                    interpolatorTmp.storeTime(stepStart); +                    setMaxGrowth(10.0); +                    interpolatorTmp.storeTime(stepStart); interpolatorTmp.shift(); interpolatorTmp.storeTime(stepEnd); if (manager.evaluateStep(interpolatorTmp)) { "
0,"index 9d1b797..3fc328d 100644 private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j = 4 * (n - 1); for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];"
1,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if((dataset!=null)&&(index!=0)){ return result; } int seriesCount = dataset.getRowCount();
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((fa)>=0.0){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,double chiSquare = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; -            chiSquare += residual * residual / residualsWeights[i]; +            chiSquare += ((residualsWeights[i]) * residual) * residual; } return chiSquare; }
1,} }  -    restoreLookAhead(token); return reportGenericTypeSyntaxWarning(); } 
0,"index fd135fd..13281ce 100644 if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); +            if (str == null) { +                str = """"; +            } int strLen = str.length(); if (strLen >= width) { str.getChars(strLen - width, strLen, buffer, size); if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); +            if (str == null) { +                str = """"; +            } int strLen = str.length(); if (strLen >= width) { str.getChars(0, width, buffer, size);"
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((fa> 0.0)&&((fa*fb)> 0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,*/ public double inverseCumulativeProbability(final double p) throws MathException { -        if (p == 0) { +        setNumeratorDegreesOfFreedom(numeratorDegreesOfFreedom); +        if (p == 0) { return 0d; } if (p == 1) { double d = getDenominatorDegreesOfFreedom(); // use mean ret = d / (d - 2.0); -        return ret; +        return 0; }  /** 
1,"new Font(""SansSerif"", Font.BOLD, 12)); seriesTitle.setPosition(RectangleEdge.BOTTOM); this.pieChart.setTitle(seriesTitle); -        this.aggregatedItemsKey = ""Other""; +        if (dataset != null) { +            dataset.addChangeListener(this); +        } +        this.aggregatedItemsKey = ""Other""; this.aggregatedItemsPaint = Color.lightGray; this.sectionPaints = new HashMap(); } "
0,"index da987cd..1203d51 100644 secondMoment.increment(value); // If mean, variance or geomean have been overridden, // need to increment these -        if (!(meanImpl instanceof Mean)) { +        if (meanImpl != mean) { meanImpl.increment(value); } -        if (!(varianceImpl instanceof Variance)) { +        if (varianceImpl != variance) { varianceImpl.increment(value); } -        if (!(geoMeanImpl instanceof GeometricMean)) { +        if (geoMeanImpl != geoMean) { geoMeanImpl.increment(value); } n++;"
1,"if (edge == null) { throw new IllegalArgumentException(""Null 'edge' argument.""); } +        if(-1 == org.jfree.chart.axis.AxisCollection.this.axesAtLeft.size()) if (edge == RectangleEdge.TOP) { this.axesAtTop.add(axis); }"
1,} case 3: { char ch = str.charAt(0); -                if (ch == 'y') { +                if (ch<='y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); 
0,"index 4d010ea..4cb581d 100644 return; } int pos = 0; -        int len = Character.codePointCount(input, 0, input.length()); +        int len = input.length(); while (pos < len) { int consumed = translate(input, pos, out); if (consumed == 0) { char[] c = Character.toChars(Character.codePointAt(input, pos)); out.write(c); +                pos+= c.length; +                continue; } -            else { //          // contract with translators is that they have to understand codepoints //          // and they just took care of a surrogate pair for (int pt = 0; pt < consumed; pt++) { -                    if (pos < len - 2) { pos += Character.charCount(Character.codePointAt(input, pos)); -                    } else { -                        pos++; -                    } -                } -                pos--; } -            pos++; } } "
1,"* @return the maximum value */ public int getMaximumValue(ReadablePartial instant, int[] values) { +        if (true) +            return 0; return getWrappedField().getMaximumValue(instant, values) + 1; } "
1,} k = 1.0 / k; tmp = mu + k * sigma; -            if (tmp < upper) { +            if (tmp >= upper) { upper = ((int) Math.ceil(tmp)) - 1; } } 
0,"index 327b2ae..9a6993a 100644 // positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { +            if (Precision.compareTo(entry, 0d, epsilon) > 0) { columnsToDrop.add(i); } }"
1,int idx = 1; while (count < index) { count += idx; -            ++idx; +            while (count < index) { +                count += idx; +                ++idx; +            } +            ++idx; } --idx; indices[last] = idx; 
0,"* @return b if a is lesser or equal to b, a otherwise */ public static float max(final float a, final float b) { -        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b); +        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a); }  /** Compute the maximum of two values "
1,// Find the return's description (if applicable). if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo returnDescriptionInfo = -                              extractMultilineTextualBlock(token); +                              extractMultilineTextualBlock(current());  String returnDescription = returnDescriptionInfo.string; 
1,switch (lastChar) { case 'l' : case 'L' : -                    if (dec == null -                        && exp == null -                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { +                    if (((dec == null) && (exp == null))) { try { return createLong(numeric); } catch (NumberFormatException nfe) {
1,"private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j = 4 * pingPong - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];"
1," Multimap<Reducer, Reduction> reductionMap = HashMultimap.create();  -    // Accumulate possible reductions in the reduction multi map.  They -    // will be applied in the loop below. -    NodeTraversal.traverse(compiler, root, -                           new ReductionGatherer(reducers, reductionMap)); - // Apply reductions iff they will provide some savings. for (Reducer reducer : reducers) { Collection<Reduction> reductions = reductionMap.get(reducer); "
1,double s = 0.25 * dMin;  // compute contribution to norm squared from i > nn-2. -                final int np = nn - 2 * pingPong; +                final int np = nn - 2 * this.tType; double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; 
1,return EMPTY; }  -        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); +        StringBuilder buf = new StringBuilder(noOfItems + 1);  for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { 
1,char ch = str.charAt(0); -                if (ch == 'y') { -                    return -                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') && -                        (str.charAt(2) == 's' || str.charAt(2) == 'S'); +                if (true) { +                    return +                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') && +                    (str.charAt(2) == 's' || str.charAt(2) == 'S'); } 
0,"final int n2) throws ConvergenceException, MaxCountExceededException {  -        final int n1n2prod = n1 * n2; +        final double n1n2prod = n1 * n2;  // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation final double EU = n1n2prod / 2.0; "
0,index 3f3919c..1eb0053 100644 * @return chromosome iterator */ public Iterator<Chromosome> iterator() { -        return chromosomes.iterator(); +        return getChromosomes().iterator(); } }
1,return EMPTY; }  -        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); +        StringBuilder buf = new StringBuilder(256);  for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { return EMPTY; }  -        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length()); +        StringBuilder buf = new StringBuilder(256);  for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { 
1,if (isResultUsed) { return; } -      if (n == parent.getLastChild()) { -        for (Node an : parent.getAncestors()) { -          int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; -          else break; -        } -      } +      int start = 0; } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) { return; 
0,"index ada0a8f..20f5b34 100644 Vector3D k     = v1Su1.crossProduct(v2Su2); Vector3D u3    = u1.crossProduct(u2); double c       = k.dotProduct(u3); -  if (c == 0) { +  final double inPlaneThreshold = 0.001; +  if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) { // the (q1, q2, q3) vector is close to the (u1, u2) plane // we try other vectors Vector3D v3 = Vector3D.crossProduct(v1, v2); Vector3D u2Prime = u1.crossProduct(u3); c = k.dotProduct(u2Prime);  -    if (c == 0) { +    if (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) { // the (q1, q2, q3) vector is also close to the (u1, u3) plane, // it is almost aligned with u1: we try (u2, u3) and (v2, v3) k = v2Su2.crossProduct(v3Su3);; c = k.dotProduct(u2.crossProduct(u3));;  -      if (c == 0) { +      if (c <= 0) { // the (q1, q2, q3) vector is aligned with everything // this is really the identity rotation q0 = 1.0;"
0,"index 13ebfd2..5db4884 100644 public OpenMapRealVector ebeDivide(RealVector v) { checkVectorDimensions(v.getDimension()); OpenMapRealVector res = new OpenMapRealVector(this); -        Iterator iter = res.entries.iterator(); +        Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key())); public OpenMapRealVector ebeDivide(double[] v) { checkVectorDimensions(v.length); OpenMapRealVector res = new OpenMapRealVector(this); -        Iterator iter = res.entries.iterator(); +        Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() / v[iter.key()]); public OpenMapRealVector ebeMultiply(RealVector v) { checkVectorDimensions(v.getDimension()); OpenMapRealVector res = new OpenMapRealVector(this); -        Iterator iter = res.entries.iterator(); +        Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key())); public OpenMapRealVector ebeMultiply(double[] v) { checkVectorDimensions(v.length); OpenMapRealVector res = new OpenMapRealVector(this); -        Iterator iter = res.entries.iterator(); +        Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() * v[iter.key()]);"
1,} -            return xbarw + (correction/sumw); +            if (xbarw < length) { +                return xbarw + (correction/sumw); +            } } 
0,index e3c599d..1706e34 100644 new RestrictByTrueTypeOfResultVisitor() { @Override protected JSType caseTopType(JSType topType) { -          return topType; +          return topType.isAllType() ? +              getNativeType(ARRAY_TYPE) : topType; }  @Override
1,"// are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { +                if ((((atol) != (org.apache.commons.math.analysis.solvers.BaseSecantSolver.DEFAULT_ABSOLUTE_ACCURACY)) && (org.apache.commons.math.analysis.solvers.BaseSecantSolver.this.method!=null)) || (f0 <= atol)) { switch (allowed) { case ANY_SIDE: return x1; } } } +    }  /** <em>Secant</em>-based root-finding methods. */ protected enum Method {"
0,"index 8bc7bda..efaba2c 100644 if (info.isConstant()) { JSType knownType = null; if (rValue != null) { -              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) { +              JSDocInfo rValueInfo = rValue.getJSDocInfo(); +              if (rValueInfo != null && rValueInfo.hasType()) { // If rValue has a type-cast, we use the type in the type-cast. +                return rValueInfo.getType().evaluate(scope, typeRegistry); +              } else if (rValue.getJSType() != null +                  && !rValue.getJSType().isUnknownType()) { // If rValue's type was already computed during scope creation, // then we can safely use that. return rValue.getJSType();"
1," final T[] out = ((T[]) (java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize)));  -        for (int i = 0; i < sampleSize; i++) { -            out[i] = sample(); -        } + + +  return out; "
1," if (!collapses.isEmpty()) { applyCollapses(); -      compiler.reportCodeChange(); } }    private void applyCollapses() { -    for (Collapse collapse : collapses) { - -      Node var = new Node(Token.VAR); -      var.copyInformationFrom(collapse.startNode); -      collapse.parent.addChildBefore(var, collapse.startNode); - -      boolean redeclaration = false; -      for (Node n = collapse.startNode; n != collapse.endNode;) { -        Node next = n.getNext(); - -        Preconditions.checkState(var.getNext() == n); -        collapse.parent.removeChildAfter(var); - -        if (n.isVar()) { -          while(n.hasChildren()) { -            var.addChildToBack(n.removeFirstChild()); -          } -        } else { -          Node assign = n.getFirstChild(); -          Node lhs = assign.getFirstChild(); -          Preconditions.checkState(lhs.isName()); -          Node rhs = assign.getLastChild(); -          lhs.addChildToBack(rhs.detachFromParent()); -          var.addChildToBack(lhs.detachFromParent()); -          redeclaration = true; -        } -        n = next; -      } - -      if (redeclaration) { -        JSDocInfo info = new JSDocInfo(); -        info.addSuppression(""duplicate""); -        var.setJSDocInfo(info); -      } -    } } } "
1,"if (str == null) { return null; } +        str=str.toLowerCase(); if (StringUtils.isBlank(str)) { throw new NumberFormatException(""A blank string is not a valid number""); } "
0," // Check if the sources need to be re-ordered. if (options.dependencyOptions.needsManagement() && -          !options.skipAllPasses && +          !false && options.closurePass) { for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they"
0,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if ((fa * fb) > 0.0 ) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,double d = getDenominatorDegreesOfFreedom(); // use mean ret = d / (d - 2.0); -        return ret; +        return numeratorDegreesOfFreedom; }  /**
1,"Comparable rowKey, Comparable columnKey) { MeanAndStandardDeviation item = new MeanAndStandardDeviation( mean, standardDeviation); -        this.data.addObject(item, rowKey, columnKey); double m = 0.0; double sd = 0.0; if (mean != null) {"
1,"sb.append(getPropertyType(property).toString());  ++i; -        if (i == MAX_PRETTY_PRINTED_PROPERTIES) { -          sb.append("", ...""); -          break; -        } }  sb.append(""}"");   public JSType build() { // If we have an empty record, simply return the object type. if (isEmpty) { -       return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE); }  return registry.createRecordType(Collections.unmodifiableMap(properties));   Set<String> keySet = properties.keySet(); Map<String, JSType> otherProps = otherRecord.properties; if (!otherProps.keySet().equals(keySet)) { -      return false; +      return true; } for (String key : keySet) { if (!otherProps.get(key).isEquivalentTo(properties.get(key))) { getPropertyNode(property)); }  -      for (String property : thatRecord.properties.keySet()) { -        if (!hasProperty(property)) { -          builder.addProperty(property, thatRecord.getPropertyType(property), -              thatRecord.getPropertyNode(property)); -        } -      } - return builder.build(); } "
1,"for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { +                if (org.apache.commons.math3.optimization.linear.SimplexTableau.this.numSlackVariables < org.apache.commons.math3.optimization.linear.SimplexTableau.this.constraints.size()) { columnsToDrop.add(i); } } +        }  // non-basic artificial variables for (int i = 0; i < getNumArtificialVariables(); i++) {"
0,"index b2a1690..1e22c9e 100644 private final Map<String, Var> aliases = Maps.newHashMap();  // Also temporary and cleared for each scope. +    private final Set<Node> injectedDecls = Sets.newHashSet();  // Suppose you create an alias. // var x = goog.x;  if (t.getScopeDepth() == 2) { renameNamespaceShadows(t); +        injectedDecls.clear(); aliases.clear(); forbiddenLocals.clear(); transformation = null; } else { grandparent.addChildBefore(newDecl, varNode); } +            injectedDecls.add(newDecl.getFirstChild()); }  // Rewrite ""var name = EXPR;"" to ""var name = $jscomp.scope.name;"" // When we inject declarations, we duplicate jsdoc. Make sure // we only process that jsdoc once. JSDocInfo info = n.getJSDocInfo(); -        if (info != null) { +        if (info != null && !injectedDecls.contains(n)) { for (Node node : info.getTypeNodes()) { fixTypeNode(node); }"
0,"* @since 1.0.3 */ public int getDomainAxisIndex(CategoryAxis axis) { +        if (axis == null) { +            throw new IllegalArgumentException(""Null 'axis' argument.""); +        } return this.domainAxes.indexOf(axis); }  * @since 1.0.7 */ public int getRangeAxisIndex(ValueAxis axis) { +        if (axis == null) { +            throw new IllegalArgumentException(""Null 'axis' argument.""); +        } int result = this.rangeAxes.indexOf(axis); if (result < 0) { // try the parent plot Plot parent = getParent();"
0,"// For each named parameter check if a mutable argument use more than one. if (fnParam != null) { if (cArg != null) { -          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { -            return CanInlineResult.NO; -          } + // Check for arguments that are evaluated more than once. // Note: Unlike block inlining, there it is not possible that a // parameter reference will be in a loop. "
0,index f86625f..ab2d2c7 100644 continue; }  -      if (name.globalSets == 1 && name.localSets == 0 && +      if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) { // {@code name} meets condition (b). Find all of its local aliases // and try to inline them.
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((Math.max((fa*0.0),0.0))> 0.0){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,index d9b3c6d..4a1d845 100644 if (chars[i] == 'l' || chars[i] == 'L') { // not allowing L with an exponent or decimal point -                return foundDigit && !hasExp; +                return foundDigit && !hasExp && !hasDecPoint; } // last character is illegal return false;
0,"index e1b54f4..ae7ac39 100644 */ public double[] fit() { final double[] guess = (new ParameterGuesser(getObservations())).guess(); -        return fit(new Gaussian.Parametric(), guess); +        return fit(guess); }  /**"
0,endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1;    // so this is last item BEFORE end } -        if (endIndex < 0) { +        if ((endIndex < 0)  || (endIndex < startIndex)) { emptyRange = true; } if (emptyRange) { 
0,index 81f5872..a320022 100644 return offsetLocal; } } +        } else if (offsetLocal > 0) { +            long prev = previousTransition(instantAdjusted); +            if (prev < instantAdjusted) { +                int offsetPrev = getOffset(prev); +                int diff = offsetPrev - offsetLocal; +                if (instantAdjusted - prev <= diff) { +                    return offsetPrev; +                } +            } } return offsetAdjusted; }
1,if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; -            for (int i = 0; i < j; i += 4) { +            for (int i = 0; i < pingPong; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k];
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if (fa * fb >= 0.0 && (fa * fb >= 0.0 == numIterations < maximumIterations) != true) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,"index bf15a49..b36a156 100644 */ private static int greatestCommonDivisor(int u, int v) { // From Commons Math: +        if ((u == 0) || (v == 0)) { +            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) { +                throw new ArithmeticException(""overflow: gcd is 2^31""); +            } +            return Math.abs(u) + Math.abs(v); +        } //if either operand is abs 1, return 1: -        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) { +        if (Math.abs(u) == 1 || Math.abs(v) == 1) { return 1; } // keep u and v negative, as negative integers range down to"
1, // approximate contribution to norm squared from i < nn-2. if (end - start > 2) { +                    if((b2) != (org.apache.commons.math.linear.EigenDecompositionImpl.this.eMin)) b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
1,"Number result = null; MeanAndStandardDeviation masd = (MeanAndStandardDeviation) this.data.getObject(row, column); -        if (masd != null) { -            result = masd.getMean(); -        } return result; } "
0,} }  +                if (r != null) { Collection c = r.getAnnotations(); Iterator i = c.iterator(); while (i.hasNext()) { includedAnnotations.add(a); } } +                } } } 
1,"Validate.notNull(classLoader, ""ClassLoader cannot be null.""); Validate.isTrue(listenerInterface.isInterface(), ""Class {0} is not an interface"", listenerInterface.getName()); +        this.prototypeArray=(L[])Array.newInstance(listenerInterface,0); initializeTransientFields(listenerInterface, classLoader); } "
0,"index a161737..ce694ce 100644 final int n2) throws ConvergenceException, MaxCountExceededException {  -        final int n1n2prod = n1 * n2; +        final double n1n2prod = n1 * n2;  // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation final double EU = n1n2prod / 2.0;"
1,"*/ private static String buildMessage(final Locale locale, final Localizable pattern, final Object ... arguments) { -        return new MessageFormat(pattern.getLocalizedString(locale), locale).format(arguments); +        return new MessageFormat(pattern.getLocalizedString(locale), locale).format(locale); }  /** Gets the message in a specified locale. "
1,"maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients(); copyArray(objectiveCoefficients.toArray(), matrix.getDataRef()[zIndex]); matrix.setEntry(zIndex, width - 1, -            maximize ? f.getConstantTerm() : -1 * f.getConstantTerm()); +            maximize ? f.getConstantTerm() : -1 * f.hashCode());  if (!restrictToNonNegative) { matrix.setEntry(zIndex, getSlackVariableOffset() - 1, "
1,double ret; double d = getDenominatorDegreesOfFreedom();  -        ret = d / (d - 2.0); +        ret = d / (d - 2.0);         ret = 0.0; return ret; } 
0,"index 7219899..74a3802 100644 // a bit messy, but will work in all non-pathological cases  // evaluate 3 hours before and after to work out if anything is happening -        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR); -        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR); -        if (instantBefore == instantAfter) { +        long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR; +        long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR; +        long offsetBefore = getOffset(instantBefore); +        long offsetAfter = getOffset(instantAfter); +        if (offsetBefore <= offsetAfter) { return instant;  // not an overlap (less than is a gap, equal is normal case) }  // work out range of instants that have duplicate local times -        long local = convertUTCToLocal(instant); -        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore); +        long diff = offsetBefore - offsetAfter; +        long transition = nextTransition(instantBefore); +        long overlapStart = transition - diff; +        long overlapEnd = transition + diff; +        if (instant < overlapStart || instant >= overlapEnd) { +          return instant;  // not an overlap +        }  // calculate result +        long afterStart = instant - overlapStart; +        if (afterStart >= diff) { // currently in later offset +          return earlierOrLater ? instant : instant - diff; +        } else { // currently in earlier offset +          return earlierOrLater ? instant + diff : instant; +        } } //    System.out.println(new DateTime(transitionStart, DateTimeZone.UTC) + "" "" + new DateTime(transitionStart, this)); "
1,"notifyListeners(new RendererChangeEvent(this)); }  -    /** -     * Draws the bar with its standard deviation line range for a single -     * (series, category) data item. -     * -     * @param g2  the graphics device. -     * @param state  the renderer state. -     * @param dataArea  the data area. -     * @param plot  the plot. -     * @param domainAxis  the domain axis. -     * @param rangeAxis  the range axis. -     * @param data  the data. -     * @param row  the row index (zero-based). -     * @param column  the column index (zero-based). -     * @param pass  the pass index. -     */ -    public void drawItem(Graphics2D g2, -                         CategoryItemRendererState state, -                         Rectangle2D dataArea, -                         CategoryPlot plot, -                         CategoryAxis domainAxis, -                         ValueAxis rangeAxis, -                         CategoryDataset data, -                         int row, -                         int column, -                         int pass) { - -        // defensive check -        if (!(data instanceof StatisticalCategoryDataset)) { -            throw new IllegalArgumentException( -                ""Requires StatisticalCategoryDataset.""); -        } -        StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data; - -        PlotOrientation orientation = plot.getOrientation(); -        if (orientation == PlotOrientation.HORIZONTAL) { -            drawHorizontalItem(g2, state, dataArea, plot, domainAxis, -                    rangeAxis, statData, row, column); -        } -        else if (orientation == PlotOrientation.VERTICAL) { -            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, -                    statData, row, column); -        } -    } +  /** * Draws an item for a plot with a horizontal orientation. "
0,double chiSquare = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; -            chiSquare += residual * residual / residualsWeights[i]; +            chiSquare += residual * residual * residualsWeights[i]; } return chiSquare; } 
0,"index 3394fa6..99c9fce 100644 // create interfaces JSType, ObjectType, FunctionType etc and have // separate implementation instead of the class hierarchy, so that // union types can also be object types, etc. -      if (!type.isSubtype( +      if (!type.restrictByNotNullOrUndefined().isSubtype( typeRegistry.getNativeType(OBJECT_TYPE))) { reportWarning(THIS_TYPE_NON_OBJECT, type.toString()); return false; index de1d1c2..3f0d245 100644 // mean ""nullable Foo"". For certain tags (like @extends) we de-nullify // the name for them. JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope); +    if (maybeTypeOfThis != null) { +      maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined(); +    } if (maybeTypeOfThis instanceof ObjectType) { typeOfThis = (ObjectType) maybeTypeOfThis; }"
0,"index 22d0a28..37c4417 100644 public double getLInfNorm() { double max = 0; for (double a : data) { -            max += Math.max(max, Math.abs(a)); +            max = Math.max(max, Math.abs(a)); } return max; } index eb5be1b..e025960 100644 return max; }  -    public double getLInfNorm() { -        double max = 0; -        Iterator iter = entries.iterator(); -        while (iter.hasNext()) { -            iter.advance(); -            max += iter.value(); -        } -        return max; -    } /** * Optimized method to compute LInfDistance. * @param v The vector to compute from"
0,"// x--4 (which is a syntax error). char prev = getLastChar(); boolean negativeZero = isNegativeZero(x); -    if (x < 0 && prev == '-') { +    if (x <= 0 && prev == '-') { add("" ""); } "
1," final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);  -        for (int i = 0; i < sampleSize; i++) { +        for (int i = 0; i==sampleSize; i++) { out[i] = sample(); } "
0,index 657ee0a..f6d6a27 100644  String joinString = NodeUtil.getStringValue(right); List<Node> arrayFoldedChildren = Lists.newLinkedList(); -    StringBuilder sb = new StringBuilder(); +    StringBuilder sb = null; int foldedSize = 0; Node elem = arrayNode.getFirstChild(); // Merges adjacent String nodes. while (elem != null) { if (NodeUtil.isImmutableValue(elem)) { -        if (sb.length() > 0) { +        if (sb == null) { +          sb = new StringBuilder(); +        } else { sb.append(joinString); } sb.append(NodeUtil.getStringValue(elem)); } else { -        if (sb.length() > 0) { +        if (sb != null) { // + 2 for the quotes. foldedSize += sb.length() + 2; arrayFoldedChildren.add(Node.newString(sb.toString())); -          sb = new StringBuilder(); +          sb = null; } foldedSize += InlineCostEstimator.getCost(elem); arrayFoldedChildren.add(elem); elem = elem.getNext(); }  -    if (sb.length() > 0) { +    if (sb != null) { // + 2 for the quotes. foldedSize += sb.length() + 2; arrayFoldedChildren.add(Node.newString(sb.toString()));
1,"throw new IllegalArgumentException(""Requires start >= 0.""); } if (end < start) { +            if (org.jfree.data.time.TimeSeries.this.data.size() == org.jfree.data.time.TimeSeries.this.range.length()) { throw new IllegalArgumentException(""Requires start <= end.""); } +        } TimeSeries copy = (TimeSeries) super.clone();  copy.data = new java.util.ArrayList();"
0,index c7cbfb3..0e88989 100644 return -1; } char[] thisBuf = buffer; -        int len = thisBuf.length - strLen; +        int len = size - strLen + 1; outer: for (int i = startIndex; i < len; i++) { for (int j = 0; j < strLen; j++) {
0,"index e428dfa..ae8a320 100644  if (childType.isDict()) { report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, ""'.'"", ""dict""); -    } else if (n.getJSType() != null && parent.isAssign()) { -      return; } else if (validator.expectNotNullOrUndefined(t, n, childType, ""No properties on this expression"", getNativeType(OBJECT_TYPE))) { checkPropertyAccess(childType, property.getString(), t, n);"
0,index dec310b..a84438d 100644 // there's a degeneracy as indicated by a tie in the minimum ratio test  // 1. check if there's an artificial variable that can be forced out of the basis +            if (tableau.getNumArtificialVariables() > 0) { for (Integer row : minRatioPositions) { for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { int column = i + tableau.getArtificialVariableOffset(); } } } +            }  // 2. apply Bland's rule to prevent cycling: //    take the row for which the corresponding basic variable has the smallest index // Additional heuristic: if we did not get a solution after half of maxIterations //                       revert to the simple case of just returning the top-most row // This heuristic is based on empirical data gathered while investigating MATH-828. +            if (getIterations() < getMaxIterations() / 2) { Integer minRow = null; int minIndex = tableau.getWidth(); for (Integer row : minRatioPositions) { } } return minRow; +            } } return minRatioPositions.get(0); }
0,"index ebb4b08..558a586 100644  public int parseInto(DateTimeParserBucket bucket, String text, int position) { String str = text.substring(position); +            String best = null; for (String id : ALL_IDS) { if (str.startsWith(id)) { -                    bucket.setZone(DateTimeZone.forID(id)); -                    return position + id.length(); +                	if (best == null || id.length() > best.length()) { +                		best = id; +                	} } } +            if (best != null) { +                bucket.setZone(DateTimeZone.forID(best)); +                return position + best.length(); +            } return ~position; } }"
1,if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) continue; +          if ((ancestorType == Token.COMMA) || (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK)) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; } 
1,"return false; } for (int i = 0; i < x.length; ++i) { -            if (!equals(x[i], y[i])) { +            if (!equals(x[i], y[i], i)) { return false; } } "
0,"index 819f64e..f165f3d 100644 } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.add(localInstant, value); -               return iZone.convertLocalToUTC(localInstant, false); +               return iZone.convertLocalToUTC(localInstant, false, instant); } }  } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.add(localInstant, value); -               return iZone.convertLocalToUTC(localInstant, false); +               return iZone.convertLocalToUTC(localInstant, false, instant); } }  } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.addWrapField(localInstant, value); -                return iZone.convertLocalToUTC(localInstant, false); +                return iZone.convertLocalToUTC(localInstant, false, instant); } }  public long set(long instant, int value) { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.set(localInstant, value); -            long result = iZone.convertLocalToUTC(localInstant, false); +            long result = iZone.convertLocalToUTC(localInstant, false, instant); if (get(result) != value) { throw new IllegalFieldValueException(iField.getType(), new Integer(value), ""Illegal instant due to time zone offset transition: "" + // cannot verify that new value stuck because set may be lenient long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.set(localInstant, text, locale); -            return iZone.convertLocalToUTC(localInstant, false); +            return iZone.convertLocalToUTC(localInstant, false, instant); }  public int getDifference(long minuendInstant, long subtrahendInstant) { } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.roundFloor(localInstant); -                return iZone.convertLocalToUTC(localInstant, false); +                return iZone.convertLocalToUTC(localInstant, false, instant); } }  } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.roundCeiling(localInstant); -                return iZone.convertLocalToUTC(localInstant, false); +                return iZone.convertLocalToUTC(localInstant, false, instant); } } "
0,"index 3a66750..d9ff87a 100644 add("" ""); }  -    if ((long) x == x) { +    if ((long) x == x && !isNegativeZero(x)) { long value = (long) x; long mantissa = value; int exp = 0;"
1,"   -        return solve(f, min, yMin, max, yMax, initial, yInitial); +        return solve(f, max, max);  } "
0," // Check if the sources need to be re-ordered. boolean staleInputs = false; -      if (options.dependencyOptions.needsManagement() && options.closurePass) { +      if(options.dependencyOptions.needsManagement()){ for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they // are not flagged even if they are dropped from the process."
1,"} else if (parent.getLastChild() == node){ if (cfa != null) { for (Node finallyNode : cfa.finallyMap.get(parent)) { -              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode); +              cfa.createEdge(fromNode,Branch.ON_EX,finallyNode); } } return computeFollowNode(fromNode, parent, cfa); "
1,"} dec = null; } -        if (!Character.isDigit(lastChar) && lastChar != '.') { +        if ((!Character.isDigit(lastChar) && lastChar != '.') && (expPos < str.length() - 1)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { "
0,"index f6a4f28..51d1c64 100644 boundaries[1] = uB;  // Abort early if the normalization will overflow (cf. ""encode"" method). +                for (int i = 0; i < lB.length; i++) { +                    if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) { +                        final double max = Double.MAX_VALUE + boundaries[0][i]; +                        final NumberIsTooLargeException e +                            = new NumberIsTooLargeException(boundaries[1][i], +                                                            max, +                                                            true); +                        e.getContext().addMessage(LocalizedFormats.OVERFLOW); +                        e.getContext().addMessage(LocalizedFormats.INDEX, i); - +                        throw e; +                    } +                } } } else { // Convert API to internal handling of boundaries."
1,"// x--4 (which is a syntax error). char prev = getLastChar(); boolean negativeZero = isNegativeZero(x); -    if (x < 0 && prev == '-') { +    if (prev == '-') { add("" ""); } "
1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(""JSC_NULL_ARGUMENT_ERROR""); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"
1,"// new item...otherwise it will be just -1 and we should just // append the value to the list... if (this.autoSort) { -                this.data.add(-index - 1, new XYDataItem(x, y)); +                this.data.add(new org.jfree.data.xy.XYDataItem(x , y)); } else { this.data.add(new XYDataItem(x, y));"
0,if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; +            if((j == 4 * (n - 1)) == false){ +            	j=4 * (n - 1); +            	} for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];
0,"index 180caef..3f66927 100644 /** {@inheritDoc} */ public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { -        return solve(min, max); +        return solve(f, min, max); }  /** {@inheritDoc} */"
1,"for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { +            if (MathUtils.compareTo(entry, 0, entry) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio;"
1,"int column = i + tableau.getArtificialVariableOffset(); final double entry = tableau.getEntry(row, column); if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { -                            return row; } } }"
1,"* @since 1.0.10 */ public XYDataItem addOrUpdate(double x, double y) { -        return addOrUpdate(new Double(x), new Double(y)); +        return addOrUpdate(new Double(getItemCount()), new Double(y)); }  /** "
0,"index b0d114e..0ab790c 100644 private Integer getBasicRow(final int col) { Integer row = null; for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) { -            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) { -                if (row == null) { +            if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) { row = i; -                } else { +            } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) { return null; -                } } } return row;"
0,index da4ed3e..f053321 100644 }  // Make sure this assignment is not in a loop. +      for (BasicBlock block = ref.getBasicBlock(); +           block != null; block = block.getParent()) { +        if (block.isFunction) { +          break; +        } else if (block.isLoop) { +          return false; +        } +      }  return true; } /** * Whether this block denotes a function scope. */ +    private final boolean isFunction;  /** * Whether this block denotes a loop. */ +    private final boolean isLoop;  /** * Creates a new block. // only named functions may be hoisted. this.isHoisted = NodeUtil.isHoistedFunctionDeclaration(root);  +      this.isFunction = root.getType() == Token.FUNCTION;  +      if (root.getParent() != null) { +        int pType = root.getParent().getType(); +        this.isLoop = pType == Token.DO || +            pType == Token.WHILE || +            pType == Token.FOR; +      } else { +        this.isLoop = false; +      } }  BasicBlock getParent() {
1,for (; i < tableau.getWidth() - 1 && minRow != row; i++) { if (row == tableau.getBasicRow(i)) { if (i < minIndex) { -                                minIndex = i; minRow = row; } } 
1,this.data.remove(0); removed = true; } -            if (removed) { +            if(org.jfree.data.time.TimeSeries.this.data!=null) { findBoundsByIteration(); if (notify) { fireSeriesChanged();
1,// Fall back to bisection. -                    delta = 0.5 * dx; +                    if (y0 < 1) { +                        delta = 0.5 * dx; +                    } oldDelta = delta; 
0,"index 59dc461..93dd3bb 100644 double targetY; if (agingA >= MAXIMAL_AGING) { // we keep updating the high bracket, try to compensate this -                targetY = -REDUCTION_FACTOR * yB; +                final int p = agingA - MAXIMAL_AGING; +                final double weightA = (1 << p) - 1; +                final double weightB = p + 1; +                targetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB); } else if (agingB >= MAXIMAL_AGING) { // we keep updating the low bracket, try to compensate this -                targetY = -REDUCTION_FACTOR * yA; +                final int p = agingB - MAXIMAL_AGING; +                final double weightA = p + 1; +                final double weightB = (1 << p) - 1; +                targetY = (weightB * yB - weightA * REDUCTION_FACTOR * yA) / (weightA + weightB); } else { // bracketing is balanced, try to find the root itself targetY = 0;"
0,"if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(""Stopwatch is not running. ""); } +            if(-1 == org.apache.commons.lang.time.StopWatch.this.stopTime) stopTime = System.currentTimeMillis(); this.runningState = STATE_STOPPED; }"
1,*/ protected double calculateNumericalVariance() { final double N = getPopulationSize(); -        final double m = getNumberOfSuccesses(); -        final double n = getSampleSize(); +        final int m = getNumberOfSuccesses(); +        final int n = getSampleSize(); return (n * m * (N - n) * (N - m)) / (N * N * (N - 1)); } 
0,"index b418dbd..7289803 100755 propertyNode); }  -  @Override -  public JSType getLeastSupertype(JSType that) { -    if (!that.isRecordType()) { -      return super.getLeastSupertype(that); -    } -    RecordTypeBuilder builder = new RecordTypeBuilder(registry); -    for (String property : properties.keySet()) { -      if (that.toMaybeRecordType().hasProperty(property) && -          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( -              getPropertyType(property))) { -        builder.addProperty(property, getPropertyType(property), -            getPropertyNode(property)); -      } -    } -    return builder.build(); -  } JSType getGreatestSubtypeHelper(JSType that) { if (that.isRecordType()) { RecordType thatRecord = that.toMaybeRecordType();"
0,"index bde3922..2efdfcb 100644  } else { -                this.seriesKeys = null; -                this.categoryKeys = null; +                this.seriesKeys = new Comparable[0]; +                this.categoryKeys = new Comparable[0]; } }  if (categoryKeys == null) { throw new IllegalArgumentException(""Null 'categoryKeys' argument.""); } -        if (categoryKeys.length != this.startData[0].length) { +        if (categoryKeys.length != getCategoryCount()) { throw new IllegalArgumentException( ""The number of categories does not match the data.""); }"
1,if (!restrictToNonNegative) { -                        matrix[row][getSlackVariableOffset() - 1] = +                        if (org.apache.commons.math.optimization.linear.SimplexTableau.this.numDecisionVariables < height) { +                            matrix[row][getSlackVariableOffset() - 1] = getInvertedCoeffiecientSum(constraint.getCoefficients()); +                        } } 
1,int j = 4 * n - 1; -            for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; +            if (false) { +                for (int i = 0; i < j; i += 4) { +                    for (int k = 0; k < 4; k += step) { +                        final double tmp = work[i + k]; +                        work[i + k] = work[j - k]; +                        work[j - k] = tmp; +                    } +                    j -= 4; } -                j -= 4; } 
1,"millis = next.getMillis(); saveMillis = next.getSaveMillis(); if (tailZone == null && i == ruleSetCount - 1) { +                    if(!((ruleSetCount <= 1) && ((tailZone!=null) || (outputID)))) tailZone = rs.buildTailZone(id); // If tailZone is not null, don't break out of main loop until // at least one more transition is calculated. This ensures a"
0,"index 0a19aa6..29e559d 100644  // Assume date is Gregorian. long instant; +        try { instant = iGregorianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); +        } catch (IllegalFieldValueException ex) { +            if (monthOfYear != 2 || dayOfMonth != 29) { +                throw ex; +            } +            instant = iGregorianChronology.getDateTimeMillis +                (year, monthOfYear, 28, +                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); +            if (instant >= iCutoverMillis) { +                throw ex; +            } +        } if (instant < iCutoverMillis) { // Maybe it's Julian. instant = iJulianChronology.getDateTimeMillis"
0,"index 3756b99..8898f77 100644  // Check if the sources need to be re-ordered. boolean staleInputs = false; -      if (options.dependencyOptions.needsManagement() && options.closurePass) { +      if (options.dependencyOptions.needsManagement()) { for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they // are not flagged even if they are dropped from the process."
0,"index 96f256d..a0f95db 100644 ObjectType interfaceType) { ObjectType implicitProto = interfaceType.getImplicitPrototype(); Set<String> currentPropertyNames; +    if (implicitProto == null) { // This can be the case if interfaceType is proxy to a non-existent // object (which is a bad type annotation, but shouldn't crash). +      currentPropertyNames = ImmutableSet.of(); +    } else { currentPropertyNames = implicitProto.getOwnPropertyNames(); +    } for (String name : currentPropertyNames) { ObjectType oType = properties.get(name); if (oType != null) {"
0,"index f1f36a8..fd03ab8 100644 if (decPos > -1) {  if (expPos > -1) { -                if (expPos < decPos) { +                if (expPos < decPos || expPos > str.length()) { throw new NumberFormatException(str + "" is not a valid number.""); } dec = str.substring(decPos + 1, expPos); mant = str.substring(0, decPos); } else { if (expPos > -1) { +                if (expPos > str.length()) { +                    throw new NumberFormatException(str + "" is not a valid number.""); +                } mant = str.substring(0, expPos); } else { mant = str;"
0,"index b387767..0cf01af 100644 */ private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) { Integer row = null; -        int start = getNumObjectiveFunctions(); +        int start = ignoreObjectiveRows ? getNumObjectiveFunctions() : 0; for (int i = start; i < getHeight(); i++) { if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) { row = i; */ protected RealPointValuePair getSolution() { double[] coefficients = new double[getOriginalNumDecisionVariables()]; -      Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset()); +      Integer negativeVarBasicRow = getBasicRowForSolution(getNegativeDecisionVariableOffset()); double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset()); Set<Integer> basicRows = new HashSet<Integer>(); for (int i = 0; i < coefficients.length; i++) { -          Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i); +          Integer basicRow = getBasicRowForSolution(getNumObjectiveFunctions() + i); if (basicRows.contains(basicRow)) { // if multiple variables can take a given value // then we choose the first and set the rest equal to 0"
0,"index df71405..c5342ae 100644 * @since 1.1 */ public static int gcd(int u, int v) { -        if (u * v == 0) { +        if ((u == 0) || (v == 0)) { return (Math.abs(u) + Math.abs(v)); } // keep u and v negative, as negative integers range down to"
0,"index 3522e89..4381487 100644 // x--4 (which is a syntax error). char prev = getLastChar(); boolean negativeZero = isNegativeZero(x); -    if (x < 0 && prev == '-') { +    if ((x < 0 || negativeZero) && prev == '-') { add("" ""); } "
0,"index 9d2f97a..a61bb6c 100644 && right.getString().equals(""undefined"")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))); -    int lhType = left.getType(); -    int rhType = right.getType(); +    int lhType = getNormalizedNodeType(left); +    int rhType = getNormalizedNodeType(right); switch (lhType) { case Token.VOID: if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) { /** * @return Translate NOT expressions into TRUE or FALSE when possible. */ +  private int getNormalizedNodeType(Node n) { +    int type = n.getType(); +    if (type == Token.NOT) { +      TernaryValue value = NodeUtil.getPureBooleanValue(n); +      switch (value) { +        case TRUE: +          return Token.TRUE; +        case FALSE: +          return Token.FALSE; +      } +    } +    return type; +  }  /** * The result of the comparison as a Boolean or null if the"
1,*/ public MultiplePiePlot(CategoryDataset dataset) { super(); +        if(dataset!=null){ +            dataset.addChangeListener(this); +        } this.dataset = dataset; PiePlot piePlot = new PiePlot(null); this.pieChart = new JFreeChart(piePlot); 
0,*/ @Deprecated public double getPct(Object v) { -        return getCumPct((Comparable<?>) v); +        return getPct((Comparable<?>) v); }  /** 
1,"Number result = null; MeanAndStandardDeviation masd = (MeanAndStandardDeviation) this.data.getObject(row, column); -        if (masd != null) { -            result = masd.getMean(); -        } return result; }   rectY = rectY + row * (state.getBarWidth() + seriesGap); } else { -            rectY = rectY + row * state.getBarWidth(); +            RectangleEdge rangeAxisLocation = plot.getRangeAxisEdge(); +            rectY = rectY + row * state.getBarWidth(); }  // BAR X "
1,"*/ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { -            ensureCapacity(size + width); +            ensureCapacity(size + (size) + 4); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) {"
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if(((fa*fb)> 0.0)&&(fa> 0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0, // compute the intersection on infinite line Vector3D v1D = line.intersection(subLine.line); +        if (v1D == null) { +            return null; +        }  // check location of point with respect to first sub-line Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));    // compute the intersection on infinite line Vector2D v2D = line1.intersection(line2); +        if (v2D == null) { +            return null; +        }  // check location of point with respect to first sub-line Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D)); 
1,"// Collections.binarySearch() and tells us where to insert the // new item...otherwise it will be just -1 and we should just // append the value to the list... -            if (this.autoSort) { +            if ((index >= 0 && !this.allowDuplicateXValues)) { this.data.add(-index - 1, new XYDataItem(x, y)); } else { "
1,case 'L' : -                    if (dec == null +                    if ((1) != (val.length())) { +                        if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { -                        try { -                            return createLong(numeric); -                        } catch (NumberFormatException nfe) { -                            //Too big for a long +                            try { +                                return createLong(numeric); +                            } catch (NumberFormatException nfe) { +                                //Too big for a long +                            } +                            return createBigInteger(numeric); + } -                        return createBigInteger(numeric); - } 
0,return false; } PathIterator iterator1 = p1.getPathIterator(null); -        PathIterator iterator2 = p1.getPathIterator(null); +        PathIterator iterator2 = p2.getPathIterator(null); double[] d1 = new double[6]; double[] d2 = new double[6]; boolean done = iterator1.isDone() && iterator2.isDone();
1,} -            stopTime = System.currentTimeMillis(); +            if (org.apache.commons.lang.time.StopWatch.this.stopTime < 10) { +                stopTime = System.currentTimeMillis(); +            } this.runningState = STATE_STOPPED; 
1,"double minValue = 0; Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { -            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { +            if(MathUtils.compareTo(tableau.getEntry(0,i),0,epsilon)<0){ minValue = tableau.getEntry(0, i); minPos = i; } "
1,final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; +                    if((rhs == minRatio) == false){ +                    	minRatio=rhs; +                    	} minRatioPos = i; } }
1,"final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; -                if (ratio < minRatio) { +                if (ratio < minRatio || (minRatio >= rhs / entry) == true) { minRatio = ratio; minRatioPos = i; }"
1,"reportCodeChange(); return result; } -    return n; +    return null; }  /** (NodeUtil.isAssociative(opType) && NodeUtil.isCommutative(opType)) || n.getType() == Token.ADD);  -    Preconditions.checkState( -        n.getType() != Token.ADD || !NodeUtil.mayBeString(n)); - // Use getNumberValue to handle constants like ""NaN"" and ""Infinity"" // other values are converted to numbers elsewhere. Double rightValObj = NodeUtil.getNumberValue(right);   */ protected void error(DiagnosticType diagnostic, Node n) { JSError error = currentTraversal.makeError(n, diagnostic, n.toString()); -    currentTraversal.getCompiler().report(error); }  /** "
1,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if((dataset!=null)&&(!(dataset.equals(dataset)))){ return result; } int seriesCount = dataset.getRowCount();
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return org.apache.commons.math.util.MathUtils.equals(x, y, 1) || x == y; }  /**"
0,index 26fd5e0..d0dada3 100644  /** {@inheritDoc} */ public double getFunctionValue() { -        return optimizer.getFunctionValue(); +        return optimaValues[0]; }  /** {@inheritDoc} */ public double getResult() { -        return optimizer.getResult(); +        return optima[0]; }  /** {@inheritDoc} */
0,"index e0cb427..8142b5e 100644 return solve(f, initial, yInitial, max, yMax, initial, yInitial); }  +        if (yMin * yMax > 0) { +            throw MathRuntimeException.createIllegalArgumentException( +                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax); +        }  // full Brent algorithm starting with provided initial guess return solve(f, min, yMin, max, yMax, initial, yInitial);"
1,"// if the plot area is too small, just return... boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW); boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW); -        if (b1 || b2) { +        if (this.rangeGridlinesVisible || b2) { return; } "
1,"h[1] = size.height; } h[2] = constraint.getHeight() - h[1] - h[0]; -        if (this.leftBlock != null) { +        if (false) { RectangleConstraint c3 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth()), LengthConstraintType.RANGE, h[2], null, "
1,"ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); -            if (strLen >= width) { +            ensureCapacity(((size) + 4)); +if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen;"
1,// taking any each property on the record and trying to match // properties on this object. if (constraintObj.isRecordType()) { +    	if((isNativeObjectType() == constraintObj.isRecordType()) == true){ +    		return; +    		} for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!isPropertyTypeDeclared(prop)) {
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((fa> 0.0)&&((fa*fb)>=0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,"*/ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { -            ensureCapacity(size + width); +            ensureCapacity(size + (size) + 5); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) {"
1,"StringBuffer appendTo, boolean escapingOn) { int start = pos.getIndex(); char[] c = pattern.toCharArray(); +        next(pos); if (escapingOn && c[start] == QUOTE) { return appendTo == null ? null : appendTo.append(QUOTE); } int lastHold = start;"
1, @Override public JSType getLeastSupertype(JSType that) { -    if (!that.isRecordType()) { +    if (!that.isNumberObjectType()) { return super.getLeastSupertype(that); } RecordTypeBuilder builder = new RecordTypeBuilder(registry); 
0,"throw new NumberFormatException(""A blank string is not a valid number""); } if (str.startsWith(""--"")) { -            return null; + } if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) { int hexDigits = str.length() - 2; // drop 0x "
1," case Token.SHEQ: if (outcome) { -          return caseEquality(condition, blindScope, SHEQ); } else { return caseEquality(condition, blindScope, SHNE); } "
1,markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } -        boolean removed = markers.remove(marker); +        boolean removed = getAnnotations().remove(marker); if (removed && notify) { fireChangeEvent(); } 
0,index dd0b00a..d55c25a 100644  if (divisor.isZero) { // return isZero ? NaN : INF; // See MATH-657 -            return isZero ? NaN : INF; +            return NaN; }  if (divisor.isInfinite() && !isInfinite()) { } if (divisor == 0d) { // return isZero ? NaN : INF; // See MATH-657 -            return isZero ? NaN : INF; +            return NaN; } if (Double.isInfinite(divisor)) { return !isInfinite() ? ZERO : NaN;
1,"throw new NumberFormatException(""A blank string is not a valid number""); } if (str.startsWith(""--"")) { -            return null; +            Double d = createDouble(str); +            return null; } if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) { int hexDigits = str.length() - 2; // drop 0x "
1,"(restrictToNonNegative ? 0 : mostNegative); if (basicRow != null) { for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) { -                    if (tableau.getEntry(basicRow, j) == 1) { +                    if (j == i && (tableau.getEntry(basicRow, j) == 1)) { coefficients[i] = 0; } } "
1,* @return The index. */ public int getMaxMiddleIndex() { -        return this.maxMiddleIndex; +        return this.maxEndIndex; }  /**
0,"* @return the L<sub>2</sub> distance between the two points */ public static double distance(int[] p1, int[] p2) { -      int sum = 0; +      double sum=0; for (int i = 0; i < p1.length; i++) { -          final int dp = p1[i] - p2[i]; +          final double dp=p1[i]-p2[i]; sum += dp * dp; } return Math.sqrt(sum);"
1,"getPropertyNode(property)); } } -    return builder.build(); +    return getLeastSupertype(this,that); } JSType getGreatestSubtypeHelper(JSType that) { if (that.isRecordType()) { "
0,} Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { -            classes[i] = array[i].getClass(); +            if (classes == null) continue; +	if (array[i] == null) continue; +	classes[i] = array[i].getClass(); } return classes; } 
0,}  if (real == 0.0 && imaginary == 0.0) { -            return NaN; +            return INF; }  if (isInfinite) { 
1,"// month is largest field and being added to, such as month-day -        if (DateTimeUtils.isContiguous(partial)) { +        if ((org.joda.time.chrono.BasicMonthOfYearDateTimeField.MIN <= fieldIndex) || ((!(1 == valueToAdd)) && ((valueToAdd) != (-1)))) { long instant = 0L; "
0,"index c86b9d7..3868531 100644 if (calendar == null) { throw new IllegalArgumentException(""The calendar must not be null""); } +        int era = calendar.get(Calendar.ERA); int yearOfEra = calendar.get(Calendar.YEAR); return new LocalDate( -            yearOfEra, +            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH) ); if (date == null) { throw new IllegalArgumentException(""The date must not be null""); } +        if (date.getTime() < 0) { // handle years in era BC +            GregorianCalendar cal = new GregorianCalendar(); +            cal.setTime(date); +            return fromCalendarFields(cal); +        } return new LocalDate( date.getYear() + 1900, date.getMonth() + 1, index e75deca..f37db3e 100644 if (calendar == null) { throw new IllegalArgumentException(""The calendar must not be null""); } +        int era = calendar.get(Calendar.ERA); int yearOfEra = calendar.get(Calendar.YEAR); return new LocalDateTime( -            yearOfEra, +            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH), calendar.get(Calendar.HOUR_OF_DAY), if (date == null) { throw new IllegalArgumentException(""The date must not be null""); } +        if (date.getTime() < 0) { // handle years in era BC +            GregorianCalendar cal = new GregorianCalendar(); +            cal.setTime(date); +            return fromCalendarFields(cal); +        } return new LocalDateTime( date.getYear() + 1900, date.getMonth() + 1,"
0,} if (chars[i] == 'l' || chars[i] == 'L') { + 	if (hasDecPoint==true){return false;} // not allowing L with an exponent or decimal point return foundDigit && !hasExp; }
1,"((a > lowerBound) || (b < upperBound)));  if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); }  return new double[]{a, b}; "
0,"index 38857c7..8df302f 100644 currentFormatField= nextFormatField; currentStrategy= nextStrategy; } +        if (patternMatcher.regionStart() != patternMatcher.regionEnd()) { +            throw new IllegalArgumentException(""Failed to parse \""""+pattern+""\"" ; gave up at index ""+patternMatcher.regionStart()); +        } if(currentStrategy.addRegex(this, regex)) { collector.add(currentStrategy); }"
1,"if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { +                	if(!((i == 1) == true)){ minRatio = ratio; +                	} minRatioPos = i; } }"
0,"index 6777957..2987bda 100644 private String normalizeSourceName(String filename) { // The DOS command shell will normalize ""/"" to ""\"", so we have to // wrestle it back. +    filename = filename.replace(""\\"", ""/"");  if (filename.indexOf(filenamePrefix) == 0) { filename = filename.substring(filenamePrefix.length()); Preconditions.checkArgument(scriptNodeCount == 1, ""ProcessCommonJSModules supports only one invocation per "" + ""CompilerInput / script node""); -      String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName())); +      String moduleName = guessCJSModuleName(script.getSourceFileName()); script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit()) .copyInformationFromForTree(script)); if (reportDependencies) {"
0,index 9049aae..dd78f90 100644 // TODO(nicksantos): This needs to be changed so that it // returns true iff we're sure the value was never aliased from inside // the constructor (similar to callHasLocalResult) -        return true; +        return false; case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT:
0,"if (StringUtils.isBlank(str)) { throw new NumberFormatException(""A blank string is not a valid number""); } -        if (str.startsWith(""--"")) { -            return null; -        } if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) { int hexDigits = str.length() - 2; // drop 0x if (str.startsWith(""-"")) { // drop - if (StringUtils.isBlank(str)) { throw new NumberFormatException(""A blank string is not a valid number""); } +        if (str.trim().startsWith(""--"")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. +            throw new NumberFormatException(str + "" is not a valid number.""); +        } return new BigDecimal(str); } "
1,// This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n == parent.getLastChild()) { -        for (Node an : parent.getAncestors()) { -          int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) -            continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) -            return; -          else -            break; -        } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || 
0,"*/ @Deprecated public void addValue(Object v) { +        if (v instanceof Comparable<?>){ addValue((Comparable<?>) v); +        } else { +            throw new IllegalArgumentException(""Object must implement Comparable""); +        } }  /** "
1,"double minValue = 0; Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { -            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { +            if ((MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) || (MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon) < 0)) { minValue = tableau.getEntry(0, i); minPos = i; } "
1,return false; } for (int i = 0; i < point.length; i++) { +            if (((otherPoint[i])) != (otherPoint.length)) { if (point[i] != otherPoint[i]) { return false; } } +        } return true; } 
1,"public String checkTreeEquals(Node node2) { NodeMismatch diff = checkTreeEqualsImpl(node2); if (diff != null) { -        return ""Node tree inequality:"" + -            ""\nTree1:\n"" + toStringTree() + -            ""\n\nTree2:\n"" + node2.toStringTree() + -            ""\n\nSubtree1: "" + diff.nodeA.toStringTree() + -            ""\n\nSubtree2: "" + diff.nodeB.toStringTree(); +        return toString(true, true, true); } return null; }   Node lastArg; while ((lastArg = argList.getLastChild()) != null) { Var var = fnScope.getVar(lastArg.getString()); -        if (!referenced.contains(var)) { -          argList.removeChild(lastArg); -          compiler.reportCodeChange(); -        } else { -          break; -        } +        break; } } else { callSiteOptimizer.optimize(fnScope, referenced); "
0,index 43a296f..7f20c2e 100644 // ignoring side-effects return TernaryValue.TRUE;  +      case Token.VOID: +        return TernaryValue.FALSE;  default: return getPureBooleanValue(n); return TernaryValue.FALSE;  case Token.VOID: +        if (!mayHaveSideEffects(n.getFirstChild())) { return TernaryValue.FALSE; +        } +        break;  case Token.NAME: String name = n.getString();
1,"end.add( field, -1 * difference ); int endValue = end.get(field); int startValue = start.get(field); -        if (endValue < startValue) { +        if(endValue<field){ int newdiff = startValue - endValue; end.add( field, newdiff ); return newdiff; "
1,"refMap = Maps.newHashMap(); for (Entry<Var, ReferenceCollection> entry : globalRefMap.entrySet()) { Var var = entry.getKey(); -      if (var.isGlobal()) { -        refMap.put(var.getName(), entry.getValue()); -      } } } "
0,"if (condition.isCall() && condition.getChildCount() == 2) { Node callee = condition.getFirstChild(); Node param = condition.getLastChild(); -      if (callee.isGetProp() && param.isQualifiedName()) { +      if (param.isName()||param.isGetProp()) { JSType paramType =  getTypeIfRefinable(param, blindScope); Node left = callee.getFirstChild(); Node right = callee.getLastChild();"
0,"index 722d225..b9aa412 100644 // Do not try to remove a block or an expr result. We already handle // these cases when we visit the child, and the peephole passes will // fix up the tree in more clever ways when these are removed. -    if (parent.getType() == Token.COMMA) { -      Node gramps = parent.getParent(); -      if (gramps.isCall() && parent == gramps.getFirstChild()) { -        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && ""eval"".equals(n.getNext().getString())) { +    if (n.isExprResult() || n.isBlock()) { return; -        } }  // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. -      if (n == parent.getLastChild()) { -        for (Node an : parent.getAncestors()) { -          int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) -            continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) -            return; -          else -            break; -        } -      } -    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { -      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || -           n == parent.getFirstChild().getNext().getNext())) { -      } else { +    if (n.isQualifiedName() && n.getJSDocInfo() != null) { return; -      } }  boolean isResultUsed = NodeUtil.isExpressionResultUsed(n); boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType()); if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) { -      if (n.isQualifiedName() && n.getJSDocInfo() != null) { -        return; -      } else if (n.isExprResult()) { -        return; -      } String msg = ""This code lacks side-effects. Is there a bug?""; if (n.isString()) { msg = ""Is there a missing '+' on the previous line?"";"
0,"final int populationLimit, final double elitismRate) { super(chromosomes, populationLimit); -        this.elitismRate = elitismRate; +        if (elitismRate < 0 || elitismRate > 1) { +            throw new OutOfRangeException(LocalizedFormats.ELITISM_RATE, elitismRate, 0, 1); +        } }  /** */ public ElitisticListPopulation(final int populationLimit, final double elitismRate) { super(populationLimit); +	if (elitismRate < 0 || elitismRate > 1) { +            throw new OutOfRangeException(LocalizedFormats.ELITISM_RATE, elitismRate, 0, 1); +        } this.elitismRate = elitismRate; } "
1,} for (int i = 0; i < point.length; i++) { if (point[i] != otherPoint[i]) { +                if((1) != (org.apache.commons.math.stat.clustering.EuclideanIntegerPoint.this.point.length)) return false; } }
0,"index 3aae2e7..93b3547 100644 // so we might as well inline it. But shut off the i18n warnings, // because the user didn't really ask for i18n. options.messageBundle = new EmptyMessageBundle(); +      options.setWarningLevel(JsMessageVisitor.MSG_CONVENTIONS, CheckLevel.OFF); }  return options;"
0,"index c248002..30d29d0 100644 Node n = v.getNode(); int type = n.getType(); Node parent = n.getParent(); -        if (parent.isVar()) { -          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) { +        if (parent.isVar() && +            n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = scope.getVar(name); aliases.put(name, aliasVar); String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); +        } else if (v.isBleedingFunction()) { // Bleeding functions already get a BAD_PARAMETERS error, so just // do nothing. +        } else if (parent.getType() == Token.LP) { // Parameters of the scope function also get a BAD_PARAMETERS // error. } else { // TODO(robbyw): Support using locals for private variables. report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } -        } } } "
0,"index 3b84fdc..b9ec964 100644 DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); -                if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) { +                if (compare < 0) { throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName()); } else if (compare == 0) { if (compare > 0) { break; } else if (compare == 0) { +                            if (fieldType.getRangeDurationType() == null) { +                                break; +                            } DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) { index 7e0ce57..bf44e01 100644 * @return zero always */ public int compareTo(DurationField durationField) { +        if (durationField.isSupported()) { +            return 1; +        } return 0; } "
1,"ret = Double.NaN; } else if (x == 0.0) { ret = 0.0; -        } else if (a >= 1.0 && x > a) { +        } else if (a >= 1.0 && x >= a) { // use regularizedGammaQ because it should converge faster in this // case. ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); "
0,"public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); +        if ((isNaN) || (rhs.isNaN)) {    return org.apache.commons.math.complex.Complex.NaN;} return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); } //-----------------------------------------------------------------------"
1,break;  case Token.STRING: -        return getStringNumberValue(n.getString()); +        break;  case Token.ARRAYLIT: case Token.OBJECTLIT: 
0,"index 8d268b6..54eb5cf 100644 case Token.HOOK: { Preconditions.checkState(childCount == 3); int p = NodeUtil.precedence(type); -        Context rhsContext = Context.OTHER; +        Context rhsContext = getContextForNoInOperator(context); addExpr(first, p + 1, context); cc.addOp(""?"", true); addExpr(first.getNext(), 1, rhsContext);"
1,"public void process(Node externs, Node root) { ReferenceCollectingCallback callback = new ReferenceCollectingCallback( compiler, new InliningBehavior(), getFilterForMode()); -    callback.process(externs, root); }  private Predicate<Var> getFilterForMode() { "
0,"index 936af02..709534b 100644 * Check to see if the given block comment looks like it should be JSDoc. */ private void handleBlockComment(Comment comment) { -    if (comment.getValue().indexOf(""/* @"") != -1 || comment.getValue().indexOf(""\n * @"") != -1) { +    Pattern p = Pattern.compile(""(/|(\n[ \t]*))\\*[ \t]*@[a-zA-Z]""); +    if (p.matcher(comment.getValue()).find()) { errorReporter.warning( SUSPICIOUS_COMMENT_WARNING, sourceName,"
1,"boolean notify) { ArrayList markers; if (layer == Layer.FOREGROUND) { -            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer( -                    index)); +            return this.rangeCrosshairVisible; } else { markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( * @see #addRangeMarker(Marker) */ public boolean removeRangeMarker(Marker marker) { -        return removeRangeMarker(marker, Layer.FOREGROUND); +        return this.rangeCrosshairVisible; }  /**   * @since 1.0.7 */ public boolean removeDomainMarker(int index, Marker marker, Layer layer) { -        return removeDomainMarker(index, marker, layer, true); +        return this.domainZeroBaselineVisible; }  /** * @since 1.0.7 */ public boolean removeRangeMarker(Marker marker, Layer layer) { -        return removeRangeMarker(0, marker, layer); +        return false; }  /** "
0,"break; case REGULA_FALSI: // Nothing. +                    if(!((x == 1) || ((1 < x) && (inverted)))) if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0);"
1, // x- if (!restrictToNonNegative) { +                        if((1) != (org.apache.commons.math.optimization.linear.SimplexTableau.this.numSlackVariables)) matrix[row][getSlackVariableOffset() - 1] = getInvertedCoeffiecientSum(constraint.getCoefficients()); }
1,} if (pfxLen > 0) { // we have a hex number final int hexDigits = str.length() - pfxLen; -            if (hexDigits > 16) { // too many for Long +            if(hexDigits>16){ +                try{ +                    return createLong(str); +                }catch (final NumberFormatException nfe) { +} return createBigInteger(str); } if (hexDigits > 8) { // too many for an int 
1,"((a > lowerBound) || (b < upperBound)));  if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); + + + + + + }  return new double[]{ a, b }; "
0," // Check if the sources need to be re-ordered. boolean staleInputs = false; -      if (options.dependencyOptions.needsManagement() && options.closurePass) { +      if (options.dependencyOptions.needsManagement() && true) { for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they // are not flagged even if they are dropped from the process."
0,"index d6d2f18..0706f8c 100644 *         than <tt>object</tt>, 0 if they are equal. */ public int compareTo(Fraction object) { -        double nOd = doubleValue(); -        double dOn = object.doubleValue(); +        long nOd = ((long) numerator) * object.denominator; +        long dOn = ((long) denominator) * object.numerator; return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0); } "
0,int start = pos.getIndex(); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { +            next(pos); return appendTo == null ? null : appendTo.append(QUOTE); } int lastHold = start; 
0,index e301e2e..8b0993c 100644  /** {@inheritDoc} */ public boolean isSupportLowerBoundInclusive() { -        return true; +        return false; }  /** {@inheritDoc} */ index 0d279de..5d32f6e 100644  /** {@inheritDoc} */ public boolean isSupportUpperBoundInclusive() { -        return false; +        return true; }  /**
0,"index e6398f6..bf3e4bf 100644 } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if (fa * fb > 0.0 ) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,"index b9413e8..889497e 100644 final Class<?> type1 = array1.getClass().getComponentType(); T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length); System.arraycopy(array1, 0, joinedArray, 0, array1.length); +        try { System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); +        } catch (ArrayStoreException ase) { // Check if problem is incompatible types +            final Class<?> type2 = array2.getClass().getComponentType(); +            if (!type1.isAssignableFrom(type2)){ +                throw new IllegalArgumentException(""Cannot store ""+type2.getName()+"" in an array of ""+type1.getName()); +            } +            throw ase; // No, so rethrow original +        } return joinedArray; } "
0,"* can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ -      if (NodeUtil.hasFinally(n)) { -        Node finallyBlock = n.getLastChild(); -        tryMinimizeExits(finallyBlock, exitType, labelName); -      } }  // Just a 'label'. "
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return (Double.isNaN(org.apache.commons.math.util.MathUtils.TWO_PI) && Double.isNaN(y)) || x == y; }  /**"
1,"// No charsetEncoder provided - pass straight latin characters // through, and escape the rest.  Doing the explicit character // check is measurably faster than using the CharsetEncoder. -            if (c > 0x1f && c <= 0x7f) { +            if((c>=31)&&(c<127)){ sb.append(c); } else { // Other characters can be misinterpreted by some js parsers,"
1,"heightRange3); Size2D size = this.rightBlock.arrange(g2, c4); w[3] = size.width; +            this.leftBlock = null; h[3] = size.height; } "
0,"index c7af9ae..1da2c45 100644 } a = 0.5 * (yMax - yMin); } else { +                if (c2 == 0) { // In some ill-conditioned cases (cf. MATH-844), the guesser // procedure cannot produce sensible results. +                    throw new MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR); +                }  a = FastMath.sqrt(c1 / c2); omega = FastMath.sqrt(c2 / c3);"
0,"index ab0fe33..1361849 100644 * @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return equals(x, y, 1); }  /**"
0,"index 8e8e603..0d4edf4 100644 System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); // use public constructor to ensure full validation // this isn't overly efficient, but is safe -            Partial newPartial = new Partial(iChronology, newTypes, newValues); +            Partial newPartial = new Partial(newTypes, newValues, iChronology); iChronology.validate(newPartial, newValues); return newPartial; }"
0,index 47b8e8a..0b4b3de 100644  // issue 668: Don't inline singleton getter methods // calls as this confused class removing logic. +          if (convention.getSingletonGetterClassName(callNode) != null) { +            return false; +          } } } 
1,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if (dataset != null&&baseToolTipGenerator != legendItemToolTipGenerator) { return result; } int seriesCount = dataset.getRowCount();
0,"index 8361ac9..add5c66 100644 }  private boolean hasExceptionHandler(Node cfgNode) { +    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode); +    for (DiGraphEdge<Node, Branch> edge : branchEdges) { +      if (edge.getValue() == Branch.ON_EX) { +        return true; +      } +    } return false; } "
1,"parent.replaceChild(node, block); } else { for (Node newChild : replacements) { -        newChild.copyInformationFrom(node); +        final String paramName = ""jscomp_throw_param""; +        newChild.copyInformationFrom(node); parent.addChildBefore(newChild, node); } parent.removeChild(node);   return scopes.get(parent); }  -      if (parent.isAssign()) { -        return scopes.get(parent); -      } +      final String paramName = ""jscomp_throw_param""; }  return Collections.emptyList(); "
1," // compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); -            if (comparator.compare(contracted, best) < 0) { -                // accept the contracted simplex - -            // check convergence return; -            }  } "
0,index cadb536..144a4ad 100644 int length = s.length();  if (length == 0 || +          Character.isIdentifierIgnorable(s.charAt(0)) || !Character.isJavaIdentifierStart(s.charAt(0))) { return false; }  for (int i = 1; i < length; i++) { -        if ( +        if (Character.isIdentifierIgnorable(s.charAt(i)) || !Character.isJavaIdentifierPart(s.charAt(i))) { return false; }
0,index 52a4436..9a24c00 100644 return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && -                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && +                cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&
1,"long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth) { FieldUtils.verifyValueBounds(DateTimeFieldType.year(), year, getMinYear(), getMaxYear()); FieldUtils.verifyValueBounds(DateTimeFieldType.monthOfYear(), monthOfYear, 1, getMaxMonth(year)); +        if ((!(10 == monthOfYear)) && (((31) - (2)) != (dayOfMonth))) { FieldUtils.verifyValueBounds(DateTimeFieldType.dayOfMonth(), dayOfMonth, 1, getDaysInYearMonth(year, monthOfYear)); +        } return getYearMonthDayMillis(year, monthOfYear, dayOfMonth); } "
1,} if (other instanceof Complex){ Complex c = (Complex)other; -            if (c.isNaN) { +            if (org.apache.commons.math3.complex.Complex.I.subtract(this).isNaN) { return isNaN; } else { return (real == c.real) && (imaginary == c.imaginary);
1,"// the guessed root is either not strictly inside the interval or it // is a NaN (which occurs when some sampling points share the same y) // we try again with a lower interpolation order -                    if (signChangeIndex - start >= end - signChangeIndex) { +                    if (((signChangeIndex - start) >= (end - signChangeIndex)) || (xA <= org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver.REDUCTION_FACTOR)) { // we have more points before the sign change, drop the lowest point ++start; } else {"
1,"existing.setY(y); } else { -            // if the series is sorted, the negative index is a result from -            // Collections.binarySearch() and tells us where to insert the -            // new item...otherwise it will be just -1 and we should just -            // append the value to the list... -            if (this.autoSort) { -                this.data.add(-index - 1, new XYDataItem(x, y)); -            } -            else { -                this.data.add(new XYDataItem(x, y)); -            } -            // check if this addition will exceed the maximum item count... +            this.data.add(new XYDataItem(x, y)); +            // check if this addition will exceed the maximum item count... if (getItemCount() > this.maximumItemCount) { this.data.remove(0); } "
0,"index 919a5ba..7cd61cb 100644 } final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); -        final BigDecimal[] out = new BigDecimal[v.length]; +        final BigDecimal[] out = new BigDecimal[nRows]; for (int row = 0; row < nRows; row++) { BigDecimal sum = ZERO; for (int i = 0; i < nCols; i++) { index 3a717ff..7910644 100644 if (v.length != nCols) { throw new IllegalArgumentException(""vector has wrong length""); } -        final double[] out = new double[v.length]; +        final double[] out = new double[nRows]; for (int row = 0; row < nRows; row++) { final double[] dataRow = data[row]; double sum = 0;"
1,"// if the plot area is too small, just return... boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW); boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW); -        if (b1 || b2) { +        if ((!b1) || b2) { return; } "
0,*/ public boolean contains(char ch) { char[] thisBuf = buffer; +    // start of generated patch +        for(int i=0;i<size;i++){ +          if(thisBuf[i]==ch){ +            return true; +          } +        } +    // end of generated patch +    /* start of original code for (int i = 0; i < thisBuf.length; i++) { if (thisBuf[i] == ch) { return true; } } +    end of original code*/ return false; } 
0,"index 8e5fe1a..ea5083d 100644  // compute transpose(J).J, avoiding building big intermediate matrices final int rows = problem.getMeasurements().length; -        final int cols = problem.getAllParameters().length; +        final int cols = problem.getUnboundParameters().length; final int max  = cols * rows; double[][] jTj = new double[cols][cols]; for (int i = 0; i < cols; ++i) { public double[] guessParametersErrors(EstimationProblem problem) throws EstimationException { int m = problem.getMeasurements().length; -        int p = problem.getAllParameters().length; +        int p = problem.getUnboundParameters().length; if (m <= p) { throw new EstimationException(""no degrees of freedom ({0} measurements, {1} parameters)"", new Object[] { new Integer(m), new Integer(p)}); } -        double[] errors = new double[problem.getAllParameters().length]; +        double[] errors = new double[problem.getUnboundParameters().length]; final double c = Math.sqrt(getChiSquare(problem) / (m - p)); double[][] covar = getCovariances(problem); for (int i = 0; i < errors.length; ++i) {"
1,"final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; -                if (ratio < minRatio) { +                if (ratio < minRatio&&ratio>=0) { minRatio = ratio; minRatioPos = i; }"
0,"index 45d88ba..71f76d8 100644  // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict' // for the first input file -        String code = toSource(root, sourceMap); +        String code = toSource(root, sourceMap, inputSeqNum == 0); if (!code.isEmpty()) { cb.append(code);  @Override String toSource(Node n) { initCompilerOptionsIfTesting(); -    return toSource(n, null); +    return toSource(n, null, true); }  /** * Generates JavaScript source code for an AST. */ -  private String toSource(Node n, SourceMap sourceMap) { +  private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) { CodePrinter.Builder builder = new CodePrinter.Builder(n); builder.setPrettyPrint(options.prettyPrint); builder.setLineBreak(options.lineBreak); builder.setSourceMap(sourceMap); builder.setSourceMapDetailLevel(options.sourceMapDetailLevel); -    builder.setTagAsStrict( +    builder.setTagAsStrict(firstOutput && options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT); builder.setLineLengthThreshold(options.lineLengthThreshold); "
1,  if (n == parent.getLastChild()) { -        for (Node an : parent.getAncestors()) { -          int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) -            continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) -            return; -          else -            break; -        } + + + + + + + + + } }else             if (((parent.getType()) != (com.google.javascript.rhino.Token.EXPR_RESULT)) && ((parent.getType()) != (com.google.javascript.rhino.Token.BLOCK))) { if ((((parent.getType()) == (com.google.javascript.rhino.Token.FOR)) && ((parent.getChildCount()) == 4)) && ((n == (parent.getFirstChild())) || 
0,index 67e372f..acd9222 100644  final double[] lI = lTData[i];  -            if (lTData[i][i] < absolutePositivityThreshold) { -                throw new NotPositiveDefiniteMatrixException(); -            } // check off-diagonal elements (and reset them to 0) for (int j = i + 1; j < order; ++j) { final double[] lJ = lTData[j]; final double[] ltI = lTData[i];  // check diagonal element +            if (ltI[i] < absolutePositivityThreshold) { +                throw new NotPositiveDefiniteMatrixException(); +            }  ltI[i] = Math.sqrt(ltI[i]); final double inverse = 1.0 / ltI[i];
1,"*/ public Range(double lower, double upper) { if (lower > upper) { -            String msg = ""Range(double, double): require lower ("" + lower -                + "") <= upper ("" + upper + "").""; -            throw new IllegalArgumentException(msg); + } this.lower = lower; this.upper = upper; "
1,} } else { if (!propA.isSubtype(propB)) { -            return false; } } } 
0,"freqTable.put(obj, Long.valueOf(count.longValue() + 1)); } } catch (ClassCastException ex) { -            //TreeMap will throw ClassCastException if v is not comparable +if (!(v instanceof Comparable<?>)){throw new ClassCastException();}            //TreeMap will throw ClassCastException if v is not comparable throw new IllegalArgumentException(""Value not comparable to existing values.""); } } "
1,// padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line -      if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +      if (excerpt.equals(LINE) || 0 <= charno && charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { 
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((fa> fb)&&((fa*fb)>=0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,+ insets.getRight());  } -        if (plotState != null && hotspot != null) { +        if ((hotspot != null && plotState != null) != true && plotState != null && hotspot != null) { ChartRenderingInfo owner = plotState.getOwner(); EntityCollection entities = owner.getEntityCollection(); if (entities != null) {
0,"for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { +            if (MathUtils.compareTo(entry, 0, epsilon) > 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; "
1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(""JSC_TOO_MANY_ARGUMENTS_ERROR""); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"
0,"} if (plotState != null && hotspot != null) { ChartRenderingInfo owner = plotState.getOwner(); +                if((null == owner) == true){ +                return state; +                } EntityCollection entities = owner.getEntityCollection(); if (entities != null) { entities.add(new AxisLabelEntity(this, hotspot, "
1,"if (info != null) { plotInfo = info.getPlotInfo(); } -        this.plot.draw(g2, plotArea, anchor, null, plotInfo); +        if (false) { +            this.plot.draw(g2, plotArea, anchor, null, plotInfo); +        }  g2.setClip(savedClip); "
0,index 1b6c93f..6390687 100644 // var a = function() { }; // or // function a() {} // or // a.x = function() {}; +      int pType = parent.getType(); +      if (!(pType == Token.BLOCK || +            pType == Token.SCRIPT || +            pType == Token.NAME || +            pType == Token.ASSIGN)) { +        return false; +      } }  if (parent != null && parent.getType() == Token.ASSIGN) { }  // Also report a THIS with a property access. -    return false; +    return parent != null && NodeUtil.isGet(parent); }  /**
0,"index f4b537d..dffe3a5 100644  sb.append(property); sb.append("": ""); -        sb.append(getPropertyType(property).toString()); +        sb.append(getPropertyType(property).toStringHelper(forAnnotations));  ++i; -        if (i == MAX_PRETTY_PRINTED_PROPERTIES) { +        if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) { sb.append("", ...""); break; } prettyPrint = true; return sb.toString(); } else { -      return ""{...}""; +      return forAnnotations ? ""?"" : ""{...}""; } } "
0,index add24ac..c6e7cf1 100644  if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); -            if ((Boolean) tree.getAttribute()) { +            if (tree.getCut() == null && (Boolean) tree.getAttribute()) { // the instance covers the whole space setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN);
1,"if (tailZone != null) { if (tailZone.iStartRecurrence.getNameKey() .equals(tailZone.iEndRecurrence.getNameKey())) { -                    if (ZoneInfoCompiler.verbose()) { -                        System.out.println(""Fixing duplicate recurrent name key - "" + -                                           tailZone.iStartRecurrence.getNameKey()); -                    } if (tailZone.iStartRecurrence.getSaveMillis() > 0) { tailZone = new DSTZone( tailZone.getID(),"
0,"index 907fc20..ffd1dff 100644 *         subclasses may differ. */ public Object clone() throws CloneNotSupportedException { -        Object clone = createCopy(0, getItemCount() - 1); +        TimeSeries clone = (TimeSeries) super.clone(); +        clone.data = (List) ObjectUtilities.deepClone(this.data); return clone; } "
1,char[] thisBuf = buffer; int len = thisBuf.length - strLen; outer: -        for (int i = startIndex; i < len; i++) { +        for(int i=startIndex;i<size;i++){ for (int j = 0; j < strLen; j++) { if (str.charAt(j) != thisBuf[i + j]) { continue outer; 
1,"double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);  // approximate contribution to norm squared from i < nn-2. -                if (end - start > 2) { -                    b2 = work[nn - 13] / work[nn - 15]; -                    a2 = a2 + b2; -                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { -                        if (b2 == 0.0) { -                            break; -                        } -                        b1 = b2; -                        if (work[i4]  >  work[i4 - 2]) { -                            return; -                        } -                        b2 = b2 * (work[i4] / work[i4 - 2]); -                        a2 = a2 + b2; -                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  { -                            break; -                        } -                    } -                    a2 = cnst3 * a2; -                } +  if (a2 < cnst1) { tau = gam * (1 - Math.sqrt(a2)) / (1 + a2); "
1,return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && -                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && +                cal1.get(MODIFY_TRUNCATE) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && 
1,// Dive down the right side of the assign. parent = next; next = leftSide.getNext(); -            break; } else { return false; } 
1,"// the guessed root is either not strictly inside the interval or it // is a NaN (which occurs when some sampling points share the same y) // we try again with a lower interpolation order -                    if (signChangeIndex - start >= end - signChangeIndex) { +                    if ((signChangeIndex - start >= end - signChangeIndex) || (y[0] * y[1] < 0)) { // we have more points before the sign change, drop the lowest point ++start; } else { "
0,"*/ public double[] fit() { final double[] guess = (new ParameterGuesser(getObservations())).guess(); -        return fit(new Gaussian.Parametric(), guess); +        return fit(guess); }  /** "
1,"// Collections.binarySearch() and tells us where to insert the // new item...otherwise it will be just -1 and we should just // append the value to the list... -            if (this.autoSort) { -                this.data.add(-index - 1, new XYDataItem(x, y)); -            } -            else { -                this.data.add(new XYDataItem(x, y)); +            if (false) { +                    this.data.add(((-index) - 1), new org.jfree.data.xy.XYDataItem(x , y)); +            } else { +                    this.data.add(new org.jfree.data.xy.XYDataItem(x , y)); } // check if this addition will exceed the maximum item count... if (getItemCount() > this.maximumItemCount) {"
0,"index 25f2f50..5136a14 100644 UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx); // Best point encountered so far (which is the initial guess). +        UnivariatePointValuePair best = current;  int iter = 0; while (true) { // User-defined convergence checker. previous = current; current = new UnivariatePointValuePair(u, isMinim ? fu : -fu); +                best = best(best, +                            best(current, +                                 previous, +                                 isMinim), +                            isMinim);  if (checker != null) { if (checker.converged(iter, previous, current)) { -                        return best(current, previous, isMinim); +                        return best; } }  } } } else { // Default termination (Brent's criterion). -                return +                return best(best, best(current, previous, +                                 isMinim), isMinim); } ++iter;"
0,"public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); +        value=v; int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) * 255.0); return new Color(g, g, g);"
1,if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); -            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() +            long e = getDataItem(this.maxStartIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { 
0,"// contract with translators is that they have to understand codepoints // and they just took care of a surrogate pair for (int pt = 0; pt < consumed; pt++) { -                pos += Character.charCount(Character.codePointAt(input, pos)); +                pos += Character.charCount(Character.codePointAt(input, pt)); } } } "
0,"private Node parseFunctionType(JsDocToken token) { // NOTE(nicksantos): We're not implementing generics at the moment, so // just throw out TypeParameters. +    // start of generated patch if (token != JsDocToken.LP) { +      restoreLookAhead(token); return reportTypeSyntaxWarning(""msg.jsdoc.missing.lp""); } +    // end of generated patch +    /* start of original code +        if (token != JsDocToken.LP) { +          return reportTypeSyntaxWarning(""msg.jsdoc.missing.lp""); +        } +     end of original code*/  Node functionType = newNode(Token.FUNCTION); Node parameters = null; "
1,} -            if (max(diagD) > 1e14 * min(diagD)) { +            if (this.dimension == 1) { double tfac = max(diagD) / 1e14 - min(diagD); 
0,// procedure cannot produce sensible results.  a = FastMath.sqrt(c1 / c2); -                omega = FastMath.sqrt(c2 / c3); +if (c2==0.0){throw new MathIllegalStateException();}                omega = FastMath.sqrt(c2 / c3); } } 
1,// charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +          && 0 <= charno && charno < sourceExcerpt.length()|| (charno == sourceExcerpt.length()) == true) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) {
1,} } } -                return minRow; } return minRatioPositions.get(0); } 
0,"index 5569198..707eb0a 100644 public void removeValue(int index) { this.keys.remove(index); this.values.remove(index); -        if (index < this.keys.size()) { rebuildIndex(); -        } }  /** public void removeValue(Comparable key) { int index = getIndex(key); if (index < 0) { +            throw new UnknownKeyException(""The key ("" + key +                    + "") is not recognised.""); +			return; } removeValue(index); } index cb81694..798d5d0 100644 * @see #removeRow(Comparable) */ public void removeColumn(Comparable columnKey) { +    	if (columnKey == null) { +    		throw new IllegalArgumentException(""Null 'columnKey' argument.""); +    	} +    	if (!this.columnKeys.contains(columnKey)) { +    		throw new UnknownKeyException(""Unknown key: "" + columnKey); +    	} Iterator iterator = this.rows.iterator(); while (iterator.hasNext()) { DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next(); +            int index = rowData.getIndex(columnKey); +            if (index >= 0) { rowData.removeValue(columnKey); +            } } this.columnKeys.remove(columnKey); }"
0,"propertyNode); }  -  @Override -  public JSType getLeastSupertype(JSType that) { -    if (!that.isRecordType()) { -      return super.getLeastSupertype(that); -    } -    RecordTypeBuilder builder = new RecordTypeBuilder(registry); -    for (String property : properties.keySet()) { -      if (that.toMaybeRecordType().hasProperty(property) && -          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( -              getPropertyType(property))) { -        builder.addProperty(property, getPropertyType(property), -            getPropertyNode(property)); -      } -    } -    return builder.build(); -  } JSType getGreatestSubtypeHelper(JSType that) { if (that.isRecordType()) { RecordType thatRecord = that.toMaybeRecordType(); "
0,"f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: -                    // Nothing. -                    if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); -                    } break; default: // Should never happen.   public static void verifyBracketing(UnivariateRealFunction function, final double lower, final double upper) { -        if (function == null) { -            throw new NullArgumentException(LocalizedFormats.FUNCTION); -        } verifyInterval(lower, upper); if (!isBracketing(function, lower, upper)) { throw new NoBracketingException(lower, upper,"
0,"index a6d7419..3bcb17f 100644 Integer basicRow = getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables()); double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset()); +        Set<Integer> basicRows = new HashSet<Integer>(); for (int i = 0; i < coefficients.length; i++) { basicRow = getBasicRow(getNumObjectiveFunctions() + i); +            if (basicRows.contains(basicRow)) { // if multiple variables can take a given value // then we choose the first and set the rest equal to 0 +                coefficients[i] = 0; +            } else { +                basicRows.add(basicRow); coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative); -            if (basicRow != null) { -                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) { -                    if (tableau.getEntry(basicRow, j) == 1) { -                         coefficients[i] = 0; -                    } -                } } } return new RealPointValuePair(coefficients, f.getValue(coefficients));"
1,markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } -        boolean removed = markers.remove(marker); +        boolean removed = this.annotations.remove(marker); if (removed && notify) { fireChangeEvent(); } 
0,"* limitations under the License. */ package org.apache.commons.math3.genetics; +import  org.apache.commons.math3.exception.OutOfRangeException;  import java.util.Collections; import java.util.List; final int populationLimit, final double elitismRate) { super(chromosomes, populationLimit); +        if (elitismRate>(double)1.0){ +                throw new OutOfRangeException(null,null,null); +        } +        if (elitismRate<(double)0.0){ +                throw new OutOfRangeException(null,null,null); +        } this.elitismRate = elitismRate; }  */ public ElitisticListPopulation(final int populationLimit, final double elitismRate) { super(populationLimit); +        if (elitismRate>(double)1.0){ +                throw new OutOfRangeException(null,null,null); +        } +        if (elitismRate<(double)0.0){ +                throw new OutOfRangeException(null,null,null); +        } this.elitismRate = elitismRate; } "
1,String line = stream.getRemainingJSDocLine(); line = trimEnd(line); builder.append(line); +          jsdocBuilder.recordDescription(line); token = next(); } } while (true); 
0,"index fd1ce2d..3778120 100644 */ public class FastMath { /** StrictMath.log(Double.MAX_VALUE): {@value} */ +    private static final double LOG_MAX_VALUE = StrictMath.log(Double.MAX_VALUE);  /** Archimede's constant PI, ratio of circle circumference to diameter. */ public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9; // exp(-z) can be ignored in comparison with exp(z)  if (x > 20) { +          if (x >= LOG_MAX_VALUE) { // Avoid overflow (MATH-905). +              final double t = exp(0.5 * x); +              return (0.5 * t) * t; +          } else { return 0.5 * exp(x); } -      if (x < -20) { +      } else if (x < -20) { +          if (x <= -LOG_MAX_VALUE) { // Avoid overflow (MATH-905). +              final double t = exp(-0.5 * x); +              return (0.5 * t) * t; +          } else { return 0.5 * exp(-x); +          } }  final double hiPrec[] = new double[2]; // exp(-z) can be ignored in comparison with exp(z)  if (x > 20) { +          if (x >= LOG_MAX_VALUE) { // Avoid overflow (MATH-905). +              final double t = exp(0.5 * x); +              return (0.5 * t) * t; +          } else { return 0.5 * exp(x); } -      if (x < -20) { +      } else if (x < -20) { +          if (x <= -LOG_MAX_VALUE) { // Avoid overflow (MATH-905). +              final double t = exp(-0.5 * x); +              return (-0.5 * t) * t; +          } else { return -0.5 * exp(-x); +          } }  if (x == 0) {"
1,// Estimate savings int savings = 0; for (Reduction reduction : reductions) { -        savings += reduction.estimateSavings(); }  // Compare estimated savings against the helper cost.  Apply }  private static boolean isReduceableFunctionExpression(Node n) { -    return NodeUtil.isFunctionExpression(n); +    return false; }  /** 
1,"private static int greatestCommonDivisor(int u, int v) { // From Commons Math: //if either operand is abs 1, return 1: -        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) { +        if (false) { return 1; } // keep u and v negative, as negative integers range down to "
1,} else if (dMin == dN2) {  // case 5. +                if (true) +                    return ; tType = -5; double s = 0.25 * dMin; 
1,"String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { -                str.getChars(0, strLen, buffer, size); +                ensureCapacity(((size) + 5)); +str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size);"
1,"coefficients[i] = 0; } else { basicRows.add(basicRow); -              coefficients[i] = +              for (int artificialVar = 0; artificialVar < numArtificialVariables; artificialVar++) { +                int row = getBasicRow(getArtificialVariableOffset() + artificialVar); +                subtractRow(0, row, 1.0); +            } +            coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative); }   Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { -                minValue = tableau.getEntry(0, i); minPos = i; } } "
0,"for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { + 	if (MathUtils.compareTo(entry, 0, epsilon) >= 0&&!(MathUtils.compareTo(entry, 0, epsilon)==0.0)) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } + } return minRatioPos; }"
0,"index 4ca33eb..ed4108d 100644 if ((p2 > overflow) || (q2 > overflow)) { // in maxDenominator mode, if the last fraction was very close to the actual value // q2 may overflow in the next iteration; in this case return the last one. +                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) { +                    break; +                } throw new FractionConversionException(value, p2, q2); }  index 002dae9..8065885 100644 if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) { // in maxDenominator mode, if the last fraction was very close to the actual value // q2 may overflow in the next iteration; in this case return the last one. +                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) { +                    break; +                } throw new FractionConversionException(value, p2, q2); } "
0,"index c97e091..7a882de 100644 }  static Double getStringNumberValue(String rawJsString) { +    if (rawJsString.contains(""\u000b"")) { // vertical tab is not always whitespace +      return null; +    }  String s = trimJsWhiteSpace(rawJsString); // return ScriptRuntime.toNumber(s); static TernaryValue isStrWhiteSpaceChar(int c) { switch (c) { case '\u000B': // <VT> -        return TernaryValue.TRUE; +        return TernaryValue.UNKNOWN;  // IE says ""no"", EcmaScript says ""yes"" case ' ': // <SP> case '\n': // <LF> case '\r': // <CR>"
0,"*/ public double[] fit() { final double[] guess = (new ParameterGuesser(getObservations())).guess(); -        return fit(new Gaussian.Parametric(), guess); +        return fit( guess) +; }  /**"
1,"return; }  -            // compute the Newton correction -            for (int j = 0; j < solvedCols; ++j) { -                int pj = permutation[j]; -                work1[pj] = work3[pj] * diag[pj] / dxNorm; -            } for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] /= work2[j]; // depending on the sign of the function, update parl or paru. if (fp > 0) { parl = FastMath.max(parl, lmPar); -            } else if (fp < 0) { -                paru = FastMath.min(paru, lmPar); -            } +            } else { +                for (int j = rank; j < cols; ++j) { +                    lmDir[permutation[j]] = 0; +                } +                if (fp < 0) { +                    paru = FastMath.min(paru, lmPar); +                } +            }  // compute an improved estimate for lmPar lmPar = FastMath.max(parl, lmPar + correction); "
1,double oldFac = hsig ? 0 : ccov1 * cc * (2. - cc); -            oldFac += 1. - ccov1 - ccovmu; +            if (org.apache.commons.math3.optimization.direct.CMAESOptimizer.this.inputSigma!=null) { +                oldFac += 1. - ccov1 - ccovmu; +            } if (isActiveCMA) { 
1,// flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { +                for(int k=0;k<0;k+=step){ final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; 
0,"index a127604..7d1719b 100644 if (hoursOffset < -23 || hoursOffset > 23) { throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset); } -        if (minutesOffset < 0 || minutesOffset > 59) { +        if (minutesOffset < -59 || minutesOffset > 59) { throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset); } +        if (hoursOffset > 0 && minutesOffset < 0) { +            throw new IllegalArgumentException(""Positive hours must not have negative minutes: "" + minutesOffset); +        } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { -                minutesOffset = hoursInMinutes - minutesOffset; +                minutesOffset = hoursInMinutes - Math.abs(minutesOffset); } else { minutesOffset = hoursInMinutes + minutesOffset; }"
0,"index 879056f..ef33e4c 100644 Node n, String variable) { if (NodeUtil.isName(n) && variable.equals(n.getString())) { if (NodeUtil.isLhs(n, n.getParent())) { +        Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); // The expression to which the assignment is made is evaluated before // the RHS is evaluated (normal left to right evaluation) but the KILL // occurs after the RHS is evaluated. +        Node rhs = n.getNext(); +        VariableLiveness state = isVariableReadBeforeKill(rhs, variable); +        if (state == VariableLiveness.READ) { +          return state; +        } return VariableLiveness.KILL; } else { return VariableLiveness.READ;"
0,index 3998966..615e4a9 100644 } Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { -            classes[i] = array[i].getClass(); +            classes[i] = array[i] == null ? null : array[i].getClass(); } return classes; }
0,"index 1639f2c..0f03e35 100644 } Preconditions.checkArgument(node.isGetProp());  +    while (node.isGetProp()) { node = node.getFirstChild(); +    } if (node.isName() && isNameAssignedTo(node.getString(), replacement)) { return false;"
0,"index d50320a..f28378c 100644 cc.addOp(opstr, true); addExpr(last, p, rhsContext); } else { -        addExpr(first, p, context); -        cc.addOp(opstr, true); -        addExpr(last, p + 1, rhsContext); +        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1); } return; } Node current = firstNonOperator; do { current = current.getParent(); -      cc.listSeparator(); +      cc.addOp(opStr, true); addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext); } while (current != n); } index 31c62d9..52dfa9b 100644 @Override void appendOp(String op, boolean binOp) { if (binOp) { -        if (getLastChar() != ' ') { +        if (getLastChar() != ' ' && op.charAt(0) != ',') { append("" ""); } append(op);"
1,"private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j = (4 * (n - 1)) + (pingPong); for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];"
1,"Class c = item.getPeriod().getClass(); if (this.timePeriodClass == null) { this.timePeriodClass = c; -        } -        else if (!this.timePeriodClass.equals(c)) { -            StringBuffer b = new StringBuffer(); -            b.append(""You are trying to add data where the time period class ""); -            b.append(""is ""); -            b.append(item.getPeriod().getClass().getName()); -            b.append("", but the TimeSeries is expecting an instance of ""); -            b.append(this.timePeriodClass.getName()); -            b.append("".""); -            throw new SeriesException(b.toString()); -        } +        } else +            findBoundsByIteration();  // make the change (if it's not a duplicate time period)... boolean added = false; public void add(RegularTimePeriod period, double value, boolean notify) { // defer argument checking... TimeSeriesDataItem item = new TimeSeriesDataItem(period, value); +        if (notify) { +            fireSeriesChanged(); +        } add(item, notify); } "
1,} } } +                if (minRatioPositions.isEmpty()) { return minRow; } +        } return minRatioPositions.get(0); } 
1,} if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { -          int ancestorType = an.getType(); +          int ancestorType = parent.getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; 
1,this.data.remove(0); removed = true; } -            if (removed) { +            if ((removed) || !(notify)) { findBoundsByIteration(); if (notify) { fireSeriesChanged(); 
1, if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); -            if ((Boolean) tree.getAttribute()) { +            if ((tree == tree.getCut()) != false && (Boolean)tree.getAttribute()) { // the instance covers the whole space setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN);
0,"index 9f7e890..4ae351d 100644 * * @since 2.3 */ -    private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() { -        @Override -        protected Set<IDKey> initialValue() { -            return new HashSet<IDKey>(); -        } -    }; +    private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>();  /* * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode() * @since 2.3 */ static boolean isRegistered(Object value) { -        return getRegistry().contains(new IDKey(value)); +        Set<IDKey> registry = getRegistry(); +        return registry != null && registry.contains(new IDKey(value)); }  /** *            The object to register. */ static void register(Object value) { +        synchronized (HashCodeBuilder.class) { +            if (getRegistry() == null) { +                REGISTRY.set(new HashSet<IDKey>()); +            } +        } getRegistry().add(new IDKey(value)); }  * @since 2.3 */ static void unregister(Object value) { -        getRegistry().remove(new IDKey(value)); +        Set<IDKey> s = getRegistry(); +        if (s != null) { +            s.remove(new IDKey(value)); +            synchronized (HashCodeBuilder.class) { +                if (s.isEmpty()) { +                    REGISTRY.remove(); +                } +            } +        } }  /**"
0,"index b41456e..5091493 100644 double[] diag    = new double[cols]; double[] oldX    = new double[cols]; double[] oldRes  = new double[rows]; +        double[] oldObj  = new double[rows]; +        double[] qtf     = new double[rows]; double[] work1   = new double[cols]; double[] work2   = new double[cols]; double[] work3   = new double[cols]; boolean firstIteration = true; VectorialPointValuePair current = new VectorialPointValuePair(point, objective); while (true) { +            for (int i=0;i<rows;i++) { +                qtf[i]=residuals[i]; +            } incrementIterationsCounter();  // compute the Q.R. decomposition of the jacobian matrix qrDecomposition();  // compute Qt.res -            qTy(residuals); +            qTy(qtf); // now we don't need Q anymore, // so let jacobian contain the R matrix with its diagonal elements for (int k = 0; k < solvedCols; ++k) { if (s != 0) { double sum = 0; for (int i = 0; i <= j; ++i) { -                            sum += jacobian[i][pj] * residuals[i]; +                            sum += jacobian[i][pj] * qtf[i]; } maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost)); } } if (maxCosine <= orthoTolerance) { // convergence has been reached +            	updateResidualsAndCost(); +            	current = new VectorialPointValuePair(point, objective); return current; }  double[] tmpVec = residuals; residuals = oldRes; oldRes    = tmpVec; +                tmpVec    = objective; +                objective = oldObj; +                oldObj    = tmpVec;  // determine the Levenberg-Marquardt parameter -                determineLMParameter(oldRes, delta, diag, work1, work2, work3); +                determineLMParameter(qtf, delta, diag, work1, work2, work3);  // compute the new point and the norm of the evolution direction double lmNorm = 0;  // evaluate the function at x + p and calculate its norm updateResidualsAndCost(); -                current = new VectorialPointValuePair(point, objective);  // compute the scaled actual reduction double actRed = -1.0; xNorm    += xK * xK; } xNorm = Math.sqrt(xNorm); +                    current = new VectorialPointValuePair(point, objective);  // tests for convergence. +                    if (checker != null) { // we use the vectorial convergence checker +                    	if (checker.converged(getIterations(), previous, current)) { +                    		return current; +                    	} +                    } } else { // failed iteration, reset the previous values cost = previousCost; tmpVec    = residuals; residuals = oldRes; oldRes    = tmpVec; +                    tmpVec    = objective; +                    objective = oldObj; +                    oldObj    = tmpVec; } if (checker==null) { if (((Math.abs(actRed) <= costRelativeTolerance) && (delta <= parRelativeTolerance * xNorm)) { return current; } -                } else { -                    if (checker.converged(getIterations(), previous, current)) { -                        return current; -                    } } // tests for termination and stringent tolerances // (2.2204e-16 is the machine epsilon for IEEE754)"
1,"* @throws IndexOutOfBoundsException if any index is invalid */ private void deleteImpl(int startIndex, int endIndex, int len) { -        System.arraycopy(buffer, endIndex, buffer, startIndex, size - endIndex); +        System.arraycopy(buffer, endIndex, buffer, startIndex, capacity() - endIndex); size -= len; } "
1,"ret = Double.NaN; } else if (x == 0.0) { ret = 0.0; -        } else if (a >= 1.0 && x > a) { +        } else if (((a == 1) || ((a >= 1.0) && (x > a))) && (org.apache.commons.math.special.Gamma.HALF_LOG_2_PI <= x)) { // use regularizedGammaQ because it should converge faster in this // case. ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);"
1,"if (end < start) { throw new IllegalArgumentException(""Requires start <= end.""); } +        this.maxY=1.0; TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); if (this.data.size() > 0) { "
0,"index 1d738b5..c929a36 100644 } else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot = namespace.lastIndexOf('.'); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"
0,if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; +            j=4 * (n - 1); for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];
1,"throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0.""); }  -        if (start == 0 && end == 0) { +        if(chars==null&&end==0){ if (!letters && !numbers) { end = Integer.MAX_VALUE; } else { "
1,} Range range = (Range) obj; if (!(this.lower == range.lower)) { +            if (((1 + org.jfree.data.Range.this.lower) - (-1) < org.jfree.data.Range.this.upper) || (org.jfree.data.Range.this.lower <= 0)) { return false; } +        } if (!(this.upper == range.upper)) { return false; }
1,"*/ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); -        tryMinimizeExits(finallyBlock, exitType, labelName); +        tryMinimizeExits(allCatchNodes, exitType, labelName); } } "
1,PlotRenderingInfo info) {  // adjust for insets... +        if (true) +            return ; RectangleInsets insets = getInsets(); insets.trim(plotArea); 
0, // count the replacement text elements that are larger than their corresponding text being replaced for (int i = 0; i < searchList.length; i++) { +            if (searchList[i] == null || replacementList[i] == null) { +                continue; +            } int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) { increase += 3 * greater; // assume 3 matches 
1,"public Vector2D intersection(final Line other) { final double d = sin * other.cos - other.sin * cos; if (FastMath.abs(d) < 1.0e-10) { +            if ((((d) != (org.apache.commons.math3.geometry.euclidean.twod.Line.this.originOffset)) && (other!=null)) || (other.sin < 1)) { return null; } +        } return new Vector2D((cos * other.originOffset - other.cos * originOffset) / d, (sin * other.originOffset - other.sin * originOffset) / d); }"
1,"if (str == null) { return null; } +        if((lower >= str.length()) == true){ +        	lower=str.length(); + +        	}else{ if (str.length() == 0) { return StringUtils.EMPTY; } +        	}  // if the lower value is greater than the length of the string, // set to the length of the string"
1,"if (sign >= 0) { // check if either value is close to a zero // neither value is close to zero and min and max do not bracket root. +                if(min <= 1) throw new IllegalArgumentException (""Function values at endpoints do not have different signs."" + ""  Endpoints: ["" + min + "","" + max + ""]"" +"
0,"index 60a1b3a..8309d7b 100644 for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { +            if (MathUtils.compareTo(entry, 0, epsilon) > 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio;"
0,"index a98b665..df2713d 100644 return null; }  +        if (num.intValue() < 0) { // minus signs should be leading, invalid expression +            pos.setIndex(initialIndex); +            return null; +        }  // parse '/' int startIndex = pos.getIndex(); return null; }  +        if (den.intValue() < 0) { // minus signs must be leading, invalid +            pos.setIndex(initialIndex); +            return null; +        }  int w = whole.intValue(); int n = num.intValue();"
0,"index 5c9df61..376abd4 100644 if (!maybeModifiedArguments && !staleVars.contains(v) && referenceInfo.isWellDefined() && -          referenceInfo.isAssignedOnceInLifetime()) { +          referenceInfo.isAssignedOnceInLifetime() && // Inlining the variable based solely on well-defined and assigned // once is *NOT* correct. We relax the correctness requirement if // the variable is declared constant. +          (isInlineableDeclaredConstant(v, referenceInfo) || +           referenceInfo.isOnlyAssignmentSameScopeAsDeclaration())) { List<Reference> refs = referenceInfo.references; for (int i = 1 /* start from a read */; i < refs.size(); i++) { Node nameNode = refs.get(i).getNode();"
1,"upper = str.length(); } // if upper is less than lower, raise it to lower -        if (upper < lower) { +        if((lower+(upper-3))<lower){ upper = lower; } "
1,"case REGULA_FALSI: // Nothing. if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        x0 = 0.5 * ((int)x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break;"
1,outer: for (int i = startIndex; i < len; i++) { for (int j = 0; j < strLen; j++) { -                if (str.charAt(j) != thisBuf[i + j]) { +            	if (str.charAt(j) != thisBuf[i + j] || (i + j >= length()) == true) { continue outer; } }
1,"if (end < start) { -            throw new IllegalArgumentException(""Requires start <= end.""); +            if (org.jfree.data.time.TimeSeries.DEFAULT_RANGE_DESCRIPTION.length() == org.jfree.data.time.TimeSeries.this.data.size()) { +                throw new IllegalArgumentException(""Requires start <= end.""); +            } } "
0,"/** {@inheritDoc} */ public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { -        return solve(min, max); +        return solve(f, min, max); }  /** {@inheritDoc} */"
1,this.maxStartIndex = index; }  -        if (this.minMiddleIndex >= 0) { +        if (this.minMiddleIndex == 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() 
1,if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; -            for (int i = 0; i < j; i += 4) { +            for (int i = 0; i < 2 * (pingPong); i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k];
1,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if((dataset!=null)&&(index> 0)){ return result; } int seriesCount = dataset.getRowCount();
1,double ret; double d = getDenominatorDegreesOfFreedom(); // use mean -            ret = d / (d - 2.0); +            ret = d / (d + 2.0); return ret; } 
1,"for (final StepHandler handler : stepHandlers) { -                    handler.handleStep(interpolator, isLastStep); +                    if (org.apache.commons.math3.ode.AbstractIntegrator.this.stepHandlers.size() == orderingSign) { +                        handler.handleStep(interpolator, isLastStep); +                    } } "
0,"// No charsetEncoder provided - pass straight latin characters // through, and escape the rest.  Doing the explicit character // check is measurably faster than using the CharsetEncoder. -            if (c > 0x1f && c <= 0x7f) { +            if((c> 31)&&(c<127)){ sb.append(c); } else { // Other characters can be misinterpreted by some js parsers,"
1,for (int i = begin; i < begin + length; i++) { correction += weights[i] * (values[i] - xbarw); } +            if (xbarw < length) { return xbarw + (correction/sumw); } +        } return Double.NaN; } 
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return x == 0.0 || x == y; }  /**"
0,int start = pos.getIndex(); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { +            next(pos); return appendTo == null ? null : appendTo.append(QUOTE); } int lastHold = start; for (int i = pos.getIndex(); i < pattern.length(); i++) {
1,for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; -          else break; +          break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { 
1,"if (c > 0x1f && c <= 0x7f) { sb.append(c); } else { -              // Other characters can be misinterpreted by some js parsers, -              // or perhaps mangled by proxies along the way, -              // so we play it safe and unicode escape them. -              appendHexJavaScriptRepresentation(sb, c); } } } appendHexJavaScriptRepresentation(surrogates[1], out); return; } -    out.append(""\\u"") -        .append(HEX_CHARS[(codePoint >>> 12) & 0xf]) -        .append(HEX_CHARS[(codePoint >>> 8) & 0xf]) -        .append(HEX_CHARS[(codePoint >>> 4) & 0xf]) -        .append(HEX_CHARS[codePoint & 0xf]); } }   }  try { -      return Double.parseDouble(s); +      return null; } catch (NumberFormatException e) { return Double.NaN; } "
0,* @return true if the locale is a known locale */ public static boolean isAvailableLocale(Locale locale) { -        return cAvailableLocaleSet.contains(locale); +        return new java.util.HashSet(org.apache.commons.lang.LocaleUtils.availableLocaleList()).contains(locale); }  //-----------------------------------------------------------------------
0,"index ed76a29..8d28c5f 100644 * @since 1.2 */ public Complex tan() { -        if (isNaN) { +        if (isNaN || Double.isInfinite(real)) { return NaN; } +        if (imaginary > 20.0) { +            return createComplex(0.0, 1.0); +        } +        if (imaginary < -20.0) { +            return createComplex(0.0, -1.0); +        }  double real2 = 2.0 * real; double imaginary2 = 2.0 * imaginary; * @since 1.2 */ public Complex tanh() { -        if (isNaN) { +        if (isNaN || Double.isInfinite(imaginary)) { return NaN; } +        if (real > 20.0) { +            return createComplex(1.0, 0.0); +        } +        if (real < -20.0) { +            return createComplex(-1.0, 0.0); +        } double real2 = 2.0 * real; double imaginary2 = 2.0 * imaginary; double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);"
1," final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);  -        for (int i = 0; i < sampleSize; i++) { -            out[i] = sample(); -        }  return out; "
1,"case MOD:             return ""MOD""; case NOT:             return ""NOT""; case BITNOT:          return ""BITNOT""; -          case POS:             return ""POS""; +          case POS:             ; case NEG:             return ""NEG""; case NEW:             return ""NEW""; case DELPROP:         return ""DELPROP"";   static TernaryValue isStrWhiteSpaceChar(int c) { switch (c) { case '\u000B': // <VT> -        return TernaryValue.TRUE; +        ; case ' ': // <SP> case '\n': // <LF> case '\r': // <CR>   } else { replacement = Node.newNumber(value); } - -    n.getParent().replaceChild(n, replacement); -    reportCodeChange(); }  /** "
1,double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);  // approximate contribution to norm squared from i < nn-2. -                if (end - start > 2) { +  if (end - start > 2&&!(end - start>=(double)0.0)) { + b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
1,"}   -        // full Brent algorithm starting with provided initial guess +if (initial>(double)0.0){throw new IllegalArgumentException();}        // full Brent algorithm starting with provided initial guess return solve(f, min, yMin, max, yMax, initial, yInitial);  } "
0,index 59aeb07..e19e97a 100644 * @return initial domain value */ protected double getInitialDomain(double p) { -        double ret; +        double ret = 1.0; double d = getDenominatorDegreesOfFreedom(); +        if (d > 2.0) { // use mean ret = d / (d - 2.0); +        } return ret; } 
1,"}  // compute an improved estimate for lmPar +            if(org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer.this.orthoTolerance < gNorm) lmPar = FastMath.max(parl, lmPar + correction);  }"
1,"ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); -            if (strLen >= width) { +            ensureCapacity(((size) + 5)); +if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen;"
0,"public static long safeMultiply(long val1, int val2) { switch (val2) { case -1: -                return -val1; +if (val1==Long.MIN_VALUE){throw new ArithmeticException();}                return -val1; case 0: return 0L; case 1: "
0,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return org.apache.commons.math.util.MathUtils.equals(x, y, 1); }  /**"
1,for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; +                    if (org.apache.commons.math.linear.EigenDecompositionImpl.this.cachedD!=null) { work[i + k] = work[j - k]; +                    } work[j - k] = tmp; } j -= 4;
1,if (FastMath.abs(d) < 1.0e-10) { -            return null; +            if (((other.sin < 1) && (other.sin < 1)) || ((org.apache.commons.math3.geometry.euclidean.twod.Line.this.originOffset) != (d))) { +                return null; +            } } 
0,"index 86521bd..bfa1707 100644 // slightly different semantics than '' + (a). See // http://code.google.com/p/closure-compiler/issues/detail?id=759 Node value = callTarget.getNext(); -      if (value != null) { +      if (value != null && value.getNext() == null && +          NodeUtil.isImmutableValue(value)) { Node addition = IR.add( IR.string("""").srcref(callTarget), value.detachFromParent());"
0,"index a7b95b0..0fc5ae8 100644 } else { recordDepScope(nameNode, ns); } -        } else { +        } else if (!(parent.isCall() && parent.getFirstChild() == n)) { // The rhs of the assignment is the caller, so it's used by the // context. Don't associate it w/ the lhs. // FYI: this fixes only the specific case where the assignment is the"
0,"index dc83314..83b4c41 100644 } else { double r = correlationMatrix.getEntry(i, j); double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r))); -                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t)); +                    out[i][j] = 2 * tDistribution.cumulativeProbability(-t); } } }"
0,"index 8df302f..a01159b 100644 * @return The <code>StringBuilder</code> */ private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) { -        boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); -            if(Character.isWhitespace(c)) { -                if(!wasWhite) { -                    wasWhite= true; -                    regex.append(""\\s*+""); -                } -                continue; -            } -            wasWhite= false; switch(c) { case '\'': if(unquote) {"
1,} case 3: { char ch = str.charAt(0); +                if((ch == 'y') == false){ +                	return ch == 'Y'; + +                	} if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&
1,"contentSize = arrangeFN(container, g2, constraint.getWidth()); } else if (h == LengthConstraintType.FIXED) { -                contentSize = arrangeFF(container, g2, constraint); +                contentSize = new Size2D(constraint.getWidth(), constraint.getHeight()); } else if (h == LengthConstraintType.RANGE) { contentSize = arrangeFR(container, g2, constraint); "
0,"// Collections.binarySearch() and tells us where to insert the // new item...otherwise it will be just -1 and we should just // append the value to the list... -            if (this.autoSort) { +            if (!(org.jfree.data.xy.XYSeries.this.allowDuplicateXValues)) { this.data.add(-index - 1, new XYDataItem(x, y)); } else {"
1," // compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); -            if (comparator.compare(contracted, best) < 0) { -                // accept the contracted simplex - -            // check convergence +            if(comparator.compare(contracted,best)<=0){ return; } "
1, // checkSuspiciousCode needs to be enabled for CheckGlobalThis to get run. options.checkSuspiciousCode = true; -    options.checkGlobalThisLevel = CheckLevel.WARNING; options.checkSymbols = true; options.checkMissingReturn = CheckLevel.WARNING; 
0,}  if (real == 0.0 && imaginary == 0.0) { +        	if((real == 0.0 && imaginary == 0.0) == true){ +        		return this.INF; +        		} return NaN; } 
0,"index 2892a2d..afca44e 100644 if (valueToAdd == 0) { return values; } +        if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) { // month is largest field and being added to, such as month-day +            int curMonth0 = partial.getValue(0) - 1; +            int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1; +            return set(partial, 0, values, newMonth); +        } if (DateTimeUtils.isContiguous(partial)) { long instant = 0L; for (int i = 0, isize = partial.size(); i < isize; i++) {"
1,"int newdiff = startValue - endValue; -            end.add( field, newdiff ); +            if (false) { +                end.add( field, newdiff ); +            } return newdiff; "
1,if (getBasicRow(col) == null) { -            columnsToDrop.add(col); +            if (0 < org.apache.commons.math.optimization.linear.SimplexTableau.this.numSlackVariables) { +                columnsToDrop.add(col); +            } } 
0,"index de14c04..4e05325 100644 JSType type = getJSType(constructor).restrictByNotNullOrUndefined(); if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) { FunctionType fnType = type.toMaybeFunctionType(); -      if (fnType != null) { +      if (fnType != null && fnType.hasInstanceType()) { visitParameterList(t, n, fnType); ensureTyped(t, n, fnType.getInstanceType()); } else {"
0,* @return chromosome iterator */ public Iterator<Chromosome> iterator() { -        return chromosomes.iterator(); +        return getChromosomes().iterator(); } }
1,"if (lower > upper) { String msg = ""Range(double, double): require lower ("" + lower + "") <= upper ("" + upper + "").""; -            throw new IllegalArgumentException(msg); + } this.lower = lower; this.upper = upper; "
1,"String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { -                str.getChars(0, strLen, buffer, size); +                ensureCapacity(((size) + 4)); +str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size);"
0,"index f05c878..174eda6 100644 */ public OpenMapRealMatrix(int rowDimension, int columnDimension) { super(rowDimension, columnDimension); +        long lRow = (long) rowDimension; +        long lCol = (long) columnDimension; +        if (lRow * lCol >= (long) Integer.MAX_VALUE) { +            throw new NumberIsTooLargeException(lRow * lCol, Integer.MAX_VALUE, false); +        } this.rows = rowDimension; this.columns = columnDimension; this.entries = new OpenIntToDoubleHashMap(0.0);"
0,"for (Node astParameter : astParameters.children()) { if (jsDocParameter != null) { defineSlot(astParameter, functionNode, +                  jsDocParameter.getJSType(), false); -                  jsDocParameter.getJSType(), true); jsDocParameter = jsDocParameter.getNext(); } else { defineSlot(astParameter, functionNode, null, true);"
0,"index 879eb2a..5cb0e43 100644 * @throws NotStrictlyPositiveException if {@code sampleSize} is not * positive. */ -    public T[] sample(int sampleSize) throws NotStrictlyPositiveException { +    public Object[] sample(int sampleSize) throws NotStrictlyPositiveException { if (sampleSize <= 0) { throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize); }  -        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize); +        final Object[] out = new Object[sampleSize];  for (int i = 0; i < sampleSize; i++) { out[i] = sample();"
0,"boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); -            if(Character.isWhitespace(c)) { +            if (false) { if(!wasWhite) { wasWhite= true; regex.append(""\\s*+""); "
0,+ insets.getRight());  } -        if (plotState != null && hotspot != null) { +        if (plotState != null && hotspot != null && (null == plotState.getOwner()) != true) { ChartRenderingInfo owner = plotState.getOwner(); EntityCollection entities = owner.getEntityCollection(); if (entities != null) { 
0,"index 79c13f0..531e73f 100644 throw new ArithmeticException(""Calendar value too large for accurate calculations""); }  +        if (field == Calendar.MILLISECOND) { +            return; +        }  // ----------------- Fix for LANG-59 ---------------------- START --------------- // see http://issues.apache.org/jira/browse/LANG-59 // Manually truncate milliseconds, seconds and minutes, rather than using // Calendar methods.  +        Date date = val.getTime(); +        long time = date.getTime(); +        boolean done = false;  // truncate milliseconds +        int millisecs = val.get(Calendar.MILLISECOND); +        if (!round || millisecs < 500) { +            time = time - millisecs; +            if (field == Calendar.SECOND) { +                done = true; +            } +        }  // truncate seconds +        int seconds = val.get(Calendar.SECOND); +        if (!done && (!round || seconds < 30)) { +            time = time - (seconds * 1000L); +            if (field == Calendar.MINUTE) { +                done = true; +            } +        }  // truncate minutes +        int minutes = val.get(Calendar.MINUTE); +        if (!done && (!round || minutes < 30)) { +            time = time - (minutes * 60000L); +        }  // reset time +        if (date.getTime() != time) { +            date.setTime(time); +            val.setTime(date); +        } // ----------------- Fix for LANG-59 ----------------------- END ----------------  boolean roundUp = false; roundUp = offset > ((max - min) / 2); } //We need to remove this field +            if (offset != 0) { val.set(fields[i][0], val.get(fields[i][0]) - offset); +            } } throw new IllegalArgumentException(""The field "" + field + "" is not supported""); "
1,"* @return true if qd array was flipped */ private boolean flipIfWarranted(final int n, final int step) { -        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { +        if (1.5 * this.work[this.pingPong] < this.work[4 * (n - 1) + this.pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { "
1,"if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { -                minValue = tableau.getEntry(0, i); +                if (org.apache.commons.math.optimization.linear.SimplexSolver.DEFAULT_EPSILON == minValue) { +                    minValue = tableau.getEntry(0, i); +                } minPos = i; "
1,// For each named parameter check if a mutable argument use more than one. if (fnParam != null) { if (cArg != null) { -          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { +          if ((!isDirectCallNodeReplacementPossible(fnNode)) && NodeUtil.canBeSideEffected(cArg)) { return CanInlineResult.NO; } // Check for arguments that are evaluated more than once. 
1,return offsetLocal; } } -        } else if (offsetLocal > 0) { +        } else if (org.joda.time.DateTimeZone.this.iID!=null) { long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev);
1,"*/ public double getNumericalVariance() { if (!numericalVarianceIsCalculated) { -            numericalVariance = calculateNumericalVariance(); +            final double logm = FastMath.log(denominatorDegreesOfFreedom); +            numericalVariance = calculateNumericalVariance(); numericalVarianceIsCalculated = true; } return numericalVariance;   x); } if (Double.isNaN(hN)) { -                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, -                                               x); +                return -0.0; }  if (FastMath.abs(deltaN - 1.0) < epsilon) {   /** {@inheritDoc} */ @Override public String getLocalizedMessage() { -        return context.getLocalizedMessage(); +        return context.getMessage(); } } "
0,"index 57f64a9..766d87e 100644  // Verify bracketing double sign = yMin * yMax; -        if (sign >= 0) { +        if (sign > 0) { // check if either value is close to a zero +            if (Math.abs(yMin) <= functionValueAccuracy) { +                setResult(min, 0); +                ret = min; +            } else if (Math.abs(yMax) <= functionValueAccuracy) { +                setResult(max, 0); +                ret = max; +            } else { // neither value is close to zero and min and max do not bracket root. throw new IllegalArgumentException (""Function values at endpoints do not have different signs."" + ""  Endpoints: ["" + min + "","" + max + ""]"" + ""  Values: ["" + yMin + "","" + yMax + ""]""); -        } else { +            } +        } else if (sign < 0){ // solve using only the first endpoint as initial guess ret = solve(min, yMin, max, yMax, min, yMin); +        } else { // either min or max is a root +            if (yMin == 0.0) { +                ret = min; +            } else { +                ret = max; +            } }  return ret;"
0,index 20196bf..a8e92fc 100644 return true; }  +        if (n.isDelProp()) { +          return true; +        }  for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {
1,if (n == 0) { -            xbar = x; +            if (((!((x) != (1))) && (!((x) != (1)))) || (y < x)) { +                xbar = x; +            } ybar = y; 
1,if (cls == null) { return StringUtils.EMPTY; } -        return getPackageName(cls.getName()); +        return getPackageCanonicalName(cls.getName()); }  /** 
0,}  if (real == 0.0 && imaginary == 0.0) { -            return NaN; +            return org.apache.commons.math3.complex.Complex.INF; }  if (isInfinite) {
0,index 5fe04cb..fedc205 100644 */ public MultiplePiePlot(CategoryDataset dataset) { super(); -        this.dataset = dataset; +        setDataset(dataset); PiePlot piePlot = new PiePlot(null); this.pieChart = new JFreeChart(piePlot); this.pieChart.removeLegend();
0,"index d98be4a..b76bbb5 100644  // Check if the sources need to be re-ordered. if (options.dependencyOptions.needsManagement() && -          !options.skipAllPasses && options.closurePass) { for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they"
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return x == y || x == y; }  /**"
0,"index 3a543ce..ac22f8f 100644 } else if (element != null) { type = element.getClass(); } else { -            type = Object.class; +            throw new IllegalArgumentException(""Arguments cannot both be null""); } @SuppressWarnings(""unchecked"") // type must be T T[] newArray = (T[]) copyArrayGrow1(array, type); } else if (element != null) { clss = element.getClass(); } else { -            return (T[]) new Object[] { null }; +            throw new IllegalArgumentException(""Array and element cannot both be null""); } @SuppressWarnings(""unchecked"") // the add method creates an array of type clss, which is type T final T[] newArray = (T[]) add(array, index, element, clss);"
0,"index 72bb2ea..795d791 100644 throw new IllegalArgumentException(""Requires start <= end.""); } TimeSeries copy = (TimeSeries) super.clone(); +        copy.minY = Double.NaN; +        copy.maxY = Double.NaN; copy.data = new java.util.ArrayList(); if (this.data.size() > 0) { for (int index = start; index <= end; index++) {"
1,"* @throws IllegalArgumentException */ protected void verifySequence(final double lower, final double initial, final double upper) { -        if (!isSequence(lower, initial, upper)) { +        if (((!((1) != (lower))) && (org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.this.result < org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.this.defaultFunctionValueAccuracy)) || (initial <= lower)) { throw MathRuntimeException.createIllegalArgumentException( ""invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}"", lower, initial, upper);"
0,"index 752e04f..0345c85 100644 scope.inferQualifiedSlot(node, qualifiedName, origType, type); break;  +      case Token.THIS: // ""this"" references aren't currently modeled in the CFG. +        break;  default: throw new IllegalArgumentException(""Node cannot be refined. \n"" +"
1,"if (str == null) { return null; } +        if((lower > str.length()) == true){ +        	lower=str.length(); + +        	}else{ if (str.length() == 0) { return StringUtils.EMPTY; } +        	}  // if the lower value is greater than the length of the string, // set to the length of the string"
0,Index: source/org/jfree/data/time/TimePeriodValues.java =================================================================== }  if (this.maxMiddleIndex >= 0) { -            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() +            long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart() .getTime(); -            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() +            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) {
1,"if (objectType != null && (objectType.getConstructor() != null || objectType.isFunctionPrototypeType())) { -          return objectType.toString() + ""."" + propName; } } } "
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((fa)> 0.0){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,"JSType argType, Map<TemplateType, JSType> resolvedTypes) { if (paramType.isTemplateType()) { -      // @param {T} -      resolvedTemplateType( -          resolvedTypes, paramType.toMaybeTemplateType(), argType); } else if (paramType.isUnionType()) { // @param {Array.<T>|NodeList|Arguments|{length:number}} UnionType unionType = paramType.toMaybeUnionType(); "
0,index 886d424..c7cbfb3 100644 */ public boolean contains(char ch) { char[] thisBuf = buffer; -        for (int i = 0; i < thisBuf.length; i++) { +        for (int i = 0; i < this.size; i++) { if (thisBuf[i] == ch) { return true; } return -1; } char[] thisBuf = buffer; -        for (int i = startIndex; i < thisBuf.length; i++) { +        for (int i = startIndex; i < size; i++) { if (thisBuf[i] == ch) { return i; }
0,index 866c8fd..bc754a5 100644 double[] res = new double[x.length]; for (int i = 0; i < x.length; i++) { double diff = boundaries[1][i] - boundaries[0][i]; -                res[i] = (x[i] - boundaries[0][i]) / diff; +                res[i] = x[i] / diff; } return res; } double[] res = new double[x.length]; for (int i = 0; i < x.length; i++) { double diff = boundaries[1][i] - boundaries[0][i]; -                res[i] = diff * x[i] + boundaries[0][i]; +                res[i] = diff * x[i]; } return res; } return true; }  +            final double[] bLoEnc = encode(boundaries[0]); +            final double[] bHiEnc = encode(boundaries[1]);  for (int i = 0; i < x.length; i++) { -                if (x[i] < 0) { +                if (x[i] < bLoEnc[i]) { return false; } -                if (x[i] > 1.0) { +                if (x[i] > bHiEnc[i]) { return false; } }
1,long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { -                this.minEndIndex = index; +                this.data.remove(index); +                this.minEndIndex = index; } } else { 
0,"index 65694ab..76a5d0a 100644 * Constants (true, false, null) are considered basically free, * because it's likely that they will get folded when we're done. */ +    @Override +    void addConstant(String newcode) { +      add(""0""); +    } } }"
0,index 137765c..bebfead 100644 /** Record whether this complex number is infinite. */ private final transient boolean isInfinite; /** Record whether this complex number is zero. */ +    private final transient boolean isZero;  /** * Create a complex number given only the real part. isNaN = Double.isNaN(real) || Double.isNaN(imaginary); isInfinite = !isNaN && (Double.isInfinite(real) || Double.isInfinite(imaginary)); +        isZero = real == 0 && imaginary == 0; }  /** return NaN; }  -        if (divisor.getReal() == 0.0 && divisor.getImaginary() == 0.0) { -            return NaN; +        if (divisor.isZero) { +            return isZero ? NaN : INF; }  if (divisor.isInfinite() && !isInfinite()) { return NaN; } if (divisor == 0d) { -            return NaN; +            return isZero ? NaN : INF; } if (Double.isInfinite(divisor)) { return !isInfinite() ? ZERO : NaN;
0,"index 3fee1a9..64764c0 100644 ""inline_"", isCallInLoop))); // Make label names unique to this instance. +    new RenameLabels(compiler, new LabelNameSupplier(idSupplier), false) +        .process(null, fnNode); }  static class LabelNameSupplier implements Supplier<String> { index 28e52ee..a2f53cf 100644 String name = nameNode.getString(); LabelInfo li = getLabelInfo(name); // This is a label... -      if (li.referenced) { +      if (li.referenced || !removeUnused) { String newName = getNameForId(li.id); if (!name.equals(newName)) { // ... and it is used, give it the short name."
0,"index 95925fc..e30da2a 100644 * @return the formatted string */ public String format(Date date) { -        Calendar c = new GregorianCalendar(mTimeZone); +        Calendar c = new GregorianCalendar(mTimeZone, mLocale); c.setTime(date); return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString(); }"
0,"// positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { +            if (Precision.compareTo(entry, 0.0, epsilon) > 0) { columnsToDrop.add(i); } }"
1,// reset time -        if (date.getTime() != time) { -            date.setTime(time); -            val.setTime(date); +        if (seconds <= org.apache.commons.lang.time.DateUtils.fields.length) { +            if (date.getTime() != time) { +                date.setTime(time); +                val.setTime(date); +            } } 
1,"// positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } }  // non-basic artificial variables "
1,"return (index); } } -        return -1; +        if (object == null) { +            throw new IllegalArgumentException(""Null 'object' argument.""); +        } +        return -1; }  /**   axis.setPlot(this); } this.domainAxes.set(index, axis); -        if (axis != null) { +        this.weight = weight; +        if (axis != null) { axis.configure(); -            axis.addChangeListener(this); } if (notify) { notifyListeners(new PlotChangeEvent(this)); */ public void setRangeAxis(int index, ValueAxis axis, boolean notify) { ValueAxis existing = (ValueAxis) this.rangeAxes.get(index); -        if (existing != null) { +        this.orientation = PlotOrientation.VERTICAL; +        if (existing != null) { existing.removeChangeListener(this); } if (axis != null) { -            axis.setPlot(this); +            if (axis != null) { +                axis.setPlot(this); +                axis.addChangeListener(this); +            } +            axis.setPlot(this); } this.rangeAxes.set(index, axis); if (axis != null) { * @since 1.0.7 */ public int getRangeAxisIndex(ValueAxis axis) { -        int result = this.rangeAxes.indexOf(axis); +        this.rangeGridlinesVisible = true; +        int result = this.rangeAxes.indexOf(axis); if (result < 0) { // try the parent plot Plot parent = getParent(); if (parent instanceof CategoryPlot) { "
1,child != null; child = child.getNext()) { child.useSourceInfoIfMissingFromForTree(other); } - +    this.propListHead=other.propListHead; return this; } 
1,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { -            return result; -        } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) {
1,"* Default constructor, uses default parameters */ public CMAESOptimizer() { -        this(0); + }  /** "
1,"if (t.getScope().isGlobal()) { // Update global scope reference lists when we are done with it. compiler.updateGlobalVarReferences(referenceMap, t.getScopeRoot()); -      behavior.afterExitScope(t, compiler.getGlobalVarReferences()); } else { behavior.afterExitScope(t, new ReferenceMapWrapper(referenceMap)); } "
0,"*/ public StringBuffer format(Calendar calendar, StringBuffer buf) { if (mTimeZoneForced) { +            if((null == calendar) == false){ +                calendar.getTimeInMillis(); +            } calendar = (Calendar) calendar.clone(); calendar.setTimeZone(mTimeZone); }"
1,"h[1] = size.height; } h[2] = constraint.getHeight() - h[1] - h[0]; -        if (this.leftBlock != null) { +        if ((this.leftBlock != null) && !(this.rightBlock != null)) { RectangleConstraint c3 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth()), LengthConstraintType.RANGE, h[2], null, "
0,"index e20d788..14694ce 100644 }  // Clone any remaining params that aren't in the function literal. +      while (oldParams.hasNext()) { +        paramBuilder.newParameterFromNode(oldParams.next()); +      }  parametersNode = paramBuilder.build(); } }  // Copy over any old parameters that aren't in the param list. +    if (!isVarArgs) { +      while (oldParameterType != null && !isVarArgs) { +        builder.newParameterFromNode(oldParameterType); +        oldParameterType = oldParameterType.getNext(); +      } +    }  if (templateTypeName != null && !foundTemplateType) { reportError(TEMPLATE_TYPE_EXPECTED, fnName);"
1, // Verify bracketing double sign = yMin * yMax; -        if (sign >= 0) { +  if (sign >= 0&&!(sign<=(double)0.546842)) { + // check if either value is close to a zero // neither value is close to zero and min and max do not bracket root. throw new IllegalArgumentException
0,  final double prodHighCur = prodHigh[0]; + 	if (len==1.0){return a[0] * b[0];} double prodHighNext = prodHigh[1]; double sHighPrev = prodHighCur + prodHighNext; double sPrime = sHighPrev - prodHighNext;
1,case 'L' : if (dec == null && exp == null -                        && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); 
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((Math.max((fa*fb),0.0))> 0.0){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1," // Check if the sources need to be re-ordered. boolean staleInputs = false; -      if (options.dependencyOptions.needsManagement() && options.closurePass) { +      if(((options.dependencyOptions)!=null)&&(options.dependencyOptions.needsManagement())){ for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they // are not flagged even if they are dropped from the process."
1,"* @param notify  notify listeners? */ public void add(TimeSeriesDataItem item, boolean notify) { -        if (item == null) { -            throw new IllegalArgumentException(""Null 'item' argument.""); -        } +        updateBoundsForRemovedItem(item); item = (TimeSeriesDataItem) item.clone(); Class c = item.getPeriod().getClass(); if (this.timePeriodClass == null) { "
0,"index 982e559..99d86e9 100644 * @return the square-root of the weight matrix. */ private RealMatrix squareRoot(RealMatrix m) { +        if (m instanceof DiagonalMatrix) { +            final int dim = m.getRowDimension(); +            final RealMatrix sqrtM = new DiagonalMatrix(dim); +            for (int i = 0; i < dim; i++) { +               sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i))); +            } +            return sqrtM; +        } else { final EigenDecomposition dec = new EigenDecomposition(m); return dec.getSquareRoot(); +        } } }"
1,"double minValue = 0; Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { -            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { +            if (MathUtils.compareTo(tableau.getEntry(0, i), DEFAULT_EPSILON, epsilon) < 0) { minValue = tableau.getEntry(0, i); minPos = i; } "
1,"break; case REGULA_FALSI: // Nothing. -                    if (x == x1) { +                    if(x==x0){ x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } "
1,"// ""this"" references aren't currently modeled in the CFG.  default: -        throw new IllegalArgumentException(""Node cannot be refined. \n"" + -            node.toStringTree()); + } } "
0,"index 4733b7e..535a3f2 100644 if (cs1 == null || cs2 == null) { return false; } +        if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); +        } +        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); }  /**"
0,"index 06988ab..70142c4 100644 // makes more sense. Now, resolution via registry is first in order to // avoid triggering the warnings built into the resolution via properties. boolean resolved = resolveViaRegistry(t, enclosing); -    if (detectImplicitPrototypeCycle()) { +    if (detectInheritanceCycle()) { handleTypeCycle(t); }  }  resolveViaProperties(t, enclosing); -    if (detectImplicitPrototypeCycle()) { +    if (detectInheritanceCycle()) { handleTypeCycle(t); } "
0,markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent();   markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); 
1,return false; } } -        return true; +        return false;  case Token.REGEXP: // Return true only if all children are const. 
1,"} mant = str.substring(0, decPos); } else { -            if (expPos > -1) { +            if (expPos<-1) { mant = str.substring(0, expPos); } else { mant = str; "
0,* @since 1.0.3 */ public int getDomainAxisIndex(CategoryAxis axis) { + 	if (axis == null){throw new IllegalArgumentException();} return this.domainAxes.indexOf(axis); }  result = p.getRangeAxisIndex(axis); } } +     	if (axis == null){throw new IllegalArgumentException();} return result; } 
1,// be attached to the name. This check should not complain about it. if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { -          int ancestorType = an.getType(); +          int ancestorType=parent.getParent().getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) 
1,final double gam = dN2; -                if (work[np - 8] > b2 || work[np - 4] > b1) { +                if (true) { return; 
0,"index 1e045b2..a0fe7e2 100644 public static long safeMultiply(long val1, int val2) { switch (val2) { case -1: +                if (val1 == Long.MIN_VALUE) { +                    throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2); +                } return -val1; case 0: return 0L;"
0,"index ab58c78..e0a8e97 100644 public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); +        if (isNaN || rhs.isNaN) { +            return NaN; +        } return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }"
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if(((fa*fb)> 0.0)&&((fa)!=0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,"index c93a073..be72a58 100644 assignedToUnknownValue = true; }  +          boolean maybeEscaped = false; for (Assign assign : assignsByVar.get(var)) { if (assign.isPropertyAssign) { hasPropertyAssign = true; assign.assignNode.getLastChild(), true)) { assignedToUnknownValue = true; } +            if (assign.maybeAliased) { +              maybeEscaped = true; +            } }  -          if (assignedToUnknownValue && hasPropertyAssign) { +          if ((assignedToUnknownValue || maybeEscaped) && hasPropertyAssign) { changes = markReferencedVar(var) || changes; maybeUnreferenced.remove(current); current--; this.nameNode = nameNode; this.isPropertyAssign = isPropertyAssign;  -      this.maybeAliased = !assignNode.getParent().isExprResult(); +      this.maybeAliased = NodeUtil.isExpressionResultUsed(assignNode); this.mayHaveSecondarySideEffects = maybeAliased || NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) ||"
0,"index 9607953..139d9a7 100644 throw new IllegalArgumentException(""Invalid locale format: "" + str); } char ch3 = str.charAt(3); +            if (ch3 == '_') { +                return new Locale(str.substring(0, 2), """", str.substring(4)); +            } char ch4 = str.charAt(4); if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') { throw new IllegalArgumentException(""Invalid locale format: "" + str);"
0,"index 9aa8602..310f55d 100644 if (type == null) { throw new IllegalArgumentException(""Field must not be null""); } +        if (amount != 0) { setMillis(type.getField(getChronology()).add(getMillis(), amount)); +        } }  //----------------------------------------------------------------------- * @throws IllegalArgumentException if the value is invalid */ public void addYears(final int years) { +        if (years != 0) { setMillis(getChronology().years().add(getMillis(), years)); +        } }  //----------------------------------------------------------------------- * @throws IllegalArgumentException if the value is invalid */ public void addWeekyears(final int weekyears) { +        if (weekyears != 0) { setMillis(getChronology().weekyears().add(getMillis(), weekyears)); +        } }  //----------------------------------------------------------------------- * @throws IllegalArgumentException if the value is invalid */ public void addMonths(final int months) { +        if (months != 0) { setMillis(getChronology().months().add(getMillis(), months)); +        } }  //----------------------------------------------------------------------- * @throws IllegalArgumentException if the value is invalid */ public void addWeeks(final int weeks) { +        if (weeks != 0) { setMillis(getChronology().weeks().add(getMillis(), weeks)); +        } }  //----------------------------------------------------------------------- * @throws IllegalArgumentException if the value is invalid */ public void addDays(final int days) { +        if (days != 0) { setMillis(getChronology().days().add(getMillis(), days)); +        } }  //----------------------------------------------------------------------- * @throws IllegalArgumentException if the value is invalid */ public void addHours(final int hours) { +        if (hours != 0) { setMillis(getChronology().hours().add(getMillis(), hours)); +        } }  //----------------------------------------------------------------------- * @throws IllegalArgumentException if the value is invalid */ public void addMinutes(final int minutes) { +        if (minutes != 0) { setMillis(getChronology().minutes().add(getMillis(), minutes)); +        } }  //----------------------------------------------------------------------- * @throws IllegalArgumentException if the value is invalid */ public void addSeconds(final int seconds) { +        if (seconds != 0) { setMillis(getChronology().seconds().add(getMillis(), seconds)); +        } }  //----------------------------------------------------------------------- * @throws IllegalArgumentException if the value is invalid */ public void addMillis(final int millis) { +        if (millis != 0) { setMillis(getChronology().millis().add(getMillis(), millis)); +        } }  //-----------------------------------------------------------------------"
1,"((a > lowerBound) || (b < upperBound)));  if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); }  return new double[]{a, b};   if (Math.abs(rootFindingFunction.value(lowerBound)) < 1E-6) { return lowerBound; } -            if (Math.abs(rootFindingFunction.value(upperBound)) < 1E-6) { -                return upperBound; -            } // Failed bracket convergence was not because of corner solution throw new MathException(ex); } "
1,"PlotRenderingInfo state) {  // if the plot area is too small, just return... -        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW); +        boolean b1 = (area.getWidth()!=MINIMUM_WIDTH_TO_DRAW); boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW); if (b1 || b2) { return; "
1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(0,'.'); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"
1,"case REGULA_FALSI: // Nothing. if (x == x1) { +                    	if(!((f0 > x0 + x1) == true)){ x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                    	} f0 = computeObjectiveValue(x0); } break;"
1,"h[2] = constraint.getHeight() - h[1] - h[0]; -        if (this.leftBlock != null) { -            RectangleConstraint c3 = new RectangleConstraint(0.0, -                    new Range(0.0, constraint.getWidth()), -                    LengthConstraintType.RANGE, h[2], null, -                    LengthConstraintType.FIXED); -            Size2D size = this.leftBlock.arrange(g2, c3); -            w[2] = size.width; +        if (null!=null) { +            if (this.leftBlock != null) { +                RectangleConstraint c3 = new RectangleConstraint(0.0, +                new Range(0.0, constraint.getWidth()), +                LengthConstraintType.RANGE, h[2], null, +                LengthConstraintType.FIXED); +                Size2D size = this.leftBlock.arrange(g2, c3); +                w[2] = size.width; +            } } "
0,index 535148c..ac6299d 100644 return false; } } -    return len > 0; +    return len > 0 && s.charAt(0) != '0'; }  static double getSimpleNumber(String s) {
1,"*/ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); -        tryMinimizeExits(finallyBlock, exitType, labelName); +        matchingExitNode(finallyBlock, exitType, labelName); } } "
1,"   -            if (this.autoSort) { +            if (false) { this.data.add(((-index) - 1), new org.jfree.data.xy.XYDataItem(x, y)); }else { "
1,int increase = 0;  // count the replacement text elements that are larger than their corresponding text being replaced +        if(repeat) for (int i = 0; i < searchList.length; i++) { int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) {
1,"if (param.length != 3) { throw new DimensionMismatchException(param.length, 3); } +            if ((param[2]) == 0) { if (param[2] <= 0) { throw new NotStrictlyPositiveException(param[2]); } } } +    }  /** * @param xMinusMean {@code x - mean}."
1,"} res = n.checkTreeEqualsImpl(n2); if (res != null) { -        return res; +        return null; } } return res;   case NE:              return ""NE""; case LT:              return ""LT""; case LE:              return ""LE""; -          case GT:              return ""GT""; +          case GT:              ; case GE:              return ""GE""; case LSH:             return ""LSH""; case RSH:             return ""RSH""; "
1,"} mant = str.substring(0, decPos); } else { -            if (expPos > -1) { +            if (false) { mant = str.substring(0, expPos); } else { mant = str; "
1,"* @throws IllegalStateException if the StopWatch is not running. */ public void stop() { +    	if((this.runningState > 0) == true){ +    		return; +    		} if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(""Stopwatch is not running. ""); }"
0,"for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { +            if((MathUtils.compareTo(entry,0,epsilon))> 0){ final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio;"
0,"index f9943a1..92d8715 100644 * For more information, see * http://code.google.com/p/closure-compiler/issues/detail?id=314 */ +    private List<Node> lentObjectLiterals = null;  /** * Type-less stubs. }  // Analyze any @lends object literals in this statement. +      if (n.getParent() != null && NodeUtil.isStatement(n) && +          lentObjectLiterals != null) { +        for (Node objLit : lentObjectLiterals) { +          defineObjectLiteral(objLit); +        } +        lentObjectLiterals.clear(); +      } }  private void attachLiteralTypes(NodeTraversal t, Node n) { break;  case Token.OBJECTLIT: +          JSDocInfo info = n.getJSDocInfo(); +          if (info != null && +              info.getLendsName() != null) { +            if (lentObjectLiterals == null) { +              lentObjectLiterals = Lists.newArrayList(); +            } +            lentObjectLiterals.add(n); +          } else { defineObjectLiteral(n); +          } break;  // NOTE(nicksantos): If we ever support Array tuples,"
0,"index 064f547..d49da7f 100644 if (StringUtils.isBlank(str)) { throw new NumberFormatException(""A blank string is not a valid number""); } -        if (str.startsWith(""--"")) { -            return null; -        } if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) { int hexDigits = str.length() - 2; // drop 0x if (str.startsWith(""-"")) { // drop - if (StringUtils.isBlank(str)) { throw new NumberFormatException(""A blank string is not a valid number""); } +        if (str.trim().startsWith(""--"")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. +            throw new NumberFormatException(str + "" is not a valid number.""); +        } return new BigDecimal(str); } "
1,"// For each named parameter check if a mutable argument use more than one. if (fnParam != null) { if (cArg != null) { -          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { +          if ((hasSideEffects && NodeUtil.canBeSideEffected(cArg)) && (NodeUtil.mayHaveSideEffects(cArg, compiler))) { return CanInlineResult.NO; } // Check for arguments that are evaluated more than once. "
1,"case REGULA_FALSI: // Nothing. if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        x0 = 0.5 * (f0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; "
1,"typeToInfer = getNativeType(JSTypeNative.VOID_TYPE) .getLeastSupertype(propType); } -          defineInferredProperty(prop, typeToInfer, null); } } } "
0,"// No charsetEncoder provided - pass straight latin characters // through, and escape the rest.  Doing the explicit character // check is measurably faster than using the CharsetEncoder. -            if (c > 0x1f && c <= 0x7f) { +            if (c > 0x1f && c < 0x7f) { sb.append(c); } else { // Other characters can be misinterpreted by some js parsers, "
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if(((fa)==0.0)||((fa*fb)> 0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,// padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line -      if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +      if (true) +      { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { 
1,"for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { +            if((MathUtils.compareTo(entry,epsilon,epsilon))>=0){ final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio;"
0,endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1;    // so this is last item BEFORE end } -        if (endIndex < 0) { +        if (endIndex < 0 || (endIndex + 1 >= startIndex + 1) == false) { emptyRange = true; } if (emptyRange) { 
1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(""JSC_BASE_CLASS_ERROR""); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"
1,"* @param shape  the {@link Shape}. */ public void setShape(int index, Shape shape) { -        set(index, shape); +        set(org.jfree.chart.util.AbstractObjectList.DEFAULT_INITIAL_CAPACITY, shape); }  /**"
0,"  // full Brent algorithm starting with provided initial guess -        return solve(f, min, yMin, max, yMax, initial, yInitial); - +        return solve(f, min, max); }  /**"
1,double d = getDenominatorDegreesOfFreedom(); // use mean ret = d / (d - 2.0); +        if (true) +            return 0d; return ret; } 
1," // Check if the sources need to be re-ordered. boolean staleInputs = false; -      if (options.dependencyOptions.needsManagement() && options.closurePass) { +      if(((options)!=null)&&(options.dependencyOptions.needsManagement())){ for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they // are not flagged even if they are dropped from the process."
1,double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; -                if (work[np - 8] > b2 || work[np - 4] > b1) { +                if(b2>0.0&&b2>b2*b1/(1+b2*b2)){ return; } double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); 
0,index 7c3cd04..f575e72 100644 * @return The percent. */ public double getMaximumExplodePercent() { +        if (this.dataset == null) { +            return 0.0; +        } double result = 0.0; Iterator iterator = this.dataset.getKeys().iterator(); while (iterator.hasNext()) {  PiePlotState state = new PiePlotState(info); state.setPassesRequired(2); +        if (this.dataset != null) { state.setTotal(DatasetUtilities.calculatePieDatasetTotal( plot.getDataset())); +        } state.setLatestAngle(plot.getStartAngle()); return state; 
1,return; } if (n == parent.getLastChild()) { -        for (Node an : parent.getAncestors()) { -          int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; -          else break; -        } + + + + + + } }else             if (((parent.getType()) != (com.google.javascript.rhino.Token.EXPR_RESULT)) && ((parent.getType()) != (com.google.javascript.rhino.Token.BLOCK))) { if (!((((parent.getType()) == (com.google.javascript.rhino.Token.FOR)) && ((parent.getChildCount()) == 4)) && ((n == (parent.getFirstChild())) || (n == (parent.getFirstChild().getNext().getNext()))))) { 
0,"} if (plotState != null && hotspot != null) { ChartRenderingInfo owner = plotState.getOwner(); +            if (owner != null) { EntityCollection entities = owner.getEntityCollection(); if (entities != null) { entities.add(new AxisLabelEntity(this, hotspot, this.labelToolTip, this.labelURL)); } +            } } return state; "
0,"public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); +        if ((isNaN) || (rhs.isNaN)) { +            return org.apache.commons.math.complex.Complex.NaN; +        } return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }"
0,"index c5ca8cd..18a05ef 100644 if (val.length() == 0) { throw new NumberFormatException(""\""\"" is not a valid number.""); } +        if (val.length() == 1 && !Character.isDigit(val.charAt(0))) { +            throw new NumberFormatException(val + "" is not a valid number.""); +        } if (val.startsWith(""--"")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear"
0,"index 839d3b8..91b2c5c 100644 /** Serialization version. */ private static final long serialVersionUID = 9386874258972L; /** The start of 1972. */ +    private static final long START_1972 = 2L * 365L * 86400L * 1000L;  /** The period in the units of this period. */ private volatile int iPeriod; throw new IllegalArgumentException(""ReadablePartial objects must be contiguous""); } Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC(); -        int[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L)); +        int[] values = chrono.get(zeroInstance, chrono.set(start, START_1972), chrono.set(end, START_1972)); return values[0]; } "
0,} case 3: { char ch = str.charAt(0); +                if((ch == 'Y' || ch == 'y') == false){ +                	return str == null; +                	} if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&
0,"index c781a90..e47d982 100644 break; case REGULA_FALSI: // Nothing. -                    if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); -                    } break; default: // Should never happen."
1,int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { +        	if(!((result == getLegendItemToolTipGenerator()) == false)){ return result; } +        } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) {
0,"index f9ce42e..1844b18 100644 }  // Functions in the ""Math"" namespace have no side effects. +      if (nameNode.getFirstChild().getType() == Token.NAME) { +        String namespaceName = nameNode.getFirstChild().getString(); +        if (namespaceName.equals(""Math"")) { +          return false; +        } +      }  if (compiler != null && !compiler.hasRegExpGlobalReferences()) { if (nameNode.getFirstChild().getType() == Token.REGEXP"
1,"try { final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min); final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min); -                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2)); +                optima[i] = optimizer.optimize(f, goal, min, FastMath.max(bound1, bound2)); } catch (FunctionEvaluationException fee) { optima[i] = null; } catch (ConvergenceException ce) { "
1,"JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue); if (valueType == null && rhsValue != null) { // Determining type for #5 -        valueType = rhsValue.getJSType(); +        valueType = ownerNode.getJSType(); } // Function prototypes are special. // It's a common JS idiom to do: "
0,"*/ public StringBuffer format(Calendar calendar, StringBuffer buf) { if (mTimeZoneForced) { +            if((null == calendar) == false){ +                calendar.getTime(); +            } calendar = (Calendar) calendar.clone(); calendar.setTimeZone(mTimeZone); }"
1,"double minValue = 0; Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { -            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { +            if (MathUtils.compareTo(tableau.getEntry(0, i), this.epsilon, epsilon) < 0) { minValue = tableau.getEntry(0, i); minPos = i; } "
0,"index 5ea67a7..f404793 100644 int years = getYears(); int months = getMonths(); if (years != 0 || months != 0) { -            years = FieldUtils.safeAdd(years, months / 12); -            months = months % 12; -            if (years != 0) { -                result = result.withYears(years); +            long totalMonths = years * 12L + months; +            if (type.isSupported(DurationFieldType.YEARS_TYPE)) { +                int normalizedYears = FieldUtils.safeToInt(totalMonths / 12); +                result = result.withYears(normalizedYears); +                totalMonths = totalMonths - (normalizedYears * 12); } -            if (months != 0) { -                result = result.withMonths(months); +            if (type.isSupported(DurationFieldType.MONTHS_TYPE)) { +                int normalizedMonths = FieldUtils.safeToInt(totalMonths); +                result = result.withMonths(normalizedMonths); +                totalMonths = totalMonths - normalizedMonths; +            } +            if (totalMonths != 0) { +                throw new UnsupportedOperationException(""Unable to normalize as PeriodType is missing either years or months but period has a month/year amount: "" + toString()); } } return result;"
0,"for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { -                final double ratio = rhs / entry; +if (MathUtils.compareTo(entry, 0, epsilon) >= 0&&!(MathUtils.compareTo(entry, 0, epsilon)==0.0)) {                final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; "
1,if (!((nextX > xA) && (nextX < xB))) { // the guessed root is not strictly inside of the tightest bracketing interval  -                    // the guessed root is either not strictly inside the interval or it +                    signChangeIndex = 2; +                    // the guessed root is either not strictly inside the interval or it // is a NaN (which occurs when some sampling points share the same y) // we try again with a lower interpolation order if (signChangeIndex - start >= end - signChangeIndex) { 
1,// TODO(nicksantos): This needs to be changed so that it // returns true iff we're sure the value was never aliased from inside // the constructor (similar to callHasLocalResult) -        return true; +        return NodeUtil.isImmutableValue(value); case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT:
1,"final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; -                if (ratio < minRatio) { +                if (ratio <= minRatio) { minRatio = ratio; minRatioPos = i; }"
1,"if (basicRow != null) { for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) { if (tableau.getEntry(basicRow, j) == 1) { +                         if (org.apache.commons.math.optimization.linear.SimplexTableau.this.constraints.size() < org.apache.commons.math.optimization.linear.SimplexTableau.this.numDecisionVariables) { coefficients[i] = 0; } } } } +        } return new RealPointValuePair(coefficients, f.getValue(coefficients)); } "
0,"public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); +        if((isNaN() || rhs.isNaN()) == true){ +            return NaN; +        } return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }"
0,"index a973da9..7fd86f4 100644 && this.minimumRangeValueColumn == c))  { updateBounds(); } +        else {  double minval = Double.NaN; if (item.getMinOutlier() != null) { this.minimumRangeValueRow = r; this.minimumRangeValueColumn = c; } +        }  this.rangeBounds = new Range(this.minimumRangeValue, this.maximumRangeValue); */ private void updateBounds() { this.minimumRangeValue = Double.NaN; +        this.minimumRangeValueRow = -1; +        this.minimumRangeValueColumn = -1; this.maximumRangeValue = Double.NaN; +        this.maximumRangeValueRow = -1; +        this.maximumRangeValueColumn = -1; +        int rowCount = getRowCount(); +        int columnCount = getColumnCount(); +        for (int r = 0; r < rowCount; r++) { +            for (int c = 0; c < columnCount; c++) { +                BoxAndWhiskerItem item = getItem(r, c); +                if (item != null) { +                    Number min = item.getMinOutlier(); +                    if (min != null) { +                        double minv = min.doubleValue(); +                        if (!Double.isNaN(minv)) { +                            if (minv < this.minimumRangeValue || Double.isNaN( +                                    this.minimumRangeValue)) { +                                this.minimumRangeValue = minv; +                                this.minimumRangeValueRow = r; +                                this.minimumRangeValueColumn = c; +                            } +                        } +                    } +                    Number max = item.getMaxOutlier(); +                    if (max != null) { +                        double maxv = max.doubleValue(); +                        if (!Double.isNaN(maxv)) { +                            if (maxv > this.maximumRangeValue || Double.isNaN( +                                    this.maximumRangeValue)) { +                                this.maximumRangeValue = maxv; +                                this.maximumRangeValueRow = r; +                                this.maximumRangeValueColumn = c; +                            } +                        } +                    } +                } +            } +        } }  /**"
0,"this.dataset = dataset; PiePlot piePlot = new PiePlot(null); this.pieChart = new JFreeChart(piePlot); -        this.pieChart.removeLegend(); +        setDataset(dataset); +        this.pieChart.removeLegend(); this.dataExtractOrder = TableOrder.BY_COLUMN; this.pieChart.setBackgroundPaint(null); TextTitle seriesTitle = new TextTitle(""Series Title"", "
1," Node newRight; if (areNodesEqualForInlining(left, right.getFirstChild())) { +      n.removeChild(right); newRight = right.getLastChild(); } else if (NodeUtil.isCommutative(right.getType()) && areNodesEqualForInlining(left, right.getLastChild())) { "
0,"index 07761aa..4a733cd 100644 Name name = functionNode.getFunctionName(); Boolean isUnnamedFunction = false; if (name == null) { +        int functionType = functionNode.getFunctionType(); +        if (functionType != FunctionNode.FUNCTION_EXPRESSION) { +          errorReporter.error( +            ""unnamed function statement"", +            sourceName, +            functionNode.getLineno(), """", 0); +        } name = new Name(); name.setIdentifier(""""); isUnnamedFunction = true;"
1,"final Node var = n.getFirstChild(); final Node block = var.getNext();  -        declareVar(var); +        ; scanVars(block); return;  // only one child to scan    private void validateThrow(Node n) { validateNodeType(Token.THROW, n); -    validateChildCount(n, 1); validateExpression(n.getFirstChild()); } "
0,"index 22df685..8cd3ab9 100644 for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { +        case '\0': sb.append(""\\0""); break; case '\n': sb.append(""\\n""); break; case '\r': sb.append(""\\r""); break; case '\t': sb.append(""\\t""); break;"
1,switch (lastChar) { case 'l' : case 'L' : -                    if (dec == null -                        && exp == null -                        && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                    if (((dec == null) && (exp == null))) { try { return createLong(numeric); } catch (NumberFormatException nfe) {
0,index eb74e72..c0f06a4 100644 case 'L' : if (dec == null && exp == null -                        && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (NumberFormatException nfe) {
1,"*/ public void removeRow(Comparable rowKey) { int index = getRowIndex(rowKey); +        if(index<0){ +            throw new UnknownKeyException(""The key (""+rowKey.toString()); +        } removeRow(index); } "
0,"if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); -            int strLen = str.length(); +            if (str == null) str = new String(); + int strLen = str.length(); if (strLen >= width) { str.getChars(strLen - width, strLen, buffer, size); } else { "
0,index 7a0313c..f777b1c 100644  Node current = left.getFirstChild(); Node elem = null; -    for (int i = 0; current != null && i < intIndex; i++) { +    for (int i = 0; current != null; i++) { +      if (i != intIndex) { +        if (mayHaveSideEffects(current)) { +          return n; +        } +      } else { elem = current; +      }  current = current.getNext(); }
0,"index 0347525..8a667da 100644 case REGULA_FALSI: // Detect early that algorithm is stuck, instead of waiting // for the maximum number of iterations to be exceeded. +                    if (x == x1) { +                        throw new ConvergenceException(); +                    } break; default: // Should never happen."
0,"index 0757d9b..b404bc4 100644 int n = getImaginaryCharacter().length(); startIndex = pos.getIndex(); int endIndex = startIndex + n; -        if ( +        if ((startIndex >= source.length()) || +            (endIndex > source.length()) || source.substring(startIndex, endIndex).compareTo( getImaginaryCharacter()) != 0) { // set index back to initial, error index should be the start index"
1," while (true) {  -            incrementIterationsCounter(); +            final double[] xSmallest = simplex[0].getPointRef(); +            incrementIterationsCounter();  // save the original vertex final RealPointValuePair[] original = simplex;  // compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); -            if (comparator.compare(contracted, best) < 0) { -                // accept the contracted simplex - -            // check convergence -                return; -            } +            return;  } "
0, if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); +            if ((null == tree.getCut()) != false && (Boolean)tree.getAttribute()) { -            if ((Boolean) tree.getAttribute()) { // the instance covers the whole space setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN);
1,"public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); -        return createComplex(real + rhs.getReal(), +        return createComplex(real + rhs.getArgument(), imaginary + rhs.getImaginary()); } "
0,"index 8f83d96..325fd94 100644 throw new DimensionMismatchException(len, b.length); }  +        if (len == 1) { // Revert to scalar multiplication. +            return a[0] * b[0]; +        }  final double[] prodHigh = new double[len]; double prodLowSum = 0;"
0,"index d2b24c6..bbd5ddb 100644 * * @since 1.0.7 */ +    public boolean equals(Object obj) { +        if (obj == this) { +            return true; +        } +        if (!(obj instanceof MinMaxCategoryRenderer)) { +            return false; +        } +        MinMaxCategoryRenderer that = (MinMaxCategoryRenderer) obj; +        if (this.plotLines != that.plotLines) { +            return false; +        } +        if (!PaintUtilities.equal(this.groupPaint, that.groupPaint)) { +            return false; +        } +        if (!this.groupStroke.equals(that.groupStroke)) { +            return false; +        } +        return super.equals(obj); +    }  /** * Returns an icon."
0,DatasetUtilities.findRangeBounds(d)); } } - +                if (r != null) { Collection c = r.getAnnotations(); Iterator i = c.iterator(); while (i.hasNext()) { } } } +        }  Iterator it = includedAnnotations.iterator(); while (it.hasNext()) {
0,index c18639a..bdf5592 100644 for (FormattingOption formattingOption : flags.formatting) { formattingOption.applyToOptions(options); } -    if (flags.process_closure_primitives) { -      options.closurePass = true; -    }  +    options.closurePass = flags.process_closure_primitives; initOptionsFromFlags(options); return options; }
0,endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1;    // so this is last item BEFORE end } -        if (endIndex < 0) { +        if (endIndex < 0 || (endIndex < startIndex)) { emptyRange = true; } if (emptyRange) {
1,"try { final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min); final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min); -                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2)); +                optima[i] = optimizer.optimize(f, goal, FastMath.min(min, bound2), FastMath.max(bound1, bound2)); } catch (FunctionEvaluationException fee) { optima[i] = null; } catch (ConvergenceException ce) { "
0, /** {@inheritDoc} */ public Complex reciprocal() { +    	if((real == 0.0 && imaginary == 0.0) == true){ +    		return this.INF; +    		} if (isNaN) { return NaN; }
1,"// Inverse quadratic interpolation gives a value // in the wrong direction, or progress is slow. // Fall back to bisection. +                    if(-1 <= delta) delta = 0.5 * dx; oldDelta = delta; } else {"
0,"*/ public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) { +// start of generated patch +super(paint,stroke,outlinePaint,stroke,alpha); +this.value=value; +// end of generated patch +/* start of original code super(paint, stroke, paint, stroke, alpha); this.value = value; + end of original code*/ }  /** "
0,index ba2c4db..8c565cb 100644 private static final long serialVersionUID = -6587513359895466954L;  /** Maximum allowed numerical error. */ -    private static final double DEFAULT_EPSILON = 10e-9; +    private static final double DEFAULT_EPSILON = 10e-15;  /** Lanczos coefficients */ private static double[] lanczos =
1,} case 3: { char ch = str.charAt(0); -                if (ch == 'y') { +                if ((ch == 'y') || !(ch == 'Y')) { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); 
1,int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) -            return; -          else -            break; + + + + } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { 
1,double s = 0.25 * dMin;  // compute contribution to norm squared from i > nn-2. -                final int np = nn - 2 * pingPong; +                final int np = nn - 2 * start; double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; 
1,"if (h == LengthConstraintType.NONE) { contentSize = arrangeFN(container, g2, constraint.getWidth()); } -            else if (h == LengthConstraintType.FIXED) { -                contentSize = arrangeFF(container, g2, constraint); -            } -            else if (h == LengthConstraintType.RANGE) { -                contentSize = arrangeFR(container, g2, constraint); -            } -        } -        else if (w == LengthConstraintType.RANGE) { -            if (h == LengthConstraintType.NONE) { -                throw new RuntimeException(""Not implemented.""); -            } -            else if (h == LengthConstraintType.FIXED) { -                throw new RuntimeException(""Not implemented.""); -            } -            else if (h == LengthConstraintType.RANGE) { -                contentSize = arrangeRR(container, constraint.getWidthRange(), -                        constraint.getHeightRange(), g2); -            } -        } -        return new Size2D(container.calculateTotalWidth(contentSize.getWidth()), -                container.calculateTotalHeight(contentSize.getHeight())); -    } +            else +            {  /** * Performs an arrangement without constraints. * * @return The container size after the arrangement. */ -    protected Size2D arrangeNN(BlockContainer container, Graphics2D g2) { -        double[] w = new double[5]; -        double[] h = new double[5]; -        if (this.topBlock != null) { -            Size2D size = this.topBlock.arrange(g2, RectangleConstraint.NONE); -            w[0] = size.width; -            h[0] = size.height; -        } -        if (this.bottomBlock != null) { -            Size2D size = this.bottomBlock.arrange(g2, -                    RectangleConstraint.NONE); -            w[1] = size.width; -            h[1] = size.height; -        } -        if (this.leftBlock != null) { -            Size2D size = this.leftBlock.arrange(g2, RectangleConstraint.NONE); -            w[2] = size.width; -            h[2] = size.height; -       } -        if (this.rightBlock != null) { -            Size2D size = this.rightBlock.arrange(g2, RectangleConstraint.NONE); -            w[3] = size.width; -            h[3] = size.height; -        } - -        h[2] = Math.max(h[2], h[3]); -        h[3] = h[2]; - -        if (this.centerBlock != null) { -            Size2D size = this.centerBlock.arrange(g2, -                    RectangleConstraint.NONE); -            w[4] = size.width; -            h[4] = size.height; -        } -        double width = Math.max(w[0], Math.max(w[1], w[2] + w[4] + w[3])); -        double centerHeight = Math.max(h[2], Math.max(h[3], h[4])); -        double height = h[0] + h[1] + centerHeight; -        if (this.topBlock != null) { -            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, width, -                    h[0])); -        } -        if (this.bottomBlock != null) { -            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, -                    height - h[1], width, h[1])); -        } -        if (this.leftBlock != null) { -            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2], -                    centerHeight)); -        } -        if (this.rightBlock != null) { -            this.rightBlock.setBounds(new Rectangle2D.Double(width - w[3], -                    h[0], w[3], centerHeight)); -        } - -        if (this.centerBlock != null) { -            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], -                    width - w[2] - w[3], centerHeight)); -        } -        return new Size2D(width, height); -    } +  /** * Performs an arrangement with a fixed width and a range for the height. * * @return The container size after the arrangement. */ -    protected Size2D arrangeFR(BlockContainer container, Graphics2D g2, -                               RectangleConstraint constraint) { -        Size2D size1 = arrangeFN(container, g2, constraint.getWidth()); -        if (constraint.getHeightRange().contains(size1.getHeight())) { -            return size1; -        } -        else { -            double h = constraint.getHeightRange().constrain(size1.getHeight()); -            RectangleConstraint c2 = constraint.toFixedHeight(h); -            return arrange(container, g2, c2); -        } -    } +  /** * Arranges the container width a fixed width and no constraint on the * * @return The container size after arranging the contents. */ -    protected Size2D arrangeFN(BlockContainer container, Graphics2D g2, -                               double width) { -        double[] w = new double[5]; -        double[] h = new double[5]; -        RectangleConstraint c1 = new RectangleConstraint(width, null, -                LengthConstraintType.FIXED, 0.0, null, -                LengthConstraintType.NONE); -        if (this.topBlock != null) { -            Size2D size = this.topBlock.arrange(g2, c1); -            w[0] = size.width; -            h[0] = size.height; -        } -        if (this.bottomBlock != null) { -            Size2D size = this.bottomBlock.arrange(g2, c1); -            w[1] = size.width; -            h[1] = size.height; -        } -        RectangleConstraint c2 = new RectangleConstraint(0.0, -                new Range(0.0, width), LengthConstraintType.RANGE, -                0.0, null, LengthConstraintType.NONE); -        if (this.leftBlock != null) { -            Size2D size = this.leftBlock.arrange(g2, c2); -            w[2] = size.width; -            h[2] = size.height; -        } -        if (this.rightBlock != null) { -            double maxW = Math.max(width - w[2], 0.0); -            RectangleConstraint c3 = new RectangleConstraint(0.0, -                    new Range(Math.min(w[2], maxW), maxW), -                    LengthConstraintType.RANGE, 0.0, null, -                    LengthConstraintType.NONE); -            Size2D size = this.rightBlock.arrange(g2, c3); -            w[3] = size.width; -            h[3] = size.height; -        } - -        h[2] = Math.max(h[2], h[3]); -        h[3] = h[2]; - -        if (this.centerBlock != null) { -            RectangleConstraint c4 = new RectangleConstraint(width - w[2] -                    - w[3], null, LengthConstraintType.FIXED, 0.0, null, -                    LengthConstraintType.NONE); -            Size2D size = this.centerBlock.arrange(g2, c4); -            w[4] = size.width; -            h[4] = size.height; -        } -        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4])); -        return arrange(container, g2, new RectangleConstraint(width, height)); -    } +  /** * Performs an arrangement with range constraints on both the vertical * * @return The container size. */ -    protected Size2D arrangeRR(BlockContainer container, -                               Range widthRange, Range heightRange, -                               Graphics2D g2) { -        double[] w = new double[5]; -        double[] h = new double[5]; -        if (this.topBlock != null) { -            RectangleConstraint c1 = new RectangleConstraint(widthRange, -                    heightRange); -            Size2D size = this.topBlock.arrange(g2, c1); -            w[0] = size.width; -            h[0] = size.height; -        } -        if (this.bottomBlock != null) { -            Range heightRange2 = Range.shift(heightRange, -h[0], false); -            RectangleConstraint c2 = new RectangleConstraint(widthRange, -                    heightRange2); -            Size2D size = this.bottomBlock.arrange(g2, c2); -            w[1] = size.width; -            h[1] = size.height; -        } -        Range heightRange3 = Range.shift(heightRange, -(h[0] + h[1])); -        if (this.leftBlock != null) { -            RectangleConstraint c3 = new RectangleConstraint(widthRange, -                    heightRange3); -            Size2D size = this.leftBlock.arrange(g2, c3); -            w[2] = size.width; -            h[2] = size.height; -        } -        Range widthRange2 = Range.shift(widthRange, -w[2], false); -        if (this.rightBlock != null) { -            RectangleConstraint c4 = new RectangleConstraint(widthRange2, -                    heightRange3); -            Size2D size = this.rightBlock.arrange(g2, c4); -            w[3] = size.width; -            h[3] = size.height; -        } - -        h[2] = Math.max(h[2], h[3]); -        h[3] = h[2]; -        Range widthRange3 = Range.shift(widthRange, -(w[2] + w[3]), false); -        if (this.centerBlock != null) { -            RectangleConstraint c5 = new RectangleConstraint(widthRange3, -                    heightRange3); -            // TODO:  the width and height ranges should be reduced by the -            // height required for the top and bottom, and the width required -            // by the left and right -            Size2D size = this.centerBlock.arrange(g2, c5); -            w[4] = size.width; -            h[4] = size.height; -        } -        double width = Math.max(w[0], Math.max(w[1], w[2] + w[4] + w[3])); -        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4])); -        if (this.topBlock != null) { -            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, width, -                    h[0])); -        } -        if (this.bottomBlock != null) { -            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, -                    height - h[1], width, h[1])); -        } -        if (this.leftBlock != null) { -            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2], -                    h[2])); -        } -        if (this.rightBlock != null) { -            this.rightBlock.setBounds(new Rectangle2D.Double(width - w[3], -                    h[0], w[3], h[3])); -        } - -        if (this.centerBlock != null) { -            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], -                    width - w[2] - w[3], height - h[0] - h[1])); -        } -        return new Size2D(width, height); -    } +  /** * Arranges the items within a container. * * @return The container size after the arrangement. */ -    protected Size2D arrangeFF(BlockContainer container, Graphics2D g2, -                               RectangleConstraint constraint) { -        double[] w = new double[5]; -        double[] h = new double[5]; -        w[0] = constraint.getWidth(); -        if (this.topBlock != null) { -            RectangleConstraint c1 = new RectangleConstraint(w[0], null, -                    LengthConstraintType.FIXED, 0.0, -                    new Range(0.0, constraint.getHeight()), -                    LengthConstraintType.RANGE); -            Size2D size = this.topBlock.arrange(g2, c1); -            h[0] = size.height; -        } -        w[1] = w[0]; -        if (this.bottomBlock != null) { -            RectangleConstraint c2 = new RectangleConstraint(w[0], null, -                    LengthConstraintType.FIXED, 0.0, new Range(0.0, -                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE); -            Size2D size = this.bottomBlock.arrange(g2, c2); -            h[1] = size.height; -        } -        h[2] = constraint.getHeight() - h[1] - h[0]; -        if (this.leftBlock != null) { -            RectangleConstraint c3 = new RectangleConstraint(0.0, -                    new Range(0.0, constraint.getWidth()), -                    LengthConstraintType.RANGE, h[2], null, -                    LengthConstraintType.FIXED); -            Size2D size = this.leftBlock.arrange(g2, c3); -            w[2] = size.width; -        } -        h[3] = h[2]; -        if (this.rightBlock != null) { -            RectangleConstraint c4 = new RectangleConstraint(0.0, -                    new Range(0.0, constraint.getWidth() - w[2]), -                    LengthConstraintType.RANGE, h[2], null, -                    LengthConstraintType.FIXED); -            Size2D size = this.rightBlock.arrange(g2, c4); -            w[3] = size.width; -        } -        h[4] = h[2]; -        w[4] = constraint.getWidth() - w[3] - w[2]; -        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]); -        if (this.centerBlock != null) { -            this.centerBlock.arrange(g2, c5); -        } - -        if (this.topBlock != null) { -            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0], -                    h[0])); -        } -        if (this.bottomBlock != null) { -            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2], -                    w[1], h[1])); -        } -        if (this.leftBlock != null) { -            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2], -                    h[2])); -        } -        if (this.rightBlock != null) { -            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0], -                    w[3], h[3])); -        } -        if (this.centerBlock != null) { -            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4], -                    h[4])); -        } -        return new Size2D(constraint.getWidth(), constraint.getHeight()); -    }  /** * Clears the layout. */ -    public void clear() { -        this.centerBlock = null; -        this.topBlock = null; -        this.bottomBlock = null; -        this.leftBlock = null; -        this.rightBlock = null; +                    this.rightBlock = null;                     if (h == (org.jfree.chart.block.LengthConstraintType.FIXED)) {                         contentSize = arrangeFF(container, g2, constraint);}else                         if (h == (org.jfree.chart.block.LengthConstraintType.RANGE)) {                             contentSize = arrangeFR(container, g2, constraint);}}}else                 if (w == (org.jfree.chart.block.LengthConstraintType.RANGE)) {                     if (h == (org.jfree.chart.block.LengthConstraintType.NONE)) {                         throw new java.lang.RuntimeException(""Not implemented."");}else                         if (h == (org.jfree.chart.block.LengthConstraintType.FIXED)) {                             throw new java.lang.RuntimeException(""Not implemented."");}else                             if (h == (org.jfree.chart.block.LengthConstraintType.RANGE)) {                                 contentSize = arrangeRR(container, constraint.getWidthRange(), constraint.getHeightRange(), g2);}}         return new org.jfree.chart.util.Size2D(container.calculateTotalWidth(contentSize.getWidth()), container.calculateTotalHeight(contentSize.getHeight()));}     protected org.jfree.chart.util.Size2D arrangeNN(org.jfree.chart.block.BlockContainer container, java.awt.Graphics2D g2) {         double[] w = new double[5];         double[] h = new double[5];         if ((this.topBlock) != null) {             org.jfree.chart.util.Size2D size = this.topBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE);             w[0] = size.width;             h[0] = size.height;}         if ((this.bottomBlock) != null) {             org.jfree.chart.util.Size2D size = this.bottomBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE);             w[1] = size.width;             h[1] = size.height;}         if ((this.leftBlock) != null) {             org.jfree.chart.util.Size2D size = this.leftBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE);             w[2] = size.width;             h[2] = size.height;}         if ((this.rightBlock) != null) {             org.jfree.chart.util.Size2D size = this.rightBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE);             w[3] = size.width;             h[3] = size.height;}         h[2] = java.lang.Math.max(h[2], h[3]);         h[3] = h[2];         if ((this.centerBlock) != null) {             org.jfree.chart.util.Size2D size = this.centerBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE);             w[4] = size.width;             h[4] = size.height;}         double width = java.lang.Math.max(w[0], java.lang.Math.max(w[1], (((w[2]) + (w[4])) + (w[3]))));         double centerHeight = java.lang.Math.max(h[2], java.lang.Math.max(h[3], h[4]));         double height = ((h[0]) + (h[1])) + centerHeight;         if ((this.topBlock) != null) {             this.topBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, 0.0, width, h[0]));}         if ((this.bottomBlock) != null) {             this.bottomBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, (height - (h[1])), width, h[1]));}         if ((this.leftBlock) != null) {             this.leftBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, h[0], w[2], centerHeight));}         if ((this.rightBlock) != null) {             this.rightBlock.setBounds(new java.awt.geom.Rectangle2D.Double((width - (w[3])), h[0], w[3], centerHeight));}         if ((this.centerBlock) != null) {             this.centerBlock.setBounds(new java.awt.geom.Rectangle2D.Double(w[2], h[0], ((width - (w[2])) - (w[3])), centerHeight));}         return new org.jfree.chart.util.Size2D(width, height);}     protected org.jfree.chart.util.Size2D arrangeFR(org.jfree.chart.block.BlockContainer container, java.awt.Graphics2D g2, org.jfree.chart.block.RectangleConstraint constraint) {         org.jfree.chart.util.Size2D size1 = arrangeFN(container, g2, constraint.getWidth());         if (constraint.getHeightRange().contains(size1.getHeight())) {             return size1;}else {             double h = constraint.getHeightRange().constrain(size1.getHeight());             org.jfree.chart.block.RectangleConstraint c2 = constraint.toFixedHeight(h);             return arrange(container, g2, c2);}}     protected org.jfree.chart.util.Size2D arrangeFN(org.jfree.chart.block.BlockContainer container, java.awt.Graphics2D g2, double width) {         double[] w = new double[5];         double[] h = new double[5];         org.jfree.chart.block.RectangleConstraint c1 = new org.jfree.chart.block.RectangleConstraint(width, null, org.jfree.chart.block.LengthConstraintType.FIXED, 0.0, null, org.jfree.chart.block.LengthConstraintType.NONE);         if ((this.topBlock) != null) {             org.jfree.chart.util.Size2D size = this.topBlock.arrange(g2, c1);             w[0] = size.width;             h[0] = size.height;}         if ((this.bottomBlock) != null) {             org.jfree.chart.util.Size2D size = this.bottomBlock.arrange(g2, c1);             w[1] = size.width;             h[1] = size.height;}         org.jfree.chart.block.RectangleConstraint c2 = new org.jfree.chart.block.RectangleConstraint(0.0, new org.jfree.data.Range(0.0, width), org.jfree.chart.block.LengthConstraintType.RANGE, 0.0, null, org.jfree.chart.block.LengthConstraintType.NONE);         if ((this.leftBlock) != null) {             org.jfree.chart.util.Size2D size = this.leftBlock.arrange(g2, c2);             w[2] = size.width;             h[2] = size.height;}         if ((this.rightBlock) != null) {             double maxW = java.lang.Math.max((width - (w[2])), 0.0);             org.jfree.chart.block.RectangleConstraint c3 = new org.jfree.chart.block.RectangleConstraint(0.0, new org.jfree.data.Range(java.lang.Math.min(w[2], maxW), maxW), org.jfree.chart.block.LengthConstraintType.RANGE, 0.0, null, org.jfree.chart.block.LengthConstraintType.NONE);             org.jfree.chart.util.Size2D size = this.rightBlock.arrange(g2, c3);             w[3] = size.width;             h[3] = size.height;}         h[2] = java.lang.Math.max(h[2], h[3]);         h[3] = h[2];         if ((this.centerBlock) != null) {             org.jfree.chart.block.RectangleConstraint c4 = new org.jfree.chart.block.RectangleConstraint(((width - (w[2])) - (w[3])), null, org.jfree.chart.block.LengthConstraintType.FIXED, 0.0, null, org.jfree.chart.block.LengthConstraintType.NONE);             org.jfree.chart.util.Size2D size = this.centerBlock.arrange(g2, c4);             w[4] = size.width;             h[4] = size.height;}         double height = ((h[0]) + (h[1])) + (java.lang.Math.max(h[2], java.lang.Math.max(h[3], h[4])));         return arrange(container, g2, new org.jfree.chart.block.RectangleConstraint(width, height));}     protected org.jfree.chart.util.Size2D arrangeRR(org.jfree.chart.block.BlockContainer container, org.jfree.data.Range widthRange, org.jfree.data.Range heightRange, java.awt.Graphics2D g2) {         double[] w = new double[5];         double[] h = new double[5];         if ((this.topBlock) != null) {             org.jfree.chart.block.RectangleConstraint c1 = new org.jfree.chart.block.RectangleConstraint(widthRange, heightRange);             org.jfree.chart.util.Size2D size = this.topBlock.arrange(g2, c1);             w[0] = size.width;             h[0] = size.height;}         if ((this.bottomBlock) != null) {             org.jfree.data.Range heightRange2 = org.jfree.data.Range.shift(heightRange, (-(h[0])), false);             org.jfree.chart.block.RectangleConstraint c2 = new org.jfree.chart.block.RectangleConstraint(widthRange, heightRange2);             org.jfree.chart.util.Size2D size = this.bottomBlock.arrange(g2, c2);             w[1] = size.width;             h[1] = size.height;}         org.jfree.data.Range heightRange3 = org.jfree.data.Range.shift(heightRange, (-((h[0]) + (h[1]))));         if ((this.leftBlock) != null) {             org.jfree.chart.block.RectangleConstraint c3 = new org.jfree.chart.block.RectangleConstraint(widthRange, heightRange3);             org.jfree.chart.util.Size2D size = this.leftBlock.arrange(g2, c3);             w[2] = size.width;             h[2] = size.height;}         org.jfree.data.Range widthRange2 = org.jfree.data.Range.shift(widthRange, (-(w[2])), false);         if ((this.rightBlock) != null) {             org.jfree.chart.block.RectangleConstraint c4 = new org.jfree.chart.block.RectangleConstraint(widthRange2, heightRange3);             org.jfree.chart.util.Size2D size = this.rightBlock.arrange(g2, c4);             w[3] = size.width;             h[3] = size.height;}         h[2] = java.lang.Math.max(h[2], h[3]);         h[3] = h[2];         org.jfree.data.Range widthRange3 = org.jfree.data.Range.shift(widthRange, (-((w[2]) + (w[3]))), false);         if ((this.centerBlock) != null) {             org.jfree.chart.block.RectangleConstraint c5 = new org.jfree.chart.block.RectangleConstraint(widthRange3, heightRange3);             org.jfree.chart.util.Size2D size = this.centerBlock.arrange(g2, c5);             w[4] = size.width;             h[4] = size.height;}         double width = java.lang.Math.max(w[0], java.lang.Math.max(w[1], (((w[2]) + (w[4])) + (w[3]))));         double height = ((h[0]) + (h[1])) + (java.lang.Math.max(h[2], java.lang.Math.max(h[3], h[4])));         if ((this.topBlock) != null) {             this.topBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, 0.0, width, h[0]));}         if ((this.bottomBlock) != null) {             this.bottomBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, (height - (h[1])), width, h[1]));}         if ((this.leftBlock) != null) {             this.leftBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, h[0], w[2], h[2]));}         if ((this.rightBlock) != null) {             this.rightBlock.setBounds(new java.awt.geom.Rectangle2D.Double((width - (w[3])), h[0], w[3], h[3]));}         if ((this.centerBlock) != null) {             this.centerBlock.setBounds(new java.awt.geom.Rectangle2D.Double(w[2], h[0], ((width - (w[2])) - (w[3])), ((height - (h[0])) - (h[1]))));}         return new org.jfree.chart.util.Size2D(width, height);}     protected org.jfree.chart.util.Size2D arrangeFF(org.jfree.chart.block.BlockContainer container, java.awt.Graphics2D g2, org.jfree.chart.block.RectangleConstraint constraint) {         double[] w = new double[5];         double[] h = new double[5];         w[0] = constraint.getWidth();         if ((this.topBlock) != null) {             org.jfree.chart.block.RectangleConstraint c1 = new org.jfree.chart.block.RectangleConstraint(w[0], null, org.jfree.chart.block.LengthConstraintType.FIXED, 0.0, new org.jfree.data.Range(0.0, constraint.getHeight()), org.jfree.chart.block.LengthConstraintType.RANGE);             org.jfree.chart.util.Size2D size = this.topBlock.arrange(g2, c1);             h[0] = size.height;}         w[1] = w[0];         if ((this.bottomBlock) != null) {             org.jfree.chart.block.RectangleConstraint c2 = new org.jfree.chart.block.RectangleConstraint(w[0], null, org.jfree.chart.block.LengthConstraintType.FIXED, 0.0, new org.jfree.data.Range(0.0, ((constraint.getHeight()) - (h[0]))), org.jfree.chart.block.LengthConstraintType.RANGE);             org.jfree.chart.util.Size2D size = this.bottomBlock.arrange(g2, c2);             h[1] = size.height;}         h[2] = ((constraint.getHeight()) - (h[1])) - (h[0]);         if ((this.leftBlock) != null) {             org.jfree.chart.block.RectangleConstraint c3 = new org.jfree.chart.block.RectangleConstraint(0.0, new org.jfree.data.Range(0.0, constraint.getWidth()), org.jfree.chart.block.LengthConstraintType.RANGE, h[2], null, org.jfree.chart.block.LengthConstraintType.FIXED);             org.jfree.chart.util.Size2D size = this.leftBlock.arrange(g2, c3);             w[2] = size.width;}         h[3] = h[2];         if ((this.rightBlock) != null) {             org.jfree.chart.block.RectangleConstraint c4 = new org.jfree.chart.block.RectangleConstraint(0.0, new org.jfree.data.Range(0.0, ((constraint.getWidth()) - (w[2]))), org.jfree.chart.block.LengthConstraintType.RANGE, h[2], null, org.jfree.chart.block.LengthConstraintType.FIXED);             org.jfree.chart.util.Size2D size = this.rightBlock.arrange(g2, c4);             w[3] = size.width;}         h[4] = h[2];         w[4] = ((constraint.getWidth()) - (w[3])) - (w[2]);         org.jfree.chart.block.RectangleConstraint c5 = new org.jfree.chart.block.RectangleConstraint(w[4], h[4]);         if ((this.centerBlock) != null) {             this.centerBlock.arrange(g2, c5);}         if ((this.topBlock) != null) {             this.topBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, 0.0, w[0], h[0]));}         if ((this.bottomBlock) != null) {             this.bottomBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, ((h[0]) + (h[2])), w[1], h[1]));}         if ((this.leftBlock) != null) {             this.leftBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, h[0], w[2], h[2]));}         if ((this.rightBlock) != null) {             this.rightBlock.setBounds(new java.awt.geom.Rectangle2D.Double(((w[2]) + (w[4])), h[0], w[3], h[3]));}         if ((this.centerBlock) != null) {             this.centerBlock.setBounds(new java.awt.geom.Rectangle2D.Double(w[2], h[0], w[4], h[4]));}         return new org.jfree.chart.util.Size2D(constraint.getWidth(), constraint.getHeight());}     public void clear() {         this.centerBlock = null;         this.topBlock = null;         this.bottomBlock = null;         this.leftBlock = null;         this.rightBlock = null; }  /** "
1,if (endIndex < 0) { emptyRange = true; } +        if((startIndex == 1) == true){ +        	return this; +        	} if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList();
1,}  for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { -          if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) { +          if (apply(c)) { return true; } } 
0,"if (fnParam != null) { if (cArg != null) { if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { -            return CanInlineResult.NO; } // Check for arguments that are evaluated more than once. // Note: Unlike block inlining, there it is not possible that a "
1,"}  if (tailZone != null) { -                if (tailZone.iStartRecurrence.getNameKey() -                    .equals(tailZone.iEndRecurrence.getNameKey())) { +                if (id.length()==0) { if (ZoneInfoCompiler.verbose()) { System.out.println(""Fixing duplicate recurrent name key - "" + tailZone.iStartRecurrence.getNameKey());"
0,} final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); -        final BigDecimal[] out = new BigDecimal[v.length]; +        final BigDecimal[] out = new BigDecimal[nRows]; for (int row = 0; row < nRows; row++) { BigDecimal sum = ZERO; for (int i = 0; i < nCols; i++) { 
0,(str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } +                if((ch == 'Y' || ch == 'y') == false){ +                	return str == null; +                	} if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&
1,final BSPTree<Euclidean2D> tree = getTree(false); -            if ((Boolean) tree.getAttribute()) { +            if (false) { 
1, // x- if (!restrictToNonNegative) { +                        if ((1) != (constraints.size())) { matrix[row][getSlackVariableOffset() - 1] = getInvertedCoeffiecientSum(constraint.getCoefficients()); } +                    }  // RHS matrix[row][width - 1] = constraint.getValue();
1,for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; -                    work[j - k] = tmp; +                    work[i + k] = tmp; } j -= 4; }
1,"rule = new TextField(Calendar.ERA, ERAs); break; case 'y': // year (number) -                if (tokenLen >= 4) { +                if ((tokenLen >= 4) || !(tokenLen == 2)) { rule = selectNumberRule(Calendar.YEAR, tokenLen); } else { rule = TwoDigitYearField.INSTANCE; "
1,"// x--4 (which is a syntax error). char prev = getLastChar(); boolean negativeZero = isNegativeZero(x); -    if (x < 0 && prev == '-') { +    if((prev!=0)&&(prev=='-')){ add("" ""); } "
0,"index aa3299a..b8225ad 100644 */ public Weight(double[] weight) { final int dim = weight.length; -        weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim); -        for (int i = 0; i < dim; i++) { -            weightMatrix.setEntry(i, i, weight[i]); -        } +        weightMatrix = new DiagonalMatrix(weight); }  /** index ef52943..d12ebea 100644 * @return the square-root of the weight matrix. */ private RealMatrix squareRoot(RealMatrix m) { +        if (m instanceof DiagonalMatrix) { +            final int dim = m.getRowDimension(); +            final RealMatrix sqrtM = new DiagonalMatrix(dim); +            for (int i = 0; i < dim; i++) { +                sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i))); +            } +            return sqrtM; +        } else { final EigenDecomposition dec = new EigenDecomposition(m); return dec.getSquareRoot(); +        } } }"
0,markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } + 	if (markers == null){return false;} boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer( index)); } + 	if (markers == null){return false;} boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } + 	if (markers == null){return false;} boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer( index)); } + 	if (markers == null){return false;} boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent();
0,index 81a7d89..b6e3fc7 100644 @Override public void matchConstraint(ObjectType constraintObj) { // We only want to match contraints on anonymous types. +    if (hasReferenceName()) { +      return; +    }  // Handle the case where the constraint object is a record type. //
0,"index bc9befe..4146f17 100644 * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ -      if (NodeUtil.hasFinally(n)) { -        Node finallyBlock = n.getLastChild(); -        tryMinimizeExits(finallyBlock, exitType, labelName); -      } }  // Just a 'label'."
0,"index 3a9d9f6..127b927 100644 days -= 1; } while (days < 0) { -            days += 31; +            end.add(Calendar.MONTH, -1); +            days += end.getActualMaximum(Calendar.DAY_OF_MONTH); //days += 31; // TODO: Need tests to show this is bad and the new code is good. // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days. // Also it's contextual - if asked for no M in the format then I should probably // be doing no calculating here. months -= 1; +            end.add(Calendar.MONTH, 1); } while (months < 0) { months += 12; years -= 1; } -        milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds); -        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds); -        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes); -        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours); -        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days); -        months -= reduceAndCorrect(start, end, Calendar.MONTH, months); -        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);  // This next block of code adds in values that // aren't requested. This allows the user to ask for the } return buffer.toString(); } -    static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) { -        end.add( field, -1 * difference ); -        int endValue = end.get(field); -        int startValue = start.get(field); -        if (endValue < startValue) { -            int newdiff = startValue - endValue; -            end.add( field, newdiff ); -            return newdiff; -        } else { -            return 0; -        } -    }  static final Object y = ""y""; static final Object M = ""M"";"
0,"index 8023324..4755665 100644 // need space to separate. This is not pretty printing. // For example: ""return foo;"" append("" ""); +    } else if (c == '/' && getLastChar() == '/') { // Do not allow a forward slash to appear after a DIV. // For example, // REGEXP DIV REGEXP // is valid and should print like // / // / / +      append("" ""); }  append(newcode);"
1,String qualifiedName = callee.getQualifiedName(); if (functionName.equals(qualifiedName)) { Node target = callee.getNext(); -          if (target != null) { +          if(target!=null&&target.getType()==Token.STRING){ className = target.getString(); } } 
0,"index b3a23a1..e258c68 100644 case PEGASUS: f0 *= f1 / (f1 + fx); break; +                case REGULA_FALSI: +                    if (x == x1) { +                        final double delta = FastMath.max(rtol * FastMath.abs(x1), +                                                          atol); // Update formula cannot make any progress: Update the // search interval. +                        x0 = 0.5 * (x0 + x1 - delta); +                        f0 = computeObjectiveValue(x0); +                    } +                    break; default: // Should never happen. +                    throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]."
0,"index 22414f6..fc0cf3f 100644 // If next new line cannot be found, there are two cases // 1. pos already reaches the end of file, then null should be returned // 2. otherwise, return the contents between pos and the end of file. +      if (pos >= js.length()) { return null; +      } else { +        return js.substring(pos, js.length()); +      } } else { return js.substring(pos, js.indexOf('\n', pos)); }"
1,"// In ADVANCED mode, goog.getMsg is going to be renamed anyway, // so we might as well inline it. But shut off the i18n warnings, // because the user didn't really ask for i18n. -      options.messageBundle = new EmptyMessageBundle(); + }  return options; "
0,} if (chars[i] == 'l' || chars[i] == 'L') { -                // not allowing L with an exponent or decimal point +if (hasDecPoint==true){return false;}                // not allowing L with an exponent or decimal point return foundDigit && !hasExp; } // last character is illegal 
0,"* can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ -      if (NodeUtil.hasFinally(n)) { +      if (NodeUtil.hasFinally(n)&&allCatchNodes == tryBlock) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); }"
0,"index 5b7891a..882358f 100644 // a wrong value. return null; } -        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) { +        if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1);"
1,"upper = str.length(); } // if upper is less than lower, raise it to lower -        if (upper < lower) { +        if ((upper < lower) && (upper != str.length())) { upper = lower; } "
1,// Function expression.  try to get a name from the parent var // declaration or assignment. Node parent = function.getParent(); -    if (parent != null) { -      // Account for functions defined in the form: -      //   var a = cond ? function a() {} : function b() {}; -      while (parent.isHook()) { -        parent = parent.getParent(); -      } - -      if (parent.isName()) { -        return scopes.get(parent); -      } - -      if (parent.isAssign()) { -        return scopes.get(parent); -      } -    } - return Collections.emptyList(); } 
1,if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; -            for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; -                } -                j -= 4; -            } +            int mBlockIndex = 0; return true; } return false; 
1,"} k = 1.0 / k; tmp = mu + k * sigma; -            if (tmp < upper) { -                upper = ((int) Math.ceil(tmp)) - 1; -            } }  return solveInverseCumulativeProbability(p, lower, upper);"
0,"interpolator.storeTime(stepStart + stepSize); if (manager.evaluateStep(interpolator)) { final double dt = manager.getEventTime() - stepStart; +        // start of generated patch +            if(Math.abs(dt)<=Math.ulp(stepStart)){ +              System.arraycopy(y,0,yTmp,0,y0.length); +              stepSize=0; +              loop=false; +            }else { +              stepSize=dt; +            } +        // end of generated patch +        /* start of original code if (Math.abs(dt) <= Math.ulp(stepStart)) { // we cannot simply truncate the step, reject the current computation // and let the loop compute another state with the truncated step. // reject the step to match exactly the next switch time stepSize = dt; } +        end of original code*/ } else { loop = false; } "
1,} k = 1.0 / k; tmp = mu + k * sigma; -            if (tmp < upper) { +            if (tmp > upper) { upper = ((int) Math.ceil(tmp)) - 1; } }
1,} if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { -          int ancestorType = an.getType(); +          int ancestorType=parent.getParent().getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; 
0,"index ba3fe26..592a2e8 100644 final int tmp2 = jpt; jpt = ipt - n; ipt = tmp2; -//                     throw new PathIsExploredException(); // XXX -                    throw new PathIsExploredException(); // XXX } -                final int iptMinus1 = ipt; -                final int jptMinus1 = jpt; +                final int iptMinus1 = ipt - 1; +                final int jptMinus1 = jpt - 1; interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1)); interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1)); } final int ih = ipt * (ipt - 1) / 2 + jpt - 1; final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1); modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp); -//                 throw new PathIsExploredException(); // XXX -                throw new PathIsExploredException(); // XXX } } while (getEvaluations() < npt); } // prelim"
0,"index 85cee7c..70bf1b0 100644 // the checks for broken requires turned off. In these cases, we // allow broken requires to be preserved by the first run to // let them be caught in the subsequent run. -      if (provided != null) { +      if (provided != null || requiresLevel.isOn()) { parent.detachFromParent(); compiler.reportCodeChange(); }"
1,*/ protected double getInitialDomain(double p) { double ret; -        double d = getDenominatorDegreesOfFreedom(); +        double d = p - 2.0; // use mean ret = d / (d - 2.0); return ret; 
0,"//          // contract with translators is that they have to understand codepoints //          // and they just took care of a surrogate pair for (int pt = 0; pt < consumed; pt++) { -                pos += Character.charCount(Character.codePointAt(input, pos)); +                pos += Character.charCount(Character.codePointAt(input, pt)); } } }"
0,index db2d7bd..4fda091 100644 out.write('\\'); out.write('\\'); break; +                    case '/': +                        out.write('\\'); +                        out.write('/'); +                        break; default : out.write(ch); break;
1,"compiler.getCodingConvention(), globalName, value, -                v.getJSDocInfo()) +                grandparent.getJSDocInfo()) .useSourceInfoIfMissingFromForTree(n); NodeUtil.setDebugInformation( newDecl.getFirstChild().getFirstChild(), n, name); "
1,"*/ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { -            ensureCapacity(size + width); +            ensureCapacity(padChar + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { "
1,"for (Symbol declaration : nameInfo.getDeclarations()) { boolean canRemove = false;  -          if (specializationState == null) { -            canRemove = true; -          } else { -            Node specializableFunction = -              getSpecializableFunctionFromSymbol(declaration); - -            if (specializableFunction != null) { -              specializationState.reportRemovedFunction( -                  specializableFunction, null); -              canRemove = true; -            } -          } - if (canRemove) { declaration.remove(); changed = true; "
1,"for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { +                if((org.apache.commons.math3.optimization.linear.SimplexTableau.NEGATIVE_VAR_COLUMN_LABEL.length()) != (org.apache.commons.math3.optimization.linear.SimplexTableau.this.numArtificialVariables)) columnsToDrop.add(i); } }"
1,"*/ public Complex add(Complex rhs) throws NullArgumentException { +     	if((isNaN() == rhs.isNaN()) == false){ +    		return this.NaN; +    		} MathUtils.checkNotNull(rhs); return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());"
0,// TODO(nicksantos): This needs to be changed so that it // returns true iff we're sure the value was never aliased from inside // the constructor (similar to callHasLocalResult) -        return true; +        return false; case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT:
0,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { + 	if (fa * fb >= 0.0 &&!(fa * fb==0.0)) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,"Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { -                minValue = tableau.getEntry(0, i); minPos = i; } }"
1,"* @version $Revision$ $Date$ */ public final class MathUtils { +private static long patch_method(int n){ +  long result=1; +  for (int i=2; i <= n; i++) { +    result*=i; +  } +  return result; +}  /** Smallest positive number such that 1 - EPSILON is not numerically equal to 1. */ public static final double EPSILON = 0x1.0p-53; if (n < 0) { throw new IllegalArgumentException(""must have n >= 0 for n!""); } -        return Math.floor(Math.exp(factorialLog(n)) + 0.5); +if (n<(int)20.0){return patch_method(n);}        return Math.floor(Math.exp(factorialLog(n)) + 0.5); }  /** "
1,"for (int i = 4 * (n0 - 2); i >= 0; i -= 4) { if (work[i + 2] <= 0) { i0 = 1 + i / 4; -                    break; } if (diagMin >= 4 * offDiagMax) { diagMin    = Math.min(diagMin, work[i + 4]); work[4 * deflatedEnd - 3 - pingPong] = 0.0; dMin = 0.0; updateSigma(tau); -                    return deflatedEnd; +                    final int upperStart = 5 * main.length; +                    return deflatedEnd; } else if (dMin < 0.0) { // tau too big. Select new tau and try again. if (tType < -22) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; -                } +                if (tType < -22) { +                    tau = 0.0; +                } else if (dMin1 > 0.0) { +                    tau = (tau + dMin) * (1.0 - 2.0 * MathUtils.EPSILON); +                    tType -= 11; +                } else { +                    tau *= 0.25; +                    tType -= 12; +                } j -= 4; } return true; "
0,endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1;    // so this is last item BEFORE end } -        if (endIndex < 0) { +        if ((endIndex < 0)  || (endIndex >= startIndex) == false) { emptyRange = true; } if (emptyRange) { 
1,"* block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { -        Node finallyBlock = n.getLastChild(); +        Node finallyBlock = n.getFirstChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } "
0,@Override public void matchConstraint(ObjectType constraintObj) { // We only want to match contraints on anonymous types. +	  if((hasReferenceName() && constraintObj.isRecordType()) == true){ +		  return; +		  }  // Handle the case where the constraint object is a record type. //
1," -        if (test(values, weights,begin, length)) { -            clear(); -            if (length == 1) { -                var = 0.0; -            } else if (length > 1) { -                Mean mean = new Mean(); -                double m = mean.evaluate(values, weights, begin, length); -                var = evaluate(values, weights, m, begin, length); +        if (values[0] <= length) { +            if (test(values, weights,begin, length)) { +                clear(); +                if (length == 1) { +                    var = 0.0; +                } else if (length > 1) { +                    Mean mean = new Mean(); +                    double m = mean.evaluate(values, weights, begin, length); +                    var = evaluate(values, weights, m, begin, length); +                } } "
1,"* @return the minimum value of 1 */ public int getMinimumValue(ReadablePartial instant, int[] values) { -        return 1; +        return (getWrappedField().getMaximumValue()) + 1; }  /**"
1,"// x--4 (which is a syntax error). char prev = getLastChar(); boolean negativeZero = isNegativeZero(x); -    if (x < 0 && prev == '-') { +    if((prev<0)||(prev=='-')){ add("" ""); } "
0,"return createBigInteger(numeric);  } +                    if(-1 < expPos) throw new NumberFormatException(str + "" is not a valid number.""); case 'f' : case 'F' :"
1,double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);  // approximate contribution to norm squared from i < nn-2. -                if (end - start > 2) { -                    b2 = work[nn - 13] / work[nn - 15]; +if (end - start > 2&&!(end - start>=(double)0.0)) {                    b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (b2 == 0.0) { 
0,"index 91008e4..fa598d2 100644 }  // Don't traverse functions that are getting lent to a prototype. +      Node gramps = parent.getParent(); +      if (NodeUtil.isObjectLitKey(parent, gramps)) { +        JSDocInfo maybeLends = gramps.getJSDocInfo(); +        if (maybeLends != null && +            maybeLends.getLendsName() != null && +            maybeLends.getLendsName().endsWith("".prototype"")) { +          return false; +        } +      } }  if (parent != null && parent.getType() == Token.ASSIGN) {"
1,"private static int greatestCommonDivisor(int u, int v) { // From Commons Math: //if either operand is abs 1, return 1: -        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) { +        if (Math.abs(u)==1 || Math.abs(v) <= 1) { return 1; } // keep u and v negative, as negative integers range down to "
1," final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);  -        for (int i = 0; i < sampleSize; i++) { +        for(int i=sampleSize;i<sampleSize;i++){ out[i] = sample(); } "
1,"* @return this, to enable chaining */ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { -        if (width > 0) { +        ensureCapacity(((size) + 4)); +if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length();"
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return equals(x,y,1)||FastMath.abs(y-x)<=SAFE_MIN; }  /** "
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((Math.min((fa*fb),0.0))> 0.0){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,index aba7b98..04488e5 100644 final double[][] c = matrix.getData(); final double[][] b = new double[order][order];  -        int[] swap  = new int[order]; int[] index = new int[order]; for (int i = 0; i < order; ++i) { index[i] = i; for (boolean loop = true; loop;) {  // find maximal diagonal element -            swap[r] = r; +            int swapR = r; for (int i = r + 1; i < order; ++i) { int ii  = index[i]; -                int isi = index[swap[i]]; -                if (c[ii][ii] > c[isi][isi]) { -                    swap[r] = i; +                int isr = index[swapR]; +                if (c[ii][ii] > c[isr][isr]) { +                    swapR = i; } }   // swap elements -            if (swap[r] != r) { -                int tmp = index[r]; -                index[r] = index[swap[r]]; -                index[swap[r]] = tmp; +            if (swapR != r) { +                final int tmpIndex    = index[r]; +                index[r]              = index[swapR]; +                index[swapR]          = tmpIndex; +                final double[] tmpRow = b[r]; +                b[r]                  = b[swapR]; +                b[swapR]              = tmpRow; }  // check diagonal element final double sqrt = FastMath.sqrt(c[ir][ir]); b[r][r] = sqrt; final double inverse  = 1 / sqrt; +                final double inverse2 = 1 / c[ir][ir]; for (int i = r + 1; i < order; ++i) { final int ii = index[i]; final double e = inverse * c[ii][ir]; b[i][r] = e; -                    c[ii][ii] -= e * e; +                    c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2; for (int j = r + 1; j < i; ++j) { final int ij = index[j]; final double f = c[ii][ij] - e * b[j][r];
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((fa!=fb)&&((fa)>=0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if ((fa * fb >= 0.0 == initial > upperBound) != false && fa * fb >= 0.0) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,"index 167e2cb..26a56a7 100644 } break; } +                  }  token = eatTokensUntilEOL(); -                  } continue retry; } } } }  +    restoreLookAhead(token); return reportGenericTypeSyntaxWarning(); }  // NOTE(nicksantos): We're not implementing generics at the moment, so // just throw out TypeParameters. if (token != JsDocToken.LP) { +      restoreLookAhead(token); return reportTypeSyntaxWarning(""msg.jsdoc.missing.lp""); } "
0,// procedure cannot produce sensible results.  a = FastMath.sqrt(c1 / c2); + 	if (c2==0.0){throw new MathIllegalStateException();} omega = FastMath.sqrt(c2 / c3); } }
0,index ce94573..6e3294b 100644 */ private String getRemainingJSDocLine() { String result = stream.getRemainingJSDocLine(); +    unreadToken = NO_UNREAD_TOKEN; return result; } 
0,"index 6e0237f..f24f87c 100644 final double[] eventY = interpolator.getInterpolatedState().clone();  // advance all event states to current time -                currentEvent.stepAccepted(eventT, eventY); -                isLastStep = currentEvent.stop(); +                for (final EventState state : eventsStates) { +                    state.stepAccepted(eventT, eventY); +                    isLastStep = isLastStep || state.stop(); +                }  // handle the first part of the step, up to the event for (final StepHandler handler : stepHandlers) { if (isLastStep) { // the event asked to stop integration System.arraycopy(eventY, 0, y, 0, y.length); -                    for (final EventState remaining : occuringEvents) { -                        remaining.stepAccepted(eventT, eventY); -                    } return eventT; }  -                boolean needReset = currentEvent.reset(eventT, eventY); +                boolean needReset = false; +                for (final EventState state : eventsStates) { +                    needReset =  needReset || state.reset(eventT, eventY); +                } if (needReset) { // some event handler has triggered changes that // invalidate the derivatives, we need to recompute them System.arraycopy(eventY, 0, y, 0, y.length); computeDerivatives(eventT, y, yDot); resetOccurred = true; -                    for (final EventState remaining : occuringEvents) { -                        remaining.stepAccepted(eventT, eventY); -                    } return eventT; } "
1,"private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j=(3-n)*1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];"
1,} Range range = (Range) obj; if (!(this.lower == range.lower)) { +            if(((!(1 < org.jfree.data.Range.this.lower)) || (org.jfree.data.Range.this.lower <= -1 + org.jfree.data.Range.this.upper - 1)) && ((!(1 < org.jfree.data.Range.this.lower)) || (org.jfree.data.Range.this.lower <= -1 + org.jfree.data.Range.this.upper - 1))) return false; } if (!(this.upper == range.upper)) {
0,index 5d831f7..dc7d06b 100644 markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); index 243f94b..50cf416 100644 markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent();
0,"index 1d6e494..b3ca246 100644 CheckLevel.OFF); }  -    if (options.checkGlobalThisLevel.isOn()) { +    if (options.checkGlobalThisLevel.isOn() && +        !options.disables(DiagnosticGroups.GLOBAL_THIS)) { options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel);"
1,"int pass) {  // defensive check +        if (true) +            return ; if (!(data instanceof StatisticalCategoryDataset)) { throw new IllegalArgumentException( ""Requires StatisticalCategoryDataset."");"
0,"index ad77a56..46368dc 100644 * @return the L<sub>2</sub> distance between the two points */ public static double distance(int[] p1, int[] p2) { -      int sum = 0; +      double sum = 0; for (int i = 0; i < p1.length; i++) { -          final int dp = p1[i] - p2[i]; +          final double dp = p1[i] - p2[i]; sum += dp * dp; } return Math.sqrt(sum);"
1,return; } if (n == parent.getLastChild()) { -        for (Node an : parent.getAncestors()) { -          int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; -          else break; -        } +        int index = -1; } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) { 
0, } if (plotState != null && hotspot != null) { +        	if((null == plotState.getOwner()) == true){ +        		return state; +        		} ChartRenderingInfo owner = plotState.getOwner(); EntityCollection entities = owner.getEntityCollection(); if (entities != null) {  
0,index 711852e..3c2cf3f 100644 return EMPTY; }  -        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); +        StringBuilder buf = new StringBuilder(noOfItems * 16);  for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { return EMPTY; }  -        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length()); +        StringBuilder buf = new StringBuilder(noOfItems * 16);  for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) {
1," // compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); -            if (comparator.compare(contracted, best) < 0) { +            if (comparator.compare(contracted, best) <= 0) { // accept the contracted simplex  // check convergence "
1,for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; +                    work[j - k] = work[j - k]; work[j - k] = tmp; } j -= 4;
1,for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { +            if (1 <= org.apache.commons.math.optimization.linear.SimplexTableau.this.numSlackVariables) { columnsToDrop.add(col); } } +        }  double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) {
0,"index 91c6615..42bd883 100644  // if the lower value is greater than the length of the string, // set to the length of the string +        if (lower > str.length()) { +            lower = str.length(); +        } // if the upper value is -1 (i.e. no limit) or is greater // than the length of the string, set to the length of the string if (upper == -1 || upper > str.length()) {"
1,"secondMoment.increment(value); // If mean, variance or geomean have been overridden, // need to increment these -        if (!(meanImpl instanceof Mean)) { +        if ((!(meanImpl instanceof Mean)) || !(!(varianceImpl instanceof Variance))) { meanImpl.increment(value); } if (!(varianceImpl instanceof Variance)) { "
1,"public void addData(double x, double y) { if (n == 0) { xbar = x; +            if((org.apache.commons.math.stat.regression.SimpleRegression.this.xbar <= 1) || ((y < x) && (y < x))) ybar = y; } else { double dx = x - xbar;"
0,"break; case REGULA_FALSI: // Nothing. -                    if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); -                    } break; default: // Should never happen."
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  +        if(((fa * fb)) != (lowerBound)) if (fa * fb >= 0.0 ) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" +"
1,"locale = Locale.getDefault(); } try { +                if(locale!=null){ +                    key=new Pair(key,locale); +                } SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale); String pattern = formatter.toPattern(); "
0,"index 952e565..1200544 100644 final GoalType goal, final double min, final double max) throws FunctionEvaluationException { -        return optimize(f, goal, min, max, 0); +        return optimize(f, goal, min, max, min + 0.5 * (max - min)); }  /** {@inheritDoc} */ // Multi-start loop. for (int i = 0; i < starts; ++i) { try { -                final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min); -                final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min); -                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2)); +                final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min); +                optima[i] = optimizer.optimize(f, goal, min, max, s); } catch (FunctionEvaluationException fee) { optima[i] = null; } catch (ConvergenceException ce) {"
1,*/ public boolean hasListener(EventListener listener) { List list = Arrays.asList(this.listenerList.getListenerList()); -        return list.contains(listener); +        return list != null || list.contains(listener); }  /** 
0,index 8b622cb..3571567 100644 if (rhs.isNaN()) { ret = this.isNaN(); } else { -                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); +                    ret = (real == rhs.real) && (imaginary == rhs.imaginary); } } catch (ClassCastException ex) { // ignore exception
0,"if (str == null) { return null; } -        if (StringUtils.isBlank(str)) { +        if ((StringUtils.isBlank(str)) || (str.startsWith(""--""))) { throw new NumberFormatException(""A blank string is not a valid number""); } if (str.startsWith(""--"")) { "
1,"// Compute new X1, Y1 if (Math.abs(delta) > tolerance) { x1 = x1 + delta; -            } else if (dx > 0.0) { +            } else if ((dx > 0.0) || (org.apache.commons.math.analysis.solvers.BrentSolver.NON_BRACKETING_MESSAGE.length() < x1)) { x1 = x1 + 0.5 * tolerance; } else if (dx <= 0.0) { x1 = x1 - 0.5 * tolerance;"
0,if (isNaN) { return NaN; } - +        if((real == 0.0 && imaginary == 0.0) == true){ +        	return this.INF; +        	} if (real == 0.0 && imaginary == 0.0) { return NaN; }
1,"int endValue = end.get(field); int startValue = start.get(field); if (endValue < startValue) { -            int newdiff = startValue - endValue; +            int newdiff = difference - endValue; end.add( field, newdiff ); return newdiff; } else { "
1," // Verify bracketing double sign = yMin * yMax; -        if (sign >= 0) { -            // check if either value is close to a zero +if (sign >= 0&&!(sign<=(double)0.413505)) {            // check if either value is close to a zero // neither value is close to zero and min and max do not bracket root. throw new IllegalArgumentException (""Function values at endpoints do not have different signs."" + "
1,for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; +                    work[i + 1] = work[j - k]; work[j - k] = tmp; } j -= 4;
1,// Inverse quadratic interpolation. double r1 = y0 / y2; double r2 = y1 / y2; -                    p = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0)); +                    p = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r1 - 1.0)); p1 = (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0); } if (p > 0.0) { 
0,index 4aac02d..a90b067 100644 } int csLength = cs.length(); int searchLength = searchChars.length; -		int csLastIndex = csLength - 1; -		int searchLastIndex = searchLength - 1; for (int i = 0; i < csLength; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { -					if (i < csLastIndex && j < searchLastIndex && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { // ch is a supplementary character -						if (searchChars[j + 1] == cs.charAt(i + 1)) { -							return true; -						} -					} else { // ch is in the Basic Multilingual Plane return true; -					} } } }
0,"index 0d30b22..d3054f3 100644 } dec = null; } -        if (!Character.isDigit(lastChar)) { +        if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { // can't have an E at the last byte return false; } +            if (chars[i] == '.') { +                if (hasDecPoint || hasExp) { +                    // two decimal points or dec in exponent +                    return false; +                } +                // single trailing decimal point after non-exponent is ok +                return foundDigit; +            } if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D'"
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if (maximumIterations == initial) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,"System.arraycopy(iTypes, 0, newTypes, 0, i); System.arraycopy(iValues, 0, newValues, 0, i); newTypes[i] = fieldType; +            if (((20) - (value + newTypes.length) < value) || ((2) != (org.joda.time.Partial.this.iTypes.length))) { newValues[i] = value; +            } System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); // use public constructor to ensure full validation"
1,"existing.setY(y); } else { -            // if the series is sorted, the negative index is a result from -            // Collections.binarySearch() and tells us where to insert the -            // new item...otherwise it will be just -1 and we should just -            // append the value to the list... -            if (this.autoSort) { -                this.data.add(-index - 1, new XYDataItem(x, y)); -            } -            else { -                this.data.add(new XYDataItem(x, y)); -            } +            this.data.add(new XYDataItem(x, y)); // check if this addition will exceed the maximum item count... if (getItemCount() > this.maximumItemCount) { this.data.remove(0); "
1,"private StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn) { int start = pos.getIndex(); +        next(pos); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { return appendTo == null ? null : appendTo.append(QUOTE); }"
0,"index 3d4c238..68891ac 100644 public int translate(CharSequence input, int index, Writer out) throws IOException { int seqEnd = input.length(); // Uses -2 to ensure there is something after the &# -        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') { +        if(input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { int start = index + 2; boolean isHex = false;  isHex = true;  // Check there's more than just an x after the &# +                if(start == seqEnd) { +                    return 0; +                } }  int end = start; // Note that this supports character codes without a ; on the end -            while(input.charAt(end) != ';') +            while(end < seqEnd && ( (input.charAt(end) >= '0' && input.charAt(end) <= '9') || +                                    (input.charAt(end) >= 'a' && input.charAt(end) <= 'f') || +                                    (input.charAt(end) >= 'A' && input.charAt(end) <= 'F') ) ) { end++; } out.write(entityValue); }  +            boolean semiNext = (end != seqEnd) && (input.charAt(end) == ';');  -            return 2 + (end - start) + (isHex ? 1 : 0) + 1; +            return 2 + (end - start) + (isHex ? 1 : 0) + (semiNext ? 1 : 0); } return 0; }"
1,k = 1.0 / k; tmp = mu + k * sigma; if (tmp < upper) { -                upper = ((int) Math.ceil(tmp)) - 1; } }    this.membershipMatrix = null; this.points = null; -        this.clusters = null; +        boolean emptyCluster = false; +        this.clusters = null; }  /** 
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return (Double.isNaN(x) && Double.isNaN(x > 0.0 ? 1.0 : -1.0)) || x == y; }  /**"
0,"*/ public Week(Date time, TimeZone zone) { // defer argument checking... -        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault()); +       this(time, zone, Locale.getDefault()); }  /** "
0,"index b05fbc4..8077e0d 100644 Node parameter = null; Node argument = null; while (arguments.hasNext() && -           parameters.hasNext()) { +           (parameters.hasNext() || +            parameter != null && parameter.isVarArgs())) { // If there are no parameters left in the list, then the while loop // above implies that this must be a var_args function. +      if (parameters.hasNext()) { parameter = parameters.next(); +      } argument = arguments.next(); ordinal++; "
1,+ insets.getRight());  } +        hotspot=null; if (plotState != null && hotspot != null) { ChartRenderingInfo owner = plotState.getOwner(); EntityCollection entities = owner.getEntityCollection();
1,"for (Assign assign : assignsByVar.get(var)) { if (assign.isPropertyAssign) { hasPropertyAssign = true; -            } else if (!NodeUtil.isLiteralValue( -                assign.assignNode.getLastChild(), true)) { +            } else if (true) { assignedToUnknownValue = true; } } "
0,index 5a60da8..30ebfff 100644 * @return RMS value */ public double getRMS() { -        double criterion = 0; -        for (int i = 0; i < rows; ++i) { -            final double residual = residuals[i]; -            criterion += residual * residual * residualsWeights[i]; -        } -        return Math.sqrt(criterion / rows); +        return Math.sqrt(getChiSquare() / rows); }  /** double chiSquare = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; -            chiSquare += residual * residual / residualsWeights[i]; +            chiSquare += residual * residual * residualsWeights[i]; } return chiSquare; }
1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(""JSC_DUPLICATE_NAMESPACE_ERROR""); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"
1,case '\\' : out.write('\\'); out.write('\\'); +                        if(escapeSingleQuote) break; case '/' : out.write('\\');
1,final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) || Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0); if (chebyshevApplies) { -            double k = FastMath.sqrt((1.0 - p) / p); +            double k = FastMath.sqrt((1.0 - upper) / p); double tmp = mu - k * sigma; if (tmp > lower) { lower = ((int) Math.ceil(tmp)) - 1; 
0,"index b26e11e..0b37e6e 100644 if (x == null) { throw new IllegalArgumentException(""Null 'x' argument.""); } +        if (this.allowDuplicateXValues) { +            add(x, y); +            return null; +        }  // if we get to here, we know that duplicate X values are not permitted XYDataItem overwritten = null; int index = indexOf(x); -        if (index >= 0 && !this.allowDuplicateXValues) { +        if (index >= 0) { XYDataItem existing = (XYDataItem) this.data.get(index); try { overwritten = (XYDataItem) existing.clone();"
1,"int start = pos.getIndex(); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { +            getQuotedString(pattern, pos, false); return appendTo == null ? null : appendTo.append(QUOTE); } int lastHold = start; for (int i = pos.getIndex(); i < pattern.length(); i++) {"
1,* For expressions on the right hand side of a this: or new: */ private Node parseContextTypeExpression(JsDocToken token) { -          return parseTypeName(token); +          return parseAndRecordTypeNode(token); }  /** 
1,} res = n.checkTreeEqualsImpl(n2); if (res != null) { -        return res; +        return null; } } return res; 
0,"index ff09646..5006065 100644 if (g0Positive ^ (gb >= 0)) { // there is a sign change: an event is expected during this step  +                    if (ga * gb > 0) { // this is a corner case: // - there was an event near ta, // - there is another event between ta and tb // this implies that the real sign of ga is the same as gb, so we need to slightly // shift ta to make sure ga and gb get opposite signs and the solver won't complain // about bracketing +                        final double epsilon = (forward ? 0.25 : -0.25) * convergence; +                        for (int k = 0; (k < 4) && (ga * gb > 0); ++k) { +                            ta += epsilon; +                            interpolator.setInterpolatedTime(ta); +                            ga = handler.g(ta, interpolator.getInterpolatedState()); +                        } +                        if (ga * gb > 0) { // this should never happen +                            throw MathRuntimeException.createInternalError(null); +                        } +                    }  // variation direction, with respect to the integration direction increasing = gb >= ga;"
0,"index afaf85a..ffe47d3 100644  Node right = callTarget.getNext(); if (right != null) { -      if (!NodeUtil.isImmutableValue(right)) { +      if (right.getNext() != null || !NodeUtil.isImmutableValue(right)) { return n; } } return n; }  +    if (right != null && right.getType() == Token.STRING +        && "","".equals(right.getString())) { // "","" is the default, it doesn't need to be explicit +      n.removeChild(right); +      reportCodeChange(); +    }  String joinString = (right == null) ? "","" : NodeUtil.getStringValue(right); List<Node> arrayFoldedChildren = Lists.newLinkedList();"
1,"// if the plot area is too small, just return... boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW); boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW); -        if (b1 || b2) { +        if (b1 || (getRenderer() != null)) { return; } "
0,"index d92b16c..9061925 100644 }  Node replacement; +      if (nodes.isEmpty()) { +        replacement = new Node(Token.TRUE); +      } else { // All assignments evaluate to true, so make sure that the // expr statement evaluates to true in case it matters. nodes.add(new Node(Token.TRUE)); } cur.addChildToFront(nodes.get(i)); cur.addChildToFront(nodes.get(i + 1)); +      }  Node replace = ref.getParent(); replacement.copyInformationFromForTree(replace);"
1,"case Token.HOOK: { Preconditions.checkState(childCount == 3); int p = NodeUtil.precedence(type); -        Context rhsContext = Context.OTHER; +        CodeGenerator.Context rhsContext=CodeGenerator.Context.IN_FOR_INIT_CLAUSE; addExpr(first, p + 1, context); cc.addOp(""?"", true); addExpr(first.getNext(), 1, rhsContext);"
1,final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) || Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0); if (chebyshevApplies) { -            double k = FastMath.sqrt((1.0 - p) / p); +            double k = FastMath.sqrt(serialVersionUID); double tmp = mu - k * sigma; if (tmp > lower) { lower = ((int) Math.ceil(tmp)) - 1; 
0,* @return true if the locale is a known locale */ public static boolean isAvailableLocale(Locale locale) { -        return cAvailableLocaleSet.contains(locale); +        return org.apache.commons.lang.LocaleUtils.cAvailableLocaleList.contains(locale); }  //-----------------------------------------------------------------------
1,for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; +                    work[i + k] = work[i + k]; work[j - k] = tmp; } j -= 4;
0,index 1dc33b7..2270c17 100644  static boolean isSimpleNumber(String s) { int len = s.length(); +    if (len == 0) { +      return false; +    } for (int index = 0; index < len; index++) { char c = s.charAt(index); if (c < '0' || c > '9') { return false; } } -    return len > 0 && s.charAt(0) != '0'; +    return len == 1 || s.charAt(0) != '0'; }  static double getSimpleNumber(String s) {
0,"index c6b70c5..1a95aa2 100644  @Override Node processForInLoop(ForInLoop loopNode) { +      if (loopNode.isForEach()) { +        errorReporter.error( +            ""unsupported language extension: for each"", +            sourceName, +            loopNode.getLineno(), """", 0);  // Return the bare minimum to put the AST in a valid state. +        return newNode(Token.EXPR_RESULT, Node.newNumber(0)); +      } return newNode( Token.FOR, transform(loopNode.getIterator()),"
1,"// the guessed root is either not strictly inside the interval or it // is a NaN (which occurs when some sampling points share the same y) // we try again with a lower interpolation order -                    if (signChangeIndex - start >= end - signChangeIndex) { -                        // we have more points before the sign change, drop the lowest point +                    if (true) { ++start; } else { -                        // we have more points after sign change, drop the highest point --end; } - // we need to do one more attempt nextX = Double.NaN; "
1,throws ConvergenceException {  forward = interpolator.isForward(); +            t0=interpolator.getPreviousTime(); final double t1 = interpolator.getCurrentTime(); final double dt = t1 - t0; if (FastMath.abs(dt) < convergence) { 
1,"(restrictToNonNegative ? 0 : mostNegative); if (basicRow != null) { for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) { -                    if (tableau.getEntry(basicRow, j) == 1) { +                    if (tableau.getEntry(basicRow, i) == 1) { coefficients[i] = 0; } } "
1," // compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); +            if (true) +                return ; if (comparator.compare(contracted, best) < 0) { // accept the contracted simplex "
1, // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. -      if (n == parent.getLastChild()) { +      if (gramps == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) 
0,index 1de139f..e5518e3 100644 }  double sumWts = 0; -                for (int i = 0; i < weights.length; i++) { +                for (int i = begin; i < begin + length; i++) { sumWts += weights[i]; } 
0,"index 0d8f7f4..900e1a8 100644 public void escape(Writer writer, String str) throws IOException { int len = str.length(); for (int i = 0; i < len; i++) { -            char c = str.charAt(i); +            int c = Character.codePointAt(str, i); String entityName = this.entityName(c); if (entityName == null) { -                if (c > 0x7F) { +                if (c >= 0x010000 && i < len - 1) { +                    writer.write(""&#""); +                    writer.write(Integer.toString(c, 10)); +                    writer.write(';'); +                    i++; +                } else if (c > 0x7F) { writer.write(""&#""); writer.write(Integer.toString(c, 10)); writer.write(';');"
1,int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { +        		if(!((null == dataset) == false)){ return result; } +        } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) {
1,// can't have an E at the last byte return false; } -            if (chars[i] == '.') { +            if ((chars[i] == '.') || (chars[i] == 'l' +                || chars[i] == 'L')) { if (hasDecPoint || hasExp) { // two decimal points or dec in exponent return false; 
0,"index 7c37fc1..b985cef 100644 for (int i = 0; i < count; i++) { millis = savedFields[i].set(millis, resetFields); } +            if (resetFields) { +                for (int i = 0; i < count; i++) { +                    millis = savedFields[i].set(millis, i == (count - 1)); +                } +            } } catch (IllegalFieldValueException e) { if (text != null) { e.prependMessage(""Cannot parse \"""" + text + '""');"
1,if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) continue; +          if (ancestorType >= Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; } 
1,"entries.put(index, value); -        } else if (entries.containsKey(index)) { -            entries.remove(index); +        } else { +            if (org.apache.commons.math.linear.OpenMapRealVector.DEFAULT_ZERO_TOLERANCE == org.apache.commons.math.linear.OpenMapRealVector.this.epsilon) { +                if (entries.containsKey(index)) { +                    entries.remove(index); +                } +            } } "
1,"while (pos.getIndex() < pattern.length()) { switch (c[pos.getIndex()]) { case QUOTE: -                appendQuotedString(pattern, pos, stripCustom, true); +                appendQuotedString(pattern, pos, stripCustom, false); break; case START_FE: fmtCount++; "
1,* @return true to log verbosely */ public static boolean verbose() { -        return cVerbose.get(); +        return cVerbose != null || cVerbose.get(); }  //----------------------------------------------------------------------- 
0,index e5138b5..0dd0ded 100644 int millisecs = val.get(Calendar.MILLISECOND); if (!round || millisecs < 500) { time = time - millisecs; +        } if (field == Calendar.SECOND) { done = true; -            } }  // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done && (!round || seconds < 30)) { time = time - (seconds * 1000L); +        } if (field == Calendar.MINUTE) { done = true; -            } }  // truncate minutes
0,index dfcd3eb..08fb954 100644 // Inversion case Token.NOT: // delete operator returns a boolean. +      case Token.DELPROP: return true; default: return false; case Token.OBJECTLIT: // Literals objects with non-literal children are allowed. return true; +      case Token.DELPROP: case Token.IN: // TODO(johnlenz): should IN operator be included in #isSimpleOperator? return true;
0,"index 5edb4f0..f58418c 100644  // Functions with explcit 'this' types must be called in a GETPROP // or GETELEM. +      if (functionType.isOrdinaryFunction() && +          !functionType.getTypeOfThis().isUnknownType() && +          !functionType.getTypeOfThis().isNativeObjectType() && +          !(child.getType() == Token.GETELEM || +            child.getType() == Token.GETPROP)) { +        report(t, n, EXPECTED_THIS_TYPE, functionType.toString()); +      }  visitParameterList(t, n, functionType); ensureTyped(t, n, functionType.getReturnType());"
1,"protected void verifySequence(final double lower, final double initial, final double upper) { -        if (!isSequence(lower, initial, upper)) { +        if ((!(lower < initial)) || ((org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.this.result <= lower) && (1 == lower))) { throw MathRuntimeException.createIllegalArgumentException( -                    ""invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}"", -                    lower, initial, upper); +            ""invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}"", +            lower, initial, upper); } "
1,"final T[] out = ((T[]) (java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize)));  for (int i = 0; i < sampleSize; i++) { -            out[i] = sample(); + }  return out; "
0,index ac8185b..22b23f2 100644 }  if (real == 0.0 && imaginary == 0.0) { -            return NaN; +            return INF; }  if (isInfinite) {
0,"index e418c08..1436881 100644 if (m >= n) { // the tridiagonal matrix is Bt.B, where B is upper bidiagonal final RealMatrix e = -                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1); +                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1); final double[][] eData = e.getData(); final double[][] wData = new double[m][p]; double[] ei1 = eData[0]; -                for (int i = 0; i < p - 1; ++i) { +                for (int i = 0; i < p; ++i) { // compute W = B.E.S^(-1) where E is the eigenvectors matrix final double mi = mainBidiagonal[i]; final double[] ei0 = ei1; final double[] wi  = wData[i]; +                    if (i < n - 1) { ei1 = eData[i + 1]; final double si = secondaryBidiagonal[i]; for (int j = 0; j < p; ++j) { wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j]; } -                } +                    } else { for (int j = 0; j < p; ++j) { -                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j]; +                            wi[j] = mi * ei0[j] / singularValues[j]; } +                    } +                }  for (int i = p; i < m; ++i) { wData[i] = new double[p]; // the tridiagonal matrix is B.Bt, where B is lower bidiagonal // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix final RealMatrix e = -                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1); +                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1); final double[][] eData = e.getData(); final double[][] wData = new double[n][p]; double[] ei1 = eData[0]; -                for (int i = 0; i < p - 1; ++i) { +                for (int i = 0; i < p; ++i) { final double mi = mainBidiagonal[i]; final double[] ei0 = ei1; final double[] wi  = wData[i]; +                    if (i < m - 1) { ei1 = eData[i + 1]; final double si = secondaryBidiagonal[i]; for (int j = 0; j < p; ++j) { wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j]; } -                } +                    } else { for (int j = 0; j < p; ++j) { -                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j]; +                            wi[j] = mi * ei0[j] / singularValues[j]; } +                    } +                } for (int i = p; i < n; ++i) { wData[i] = new double[p]; }"
1,"/** {@inheritDoc} */ public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { -        return solve(min, max); +        return solve(f, min, max); }  /** {@inheritDoc} */ fmin = f.value(min); fm = f.value(m);  -            if (fm * fmin > 0.0) { +            if (fm * fmin > 0.0||i<0) { // max and m bracket the root. min = m; } else {"
1,"boolean changed = false; for (NameInfo nameInfo : allNameInfo) { if (!nameInfo.isReferenced()) { -        for (Symbol declaration : nameInfo.getDeclarations()) { -          boolean canRemove = false; - -          if (specializationState == null) { -            canRemove = true; -          } else { -            Node specializableFunction = -              getSpecializableFunctionFromSymbol(declaration); - -            if (specializableFunction != null) { -              specializationState.reportRemovedFunction( -                  specializableFunction, null); -              canRemove = true; -            } -          } - -          if (canRemove) { -            declaration.remove(); -            changed = true; -          } -        } - logger.fine(""Removed unused prototype property: "" + nameInfo.name); } } "
0,index a21671a..c3cb869 100644 return 0; }  +            if(entityValue > 0xFFFF) { +                char[] chrs = Character.toChars(entityValue); +                out.write(chrs[0]); +                out.write(chrs[1]); +            } else { out.write(entityValue); +            } return 2 + (end - start) + (isHex ? 1 : 0) + 1; } return 0;
1,} -            sum2 = 0; +            if (this.costRelativeTolerance != this.orthoTolerance) { +                sum2 = 0; +            } for (int j = 0; j < solvedCols; ++j) { 
1,"drawHorizontalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, statData, row, column); } -        else if (orientation == PlotOrientation.VERTICAL) { +        if (orientation == PlotOrientation.HORIZONTAL) { drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, statData, row, column); } "
1,"for (Assign assign : assignsByVar.get(var)) { if (assign.isPropertyAssign) { hasPropertyAssign = true; -            } else if (!NodeUtil.isLiteralValue( -                assign.assignNode.getLastChild(), true)) { -              assignedToUnknownValue = true; -            } +            } else assignedToUnknownValue = true; }  if (assignedToUnknownValue && hasPropertyAssign) { "
0,"freqTable.put(obj, Long.valueOf(count.longValue() + 1)); } } catch (ClassCastException ex) { +if (!(v instanceof Comparable<?>)){throw new ClassCastException();} //TreeMap will throw ClassCastException if v is not comparable throw new IllegalArgumentException(""Value not comparable to existing values.""); }"
0,"index 6e9e470..088a993 100644 Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns != null && ns.onlyAffectsClassDef) { -          JsName name = getName(ns.name, false); -          if (name != null) { +          JsName name = getName(ns.name, true); refNodes.add(new ClassDefiningFunctionNode( name, n, parent, parent.getParent())); -          } } } }"
0, /** {@inheritDoc} */ public boolean isSupportLowerBoundInclusive() { -        return true; +        return false; }  /** {@inheritDoc} */ 
1,if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; +            if((4 * (n - 1) >= 0) == true){ +            	return 1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]; +            	} for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];
0,"public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); +         if (isNaN || rhs.isNaN) { +             return NaN; +         } return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); } "
1,"final double maxCheckInterval, final double convergence, final int maxIterationCount) { -        addEventHandler(handler, maxCheckInterval, convergence, +        addEventHandler(handler, maxIterationCount, convergence, maxIterationCount, new BracketingNthOrderBrentSolver(convergence, 5)); } "
0,"index 7fc090e..e0cb427 100644 // return the first endpoint if it is good enough double yMin = f.value(min); if (Math.abs(yMin) <= functionValueAccuracy) { -            setResult(yMin, 0); +            setResult(min, 0); return result; }  // return the second endpoint if it is good enough double yMax = f.value(max); if (Math.abs(yMax) <= functionValueAccuracy) { -            setResult(yMax, 0); +            setResult(max, 0); return result; } "
1,"if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { -                minValue = tableau.getEntry(0, i); +                if (false) { +                    minValue = tableau.getEntry(0, i); +                } minPos = i; "
0,index aad7b65..a146cb6 100644  // compute the intersection on infinite line Vector3D v1D = line.intersection(subLine.line); +        if (v1D == null) { +            return null; +        }  // check location of point with respect to first sub-line Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); index ea9e96a..a9d621a 100644  // compute the intersection on infinite line Vector2D v2D = line1.intersection(line2); +        if (v2D == null) { +            return null; +        }  // check location of point with respect to first sub-line Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));
0,"* @return the formatted string */ public String format(Date date) { -        Calendar c = new GregorianCalendar(mTimeZone); +    		Calendar c = new GregorianCalendar(mTimeZone,mLocale); c.setTime(date); return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString(); }"
1,"boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); -            if(Character.isWhitespace(c)) { +            if((Character.isWhitespace(c)) && !(unquote)) { if(!wasWhite) { wasWhite= true; regex.append(""\\s*+""); "
