1,"int column = i + tableau.getArtificialVariableOffset(); final double entry = tableau.getEntry(row, column); if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { -                            return row; } } }"
1,"Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { -                minValue = tableau.getEntry(0, i); minPos = i; } }"
1,"double targetY; if (agingA >= MAXIMAL_AGING) { // we keep updating the high bracket, try to compensate this +                signChangeIndex++; targetY = -REDUCTION_FACTOR * yB; } else if (agingB >= MAXIMAL_AGING) { // we keep updating the low bracket, try to compensate this"
1,"if (info != null) { plotInfo = info.getPlotInfo(); } -        this.plot.draw(g2, plotArea, anchor, null, plotInfo); +        fireChartChanged();  g2.setClip(savedClip); "
1,"* @return the minimum value of 1 */ public int getMinimumValue(ReadablePartial instant, int[] values) { -        return 1; +        return (getWrappedField().getMaximumValue()) + 1; }  /**"
1," // compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); -            if (comparator.compare(contracted, best) < 0) { -                // accept the contracted simplex - -            // check convergence return; -            }  } "
1,"Comparable rowKey, Comparable columnKey) { MeanAndStandardDeviation item = new MeanAndStandardDeviation( mean, standardDeviation); -        this.data.addObject(item, rowKey, columnKey); double m = 0.0; double sd = 0.0; if (mean != null) {"
1,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { -            return result; -        } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) {
1," final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);  -        for (int i = 0; i < sampleSize; i++) { -            out[i] = sample(); -        }  return out; "
1,int np; if (dMin == dN) { gam = dN; -                        a2 = 0.0; if (work[nn - 5]  >  work[nn - 7]) { return; }
1,"if (tailZone != null) { if (tailZone.iStartRecurrence.getNameKey() .equals(tailZone.iEndRecurrence.getNameKey())) { -                    if (ZoneInfoCompiler.verbose()) { -                        System.out.println(""Fixing duplicate recurrent name key - "" + -                                           tailZone.iStartRecurrence.getNameKey()); -                    } if (tailZone.iStartRecurrence.getSaveMillis() > 0) { tailZone = new DSTZone( tailZone.getID(),"
1,"// new item...otherwise it will be just -1 and we should just // append the value to the list... if (this.autoSort) { -                this.data.add(-index - 1, new XYDataItem(x, y)); +                this.data.add(new org.jfree.data.xy.XYDataItem(x , y)); } else { this.data.add(new XYDataItem(x, y));"
1,* @return The index. */ public int getMaxMiddleIndex() { -        return this.maxMiddleIndex; +        return this.maxEndIndex; }  /**
1,double d = getDenominatorDegreesOfFreedom(); // use mean ret = d / (d - 2.0); -        return ret; +        return numeratorDegreesOfFreedom; }  /**
1,// flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; -                } j -= 4; } return true;
1,"heightRange3); Size2D size = this.rightBlock.arrange(g2, c4); w[3] = size.width; +            this.leftBlock = null; h[3] = size.height; } "
1,k = 1.0 / k; tmp = mu + k * sigma; if (tmp < upper) { -                upper = ((int) Math.ceil(tmp)) - 1; +                tmp = mu + (k * sigma); } } 
1,"int increase = 0;  // count the replacement text elements that are larger than their corresponding text being replaced -        for (int i = 0; i < searchList.length; i++) { -            int greater = replacementList[i].length() - searchList[i].length(); -            if (greater > 0) { -                increase += 3 * greater; // assume 3 matches -            } -        } + + + + + + // have upper-bound at 20% increase, then let Java take over increase = Math.min(increase, text.length() / 5); "
1,"mant = str.substring(0, decPos); } else { if (expPos > -1) { -                mant = str.substring(0, expPos); -            } else { -                mant = str; +                mant = str;}else {                 mant = str; } dec = null; } "
1,return; } if (n == parent.getLastChild()) { -        for (Node an : parent.getAncestors()) { -          int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; -          else break; -        } + + + + + + } }else             if (((parent.getType()) != (com.google.javascript.rhino.Token.EXPR_RESULT)) && ((parent.getType()) != (com.google.javascript.rhino.Token.BLOCK))) { if (!((((parent.getType()) == (com.google.javascript.rhino.Token.FOR)) && ((parent.getChildCount()) == 4)) && ((n == (parent.getFirstChild())) || (n == (parent.getFirstChild().getNext().getNext()))))) { 
1,  if (n == parent.getLastChild()) { -        for (Node an : parent.getAncestors()) { -          int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) -            continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) -            return; -          else -            break; -        } + + + + + + + + + } }else             if (((parent.getType()) != (com.google.javascript.rhino.Token.EXPR_RESULT)) && ((parent.getType()) != (com.google.javascript.rhino.Token.BLOCK))) { if ((((parent.getType()) == (com.google.javascript.rhino.Token.FOR)) && ((parent.getChildCount()) == 4)) && ((n == (parent.getFirstChild())) || 
1,"// Collections.binarySearch() and tells us where to insert the // new item...otherwise it will be just -1 and we should just // append the value to the list... -            if (this.autoSort) { -                this.data.add(-index - 1, new XYDataItem(x, y)); +            if (this.autoSort) {                 add(x, y, true); + } else { this.data.add(new XYDataItem(x, y)); "
1,"if (h == LengthConstraintType.NONE) { contentSize = arrangeFN(container, g2, constraint.getWidth()); } -            else if (h == LengthConstraintType.FIXED) { -                contentSize = arrangeFF(container, g2, constraint); -            } -            else if (h == LengthConstraintType.RANGE) { -                contentSize = arrangeFR(container, g2, constraint); -            } -        } -        else if (w == LengthConstraintType.RANGE) { -            if (h == LengthConstraintType.NONE) { -                throw new RuntimeException(""Not implemented.""); -            } -            else if (h == LengthConstraintType.FIXED) { -                throw new RuntimeException(""Not implemented.""); -            } -            else if (h == LengthConstraintType.RANGE) { -                contentSize = arrangeRR(container, constraint.getWidthRange(), -                        constraint.getHeightRange(), g2); -            } -        } -        return new Size2D(container.calculateTotalWidth(contentSize.getWidth()), -                container.calculateTotalHeight(contentSize.getHeight())); -    } +            else +            {  /** * Performs an arrangement without constraints. * * @return The container size after the arrangement. */ -    protected Size2D arrangeNN(BlockContainer container, Graphics2D g2) { -        double[] w = new double[5]; -        double[] h = new double[5]; -        if (this.topBlock != null) { -            Size2D size = this.topBlock.arrange(g2, RectangleConstraint.NONE); -            w[0] = size.width; -            h[0] = size.height; -        } -        if (this.bottomBlock != null) { -            Size2D size = this.bottomBlock.arrange(g2, -                    RectangleConstraint.NONE); -            w[1] = size.width; -            h[1] = size.height; -        } -        if (this.leftBlock != null) { -            Size2D size = this.leftBlock.arrange(g2, RectangleConstraint.NONE); -            w[2] = size.width; -            h[2] = size.height; -       } -        if (this.rightBlock != null) { -            Size2D size = this.rightBlock.arrange(g2, RectangleConstraint.NONE); -            w[3] = size.width; -            h[3] = size.height; -        } - -        h[2] = Math.max(h[2], h[3]); -        h[3] = h[2]; - -        if (this.centerBlock != null) { -            Size2D size = this.centerBlock.arrange(g2, -                    RectangleConstraint.NONE); -            w[4] = size.width; -            h[4] = size.height; -        } -        double width = Math.max(w[0], Math.max(w[1], w[2] + w[4] + w[3])); -        double centerHeight = Math.max(h[2], Math.max(h[3], h[4])); -        double height = h[0] + h[1] + centerHeight; -        if (this.topBlock != null) { -            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, width, -                    h[0])); -        } -        if (this.bottomBlock != null) { -            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, -                    height - h[1], width, h[1])); -        } -        if (this.leftBlock != null) { -            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2], -                    centerHeight)); -        } -        if (this.rightBlock != null) { -            this.rightBlock.setBounds(new Rectangle2D.Double(width - w[3], -                    h[0], w[3], centerHeight)); -        } - -        if (this.centerBlock != null) { -            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], -                    width - w[2] - w[3], centerHeight)); -        } -        return new Size2D(width, height); -    } +  /** * Performs an arrangement with a fixed width and a range for the height. * * @return The container size after the arrangement. */ -    protected Size2D arrangeFR(BlockContainer container, Graphics2D g2, -                               RectangleConstraint constraint) { -        Size2D size1 = arrangeFN(container, g2, constraint.getWidth()); -        if (constraint.getHeightRange().contains(size1.getHeight())) { -            return size1; -        } -        else { -            double h = constraint.getHeightRange().constrain(size1.getHeight()); -            RectangleConstraint c2 = constraint.toFixedHeight(h); -            return arrange(container, g2, c2); -        } -    } +  /** * Arranges the container width a fixed width and no constraint on the * * @return The container size after arranging the contents. */ -    protected Size2D arrangeFN(BlockContainer container, Graphics2D g2, -                               double width) { -        double[] w = new double[5]; -        double[] h = new double[5]; -        RectangleConstraint c1 = new RectangleConstraint(width, null, -                LengthConstraintType.FIXED, 0.0, null, -                LengthConstraintType.NONE); -        if (this.topBlock != null) { -            Size2D size = this.topBlock.arrange(g2, c1); -            w[0] = size.width; -            h[0] = size.height; -        } -        if (this.bottomBlock != null) { -            Size2D size = this.bottomBlock.arrange(g2, c1); -            w[1] = size.width; -            h[1] = size.height; -        } -        RectangleConstraint c2 = new RectangleConstraint(0.0, -                new Range(0.0, width), LengthConstraintType.RANGE, -                0.0, null, LengthConstraintType.NONE); -        if (this.leftBlock != null) { -            Size2D size = this.leftBlock.arrange(g2, c2); -            w[2] = size.width; -            h[2] = size.height; -        } -        if (this.rightBlock != null) { -            double maxW = Math.max(width - w[2], 0.0); -            RectangleConstraint c3 = new RectangleConstraint(0.0, -                    new Range(Math.min(w[2], maxW), maxW), -                    LengthConstraintType.RANGE, 0.0, null, -                    LengthConstraintType.NONE); -            Size2D size = this.rightBlock.arrange(g2, c3); -            w[3] = size.width; -            h[3] = size.height; -        } - -        h[2] = Math.max(h[2], h[3]); -        h[3] = h[2]; - -        if (this.centerBlock != null) { -            RectangleConstraint c4 = new RectangleConstraint(width - w[2] -                    - w[3], null, LengthConstraintType.FIXED, 0.0, null, -                    LengthConstraintType.NONE); -            Size2D size = this.centerBlock.arrange(g2, c4); -            w[4] = size.width; -            h[4] = size.height; -        } -        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4])); -        return arrange(container, g2, new RectangleConstraint(width, height)); -    } +  /** * Performs an arrangement with range constraints on both the vertical * * @return The container size. */ -    protected Size2D arrangeRR(BlockContainer container, -                               Range widthRange, Range heightRange, -                               Graphics2D g2) { -        double[] w = new double[5]; -        double[] h = new double[5]; -        if (this.topBlock != null) { -            RectangleConstraint c1 = new RectangleConstraint(widthRange, -                    heightRange); -            Size2D size = this.topBlock.arrange(g2, c1); -            w[0] = size.width; -            h[0] = size.height; -        } -        if (this.bottomBlock != null) { -            Range heightRange2 = Range.shift(heightRange, -h[0], false); -            RectangleConstraint c2 = new RectangleConstraint(widthRange, -                    heightRange2); -            Size2D size = this.bottomBlock.arrange(g2, c2); -            w[1] = size.width; -            h[1] = size.height; -        } -        Range heightRange3 = Range.shift(heightRange, -(h[0] + h[1])); -        if (this.leftBlock != null) { -            RectangleConstraint c3 = new RectangleConstraint(widthRange, -                    heightRange3); -            Size2D size = this.leftBlock.arrange(g2, c3); -            w[2] = size.width; -            h[2] = size.height; -        } -        Range widthRange2 = Range.shift(widthRange, -w[2], false); -        if (this.rightBlock != null) { -            RectangleConstraint c4 = new RectangleConstraint(widthRange2, -                    heightRange3); -            Size2D size = this.rightBlock.arrange(g2, c4); -            w[3] = size.width; -            h[3] = size.height; -        } - -        h[2] = Math.max(h[2], h[3]); -        h[3] = h[2]; -        Range widthRange3 = Range.shift(widthRange, -(w[2] + w[3]), false); -        if (this.centerBlock != null) { -            RectangleConstraint c5 = new RectangleConstraint(widthRange3, -                    heightRange3); -            // TODO:  the width and height ranges should be reduced by the -            // height required for the top and bottom, and the width required -            // by the left and right -            Size2D size = this.centerBlock.arrange(g2, c5); -            w[4] = size.width; -            h[4] = size.height; -        } -        double width = Math.max(w[0], Math.max(w[1], w[2] + w[4] + w[3])); -        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4])); -        if (this.topBlock != null) { -            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, width, -                    h[0])); -        } -        if (this.bottomBlock != null) { -            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, -                    height - h[1], width, h[1])); -        } -        if (this.leftBlock != null) { -            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2], -                    h[2])); -        } -        if (this.rightBlock != null) { -            this.rightBlock.setBounds(new Rectangle2D.Double(width - w[3], -                    h[0], w[3], h[3])); -        } - -        if (this.centerBlock != null) { -            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], -                    width - w[2] - w[3], height - h[0] - h[1])); -        } -        return new Size2D(width, height); -    } +  /** * Arranges the items within a container. * * @return The container size after the arrangement. */ -    protected Size2D arrangeFF(BlockContainer container, Graphics2D g2, -                               RectangleConstraint constraint) { -        double[] w = new double[5]; -        double[] h = new double[5]; -        w[0] = constraint.getWidth(); -        if (this.topBlock != null) { -            RectangleConstraint c1 = new RectangleConstraint(w[0], null, -                    LengthConstraintType.FIXED, 0.0, -                    new Range(0.0, constraint.getHeight()), -                    LengthConstraintType.RANGE); -            Size2D size = this.topBlock.arrange(g2, c1); -            h[0] = size.height; -        } -        w[1] = w[0]; -        if (this.bottomBlock != null) { -            RectangleConstraint c2 = new RectangleConstraint(w[0], null, -                    LengthConstraintType.FIXED, 0.0, new Range(0.0, -                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE); -            Size2D size = this.bottomBlock.arrange(g2, c2); -            h[1] = size.height; -        } -        h[2] = constraint.getHeight() - h[1] - h[0]; -        if (this.leftBlock != null) { -            RectangleConstraint c3 = new RectangleConstraint(0.0, -                    new Range(0.0, constraint.getWidth()), -                    LengthConstraintType.RANGE, h[2], null, -                    LengthConstraintType.FIXED); -            Size2D size = this.leftBlock.arrange(g2, c3); -            w[2] = size.width; -        } -        h[3] = h[2]; -        if (this.rightBlock != null) { -            RectangleConstraint c4 = new RectangleConstraint(0.0, -                    new Range(0.0, constraint.getWidth() - w[2]), -                    LengthConstraintType.RANGE, h[2], null, -                    LengthConstraintType.FIXED); -            Size2D size = this.rightBlock.arrange(g2, c4); -            w[3] = size.width; -        } -        h[4] = h[2]; -        w[4] = constraint.getWidth() - w[3] - w[2]; -        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]); -        if (this.centerBlock != null) { -            this.centerBlock.arrange(g2, c5); -        } - -        if (this.topBlock != null) { -            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0], -                    h[0])); -        } -        if (this.bottomBlock != null) { -            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2], -                    w[1], h[1])); -        } -        if (this.leftBlock != null) { -            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2], -                    h[2])); -        } -        if (this.rightBlock != null) { -            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0], -                    w[3], h[3])); -        } -        if (this.centerBlock != null) { -            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4], -                    h[4])); -        } -        return new Size2D(constraint.getWidth(), constraint.getHeight()); -    }  /** * Clears the layout. */ -    public void clear() { -        this.centerBlock = null; -        this.topBlock = null; -        this.bottomBlock = null; -        this.leftBlock = null; -        this.rightBlock = null; +                    this.rightBlock = null;                     if (h == (org.jfree.chart.block.LengthConstraintType.FIXED)) {                         contentSize = arrangeFF(container, g2, constraint);}else                         if (h == (org.jfree.chart.block.LengthConstraintType.RANGE)) {                             contentSize = arrangeFR(container, g2, constraint);}}}else                 if (w == (org.jfree.chart.block.LengthConstraintType.RANGE)) {                     if (h == (org.jfree.chart.block.LengthConstraintType.NONE)) {                         throw new java.lang.RuntimeException(""Not implemented."");}else                         if (h == (org.jfree.chart.block.LengthConstraintType.FIXED)) {                             throw new java.lang.RuntimeException(""Not implemented."");}else                             if (h == (org.jfree.chart.block.LengthConstraintType.RANGE)) {                                 contentSize = arrangeRR(container, constraint.getWidthRange(), constraint.getHeightRange(), g2);}}         return new org.jfree.chart.util.Size2D(container.calculateTotalWidth(contentSize.getWidth()), container.calculateTotalHeight(contentSize.getHeight()));}     protected org.jfree.chart.util.Size2D arrangeNN(org.jfree.chart.block.BlockContainer container, java.awt.Graphics2D g2) {         double[] w = new double[5];         double[] h = new double[5];         if ((this.topBlock) != null) {             org.jfree.chart.util.Size2D size = this.topBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE);             w[0] = size.width;             h[0] = size.height;}         if ((this.bottomBlock) != null) {             org.jfree.chart.util.Size2D size = this.bottomBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE);             w[1] = size.width;             h[1] = size.height;}         if ((this.leftBlock) != null) {             org.jfree.chart.util.Size2D size = this.leftBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE);             w[2] = size.width;             h[2] = size.height;}         if ((this.rightBlock) != null) {             org.jfree.chart.util.Size2D size = this.rightBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE);             w[3] = size.width;             h[3] = size.height;}         h[2] = java.lang.Math.max(h[2], h[3]);         h[3] = h[2];         if ((this.centerBlock) != null) {             org.jfree.chart.util.Size2D size = this.centerBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE);             w[4] = size.width;             h[4] = size.height;}         double width = java.lang.Math.max(w[0], java.lang.Math.max(w[1], (((w[2]) + (w[4])) + (w[3]))));         double centerHeight = java.lang.Math.max(h[2], java.lang.Math.max(h[3], h[4]));         double height = ((h[0]) + (h[1])) + centerHeight;         if ((this.topBlock) != null) {             this.topBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, 0.0, width, h[0]));}         if ((this.bottomBlock) != null) {             this.bottomBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, (height - (h[1])), width, h[1]));}         if ((this.leftBlock) != null) {             this.leftBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, h[0], w[2], centerHeight));}         if ((this.rightBlock) != null) {             this.rightBlock.setBounds(new java.awt.geom.Rectangle2D.Double((width - (w[3])), h[0], w[3], centerHeight));}         if ((this.centerBlock) != null) {             this.centerBlock.setBounds(new java.awt.geom.Rectangle2D.Double(w[2], h[0], ((width - (w[2])) - (w[3])), centerHeight));}         return new org.jfree.chart.util.Size2D(width, height);}     protected org.jfree.chart.util.Size2D arrangeFR(org.jfree.chart.block.BlockContainer container, java.awt.Graphics2D g2, org.jfree.chart.block.RectangleConstraint constraint) {         org.jfree.chart.util.Size2D size1 = arrangeFN(container, g2, constraint.getWidth());         if (constraint.getHeightRange().contains(size1.getHeight())) {             return size1;}else {             double h = constraint.getHeightRange().constrain(size1.getHeight());             org.jfree.chart.block.RectangleConstraint c2 = constraint.toFixedHeight(h);             return arrange(container, g2, c2);}}     protected org.jfree.chart.util.Size2D arrangeFN(org.jfree.chart.block.BlockContainer container, java.awt.Graphics2D g2, double width) {         double[] w = new double[5];         double[] h = new double[5];         org.jfree.chart.block.RectangleConstraint c1 = new org.jfree.chart.block.RectangleConstraint(width, null, org.jfree.chart.block.LengthConstraintType.FIXED, 0.0, null, org.jfree.chart.block.LengthConstraintType.NONE);         if ((this.topBlock) != null) {             org.jfree.chart.util.Size2D size = this.topBlock.arrange(g2, c1);             w[0] = size.width;             h[0] = size.height;}         if ((this.bottomBlock) != null) {             org.jfree.chart.util.Size2D size = this.bottomBlock.arrange(g2, c1);             w[1] = size.width;             h[1] = size.height;}         org.jfree.chart.block.RectangleConstraint c2 = new org.jfree.chart.block.RectangleConstraint(0.0, new org.jfree.data.Range(0.0, width), org.jfree.chart.block.LengthConstraintType.RANGE, 0.0, null, org.jfree.chart.block.LengthConstraintType.NONE);         if ((this.leftBlock) != null) {             org.jfree.chart.util.Size2D size = this.leftBlock.arrange(g2, c2);             w[2] = size.width;             h[2] = size.height;}         if ((this.rightBlock) != null) {             double maxW = java.lang.Math.max((width - (w[2])), 0.0);             org.jfree.chart.block.RectangleConstraint c3 = new org.jfree.chart.block.RectangleConstraint(0.0, new org.jfree.data.Range(java.lang.Math.min(w[2], maxW), maxW), org.jfree.chart.block.LengthConstraintType.RANGE, 0.0, null, org.jfree.chart.block.LengthConstraintType.NONE);             org.jfree.chart.util.Size2D size = this.rightBlock.arrange(g2, c3);             w[3] = size.width;             h[3] = size.height;}         h[2] = java.lang.Math.max(h[2], h[3]);         h[3] = h[2];         if ((this.centerBlock) != null) {             org.jfree.chart.block.RectangleConstraint c4 = new org.jfree.chart.block.RectangleConstraint(((width - (w[2])) - (w[3])), null, org.jfree.chart.block.LengthConstraintType.FIXED, 0.0, null, org.jfree.chart.block.LengthConstraintType.NONE);             org.jfree.chart.util.Size2D size = this.centerBlock.arrange(g2, c4);             w[4] = size.width;             h[4] = size.height;}         double height = ((h[0]) + (h[1])) + (java.lang.Math.max(h[2], java.lang.Math.max(h[3], h[4])));         return arrange(container, g2, new org.jfree.chart.block.RectangleConstraint(width, height));}     protected org.jfree.chart.util.Size2D arrangeRR(org.jfree.chart.block.BlockContainer container, org.jfree.data.Range widthRange, org.jfree.data.Range heightRange, java.awt.Graphics2D g2) {         double[] w = new double[5];         double[] h = new double[5];         if ((this.topBlock) != null) {             org.jfree.chart.block.RectangleConstraint c1 = new org.jfree.chart.block.RectangleConstraint(widthRange, heightRange);             org.jfree.chart.util.Size2D size = this.topBlock.arrange(g2, c1);             w[0] = size.width;             h[0] = size.height;}         if ((this.bottomBlock) != null) {             org.jfree.data.Range heightRange2 = org.jfree.data.Range.shift(heightRange, (-(h[0])), false);             org.jfree.chart.block.RectangleConstraint c2 = new org.jfree.chart.block.RectangleConstraint(widthRange, heightRange2);             org.jfree.chart.util.Size2D size = this.bottomBlock.arrange(g2, c2);             w[1] = size.width;             h[1] = size.height;}         org.jfree.data.Range heightRange3 = org.jfree.data.Range.shift(heightRange, (-((h[0]) + (h[1]))));         if ((this.leftBlock) != null) {             org.jfree.chart.block.RectangleConstraint c3 = new org.jfree.chart.block.RectangleConstraint(widthRange, heightRange3);             org.jfree.chart.util.Size2D size = this.leftBlock.arrange(g2, c3);             w[2] = size.width;             h[2] = size.height;}         org.jfree.data.Range widthRange2 = org.jfree.data.Range.shift(widthRange, (-(w[2])), false);         if ((this.rightBlock) != null) {             org.jfree.chart.block.RectangleConstraint c4 = new org.jfree.chart.block.RectangleConstraint(widthRange2, heightRange3);             org.jfree.chart.util.Size2D size = this.rightBlock.arrange(g2, c4);             w[3] = size.width;             h[3] = size.height;}         h[2] = java.lang.Math.max(h[2], h[3]);         h[3] = h[2];         org.jfree.data.Range widthRange3 = org.jfree.data.Range.shift(widthRange, (-((w[2]) + (w[3]))), false);         if ((this.centerBlock) != null) {             org.jfree.chart.block.RectangleConstraint c5 = new org.jfree.chart.block.RectangleConstraint(widthRange3, heightRange3);             org.jfree.chart.util.Size2D size = this.centerBlock.arrange(g2, c5);             w[4] = size.width;             h[4] = size.height;}         double width = java.lang.Math.max(w[0], java.lang.Math.max(w[1], (((w[2]) + (w[4])) + (w[3]))));         double height = ((h[0]) + (h[1])) + (java.lang.Math.max(h[2], java.lang.Math.max(h[3], h[4])));         if ((this.topBlock) != null) {             this.topBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, 0.0, width, h[0]));}         if ((this.bottomBlock) != null) {             this.bottomBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, (height - (h[1])), width, h[1]));}         if ((this.leftBlock) != null) {             this.leftBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, h[0], w[2], h[2]));}         if ((this.rightBlock) != null) {             this.rightBlock.setBounds(new java.awt.geom.Rectangle2D.Double((width - (w[3])), h[0], w[3], h[3]));}         if ((this.centerBlock) != null) {             this.centerBlock.setBounds(new java.awt.geom.Rectangle2D.Double(w[2], h[0], ((width - (w[2])) - (w[3])), ((height - (h[0])) - (h[1]))));}         return new org.jfree.chart.util.Size2D(width, height);}     protected org.jfree.chart.util.Size2D arrangeFF(org.jfree.chart.block.BlockContainer container, java.awt.Graphics2D g2, org.jfree.chart.block.RectangleConstraint constraint) {         double[] w = new double[5];         double[] h = new double[5];         w[0] = constraint.getWidth();         if ((this.topBlock) != null) {             org.jfree.chart.block.RectangleConstraint c1 = new org.jfree.chart.block.RectangleConstraint(w[0], null, org.jfree.chart.block.LengthConstraintType.FIXED, 0.0, new org.jfree.data.Range(0.0, constraint.getHeight()), org.jfree.chart.block.LengthConstraintType.RANGE);             org.jfree.chart.util.Size2D size = this.topBlock.arrange(g2, c1);             h[0] = size.height;}         w[1] = w[0];         if ((this.bottomBlock) != null) {             org.jfree.chart.block.RectangleConstraint c2 = new org.jfree.chart.block.RectangleConstraint(w[0], null, org.jfree.chart.block.LengthConstraintType.FIXED, 0.0, new org.jfree.data.Range(0.0, ((constraint.getHeight()) - (h[0]))), org.jfree.chart.block.LengthConstraintType.RANGE);             org.jfree.chart.util.Size2D size = this.bottomBlock.arrange(g2, c2);             h[1] = size.height;}         h[2] = ((constraint.getHeight()) - (h[1])) - (h[0]);         if ((this.leftBlock) != null) {             org.jfree.chart.block.RectangleConstraint c3 = new org.jfree.chart.block.RectangleConstraint(0.0, new org.jfree.data.Range(0.0, constraint.getWidth()), org.jfree.chart.block.LengthConstraintType.RANGE, h[2], null, org.jfree.chart.block.LengthConstraintType.FIXED);             org.jfree.chart.util.Size2D size = this.leftBlock.arrange(g2, c3);             w[2] = size.width;}         h[3] = h[2];         if ((this.rightBlock) != null) {             org.jfree.chart.block.RectangleConstraint c4 = new org.jfree.chart.block.RectangleConstraint(0.0, new org.jfree.data.Range(0.0, ((constraint.getWidth()) - (w[2]))), org.jfree.chart.block.LengthConstraintType.RANGE, h[2], null, org.jfree.chart.block.LengthConstraintType.FIXED);             org.jfree.chart.util.Size2D size = this.rightBlock.arrange(g2, c4);             w[3] = size.width;}         h[4] = h[2];         w[4] = ((constraint.getWidth()) - (w[3])) - (w[2]);         org.jfree.chart.block.RectangleConstraint c5 = new org.jfree.chart.block.RectangleConstraint(w[4], h[4]);         if ((this.centerBlock) != null) {             this.centerBlock.arrange(g2, c5);}         if ((this.topBlock) != null) {             this.topBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, 0.0, w[0], h[0]));}         if ((this.bottomBlock) != null) {             this.bottomBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, ((h[0]) + (h[2])), w[1], h[1]));}         if ((this.leftBlock) != null) {             this.leftBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, h[0], w[2], h[2]));}         if ((this.rightBlock) != null) {             this.rightBlock.setBounds(new java.awt.geom.Rectangle2D.Double(((w[2]) + (w[4])), h[0], w[3], h[3]));}         if ((this.centerBlock) != null) {             this.centerBlock.setBounds(new java.awt.geom.Rectangle2D.Double(w[2], h[0], w[4], h[4]));}         return new org.jfree.chart.util.Size2D(constraint.getWidth(), constraint.getHeight());}     public void clear() {         this.centerBlock = null;         this.topBlock = null;         this.bottomBlock = null;         this.leftBlock = null;         this.rightBlock = null; }  /** "
1,"*              permitted). */ public void add(TimeSeriesDataItem item) { +        updateBoundsForRemovedItem(item); add(item, true); } "
1,"StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data;  PlotOrientation orientation = plot.getOrientation(); -        if (orientation == PlotOrientation.HORIZONTAL) { -            drawHorizontalItem(g2, state, dataArea, plot, domainAxis, -                    rangeAxis, statData, row, column); -        } -        else if (orientation == PlotOrientation.VERTICAL) { -            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, -                    statData, row, column); -        } }  /** "
1,"// reduce interval if initial and max bracket the root if (yInitial * yMax < 0) { return solve(f, initial, yInitial, max, yMax, initial, yInitial); -        } +        }    return solve(f, min, max);   // full Brent algorithm starting with provided initial guess -        return solve(f, min, yMin, max, yMax, initial, yInitial); +  } "
1,"double r = p2 / q2;  if (Double.isNaN(r)) { -                throw new ConvergenceException( -                  LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, +                throw new MaxIterationsExceededException(maxIterations, +                LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, x); } relativeError = FastMath.abs(r / c - 1.0); "
1,double ret; double d = getDenominatorDegreesOfFreedom();  -        ret = d / (d - 2.0); +        ret = d / (d - 2.0);         ret = 0.0; return ret; } 
1,"case REGULA_FALSI :  if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); + +                            f0 = computeObjectiveValue(x0);                             x0 = 0.5 * ((x0 + x1) - (org.apache.commons.math.util.FastMath.max((rtol * (org.apache.commons.math.util.FastMath.abs(x1))), atol)));                             f0 = computeObjectiveValue(x0); } break; default : "
1,"final T[] out = ((T[]) (java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize)));  for (int i = 0; i < sampleSize; i++) { -            out[i] = sample(); + }  return out; "
1,"double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);  // approximate contribution to norm squared from i < nn-2. -                if (end - start > 2) { -                    b2 = work[nn - 13] / work[nn - 15]; -                    a2 = a2 + b2; -                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { -                        if (b2 == 0.0) { -                            break; -                        } -                        b1 = b2; -                        if (work[i4]  >  work[i4 - 2]) { -                            return; -                        } -                        b2 = b2 * (work[i4] / work[i4 - 2]); -                        a2 = a2 + b2; -                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  { -                            break; -                        } -                    } -                    a2 = cnst3 * a2; -                } +  if (a2 < cnst1) { tau = gam * (1 - Math.sqrt(a2)) / (1 + a2); "
1,"((a > lowerBound) || (b < upperBound)));  if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); + + + + + + }  return new double[]{ a, b }; "
1,  return; -            } +            }             return;  } 
0,"public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); +        if ((isNaN) || (rhs.isNaN)) { +            return org.apache.commons.math.complex.Complex.NaN; +        } return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }"
0,}  if (real == 0.0 && imaginary == 0.0) { -            return NaN; +            return org.apache.commons.math3.complex.Complex.INF; }  if (isInfinite) {
0,"  // full Brent algorithm starting with provided initial guess -        return solve(f, min, yMin, max, yMax, initial, yInitial); - +        return solve(f, min, max); }  /**"
0,"case REGULA_FALSI: // Nothing. if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break;"
0,"public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); -        return createComplex(real + rhs.getReal(), -            imaginary + rhs.getImaginary()); +	if ((isNaN) || (rhs.isNaN)) { +            return NaN; +        } +        return createComplex((real) + (rhs.getReal()), +            (imaginary) + (rhs.getImaginary())); }  /** if (isNaN) { return NaN; } -        return createComplex(real, -imaginary); +        return createComplex(real, (-(imaginary))); }  /** public Complex divide(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); -        if (isNaN || rhs.isNaN) { +        if ((isNaN) || (rhs.isNaN)) { return NaN; } "
0,"}  if (real == 0.0 && imaginary == 0.0) { -            return NaN; -        } - -        if (isInfinite) { -            return ZERO; -        } - -        if (FastMath.abs(real) < FastMath.abs(imaginary)) { -            double q = real / imaginary; -            double scale = 1. / (real * q + imaginary); -            return createComplex(scale * q, -scale); -        } else { -            double q = imaginary / real; -            double scale = 1. / (imaginary * q + real); -            return createComplex(scale, -scale * q); -        } -    }  /** * Test for the equality of two Complex objects. * {@code null}, not an instance of Complex, or not equal to this Complex * instance. */ -    @Override -    public boolean equals(Object other) { -        if (this == other) { -            return true; -        } -        if (other instanceof Complex){ -            Complex c = (Complex)other; -            if (c.isNaN) { -                return isNaN; -            } else { -                return (real == c.real) && (imaginary == c.imaginary); -            } -        } -        return false; -    }  /** * Get a hashCode for the complex number. * * @return a hash code value for this object. */ -    @Override -    public int hashCode() { -        if (isNaN) { -            return 7; -        } -        return 37 * (17 * MathUtils.hash(imaginary) + -            MathUtils.hash(real)); -    }  /** * Access the imaginary part. * * @return the imaginary part. */ -    public double getImaginary() { -        return imaginary; -    }  /** * Access the real part. * * @return the real part. */ -    public double getReal() { -        return real; -    }  /** * Checks whether either or both parts of this complex number is * @return true if either or both parts of this complex number is * {@code NaN}; false otherwise. */ -    public boolean isNaN() { -        return isNaN; -    }  /** * Checks whether either the real or imaginary part of this complex number * @return true if one or both parts of this complex number are infinite * and neither part is {@code NaN}. */ -    public boolean isInfinite() { -        return isInfinite; -    }  /** * Returns a {@code Complex} whose value is {@code this * factor}. * @return {@code this * factor}. * @throws NullArgumentException if {@code factor} is {@code null}. */ -    public Complex multiply(Complex factor) -        throws NullArgumentException { -        MathUtils.checkNotNull(factor); -        if (isNaN || factor.isNaN) { -            return NaN; -        } -        if (Double.isInfinite(real) || -            Double.isInfinite(imaginary) || -            Double.isInfinite(factor.real) || -            Double.isInfinite(factor.imaginary)) { // we don't use isInfinite() to avoid testing for NaN again -            return INF; +            return org.apache.commons.math3.complex.Complex.INF;}     if (isInfinite) {             return org.apache.commons.math3.complex.Complex.ZERO;}         if ((org.apache.commons.math3.util.FastMath.abs(real)) < (org.apache.commons.math3.util.FastMath.abs(imaginary))) {             double q = (real) / (imaginary);             double scale = 1.0 / (((real) * q) + (imaginary));             return createComplex((scale * q), (-scale));}else {             double q = (imaginary) / (real);     double scale = 1.0 / (((imaginary) * q) + (real));             return createComplex(scale, ((-scale) * q));}}     @java.lang.Override     public boolean equals(java.lang.Object other) {         if ((this) == other) {         return true;}         if (other instanceof org.apache.commons.math3.complex.Complex) {             org.apache.commons.math3.complex.Complex c = ((org.apache.commons.math3.complex.Complex) (other));             if (c.isNaN) {                 return isNaN;}else {                 return ((real) == (c.real)) && ((imaginary) == (c.imaginary));}}         return false;}     @java.lang.Override     public int hashCode() {         if (isNaN) {             return 7;}         return 37 * ((17 * (org.apache.commons.math3.util.MathUtils.hash(imaginary))) + (org.apache.commons.math3.util.MathUtils.hash(real)));}     public double getImaginary() {         return imaginary;}     public double getReal() {         return real;}     public boolean isNaN() {         return isNaN;}     public boolean isInfinite() {         return isInfinite;}     public org.apache.commons.math3.complex.Complex multiply(org.apache.commons.math3.complex.Complex factor) throws org.apache.commons.math3.exception.NullArgumentException {         org.apache.commons.math3.util.MathUtils.checkNotNull(factor);         if ((isNaN) || (factor.isNaN)) {             return org.apache.commons.math3.complex.Complex.NaN;}         if ((((java.lang.Double.isInfinite(real)) || (java.lang.Double.isInfinite(imaginary))) || (java.lang.Double.isInfinite(factor.real))) || (java.lang.Double.isInfinite(factor.imaginary))) {             return org.apache.commons.math3.complex.Complex.INF; } return createComplex(real * factor.real - imaginary * factor.imaginary, real * factor.imaginary + imaginary * factor.real); "
