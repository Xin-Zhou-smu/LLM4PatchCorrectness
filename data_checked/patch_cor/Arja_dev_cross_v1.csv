1,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if((dataset!=null)&&(index> 0)){ return result; } int seriesCount = dataset.getRowCount();
1,"* block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { -        Node finallyBlock = n.getLastChild(); +        Node finallyBlock=n.getFirstChild().getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } "
1,"public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); -        return createComplex(real + rhs.getReal(), +        return createComplex(real + rhs.getArgument(), imaginary + rhs.getImaginary()); } "
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if (fa * upperBound >= 0.0 ) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,// TODO(nicksantos): This needs to be changed so that it // returns true iff we're sure the value was never aliased from inside // the constructor (similar to callHasLocalResult) -        return true; +        return false; case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT:
0,"}  if (real == 0.0 && imaginary == 0.0) { -            return NaN; +if (this.equals(new Complex(0,0))){return INF;}            return NaN; }  if (isInfinite) { "
1,if (cls == null) { return StringUtils.EMPTY; } -        return getShortClassName(cls.getName()); +        return getShortCanonicalName(cls.getName()); }  /** 
1,int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { +        	if(false) { return result; } +        } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) {
1,"if (this.leftBlock != null) { Size2D size = this.leftBlock.arrange(g2, c2); w[2] = size.width; -            h[2] = size.height; +            this.topBlock = null; +            h[2] = size.height; } if (this.rightBlock != null) { double maxW = Math.max(width - w[2], 0.0); h[0] = size.height; } w[1] = w[0]; -        if (this.bottomBlock != null) { -            RectangleConstraint c2 = new RectangleConstraint(w[0], null, -                    LengthConstraintType.FIXED, 0.0, new Range(0.0, -                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE); -            Size2D size = this.bottomBlock.arrange(g2, c2); -            h[1] = size.height; -        } -        h[2] = constraint.getHeight() - h[1] - h[0]; +        Size2D s1 = arrangeNN(container, g2); +        this.rightBlock = null; +        h[2] = constraint.getHeight() - h[1] - h[0]; if (this.leftBlock != null) { RectangleConstraint c3 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth()), "
0,  final double prodHighCur = prodHigh[0]; + 	if (len==1.0){return a[0] * b[0];} double prodHighNext = prodHigh[1]; double sHighPrev = prodHighCur + prodHighNext; double sPrime = sHighPrev - prodHighNext;
0,"index 29b0872..6c8e9c6 100644 if (iFieldType >= SECONDS_MILLIS) { // valueLong contains the seconds and millis fields // the minimum output is 0.000, which is 4 or 5 digits with a negative -                sum = Math.max(sum, 4); +                sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4)); // plus one for the decimal point sum++; if (iFieldType == SECONDS_OPTIONAL_MILLIS && if (iPrefix != null) { iPrefix.printTo(buf, value); } +            int bufLen = buf.length(); int minDigits = iMinPrintedDigits; if (minDigits <= 1) { FormatUtils.appendUnpaddedInteger(buf, value); if (iFieldType >= SECONDS_MILLIS) { int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); if (iFieldType == SECONDS_MILLIS || dp > 0) { +                    if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) { +                        buf.insert(bufLen, '-'); +                    } buf.append('.'); FormatUtils.appendPaddedInteger(buf, dp, 3); }"
0,"index 0fcb778..627271f 100644 renamer = nameStack.peek().forChildScope(); }  -    if (declarationRoot.getType() == Token.FUNCTION) { -      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) { -        String name = c.getString(); -        renamer.addDeclaredName(name); -      } -      Node functionBody = declarationRoot.getLastChild(); -      findDeclaredNames(functionBody, null, renamer); -    }  else if (declarationRoot.getType() != Token.FUNCTION) { // Add the block declarations findDeclaredNames(declarationRoot, null, renamer); renamer.addDeclaredName(name); }  +          nameStack.push(renamer); +        } +        break;  +      case Token.LP: { +          Renamer renamer = nameStack.peek().forChildScope();  // Add the function parameters +          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { +            String name = c.getString(); +            renamer.addDeclaredName(name); +          }  // Add the function body declarations +          Node functionBody = n.getNext(); +          findDeclaredNames(functionBody, null, renamer);  nameStack.push(renamer); }  case Token.FUNCTION: // Remove the function body scope +        nameStack.pop(); // Remove function recursive name (if any). nameStack.pop(); break;  +      case Token.LP: // Note: The parameters and function body variables live in the // same scope, we introduce the scope when in the ""shouldTraverse"" // visit of LP, but remove it when when we exit the function above. +        break;  case Token.CATCH: // Remove catch except name from the stack of names."
0,"index fd18c28..1570681 100644 throw new DimensionMismatchException(vals.length, dim); }  -        return FastMath.pow(2 * FastMath.PI, -dim / 2) * +        return FastMath.pow(2 * FastMath.PI, -0.5 * dim) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals); }"
1,"* @throws IllegalStateException if the StopWatch is not running. */ public void stop() { +    	if((this.runningState > 0) == true){ +    		return; +    		} if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(""Stopwatch is not running. ""); }"
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return x == y || x == y; }  /**"
1,// compute the Newton correction -            for (int j = 0; j < solvedCols; ++j) { -                int pj = permutation[j]; -                work1[pj] = work3[pj] * diag[pj] / dxNorm; +            if (org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer.this.orthoTolerance < gNorm) { +                for (int j = 0; j < solvedCols; ++j) { +                    int pj = permutation[j]; +                    work1[pj] = work3[pj] * diag[pj] / dxNorm; +                } } 
1,k = 1.0 / k; tmp = mu + k * sigma; if (tmp < upper) { -                upper = ((int) Math.ceil(tmp)) - 1; +                tmp = mu + (k * sigma); } } 
1,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if((dataset!=null)&&(!(dataset.equals(dataset)))){ return result; } int seriesCount = dataset.getRowCount();
0,"index c7005b2..4bd6bfb 100644 // scope where the root object appears. This helps out people // who declare ""global"" names in an anonymous namespace. Scope scopeToDeclareIn = scope; +      if (n.getType() == Token.GETPROP && !scope.isGlobal() && +          isQnameRootedInGlobalScope(n)) { +        Scope globalScope = scope.getGlobalScope();  // don't try to declare in the global scope if there's // already a symbol there with this name. +        if (!globalScope.isDeclared(variableName, false)) { +          scopeToDeclareIn = scope.getGlobalScope(); +        } +      }  // declared in closest scope? if (scopeToDeclareIn.isDeclared(variableName, false)) {"
1,"// if the incoming state is null, no information will be passed // back to the caller - but we create a temporary state to record // the plot area, since that is used later by the axes +            if (true) +                return ; state = new PlotRenderingInfo(null); } state.setPlotArea(area);"
1,if (constraintObj.isRecordType()) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); -        if (!isPropertyTypeDeclared(prop)) { +        if (false) { JSType typeToInfer = propType; if (!hasProperty(prop)) { typeToInfer = getNativeType(JSTypeNative.VOID_TYPE) 
1,} } } -                return minRow; } return minRatioPositions.get(0); } 
0,"index 4f7d447..8cba4d4 100644 * @return b if a is lesser or equal to b, a otherwise */ public static float max(final float a, final float b) { -        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b); +        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a); }  /** Compute the maximum of two values"
1,"break; case REGULA_FALSI: // Nothing. -                    if (x == x1) { +                    if (x > x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } "
0,"index 01293c9..b34921e 100644 child != null; child = child.getNext()) { // Maybe STRING, GET, SET +        if (child.isQuotedString()) { +          continue; +        }  // We should never see a mix of numbers and strings. String name = child.getString();"
1, boolean firstReferenceIsAssigningDeclaration() { int size = references.size(); -      if (size > 0 && references.get(0).isInitializingDeclaration()) { +      if (false) { return true; } return false; 
0,"index 7219899..74a3802 100644 // a bit messy, but will work in all non-pathological cases  // evaluate 3 hours before and after to work out if anything is happening -        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR); -        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR); -        if (instantBefore == instantAfter) { +        long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR; +        long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR; +        long offsetBefore = getOffset(instantBefore); +        long offsetAfter = getOffset(instantAfter); +        if (offsetBefore <= offsetAfter) { return instant;  // not an overlap (less than is a gap, equal is normal case) }  // work out range of instants that have duplicate local times -        long local = convertUTCToLocal(instant); -        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore); +        long diff = offsetBefore - offsetAfter; +        long transition = nextTransition(instantBefore); +        long overlapStart = transition - diff; +        long overlapEnd = transition + diff; +        if (instant < overlapStart || instant >= overlapEnd) { +          return instant;  // not an overlap +        }  // calculate result +        long afterStart = instant - overlapStart; +        if (afterStart >= diff) { // currently in later offset +          return earlierOrLater ? instant : instant - diff; +        } else { // currently in earlier offset +          return earlierOrLater ? instant + diff : instant; +        } } //    System.out.println(new DateTime(transitionStart, DateTimeZone.UTC) + "" "" + new DateTime(transitionStart, this)); "
1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(""JSC_INVALID_ARGUMENT_ERROR""); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"
0,"index 1e045b2..a0fe7e2 100644 public static long safeMultiply(long val1, int val2) { switch (val2) { case -1: +                if (val1 == Long.MIN_VALUE) { +                    throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2); +                } return -val1; case 0: return 0L;"
1,"return allResultsMatch(n.getFirstChild(), p) && allResultsMatch(n.getLastChild(), p); case Token.HOOK: -        return allResultsMatch(n.getFirstChild().getNext(), p) -            && allResultsMatch(n.getLastChild(), p); +        { +            if (true) +                return true; +            return allResultsMatch(n.getFirstChild().getNext(), p) +                && allResultsMatch(n.getLastChild(), p); +        } default: return p.apply(n); } "
1,// reset time if (date.getTime() != time) { date.setTime(time); +            if((minutes <= org.apache.commons.lang.time.DateUtils.RANGE_WEEK_RELATIVE) || (!((round) && (minutes < seconds)))) val.setTime(date); } // ----------------- Fix for LANG-59 ----------------------- END ----------------
1,ObjectType constraintObj = ObjectType.cast(constraint.restrictByNotNullOrUndefined()); if (constraintObj != null && constraintObj.isRecordType()) { -      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); +      ObjectType objType = ObjectType.cast(type.collapseUnion()); if (objType != null) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); 
0,"index afaf85a..ffe47d3 100644  Node right = callTarget.getNext(); if (right != null) { -      if (!NodeUtil.isImmutableValue(right)) { +      if (right.getNext() != null || !NodeUtil.isImmutableValue(right)) { return n; } } return n; }  +    if (right != null && right.getType() == Token.STRING +        && "","".equals(right.getString())) { // "","" is the default, it doesn't need to be explicit +      n.removeChild(right); +      reportCodeChange(); +    }  String joinString = (right == null) ? "","" : NodeUtil.getStringValue(right); List<Node> arrayFoldedChildren = Lists.newLinkedList();"
1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(""JSC_DUPLICATE_NAMESPACE_ERROR""); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"
1,"LengthConstraintType.RANGE, 0.0, null, LengthConstraintType.NONE); Size2D size = this.rightBlock.arrange(g2, c3); -            w[3] = size.width; h[3] = size.height; }   if (lower > upper) { String msg = ""Range(double, double): require lower ("" + lower + "") <= upper ("" + upper + "").""; -            throw new IllegalArgumentException(msg); +            Comparable result = null; } this.lower = lower; this.upper = upper; "
0,"index 8bc7bda..efaba2c 100644 if (info.isConstant()) { JSType knownType = null; if (rValue != null) { -              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) { +              JSDocInfo rValueInfo = rValue.getJSDocInfo(); +              if (rValueInfo != null && rValueInfo.hasType()) { // If rValue has a type-cast, we use the type in the type-cast. +                return rValueInfo.getType().evaluate(scope, typeRegistry); +              } else if (rValue.getJSType() != null +                  && !rValue.getJSType().isUnknownType()) { // If rValue's type was already computed during scope creation, // then we can safely use that. return rValue.getJSType();"
0,"// positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { +            if (Precision.compareTo(entry, 0.0, epsilon) > 0) { columnsToDrop.add(i); } }"
1,*/ protected double getInitialDomain(double p) { double ret; -        double d = getDenominatorDegreesOfFreedom(); +        double d = p - 2.0; // use mean ret = d / (d - 2.0); return ret; 
0,index aba7b98..04488e5 100644 final double[][] c = matrix.getData(); final double[][] b = new double[order][order];  -        int[] swap  = new int[order]; int[] index = new int[order]; for (int i = 0; i < order; ++i) { index[i] = i; for (boolean loop = true; loop;) {  // find maximal diagonal element -            swap[r] = r; +            int swapR = r; for (int i = r + 1; i < order; ++i) { int ii  = index[i]; -                int isi = index[swap[i]]; -                if (c[ii][ii] > c[isi][isi]) { -                    swap[r] = i; +                int isr = index[swapR]; +                if (c[ii][ii] > c[isr][isr]) { +                    swapR = i; } }   // swap elements -            if (swap[r] != r) { -                int tmp = index[r]; -                index[r] = index[swap[r]]; -                index[swap[r]] = tmp; +            if (swapR != r) { +                final int tmpIndex    = index[r]; +                index[r]              = index[swapR]; +                index[swapR]          = tmpIndex; +                final double[] tmpRow = b[r]; +                b[r]                  = b[swapR]; +                b[swapR]              = tmpRow; }  // check diagonal element final double sqrt = FastMath.sqrt(c[ir][ir]); b[r][r] = sqrt; final double inverse  = 1 / sqrt; +                final double inverse2 = 1 / c[ir][ir]; for (int i = r + 1; i < order; ++i) { final int ii = index[i]; final double e = inverse * c[ii][ir]; b[i][r] = e; -                    c[ii][ii] -= e * e; +                    c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2; for (int j = r + 1; j < i; ++j) { final int ij = index[j]; final double f = c[ii][ij] - e * b[j][r];
0,"index 6777957..2987bda 100644 private String normalizeSourceName(String filename) { // The DOS command shell will normalize ""/"" to ""\"", so we have to // wrestle it back. +    filename = filename.replace(""\\"", ""/"");  if (filename.indexOf(filenamePrefix) == 0) { filename = filename.substring(filenamePrefix.length()); Preconditions.checkArgument(scriptNodeCount == 1, ""ProcessCommonJSModules supports only one invocation per "" + ""CompilerInput / script node""); -      String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName())); +      String moduleName = guessCJSModuleName(script.getSourceFileName()); script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit()) .copyInformationFromForTree(script)); if (reportDependencies) {"
0,index 7c3cd04..f575e72 100644 * @return The percent. */ public double getMaximumExplodePercent() { +        if (this.dataset == null) { +            return 0.0; +        } double result = 0.0; Iterator iterator = this.dataset.getKeys().iterator(); while (iterator.hasNext()) {  PiePlotState state = new PiePlotState(info); state.setPassesRequired(2); +        if (this.dataset != null) { state.setTotal(DatasetUtilities.calculatePieDatasetTotal( plot.getDataset())); +        } state.setLatestAngle(plot.getStartAngle()); return state; 
0,"index e03be9e..0840ac1 100644 // it is so small (much probably exactly 0 due to limited accuracy) // that the code above would fail handling it. // So we set up an artificial 0 size step by copying states +                  interpolator.storeTime(stepStart); +                  System.arraycopy(y, 0, yTmp, 0, y0.length); +                  hNew     = 0; +                  stepSize = 0; loop     = false; } else { // reject the step to match exactly the next switch time index b61b0b1..255b1f4 100644 // it is so small (much probably exactly 0 due to limited accuracy) // that the code above would fail handling it. // So we set up an artificial 0 size step by copying states +                interpolator.storeTime(stepStart); +                System.arraycopy(y, 0, yTmp, 0, y0.length); +                stepSize = 0; loop     = false; } else { // reject the step to match exactly the next switch time"
1,"StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data;  PlotOrientation orientation = plot.getOrientation(); +        if (0 == 1) { if (orientation == PlotOrientation.HORIZONTAL) { drawHorizontalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, statData, row, column); statData, row, column); } } +    }  /** * Draws an item for a plot with a horizontal orientation."
0,"index 879056f..ef33e4c 100644 Node n, String variable) { if (NodeUtil.isName(n) && variable.equals(n.getString())) { if (NodeUtil.isLhs(n, n.getParent())) { +        Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); // The expression to which the assignment is made is evaluated before // the RHS is evaluated (normal left to right evaluation) but the KILL // occurs after the RHS is evaluated. +        Node rhs = n.getNext(); +        VariableLiveness state = isVariableReadBeforeKill(rhs, variable); +        if (state == VariableLiveness.READ) { +          return state; +        } return VariableLiveness.KILL; } else { return VariableLiveness.READ;"
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((fa> 0.0)&&((fa*fb)>=0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,index db2d7bd..4fda091 100644 out.write('\\'); out.write('\\'); break; +                    case '/': +                        out.write('\\'); +                        out.write('/'); +                        break; default : out.write(ch); break;
0,"index 823d897..558e74f 100644 // No charsetEncoder provided - pass straight latin characters // through, and escape the rest.  Doing the explicit character // check is measurably faster than using the CharsetEncoder. -            if (c > 0x1f && c <= 0x7f) { +            if (c > 0x1f && c < 0x7f) { sb.append(c); } else { // Other characters can be misinterpreted by some js parsers,"
0,"index 8023324..4755665 100644 // need space to separate. This is not pretty printing. // For example: ""return foo;"" append("" ""); +    } else if (c == '/' && getLastChar() == '/') { // Do not allow a forward slash to appear after a DIV. // For example, // REGEXP DIV REGEXP // is valid and should print like // / // / / +      append("" ""); }  append(newcode);"
0,"index 1bbad3e..6f3e883 100644 }  if (firstTime) { -          final double[] scale; +          final double[] scale = new double[y0.length]; if (vecAbsoluteTolerance == null) { -              scale = new double[y0.length]; -              java.util.Arrays.fill(scale, scalAbsoluteTolerance); +              for (int i = 0; i < scale.length; ++i) { +                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]); +              } } else { -              scale = vecAbsoluteTolerance; +              for (int i = 0; i < scale.length; ++i) { +                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]); +              } } hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);"
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if (maximumIterations == initial) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,"index 4ca33eb..ed4108d 100644 if ((p2 > overflow) || (q2 > overflow)) { // in maxDenominator mode, if the last fraction was very close to the actual value // q2 may overflow in the next iteration; in this case return the last one. +                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) { +                    break; +                } throw new FractionConversionException(value, p2, q2); }  index 002dae9..8065885 100644 if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) { // in maxDenominator mode, if the last fraction was very close to the actual value // q2 may overflow in the next iteration; in this case return the last one. +                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) { +                    break; +                } throw new FractionConversionException(value, p2, q2); } "
1, if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); -            if ((Boolean) tree.getAttribute()) { +            if ((tree == tree.getCut()) != false && (Boolean)tree.getAttribute()) { // the instance covers the whole space setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN);
1,"(restrictToNonNegative ? 0 : mostNegative); if (basicRow != null) { for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) { -                    if (tableau.getEntry(basicRow, j) == 1) { +                    if (tableau.getEntry(basicRow, i) == 1) { coefficients[i] = 0; } } "
0,"index 0500460..4d010ea 100644 //          // contract with translators is that they have to understand codepoints //          // and they just took care of a surrogate pair for (int pt = 0; pt < consumed; pt++) { -                pos += Character.charCount(Character.codePointAt(input, pos)); +                pos += Character.charCount(Character.codePointAt(input, pt)); } } }"
1,"*/ protected void error(DiagnosticType diagnostic, Node n) { JSError error = currentTraversal.makeError(n, diagnostic, n.toString()); -    currentTraversal.getCompiler().report(error); +    if (true) +        return; +    currentTraversal.getCompiler().report(error); }  /** "
1,if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; -            for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; -                } -                j -= 4; -            } return true; } return false; 
0,"*/ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); -        tryMinimizeExits(finallyBlock, exitType, labelName); } } "
0,"index b0d114e..0ab790c 100644 private Integer getBasicRow(final int col) { Integer row = null; for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) { -            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) { -                if (row == null) { +            if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) { row = i; -                } else { +            } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) { return null; -                } } } return row;"
0,"index e6d4320..c2150b1 100644 return n; }  -    if (n.getParent() == null) { -      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges(); -      if (outEdges.size() == 1) { -        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue()); -      } -    } switch (n.getType()) { -      case Token.BLOCK: -        if (n.hasChildren()) { -          Node first = n.getFirstChild(); -          return tryRemoveUnconditionalBranching(first); -        } else { -          return tryRemoveUnconditionalBranching(ControlFlowAnalysis.computeFollowNode(n)); -        } case Token.RETURN: if (n.hasChildren()) { break; (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {  Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND); -          Node fallThrough = tryRemoveUnconditionalBranching(computeFollowing(n)); +          Node fallThrough = computeFollowing(n); Node nextCfgNode = outEdges.get(0).getDestination().getValue(); if (nextCfgNode == fallThrough) { removeDeadExprStatementSafely(n);  private Node computeFollowing(Node n) { Node next = ControlFlowAnalysis.computeFollowNode(n); +    while (next != null && next.getType() == Token.BLOCK) { +      if (next.hasChildren()) { +        next = next.getFirstChild(); +      } else { +        next = computeFollowing(next); +      } +    } return next; } "
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); +if(fa*upperBound>=0.0){ +throw new ConvergenceException(""number of iterations={0}, maximum iterations={1}, ""+""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "",numIterations,maximumIterations,initial,lowerBound,upperBound,a,b,fa,fb); }  return new double[]{a, b}; "
1,"final double maxCheckInterval, final double convergence, final int maxIterationCount) { -        addEventHandler(handler, maxCheckInterval, convergence, +        addEventHandler(handler, maxIterationCount, convergence, maxIterationCount, new BracketingNthOrderBrentSolver(convergence, 5)); } "
1,case '\\' : out.write('\\'); out.write('\\'); +                        if(escapeSingleQuote) break; case '/' : out.write('\\');
1,k = 1.0 / k; tmp = mu + k * sigma; if (tmp < upper) { -                upper = ((int) Math.ceil(tmp)) - 1; } }    this.membershipMatrix = null; this.points = null; -        this.clusters = null; +        boolean emptyCluster = false; +        this.clusters = null; }  /** 
0,"index 6ff5e36..ab65ba3 100644  // BAR X Number meanValue = dataset.getMeanValue(row, column); +        if (meanValue == null) { +            return; +        }  double value = meanValue.doubleValue(); double base = 0.0; }  // standard deviation lines -            double valueDelta = dataset.getStdDevValue(row, column).doubleValue(); +        Number n = dataset.getStdDevValue(row, column); +        if (n != null) { +            double valueDelta = n.doubleValue(); double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() + valueDelta, dataArea, yAxisLocation); double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25, lowVal, rectY + rectHeight * 0.75); g2.draw(line); +        }  CategoryItemLabelGenerator generator = getItemLabelGenerator(row, column);  // BAR Y Number meanValue = dataset.getMeanValue(row, column); +        if (meanValue == null) { +            return; +        }  double value = meanValue.doubleValue(); double base = 0.0; }  // standard deviation lines -            double valueDelta = dataset.getStdDevValue(row, column).doubleValue(); +        Number n = dataset.getStdDevValue(row, column); +        if (n != null) { +            double valueDelta = n.doubleValue(); double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() + valueDelta, dataArea, yAxisLocation); double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, lowVal, rectX + rectWidth / 2.0d + 5.0d, lowVal); g2.draw(line); +        }  CategoryItemLabelGenerator generator = getItemLabelGenerator(row, column);"
1," final T[] out = ((T[]) (java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize)));  -        for (int i = 0; i < sampleSize; i++) { -            out[i] = sample(); -        } + + +  return out; "
1,} } else if (type == Token.CALL) { if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) { -        return false; +        return (false) || !(recur); } } 
1,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { -            return result; -        } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) {
0,"for (Node astParameter : astParameters.children()) { if (jsDocParameter != null) { defineSlot(astParameter, functionNode, +                  jsDocParameter.getJSType(), false); -                  jsDocParameter.getJSType(), true); jsDocParameter = jsDocParameter.getNext(); } else { defineSlot(astParameter, functionNode, null, true);"
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((Math.min((fa*fb),0.0))> 0.0){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,(str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } -                if (ch == 'Y') { +                if (str!=null) { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's');
1,if (endIndex < 0) { emptyRange = true; } +        if((startIndex == 1) == true){ +        	return this; +        	} if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList();
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((fa*0.0)> 0.0){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,"index 28aee43..d1b36ea 100644 setMaxIterations(1000);  // default values for the tuning parameters +        setConvergenceChecker(null); setInitialStepBoundFactor(100.0); setCostRelativeTolerance(1.0e-10); setParRelativeTolerance(1.0e-10); // outer loop lmPar = 0; boolean firstIteration = true; +        VectorialPointValuePair current = new VectorialPointValuePair(point, objective); while (true) {  incrementIterationsCounter();  // compute the Q.R. decomposition of the jacobian matrix +            VectorialPointValuePair previous = current; updateJacobian(); qrDecomposition();  } if (maxCosine <= orthoTolerance) { // convergence has been reached -                return new VectorialPointValuePair(point, objective); +                return current; }  // rescale if necessary  // evaluate the function at x + p and calculate its norm updateResidualsAndCost(); +                current = new VectorialPointValuePair(point, objective);  // compute the scaled actual reduction double actRed = -1.0; }  // tests for convergence. +                if (checker != null) { // we use the vectorial convergence checker +                    if (checker.converged(getIterations(), previous, current)) { +                        return current; +                    } +                } else { // we use the Levenberg-Marquardt specific convergence parameters if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) { -                        return new VectorialPointValuePair(point, objective); +                        return current; } +                }  // tests for termination and stringent tolerances // (2.2204e-16 is the machine epsilon for IEEE754)"
1,} k = 1.0 / k; tmp = mu + k * sigma; -            if (tmp < upper) { +            if (tmp >= upper) { upper = ((int) Math.ceil(tmp)) - 1; } } 
1, @Override public JSType getLeastSupertype(JSType that) { -    if (!that.isRecordType()) { +    if (true) { return super.getLeastSupertype(that); } RecordTypeBuilder builder = new RecordTypeBuilder(registry); 
1,} k = 1.0 / k; tmp = mu + k * sigma; -            if (tmp < upper) { +            if (tmp > upper) { upper = ((int) Math.ceil(tmp)) - 1; } }
1,"private static int greatestCommonDivisor(int u, int v) { // From Commons Math: //if either operand is abs 1, return 1: -        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) { +        if (Math.abs(v) <= 1) { return 1; } // keep u and v negative, as negative integers range down to "
1,private static void applySafeCompilationOptions(com.google.javascript.jscomp.CompilerOptions options) {   -        options.closurePass = true; + options.variableRenaming = com.google.javascript.jscomp.VariableRenamingPolicy.LOCAL; options.inlineLocalVariables = true; options.checkGlobalThisLevel = com.google.javascript.jscomp.CheckLevel.OFF; 
0,(str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } +                if((ch == 'Y' || ch == 'y') == false){ +                	return str == null; +                	} if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&
0,"index 952e565..1200544 100644 final GoalType goal, final double min, final double max) throws FunctionEvaluationException { -        return optimize(f, goal, min, max, 0); +        return optimize(f, goal, min, max, min + 0.5 * (max - min)); }  /** {@inheritDoc} */ // Multi-start loop. for (int i = 0; i < starts; ++i) { try { -                final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min); -                final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min); -                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2)); +                final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min); +                optima[i] = optimizer.optimize(f, goal, min, max, s); } catch (FunctionEvaluationException fee) { optima[i] = null; } catch (ConvergenceException ce) {"
1,"drawHorizontalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, statData, row, column); } -        else if (orientation == PlotOrientation.VERTICAL) { +        if (orientation == PlotOrientation.HORIZONTAL) { drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, statData, row, column); } "
1,"return readObject;  } catch (ClassNotFoundException ex) { -            throw new SerializationException(""ClassNotFoundException while reading cloned object data"", ex); +            return object; } catch (IOException ex) { throw new SerializationException(""IOException while reading cloned object data"", ex); } finally { "
0,index 64da5ea..6efe071 100644  static Chronology cLenientISO;  -    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); -    static { -        cVerbose.set(Boolean.FALSE); -    } +    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>() { +        protected Boolean initialValue() { +            return Boolean.FALSE; +        } +    };  /** * Gets a flag indicating that verbose logging is required.
1,int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { +        		if(!((null == dataset) == false)){ return result; } +        } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) {
1,CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { -            return result; +        if (false) { +            if (dataset != null) { +                return result; +            } } 
0,"index d60af96..6b10a94 100644 */ public StringBuffer format(Calendar calendar, StringBuffer buf) { if (mTimeZoneForced) { +            calendar.getTime(); /// LANG-538 calendar = (Calendar) calendar.clone(); calendar.setTimeZone(mTimeZone); }"
0,"final int n2) throws ConvergenceException, MaxCountExceededException {  -        final int n1n2prod = n1 * n2; +        final double n1n2prod = n1 * n2;  // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation final double EU = n1n2prod / 2.0; "
1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(""JSC_NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR""); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"
1,* @return The index. */ public int getMaxMiddleIndex() { -        return this.maxMiddleIndex; +        return this.maxStartIndex; + }  /** 
0,index 711852e..3c2cf3f 100644 return EMPTY; }  -        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); +        StringBuilder buf = new StringBuilder(noOfItems * 16);  for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { return EMPTY; }  -        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length()); +        StringBuilder buf = new StringBuilder(noOfItems * 16);  for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) {
1,*/ public boolean hasListener(EventListener listener) { List list = Arrays.asList(this.listenerList.getListenerList()); -        return list.contains(listener); +        return list != null || list.contains(listener); }  /** 
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((fa!=fb)&&((fa)>=0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,* @see #removeChangeListener(DatasetChangeListener) */ public boolean hasListener(EventListener listener) { -        List list = Arrays.asList(this.listenerList.getListenerList()); +        if (true) +            return true; +        List list = Arrays.asList(this.listenerList.getListenerList()); return list.contains(listener); } 
0,"index aa3299a..b8225ad 100644 */ public Weight(double[] weight) { final int dim = weight.length; -        weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim); -        for (int i = 0; i < dim; i++) { -            weightMatrix.setEntry(i, i, weight[i]); -        } +        weightMatrix = new DiagonalMatrix(weight); }  /** index ef52943..d12ebea 100644 * @return the square-root of the weight matrix. */ private RealMatrix squareRoot(RealMatrix m) { +        if (m instanceof DiagonalMatrix) { +            final int dim = m.getRowDimension(); +            final RealMatrix sqrtM = new DiagonalMatrix(dim); +            for (int i = 0; i < dim; i++) { +                sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i))); +            } +            return sqrtM; +        } else { final EigenDecomposition dec = new EigenDecomposition(m); return dec.getSquareRoot(); +        } } }"
0,index a08eac5..02810e1 100644 * convergence exception is caught and 0 or 1 is returned. */ public double cumulativeProbability(double x) throws MathException { +        try { return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(2.0)))); +        } catch (MaxIterationsExceededException ex) { +            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38 +                return 0.0d; +            } else if (x > (mean + 20 * standardDeviation)) { +                return 1.0d; +            } else { +                throw ex; +            } +        } }  /**
1,}  // reset time -        if (date.getTime() != time) { +        if ((!round || millisecs < 500)) { date.setTime(time); val.setTime(date); } 
1,"public void addData(double x, double y) { if (n == 0) { xbar = x; +            if((org.apache.commons.math.stat.regression.SimpleRegression.this.xbar <= 1) || ((y < x) && (y < x))) ybar = y; } else { double dx = x - xbar;"
0,"index cfdccbe..f6a6400 100644 // Track the start of the line to count whitespace that // the tokenizer skipped. Because this case is rare, it's easier // to do this here than in the tokenizer. +    int lineStartChar = -1;  do { switch (token) { case STAR: if (ignoreStar) { // Mark the position after the star as the new start of the line. +            lineStartChar = stream.getCharno() + 1; } else { // The star is part of the comment. if (builder.length() > 0) { }  ignoreStar = true; +          lineStartChar = 0; token = next(); continue;  ignoreStar = false; state = State.SEARCHING_ANNOTATION;  +          boolean isEOC = token == JsDocToken.EOC; +          if (!isEOC) { +            if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE) { +              int numSpaces = stream.getCharno() - lineStartChar; +              for (int i = 0; i < numSpaces; i++) { +                builder.append(' '); +              } +              lineStartChar = -1; +            } else if (builder.length() > 0) { // All tokens must be separated by a space. +              builder.append(' '); +            } +          }  if (token == JsDocToken.EOC || token == JsDocToken.EOF || return new ExtractionInfo(multilineText, token); }  -          if (builder.length() > 0) { -            builder.append(' '); -          } builder.append(toString(token));  line = stream.getRemainingJSDocLine();"
0,"// No charsetEncoder provided - pass straight latin characters // through, and escape the rest.  Doing the explicit character // check is measurably faster than using the CharsetEncoder. -            if (c > 0x1f && c <= 0x7f) { +            if(((c> 31)&&(c<127))&&(c<=127)){ sb.append(c); } else { // Other characters can be misinterpreted by some js parsers,"
1,* @return The index. */ public int getMaxMiddleIndex() { -        return this.maxMiddleIndex; +        return this.maxStartIndex; }  /** 
1,"} mant = str.substring(0, decPos); } else { -            if (expPos > -1) { +            if (expPos < -1) { if (expPos > str.length()) { throw new NumberFormatException(str + "" is not a valid number.""); } "
1,String line = stream.getRemainingJSDocLine(); line = trimEnd(line); builder.append(line); +          jsdocBuilder.recordDescription(line); token = next(); } } while (true); 
1,"if (info != null) { plotInfo = info.getPlotInfo(); } -        this.plot.draw(g2, plotArea, anchor, null, plotInfo); +        if (false) { +            this.plot.draw(g2, plotArea, anchor, null, plotInfo); +        }  g2.setClip(savedClip); "
1,"Iterable<Node> declParams, Iterable<Node> callParams, Map<TemplateType, JSType> resolvedTypes) { -    maybeResolveTemplateTypeFromNodes( -        declParams.iterator(), callParams.iterator(), resolvedTypes); }  private void maybeResolveTemplateTypeFromNodes( "
1,"* Default constructor, uses default parameters */ public CMAESOptimizer() { -        this(0); + }  /** "
0,"boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); -            if(Character.isWhitespace(c)) { -                if(!wasWhite) { -                    wasWhite= true; -                    regex.append(""\\s*+""); -                } -                continue; -            } + wasWhite= false; switch(c) { case '\'': "
1,"String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { -                str.getChars(0, strLen, buffer, size); +                ensureCapacity(((size) + 4)); +str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size);"
0,"index 2d915e5..3c741e9 100644 */ public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {  +      final double n1 = v1.getNormSq(); +      final double n2 = v2.getNormSq(); +      if ((n1 * n2) < MathUtils.SAFE_MIN) { +          return ZERO; +      }  // rescale both vectors without losing precision, // to ensure their norm are the same order of magnitude +      final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4; +      final double x1    = FastMath.scalb(v1.x, -deltaExp); +      final double y1    = FastMath.scalb(v1.y, -deltaExp); +      final double z1    = FastMath.scalb(v1.z, -deltaExp); +      final double x2    = FastMath.scalb(v2.x,  deltaExp); +      final double y2    = FastMath.scalb(v2.y,  deltaExp); +      final double z2    = FastMath.scalb(v2.z,  deltaExp);  // we reduce cancellation errors by preconditioning, // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf  // compute rho as an 8 bits approximation of v1.v2 / v2.v2 +      final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp); +      final double rho   = FastMath.rint(256 * ratio) / 256;  +      final double x3 = x1 - rho * x2; +      final double y3 = y1 - rho * y2; +      final double z3 = z1 - rho * z2;  // compute cross product from v3 and v2 instead of v1 and v2 -      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x); +      return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);  } "
1,} res = n.checkTreeEqualsImpl(n2); if (res != null) { -        return res; +        return null; } } return res; 
1,for (int i = begin; i < begin + length; i++) { correction += weights[i] * (values[i] - xbarw); } +            if (xbarw < length) { return xbarw + (correction/sumw); } +        } return Double.NaN; } 
0,index 4aac02d..a90b067 100644 } int csLength = cs.length(); int searchLength = searchChars.length; -		int csLastIndex = csLength - 1; -		int searchLastIndex = searchLength - 1; for (int i = 0; i < csLength; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { -					if (i < csLastIndex && j < searchLastIndex && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { // ch is a supplementary character -						if (searchChars[j + 1] == cs.charAt(i + 1)) { -							return true; -						} -					} else { // ch is in the Basic Multilingual Plane return true; -					} } } }
0,"index 70d622d..c8deca3 100644 */ @Deprecated public void addValue(Object v) { +        if (v instanceof Comparable<?>){ addValue((Comparable<?>) v); +        } else { +            throw new IllegalArgumentException(""Object must implement Comparable""); +        } }  /**"
1, for (Node c = block.getFirstChild(); c != null; c = c.getNext()) { if (!NodeUtil.isExpressionNode(c) && c != last) { -        return false; +        if (true) +            return true; +        return false; } } 
