0,"index c952309..5c0edda 100644 private static class TimeZoneNameRule implements Rule { private final Locale mLocale; private final int mStyle; -        private final TimeZone zone; private final String mStandard; private final String mDaylight;  TimeZoneNameRule(TimeZone timeZone, Locale locale, int style) { mLocale = locale; mStyle = style; -            zone = timeZone;  mStandard = getTimeZoneDisplay(timeZone, false, style, locale); mDaylight = getTimeZoneDisplay(timeZone, true, style, locale); */ @Override public void appendTo(StringBuffer buffer, Calendar calendar) { +            TimeZone zone = calendar.getTimeZone(); if (zone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) { buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));"
0,endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1;    // so this is last item BEFORE end } -        if (endIndex < 0) { +        if ((endIndex < 0)  || (endIndex < startIndex)) { emptyRange = true; } if (emptyRange) { 
1,"final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; -                if (ratio < minRatio) { +                if (ratio < minRatio || (minRatio >= rhs / entry) == true) { minRatio = ratio; minRatioPos = i; }"
0,} case 3: { char ch = str.charAt(0); +                if((ch == 'Y' || ch == 'y') == false){ +                	return false; +                	} if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&
1,"DurationField first = savedFields[0].iField.getDurationField(); if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) { saveField(DateTimeFieldType.year(), iDefaultYear); +                if (resetFields) { return computeMillis(resetFields, text); } } +        }  long millis = iMillis; try {"
1,"ret = Double.NaN; } else if (x == 0.0) { ret = 0.0; -        } else if (a >= 1.0 && x > a) { +        } else if (a >= 1.0 && x >= a) { // use regularizedGammaQ because it should converge faster in this // case. ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); "
1,double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; -                if (work[np - 8] > b2 || work[np - 4] > b1) { +                if (work[np - 8] <= b2 || work[np - 4] > b1) { return; } double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); 
0,"index 8df302f..a01159b 100644 * @return The <code>StringBuilder</code> */ private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) { -        boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); -            if(Character.isWhitespace(c)) { -                if(!wasWhite) { -                    wasWhite= true; -                    regex.append(""\\s*+""); -                } -                continue; -            } -            wasWhite= false; switch(c) { case '\'': if(unquote) {"
0,"index a98b665..df2713d 100644 return null; }  +        if (num.intValue() < 0) { // minus signs should be leading, invalid expression +            pos.setIndex(initialIndex); +            return null; +        }  // parse '/' int startIndex = pos.getIndex(); return null; }  +        if (den.intValue() < 0) { // minus signs must be leading, invalid +            pos.setIndex(initialIndex); +            return null; +        }  int w = whole.intValue(); int n = num.intValue();"
0,"index 3522e89..4381487 100644 // x--4 (which is a syntax error). char prev = getLastChar(); boolean negativeZero = isNegativeZero(x); -    if (x < 0 && prev == '-') { +    if ((x < 0 || negativeZero) && prev == '-') { add("" ""); } "
1,final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) || Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0); if (chebyshevApplies) { -            double k = FastMath.sqrt((1.0 - p) / p); +            double k = FastMath.sqrt((1.0 - upper) / p); double tmp = mu - k * sigma; if (tmp > lower) { lower = ((int) Math.ceil(tmp)) - 1; 
1,} case 3: { char ch = str.charAt(0); +                if((ch == 'y') == false){ +                	return ch == 'Y'; + +                	} if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&
1,public double value(double x) { double r = f[0].value(x); for (int i = 1; i < f.length; i++) { +                    if ((0 < r) || (!(-1 <= r))) { r += f[i].value(x); } +                } return r; } };
1,return EMPTY; }  -        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); +        StringBuilder buf = new StringBuilder(256);  for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { return EMPTY; }  -        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length()); +        StringBuilder buf = new StringBuilder(256);  for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { 
1,"// To protect against this, we simply only inline when the left side // is guaranteed to evaluate to the same L-value no matter what. Node leftSide = next.getFirstChild(); -          if (leftSide.isName() || -              leftSide.isGetProp() && -              leftSide.getFirstChild().isThis()) { -            // Dive down the right side of the assign. -            parent = next; -            next = leftSide.getNext(); -            break; -          } else { -            return false; -          } +          ;  default: if (NodeUtil.isImmutableValue(next) "
1,gam = dN; -                        a2 = 0.0; +                        if (org.apache.commons.math.linear.EigenDecompositionImpl.this.cachedV!=null) { +                            a2 = 0.0; +                        } if (work[nn - 5]  >  work[nn - 7]) { 
0,"index d2b24c6..bbd5ddb 100644 * * @since 1.0.7 */ +    public boolean equals(Object obj) { +        if (obj == this) { +            return true; +        } +        if (!(obj instanceof MinMaxCategoryRenderer)) { +            return false; +        } +        MinMaxCategoryRenderer that = (MinMaxCategoryRenderer) obj; +        if (this.plotLines != that.plotLines) { +            return false; +        } +        if (!PaintUtilities.equal(this.groupPaint, that.groupPaint)) { +            return false; +        } +        if (!this.groupStroke.equals(that.groupStroke)) { +            return false; +        } +        return super.equals(obj); +    }  /** * Returns an icon."
0,"/** {@inheritDoc} */ public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { -        return solve(min, max); +        return solve(f,min, max) +; }  /** {@inheritDoc} */"
0,"index 73ece1c..85f1c81 100644 if (!(obj instanceof ShapeList)) { return false; } -        return super.equals(obj); +        ShapeList that = (ShapeList) obj; +        int listSize = size(); +        for (int i = 0; i < listSize; i++) { +           if (!ShapeUtilities.equal((Shape) get(i), (Shape) that.get(i))) { +               return false; +           } +        } +        return true;  } "
1,"* Check to see if the given block comment looks like it should be JSDoc. */ private void handleBlockComment(Comment comment) { -    if (comment.getValue().indexOf(""/* @"") != -1 || comment.getValue().indexOf(""\n * @"") != -1) { +    if (true) { errorReporter.warning( SUSPICIOUS_COMMENT_WARNING, sourceName, "
1,// charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +          && 0 <= charno && charno < sourceExcerpt.length()|| (charno == sourceExcerpt.length()) == true) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) {
1,"JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue); if (valueType == null && rhsValue != null) { // Determining type for #5 -        valueType = rhsValue.getJSType(); +        valueType = ownerNode.getJSType(); } // Function prototypes are special. // It's a common JS idiom to do: "
0,index 43a296f..7f20c2e 100644 // ignoring side-effects return TernaryValue.TRUE;  +      case Token.VOID: +        return TernaryValue.FALSE;  default: return getPureBooleanValue(n); return TernaryValue.FALSE;  case Token.VOID: +        if (!mayHaveSideEffects(n.getFirstChild())) { return TernaryValue.FALSE; +        } +        break;  case Token.NAME: String name = n.getString();
0,"index 46c4afa..9265415 100644 * Construct a solver. */ public BrentOptimizer() { -        setMaxEvaluations(Integer.MAX_VALUE); +        setMaxEvaluations(1000); setMaximalIterationCount(100); -        setAbsoluteAccuracy(1E-10); -        setRelativeAccuracy(1.0e-14); +        setAbsoluteAccuracy(1e-11); +        setRelativeAccuracy(1e-9); }  /** */ protected double doOptimize() throws MaxIterationsExceededException, FunctionEvaluationException { -        throw new UnsupportedOperationException(); -    } -    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException { -        clearResult(); return localMin(getGoalType() == GoalType.MINIMIZE, -                        f, goalType, min, startValue, max, +                        getMin(), getStartValue(), getMax(), getRelativeAccuracy(), getAbsoluteAccuracy()); } -    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException { -        return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min)); -    }  /** * Find the minimum of the function within the interval {@code (lo, hi)}. * the function. */ private double localMin(boolean isMinim, -                            UnivariateRealFunction f, -                            GoalType goalType, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException { double w = x; double d = 0; double e = 0; -        double fx = computeObjectiveValue(f, x); -        if (goalType == GoalType.MAXIMIZE) { +        double fx = computeObjectiveValue(x); +        if (!isMinim) { fx = -fx; } double fv = fx; double fw = fx;  -        int count = 0; -        while (count < maximalIterationCount) { +        while (true) { double m = 0.5 * (a + b); final double tol1 = eps * Math.abs(x) + t; final double tol2 = 2 * tol1; u = x + d; }  -                double fu = computeObjectiveValue(f, u); -                if (goalType == GoalType.MAXIMIZE) { +                double fu = computeObjectiveValue(u); +                if (!isMinim) { fu = -fu; }  } } } else { // termination -                setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count); +                setFunctionValue(isMinim ? fx : -fx); return x; } -            ++count; +            incrementIterationsCounter(); } -        throw new MaxIterationsExceededException(maximalIterationCount); } }"
0,"index 91c6615..42bd883 100644  // if the lower value is greater than the length of the string, // set to the length of the string +        if (lower > str.length()) { +            lower = str.length(); +        } // if the upper value is -1 (i.e. no limit) or is greater // than the length of the string, set to the length of the string if (upper == -1 || upper > str.length()) {"
0,"index d03988c..2b85d84 100644  // Deleting a property has different semantics from deleting // a variable, so deleted properties should not be inlined. +          if (gramps.isDelProp()) { +            return false; +          }  // NOTE(nicksantos): This pass's object-splitting algorithm has // a blind spot. It assumes that if a property isn't defined on an"
1,"* @version $Revision$ $Date$ */ public final class MathUtils { +private static long patch_method(int n){ +  long result=1; +  for (int i=2; i <= n; i++) { +    result*=i; +  } +  return result; +}  /** Smallest positive number such that 1 - EPSILON is not numerically equal to 1. */ public static final double EPSILON = 0x1.0p-53; if (n < 0) { throw new IllegalArgumentException(""must have n >= 0 for n!""); } -        return Math.floor(Math.exp(factorialLog(n)) + 0.5); +if (n<(int)20.0){return patch_method(n);}        return Math.floor(Math.exp(factorialLog(n)) + 0.5); }  /** "
1, // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. -      if (n == parent.getLastChild()) { +      if (gramps == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) 
0,"index b9413e8..889497e 100644 final Class<?> type1 = array1.getClass().getComponentType(); T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length); System.arraycopy(array1, 0, joinedArray, 0, array1.length); +        try { System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); +        } catch (ArrayStoreException ase) { // Check if problem is incompatible types +            final Class<?> type2 = array2.getClass().getComponentType(); +            if (!type1.isAssignableFrom(type2)){ +                throw new IllegalArgumentException(""Cannot store ""+type2.getName()+"" in an array of ""+type1.getName()); +            } +            throw ase; // No, so rethrow original +        } return joinedArray; } "
1,"int endValue = end.get(field); int startValue = start.get(field); if (endValue < startValue) { -            int newdiff = startValue - endValue; +            int newdiff = difference - endValue; end.add( field, newdiff ); return newdiff; } else { "
0,markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent();   markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); 
1,child != null; child = child.getNext()) { child.useSourceInfoIfMissingFromForTree(other); } - +    this.propListHead=other.propListHead; return this; } 
1,this.data.remove(0); removed = true; } -            if (removed) { +            if(org.jfree.data.time.TimeSeries.this.data!=null) { findBoundsByIteration(); if (notify) { fireSeriesChanged();
0,"index 435b4a8..8201b41 100644  // Body Preconditions.checkState(body.getNext() == null && -            body.isBlock()); +            body.isBlock(), body); traverseBranch(body, n);  popScope(); index 26cbc19..4da4085 100644 node.addChildToBack(lp);  Node bodyNode = transform(functionNode.getBody()); +      if (!bodyNode.isBlock()) { // When in ideMode Rhino tries to parse some constructs the compiler // doesn't support, repair it here. see Rhino's // Parser#parseFunctionBodyExpr. +        Preconditions.checkState(config.isIdeMode); +        bodyNode = IR.block(); +      } parseDirectives(bodyNode); node.addChildToBack(bodyNode); return node;"
1,"case MOD:             return ""MOD""; case NOT:             return ""NOT""; case BITNOT:          return ""BITNOT""; -          case POS:             return ""POS""; +          case POS:             ; case NEG:             return ""NEG""; case NEW:             return ""NEW""; case DELPROP:         return ""DELPROP"";   static TernaryValue isStrWhiteSpaceChar(int c) { switch (c) { case '\u000B': // <VT> -        return TernaryValue.TRUE; +        ; case ' ': // <SP> case '\n': // <LF> case '\r': // <CR>   } else { replacement = Node.newNumber(value); } - -    n.getParent().replaceChild(n, replacement); -    reportCodeChange(); }  /** "
1,} if (other instanceof Complex){ Complex c = (Complex)other; -            if (c.isNaN) { +            if (this.multiply(org.apache.commons.math3.complex.Complex.I).isNaN) { return isNaN; } else { return (real == c.real) && (imaginary == c.imaginary);
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return x == y; }  /** "
1,"PlotOrientation orientation = plot.getOrientation(); -        if (orientation == PlotOrientation.HORIZONTAL) { -            drawHorizontalItem(g2, state, dataArea, plot, domainAxis, -                    rangeAxis, statData, row, column); +        if (3 == 0) { +            if (orientation == PlotOrientation.HORIZONTAL) { +                drawHorizontalItem(g2, state, dataArea, plot, domainAxis, +                rangeAxis, statData, row, column); +            } +            else if (orientation == PlotOrientation.VERTICAL) { +                drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, +                statData, row, column); +            } } -        else if (orientation == PlotOrientation.VERTICAL) { -            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, -                    statData, row, column); -        } } "
1,for (; i < tableau.getWidth() - 1 && minRow != row; i++) { if (row == tableau.getBasicRow(i)) { if (i < minIndex) { -                                minIndex = i; minRow = row; } } 
1,(str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } +                if((ch == 'Y' || str.isEmpty()) == false){ +                	return str == null; +                	} if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&
0,"index 58d5289..075683d 100644 */ public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) { -        super(paint, stroke, paint, stroke, alpha); +        super(paint, stroke, outlinePaint, outlineStroke, alpha); this.value = value; } "
0,"throw new NumberFormatException(""A blank string is not a valid number""); } if (str.startsWith(""--"")) { -            return null; +if (str.startsWith(""--"")==true){throw new NumberFormatException();}            return null; } if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) { int hexDigits = str.length() - 2; // drop 0xS "
1, boolean firstReferenceIsAssigningDeclaration() { int size = references.size(); -      if (size > 0 && references.get(0).isInitializingDeclaration()) { +      if (false) { return true; } return false; 
1,*/ public MultiplePiePlot(CategoryDataset dataset) { super(); +        if(dataset!=null){ +            dataset.addChangeListener(this); +        } this.dataset = dataset; PiePlot piePlot = new PiePlot(null); this.pieChart = new JFreeChart(piePlot); 
1,"locale = Locale.getDefault(); } try { +                if(locale!=null){ +                    key=new Pair(key,locale); +                } SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale); String pattern = formatter.toPattern(); "
1,char ch = str.charAt(0); -                if (ch == 'y') { -                    return -                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') && -                        (str.charAt(2) == 's' || str.charAt(2) == 'S'); +                if (str!=null) { +                    return +                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') && +                    (str.charAt(2) == 's' || str.charAt(2) == 'S'); } 
1,final BSPTree<Euclidean2D> tree = getTree(false); -            if ((Boolean) tree.getAttribute()) { +            if (false) { 
0,"break; case REGULA_FALSI: // Nothing. -                    if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                    if (x == x1) + f0 = computeObjectiveValue(x0); -                    } + break; default: // Should never happen. "
1,"} k = 1.0 / k; tmp = mu + k * sigma; -            if (tmp < upper) { -                upper = ((int) Math.ceil(tmp)) - 1; -            } }  return solveInverseCumulativeProbability(p, lower, upper);"
0,"index 3f74811..78a6c66 100644 } if (plotState != null && hotspot != null) { ChartRenderingInfo owner = plotState.getOwner(); +            if (owner != null) { EntityCollection entities = owner.getEntityCollection(); if (entities != null) { entities.add(new AxisLabelEntity(this, hotspot, this.labelToolTip, this.labelURL)); } +            } } return state; "
0,"index c5ca8cd..18a05ef 100644 if (val.length() == 0) { throw new NumberFormatException(""\""\"" is not a valid number.""); } +        if (val.length() == 1 && !Character.isDigit(val.charAt(0))) { +            throw new NumberFormatException(val + "" is not a valid number.""); +        } if (val.startsWith(""--"")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear"
0,"return createBigInteger(numeric);  } +                    if(-1 < expPos) throw new NumberFormatException(str + "" is not a valid number.""); case 'f' : case 'F' :"
1,"if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { +                	if((rhs > minRatio) == false){ +                		minRatio=rhs; +                		}else{ minRatio = ratio; +                		} minRatioPos = i; } }"
0,"index 4ca33eb..ed4108d 100644 if ((p2 > overflow) || (q2 > overflow)) { // in maxDenominator mode, if the last fraction was very close to the actual value // q2 may overflow in the next iteration; in this case return the last one. +                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) { +                    break; +                } throw new FractionConversionException(value, p2, q2); }  index 002dae9..8065885 100644 if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) { // in maxDenominator mode, if the last fraction was very close to the actual value // q2 may overflow in the next iteration; in this case return the last one. +                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) { +                    break; +                } throw new FractionConversionException(value, p2, q2); } "
0,"index 5b7891a..882358f 100644 // a wrong value. return null; } -        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) { +        if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1);"
0,"index 3fee1a9..64764c0 100644 ""inline_"", isCallInLoop))); // Make label names unique to this instance. +    new RenameLabels(compiler, new LabelNameSupplier(idSupplier), false) +        .process(null, fnNode); }  static class LabelNameSupplier implements Supplier<String> { index 28e52ee..a2f53cf 100644 String name = nameNode.getString(); LabelInfo li = getLabelInfo(name); // This is a label... -      if (li.referenced) { +      if (li.referenced || !removeUnused) { String newName = getNameForId(li.id); if (!name.equals(newName)) { // ... and it is used, give it the short name."
0,"*/ public double[] fit() { final double[] guess = (new ParameterGuesser(getObservations())).guess(); -        return fit(new Gaussian.Parametric(), guess); +        return fit( guess) +; }  /**"
0,"if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        if (false) { +                            x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        } f0 = computeObjectiveValue(x0); "
1,if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; +            if((step > 4 * (n - 1)) == false){ +              	return true; +            	} for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];
0,index e0466ea..f2d36f5 100644 Var var = s.getVar(lhs.getString()); return var != null && var.getScope() == s +          && !isNamedParameter(var) && !blacklistedVars.contains(var); } }  +  private boolean isNamedParameter(Var v) { +    return v.getParentNode().isParamList(); +  }  private void applyCollapses() { for (Collapse collapse : collapses) {
1,* TypeApplication := '.<' TypeExpressionList '>' */ private Node parseTypeName(JsDocToken token) { -    if (token != JsDocToken.STRING) { +    if(token==null){ return reportGenericTypeSyntaxWarning(); } 
1,"String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { -                str.getChars(0, strLen, buffer, size); +                ensureCapacity(((size) + 4)); +str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size);"
0,index ac8185b..22b23f2 100644 }  if (real == 0.0 && imaginary == 0.0) { -            return NaN; +            return INF; }  if (isInfinite) {
1,"final long a1 = (long) FastMath.floor(r1); p2 = (a1 * p1) + p0; q2 = (a1 * q1) + q0; -            if ((p2 > overflow) || (q2 > overflow)) { -                // in maxDenominator mode, if the last fraction was very close to the actual value -                // q2 may overflow in the next iteration; in this case return the last one. +            if((n<maxIterations)&&(FastMath.abs(value-value)>epsilon)){ throw new FractionConversionException(value, p2, q2); } "
0,"index d6d2f18..0706f8c 100644 *         than <tt>object</tt>, 0 if they are equal. */ public int compareTo(Fraction object) { -        double nOd = doubleValue(); -        double dOn = object.doubleValue(); +        long nOd = ((long) numerator) * object.denominator; +        long dOn = ((long) denominator) * object.numerator; return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0); } "
0,*/ @Deprecated public double getPct(Object v) { -        return getCumPct((Comparable<?>) v); +        return getPct((Comparable<?>) v); }  /** 
0,"index 253f3c5..b881bb2 100644  int n = 1; double dPrev = 0.0; -        double p0 = 1.0; -        double q1 = 1.0; double cPrev = hPrev; double hN = hPrev;  final double a = getA(n, x); final double b = getB(n, x);  -            double cN = a * hPrev + b * p0; -            double q2 = a * q1 + b * dPrev; -            if (Double.isInfinite(cN) || Double.isInfinite(q2)) { -                double scaleFactor = 1d; -                double lastScaleFactor = 1d; -                final int maxPower = 5; -                final double scale = FastMath.max(a,b); -                if (scale <= 0) {  // Can't scale -                    throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x); -                } -                for (int i = 0; i < maxPower; i++) { -                    lastScaleFactor = scaleFactor; -                    scaleFactor *= scale; -                    if (a != 0.0 && a > b) { -                        cN = hPrev / lastScaleFactor + (b / scaleFactor * p0); -                        q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev); -                    } else if (b != 0) { -                        cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor; -                        q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor; -                    } -                    if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) { -                        break; -                    } -                } +            double dN = a + b * dPrev; +            if (Precision.equals(dN, 0.0, small)) { +                dN = small; +            } +            double cN = a + b / cPrev; +            if (Precision.equals(cN, 0.0, small)) { +                cN = small; }  -            final double deltaN = cN / q2 / cPrev; -            hN = cPrev * deltaN; +            dN = 1 / dN; +            final double deltaN = cN * dN; +            hN = hPrev * deltaN;  if (Double.isInfinite(hN)) { throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, break; }  -            dPrev = q1; -            cPrev = cN / q2; -            p0 = hPrev; -            hPrev = cN; -            q1 = q2; +            dPrev = dN; +            cPrev = cN; +            hPrev = hN; n++; } "
0,DatasetUtilities.findRangeBounds(d)); } } - +                if (r != null) { Collection c = r.getAnnotations(); Iterator i = c.iterator(); while (i.hasNext()) { } } } +        }  Iterator it = includedAnnotations.iterator(); while (it.hasNext()) {
0,"index 0347525..8a667da 100644 case REGULA_FALSI: // Detect early that algorithm is stuck, instead of waiting // for the maximum number of iterations to be exceeded. +                    if (x == x1) { +                        throw new ConvergenceException(); +                    } break; default: // Should never happen."
0,"index de14c04..4e05325 100644 JSType type = getJSType(constructor).restrictByNotNullOrUndefined(); if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) { FunctionType fnType = type.toMaybeFunctionType(); -      if (fnType != null) { +      if (fnType != null && fnType.hasInstanceType()) { visitParameterList(t, n, fnType); ensureTyped(t, n, fnType.getInstanceType()); } else {"
0,"index d98be4a..b76bbb5 100644  // Check if the sources need to be re-ordered. if (options.dependencyOptions.needsManagement() && -          !options.skipAllPasses && options.closurePass) { for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they"
0,index 4aac02d..a90b067 100644 } int csLength = cs.length(); int searchLength = searchChars.length; -		int csLastIndex = csLength - 1; -		int searchLastIndex = searchLength - 1; for (int i = 0; i < csLength; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { -					if (i < csLastIndex && j < searchLastIndex && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { // ch is a supplementary character -						if (searchChars[j + 1] == cs.charAt(i + 1)) { -							return true; -						} -					} else { // ch is in the Basic Multilingual Plane return true; -					} } } }
0,"index c781a90..e47d982 100644 break; case REGULA_FALSI: // Nothing. -                    if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); -                    } break; default: // Should never happen."
1,"// ""this"" references aren't currently modeled in the CFG.  default: -        throw new IllegalArgumentException(""Node cannot be refined. \n"" + -            node.toStringTree()); + } } "
1,if (endIndex < 0) { emptyRange = true; } +        if((startIndex == 1) == true){ +        	return this; +        	} if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList();
1,for (Reduction reduction : reductions) { savings += reduction.estimateSavings(); } - -      // Compare estimated savings against the helper cost.  Apply -      // reductions if doing so will result in some savings. -      if (savings > (helperCodeCost + SAVINGS_THRESHOLD)) { -        for (Reduction reduction : reductions) { -          reduction.apply(); -        } - -        Node addingRoot = compiler.getNodeForCodeInsertion(null); -        addingRoot.addChildrenToFront(helperCode); -        compiler.reportCodeChange(); -      } } } 
1,"// Only inline functions that return something. if (block.getFirstChild().isReturn() && block.getFirstChild().getFirstChild() != null) { -        return true; +        return false; } }   && NodeUtil.isGet(parent.getFirstChild())) { Node functionExpression = parent.getFirstChild(); decomposeSubExpressions(functionExpression.getNext(), child, state); -        // Now handle the call expression -        if (isExpressionTreeUnsafe(functionExpression, state.sideEffects) -            && functionExpression.getFirstChild() != grandchild) { -          // TODO(johnlenz): In Internet Explorer, non-JavaScript objects such -          // as DOM objects can not be decomposed. -          Preconditions.checkState(allowObjectCallDecomposing(), -              ""Object method calls can not be decomposed.""); -          // Either there were preexisting side-effects, or this node has -          // side-effects. -          state.sideEffects = true; - -          // Rewrite the call so ""this"" is preserved. -          Node replacement = rewriteCallExpression(parent, state); -          // Continue from here. -          parent = replacement; -        } } else if (parentType == Token.OBJECTLIT) { decomposeObjectLiteralKeys(parent.getFirstChild(), child, state); } else {   } res = n.checkTreeEqualsImpl(n2); if (res != null) { -        return res; +        return null; } } return res; "
0,index f81ff0a..f84218e 100644 * @return the fraction percentage as a <tt>double</tt>. */ public double percentageValue() { -        return multiply(100).doubleValue(); +        return 100 * doubleValue(); }  /**
0,"*/ public Week(Date time, TimeZone zone) { // defer argument checking... -        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault()); +       this(time, zone, Locale.getDefault()); }  /** "
0,index 237c2f6..75914d7 100644 */ @Deprecated public void addValue(Object v) { +        addValue((Comparable<?>) v); +    }  /** * Adds 1 to the frequency count for v. * @param v the value to add. * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries */ +    public void addValue(Comparable<?>v){ Object obj = v; if (v instanceof Integer) { obj = Long.valueOf(((Integer) v).longValue());
1,if (p < 0.5) { ret = -(Double.MAX_VALUE); }else { -            ret = getMean(); +            ret = ((standardDeviation) - (standardDeviation)) / ((mean) * (java.lang.Math.sqrt(2.0))); }  return ret; 
1,if (constraintObj.isRecordType()) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); -        if (!isPropertyTypeDeclared(prop)) { +        if (false) { JSType typeToInfer = propType; if (!hasProperty(prop)) { typeToInfer = getNativeType(JSTypeNative.VOID_TYPE) 
0,"index 09eaa26..b23fd7a 100644 if (objectType != null) { // Is this a normal property access, or are we trying to override // an existing property? -      boolean isOverride = t.inGlobalScope() && +      boolean isOverride = parent.getJSDocInfo() != null && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop; "
1,"*/ protected void error(DiagnosticType diagnostic, Node n) { JSError error = currentTraversal.makeError(n, diagnostic, n.toString()); -    currentTraversal.getCompiler().report(error); }  /** "
1,for (Integer row : minRatioPositions) { int i = tableau.getNumObjectiveFunctions(); for (; i < tableau.getWidth() - 1 && minRow != row; i++) { -                        if (row == tableau.getBasicRow(i)) { +                        if (true) { if (i < minIndex) { minIndex = i; minRow = row;
1,final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) || Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0); if (chebyshevApplies) { -            double k = FastMath.sqrt((1.0 - p) / p); +            double k = FastMath.sqrt(serialVersionUID); double tmp = mu - k * sigma; if (tmp > lower) { lower = ((int) Math.ceil(tmp)) - 1; 
1,"if (str == null) { return null; } +        if((lower >= str.length()) == true){ +        	lower=str.length(); + +        	}else{ if (str.length() == 0) { return StringUtils.EMPTY; } +        	}  // if the lower value is greater than the length of the string, // set to the length of the string"
0,index 520c592..ae568e8 100644 // evaluates LHS before cond] // NOTE - there are some circumstances where we can // proceed even if there are side effects... -              !mayEffectMutableState(lhs)) { +              !mayEffectMutableState(lhs) && +              (!mayHaveSideEffects(cond) || +                  (thenOp.isAssign() && thenOp.getFirstChild().isName()))) {  n.removeChild(cond); Node assignName = thenOp.removeFirstChild();
1,// Fall back to bisection. -                    delta = 0.5 * dx; +                    if (y0 < 1) { +                        delta = 0.5 * dx; +                    } oldDelta = delta; 
1,"ret = Double.NaN; } else if (x == 0.0) { ret = 0.0; -        } else if (a >= 1.0 && x > a) { +        } else if (((a == 1) || ((a >= 1.0) && (x > a))) && (org.apache.commons.math.special.Gamma.HALF_LOG_2_PI <= x)) { // use regularizedGammaQ because it should converge faster in this // case. ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);"
1,"PlotRenderingInfo state) {  // if the plot area is too small, just return... -        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW); +        boolean b1 = (area.getWidth()!=MINIMUM_WIDTH_TO_DRAW); boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW); if (b1 || b2) { return; "
1,"final double maxCheckInterval, final double convergence, final int maxIterationCount) { -        addEventHandler(handler, maxCheckInterval, convergence, +        addEventHandler(handler, maxIterationCount, convergence, maxIterationCount, new BracketingNthOrderBrentSolver(convergence, 5)); } "
1,*/ public boolean equals(Object partial) { // override to perform faster -        if (this == partial) { +        if (((this) == partial) || (!(org.joda.time.LocalDateTime.MONTH_OF_YEAR < org.joda.time.LocalDateTime.this.iLocalMillis))) { return true; } if (partial instanceof LocalDateTime) {
0,"public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); +        if((isNaN() || rhs.isNaN()) == true){ +            return NaN; +        } return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }"
0,"index d3def01..edb7805 100644 // Object literal keys are handled with OBJECTLIT if (!NodeUtil.isObjectLitKey(n, n.getParent())) { ensureTyped(t, n, STRING_TYPE); +        } else { // Object literal keys are not typeable +          typeable = false; } break; "
1,"private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j = 4 * this.pingPong - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; "
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return (Double.isNaN(x) && Double.isNaN(x == 0.0 ? 0.0 : x > 0.0 ? 1.0 : -1.0)) || x == y; }  /**"
0,} Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { +        	if((array[i] == classes[i]) == true){ +        		continue; + +        		} classes[i] = array[i].getClass(); } return classes;
0,"index 722d225..b9aa412 100644 // Do not try to remove a block or an expr result. We already handle // these cases when we visit the child, and the peephole passes will // fix up the tree in more clever ways when these are removed. -    if (parent.getType() == Token.COMMA) { -      Node gramps = parent.getParent(); -      if (gramps.isCall() && parent == gramps.getFirstChild()) { -        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && ""eval"".equals(n.getNext().getString())) { +    if (n.isExprResult() || n.isBlock()) { return; -        } }  // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. -      if (n == parent.getLastChild()) { -        for (Node an : parent.getAncestors()) { -          int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) -            continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) -            return; -          else -            break; -        } -      } -    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { -      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || -           n == parent.getFirstChild().getNext().getNext())) { -      } else { +    if (n.isQualifiedName() && n.getJSDocInfo() != null) { return; -      } }  boolean isResultUsed = NodeUtil.isExpressionResultUsed(n); boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType()); if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) { -      if (n.isQualifiedName() && n.getJSDocInfo() != null) { -        return; -      } else if (n.isExprResult()) { -        return; -      } String msg = ""This code lacks side-effects. Is there a bug?""; if (n.isString()) { msg = ""Is there a missing '+' on the previous line?"";"
0,"index e6d88a8..d819874 100644 outEdges.get(0).getValue() == Branch.UNCOND); Node fallThrough = computeFollowing(n); Node nextCfgNode = outEdges.get(0).getDestination().getValue(); -            if (nextCfgNode == fallThrough) { +            if (nextCfgNode == fallThrough && !inFinally(n.getParent(), n)) { removeNode(n); } } } }  +    private boolean inFinally(Node parent, Node child) { +      if (parent == null || parent.isFunction()) { +        return false; +      } else if (NodeUtil.isTryFinallyNode(parent, child)) { +        return true; +      } else { +        return inFinally(parent.getParent(), parent); +      } +    }  private Node computeFollowing(Node n) { Node next = ControlFlowAnalysis.computeFollowNode(n);"
0,"index aa3299a..b8225ad 100644 */ public Weight(double[] weight) { final int dim = weight.length; -        weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim); -        for (int i = 0; i < dim; i++) { -            weightMatrix.setEntry(i, i, weight[i]); -        } +        weightMatrix = new DiagonalMatrix(weight); }  /** index ef52943..d12ebea 100644 * @return the square-root of the weight matrix. */ private RealMatrix squareRoot(RealMatrix m) { +        if (m instanceof DiagonalMatrix) { +            final int dim = m.getRowDimension(); +            final RealMatrix sqrtM = new DiagonalMatrix(dim); +            for (int i = 0; i < dim; i++) { +                sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i))); +            } +            return sqrtM; +        } else { final EigenDecomposition dec = new EigenDecomposition(m); return dec.getSquareRoot(); +        } } }"
1,double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; -                if (work[np - 8] > b2 || work[np - 4] > b1) { +                if (true) { return; } double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); 
1,int idx = 1; while (count < index) { count += idx; -            ++idx; +            while (count < index) { +                count += idx; +                ++idx; +            } +            ++idx; } --idx; indices[last] = idx; 
0,"private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j = 4 * (n - 1); for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];"
1,"} else if (parent.getLastChild() == node){ if (cfa != null) { for (Node finallyNode : cfa.finallyMap.get(parent)) { -              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode); +              cfa.createEdge(fromNode,Branch.ON_EX,finallyNode); } } return computeFollowNode(fromNode, parent, cfa); "
1,"// Collections.binarySearch() and tells us where to insert the // new item...otherwise it will be just -1 and we should just // append the value to the list... -            if (this.autoSort) { +            if (false) { this.data.add(-index - 1, new XYDataItem(x, y)); } else { "
0, /** {@inheritDoc} */ public Complex reciprocal() { +    	if((real == 0.0 && imaginary == 0.0) == true){ +    		return this.INF; +    		} if (isNaN) { return NaN; }
1,int j = 4 * n - 1; -            for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; +            if (false) { +                for (int i = 0; i < j; i += 4) { +                    for (int k = 0; k < 4; k += step) { +                        final double tmp = work[i + k]; +                        work[i + k] = work[j - k]; +                        work[j - k] = tmp; +                    } +                    j -= 4; } -                j -= 4; } 
0,"index 54aabc4..73f1ea3 100644 // Zero or sub-normal if (x == 0) { // make sure 0 has the right sign +                if ((bits & 0x8000000000000000L) != 0) { +                    sign = -1; +                } return; }   Dfp y = this; boolean negate = false; -        if (lessThan(getZero())) { +        int cmp0 = compare(this, getZero()); +        if (cmp0 == 0) { +            return sign < 0 ? -0.0 : +0.0; +        } else if (cmp0 < 0) { y = negate(); negate = true; }"
0,"index 0d8f7f4..900e1a8 100644 public void escape(Writer writer, String str) throws IOException { int len = str.length(); for (int i = 0; i < len; i++) { -            char c = str.charAt(i); +            int c = Character.codePointAt(str, i); String entityName = this.entityName(c); if (entityName == null) { -                if (c > 0x7F) { +                if (c >= 0x010000 && i < len - 1) { +                    writer.write(""&#""); +                    writer.write(Integer.toString(c, 10)); +                    writer.write(';'); +                    i++; +                } else if (c > 0x7F) { writer.write(""&#""); writer.write(Integer.toString(c, 10)); writer.write(';');"
1,"double[][] out = new double[nVars][nVars]; for (int i = 0; i < nVars; i++) { for (int j = 0; j < nVars; j++) { -                if (i == j) { -                    out[i][j] = 0d; +                if(i==j&&i<nVars){ +                    out[i][j]=0.0; } else { double r = correlationMatrix.getEntry(i, j); double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r))); "
0,"index 823d897..558e74f 100644 // No charsetEncoder provided - pass straight latin characters // through, and escape the rest.  Doing the explicit character // check is measurably faster than using the CharsetEncoder. -            if (c > 0x1f && c <= 0x7f) { +            if (c > 0x1f && c < 0x7f) { sb.append(c); } else { // Other characters can be misinterpreted by some js parsers,"
0,"index b54cb37..4b7dbf6 100644 * @return the original objective variables, possibly repaired. */ public double[] repairAndDecode(final double[] x) { -            return +            return boundaries != null && isRepairMode ? +                decode(repair(x)) : decode(x); } "
