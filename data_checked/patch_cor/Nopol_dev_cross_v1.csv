0,"index 253f3c5..b881bb2 100644  int n = 1; double dPrev = 0.0; -        double p0 = 1.0; -        double q1 = 1.0; double cPrev = hPrev; double hN = hPrev;  final double a = getA(n, x); final double b = getB(n, x);  -            double cN = a * hPrev + b * p0; -            double q2 = a * q1 + b * dPrev; -            if (Double.isInfinite(cN) || Double.isInfinite(q2)) { -                double scaleFactor = 1d; -                double lastScaleFactor = 1d; -                final int maxPower = 5; -                final double scale = FastMath.max(a,b); -                if (scale <= 0) {  // Can't scale -                    throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x); -                } -                for (int i = 0; i < maxPower; i++) { -                    lastScaleFactor = scaleFactor; -                    scaleFactor *= scale; -                    if (a != 0.0 && a > b) { -                        cN = hPrev / lastScaleFactor + (b / scaleFactor * p0); -                        q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev); -                    } else if (b != 0) { -                        cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor; -                        q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor; -                    } -                    if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) { -                        break; -                    } -                } +            double dN = a + b * dPrev; +            if (Precision.equals(dN, 0.0, small)) { +                dN = small; +            } +            double cN = a + b / cPrev; +            if (Precision.equals(cN, 0.0, small)) { +                cN = small; }  -            final double deltaN = cN / q2 / cPrev; -            hN = cPrev * deltaN; +            dN = 1 / dN; +            final double deltaN = cN * dN; +            hN = hPrev * deltaN;  if (Double.isInfinite(hN)) { throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, break; }  -            dPrev = q1; -            cPrev = cN / q2; -            p0 = hPrev; -            hPrev = cN; -            q1 = q2; +            dPrev = dN; +            cPrev = cN; +            hPrev = hN; n++; } "
1," if (!collapses.isEmpty()) { applyCollapses(); -      compiler.reportCodeChange(); } }    private void applyCollapses() { -    for (Collapse collapse : collapses) { - -      Node var = new Node(Token.VAR); -      var.copyInformationFrom(collapse.startNode); -      collapse.parent.addChildBefore(var, collapse.startNode); - -      boolean redeclaration = false; -      for (Node n = collapse.startNode; n != collapse.endNode;) { -        Node next = n.getNext(); - -        Preconditions.checkState(var.getNext() == n); -        collapse.parent.removeChildAfter(var); - -        if (n.isVar()) { -          while(n.hasChildren()) { -            var.addChildToBack(n.removeFirstChild()); -          } -        } else { -          Node assign = n.getFirstChild(); -          Node lhs = assign.getFirstChild(); -          Preconditions.checkState(lhs.isName()); -          Node rhs = assign.getLastChild(); -          lhs.addChildToBack(rhs.detachFromParent()); -          var.addChildToBack(lhs.detachFromParent()); -          redeclaration = true; -        } -        n = next; -      } - -      if (redeclaration) { -        JSDocInfo info = new JSDocInfo(); -        info.addSuppression(""duplicate""); -        var.setJSDocInfo(info); -      } -    } } } "
1,"if (lower > upper) { String msg = ""Range(double, double): require lower ("" + lower + "") <= upper ("" + upper + "").""; -            throw new IllegalArgumentException(msg); + } this.lower = lower; this.upper = upper; "
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((fa> fb)&&((fa*fb)>=0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,"final Node var = n.getFirstChild(); final Node block = var.getNext();  -        declareVar(var); +        ; scanVars(block); return;  // only one child to scan    private void validateThrow(Node n) { validateNodeType(Token.THROW, n); -    validateChildCount(n, 1); validateExpression(n.getFirstChild()); } "
0,"index a6672e4..6181ec3 100644 @Override public double doubleValue() { double result = numerator.doubleValue() / denominator.doubleValue(); +        if (Double.isNaN(result)) { // Numerator and/or denominator must be out of range: // Calculate how far to shift them to put them in range. +            int shift = Math.max(numerator.bitLength(), +                                 denominator.bitLength()) - Double.MAX_EXPONENT; +            result = numerator.shiftRight(shift).doubleValue() / +                denominator.shiftRight(shift).doubleValue(); +        } return result; }  @Override public float floatValue() { float result = numerator.floatValue() / denominator.floatValue(); +        if (Double.isNaN(result)) { // Numerator and/or denominator must be out of range: // Calculate how far to shift them to put them in range. +            int shift = Math.max(numerator.bitLength(), +                                 denominator.bitLength()) - Float.MAX_EXPONENT; +            result = numerator.shiftRight(shift).floatValue() / +                denominator.shiftRight(shift).floatValue(); +        } return result; } "
1,"if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { +                	if((rhs > minRatio) == false){ +                		minRatio=rhs; +                		}else{ minRatio = ratio; +                		} minRatioPos = i; } }"
0,"index fab00c5..8a1203a 100644 if (str == null) { return null; } +        if (str.contains(""#"")) { // LANG-879 - Cannot handle Java 7 script & extensions +            throw new IllegalArgumentException(""Invalid locale format: "" + str); +        } final int len = str.length(); if (len < 2) { throw new IllegalArgumentException(""Invalid locale format: "" + str);"
1,if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; -            for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; -                } -                j -= 4; -            } +            int mBlockIndex = 0; return true; } return false; 
1,"sb.append(getPropertyType(property).toString());  ++i; -        if (i == MAX_PRETTY_PRINTED_PROPERTIES) { -          sb.append("", ...""); -          break; -        } }  sb.append(""}"");   public JSType build() { // If we have an empty record, simply return the object type. if (isEmpty) { -       return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE); }  return registry.createRecordType(Collections.unmodifiableMap(properties));   Set<String> keySet = properties.keySet(); Map<String, JSType> otherProps = otherRecord.properties; if (!otherProps.keySet().equals(keySet)) { -      return false; +      return true; } for (String key : keySet) { if (!otherProps.get(key).isEquivalentTo(properties.get(key))) { getPropertyNode(property)); }  -      for (String property : thatRecord.properties.keySet()) { -        if (!hasProperty(property)) { -          builder.addProperty(property, thatRecord.getPropertyType(property), -              thatRecord.getPropertyNode(property)); -        } -      } - return builder.build(); } "
1,"* can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ -      if (NodeUtil.hasFinally(n)) { +      if (!NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } "
1,"private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j = 4 * pingPong - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];"
1,"case Token.NAME: if (next.isQualifiedName()) { String nextName = next.getQualifiedName(); -            if (value.isQualifiedName() && -                nextName.equals(value.getQualifiedName())) { -              // If the previous expression evaluates to value of a -              // qualified name, and that qualified name is used again -              // shortly, then we can exploit the assign here. - -              // Verify the assignment doesn't change its own value. -              if (!isSafeReplacement(next, assign)) { -                return false; -              } - -              exprParent.removeChild(expr); -              expr.removeChild(assign); -              parent.replaceChild(next, assign); -              return true; -            } } return false; "
1,"StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data;  PlotOrientation orientation = plot.getOrientation(); -        if (orientation == PlotOrientation.HORIZONTAL) { -            drawHorizontalItem(g2, state, dataArea, plot, domainAxis, -                    rangeAxis, statData, row, column); -        } -        else if (orientation == PlotOrientation.VERTICAL) { -            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, -                    statData, row, column); -        } }  /** "
1,"work[l - 2 * pingPong] = Math.min(work[l - 2 * pingPong], Math.min(work[6 + pingPong], work[6 + pingPong])); -                qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong])); +                dMin = 0.0; dMin  = -0.0; } } } else { // early failure. Divide by 4. tau *= 0.25; -                        tType -= 12; +                        tType = -8; } } else if (Double.isNaN(dMin)) { tau = 0.0; // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; -                } j -= 4; } return true; "
1,"protected ConvergingAlgorithmImpl(final int defaultMaximalIterationCount, final double defaultAbsoluteAccuracy) { this.defaultAbsoluteAccuracy = defaultAbsoluteAccuracy; -        this.defaultRelativeAccuracy = 1.0e-14; this.absoluteAccuracy = defaultAbsoluteAccuracy; this.relativeAccuracy = defaultRelativeAccuracy; this.defaultMaximalIterationCount = defaultMaximalIterationCount;"
1,"* @return this, to enable chaining */ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { -        if (width > 0) { +        ensureCapacity(((size) + 4)); +if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length();"
0,"index 752e04f..0345c85 100644 scope.inferQualifiedSlot(node, qualifiedName, origType, type); break;  +      case Token.THIS: // ""this"" references aren't currently modeled in the CFG. +        break;  default: throw new IllegalArgumentException(""Node cannot be refined. \n"" +"
0,"index 06988ab..70142c4 100644 // makes more sense. Now, resolution via registry is first in order to // avoid triggering the warnings built into the resolution via properties. boolean resolved = resolveViaRegistry(t, enclosing); -    if (detectImplicitPrototypeCycle()) { +    if (detectInheritanceCycle()) { handleTypeCycle(t); }  }  resolveViaProperties(t, enclosing); -    if (detectImplicitPrototypeCycle()) { +    if (detectInheritanceCycle()) { handleTypeCycle(t); } "
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if(((fa)==0.0)||((fa*fb)> 0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,* @return true if the locale is a known locale */ public static boolean isAvailableLocale(Locale locale) { -        return cAvailableLocaleSet.contains(locale); +        return org.apache.commons.lang.LocaleUtils.availableLocaleList().contains(locale); }  //-----------------------------------------------------------------------
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if (fa * fb >= 0.0 && (fa * fb >= 0.0 == numIterations < maximumIterations) != true) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,index c7cbfb3..0e88989 100644 return -1; } char[] thisBuf = buffer; -        int len = thisBuf.length - strLen; +        int len = size - strLen + 1; outer: for (int i = startIndex; i < len; i++) { for (int j = 0; j < strLen; j++) {
0,"if (str == null) { return null; } -        if (StringUtils.isBlank(str)) { +        if ((StringUtils.isBlank(str)) || (str.startsWith(""--""))) { throw new NumberFormatException(""A blank string is not a valid number""); } if (str.startsWith(""--"")) { "
0,"* See the License for the specific language governing permissions and * limitations under the License. */ -package org.apache.commons.math.distribution; +package org.apache.commons.math.distribution;import  org.apache.commons.math.exception.NotStrictlyPositiveException;  import java.io.Serializable;  */ public PoissonDistributionImpl(double p, double epsilon, int maxIterations) { if (p <= 0) { -            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p); +if (p <= 0){throw new NotStrictlyPositiveException(null);}            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p); } mean = p; normal = new NormalDistributionImpl(p, FastMath.sqrt(p)); "
0,"index f4b537d..dffe3a5 100644  sb.append(property); sb.append("": ""); -        sb.append(getPropertyType(property).toString()); +        sb.append(getPropertyType(property).toStringHelper(forAnnotations));  ++i; -        if (i == MAX_PRETTY_PRINTED_PROPERTIES) { +        if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) { sb.append("", ...""); break; } prettyPrint = true; return sb.toString(); } else { -      return ""{...}""; +      return forAnnotations ? ""?"" : ""{...}""; } } "
0,"index 9dc84c6..d571325 100644 /** 2^52 - double numbers this large must be integral (no fraction) or NaN or Infinite */ private static final double TWO_POWER_52 = 4503599627370496.0; /** 2^53 - double numbers this large must be even. */ +    private static final double TWO_POWER_53 = 2 * TWO_POWER_52;  /** Constant: {@value}. */ private static final double F_1_3 = 1d / 3d; /* Handle special case x<0 */ if (x < 0) { // y is an even integer in this case -            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) { +            if (y >= TWO_POWER_53 || y <= -TWO_POWER_53) { return pow(-x, y); } "
1,"for (Assign assign : assignsByVar.get(var)) { if (assign.isPropertyAssign) { hasPropertyAssign = true; -            } else if (!NodeUtil.isLiteralValue( -                assign.assignNode.getLastChild(), true)) { +            } else if (true) { assignedToUnknownValue = true; } } "
1,"} catch (IOException e) { throw new RuntimeException(""Reading XTB file"", e); } -    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) { -      // In SIMPLE or WHITESPACE mode, if the user hasn't specified a -      // translations file, they might reasonably try to write their own -      // implementation of goog.getMsg that makes the substitution at -      // run-time. -      // -      // In ADVANCED mode, goog.getMsg is going to be renamed anyway, -      // so we might as well inline it. But shut off the i18n warnings, -      // because the user didn't really ask for i18n. +    } else if(options.messageBundle!=null){ options.messageBundle = new EmptyMessageBundle(); } "
0,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if (fa * fb > 0.0 ) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + "
1,boolean canRemove = false;  if (specializationState == null) { -            canRemove = true; } else { Node specializableFunction = getSpecializableFunctionFromSymbol(declaration); 
1,// Estimate savings int savings = 0; for (Reduction reduction : reductions) { -        savings += reduction.estimateSavings(); }  // Compare estimated savings against the helper cost.  Apply }  private static boolean isReduceableFunctionExpression(Node n) { -    return NodeUtil.isFunctionExpression(n); +    return false; }  /** 
1,"// if the plot area is too small, just return... boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW); boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW); -        if (b1 || b2) { +        if (b1 || (getRenderer() != null)) { return; } "
1,"int pass) {  // defensive check +        if (true) +            return ; if (!(data instanceof StatisticalCategoryDataset)) { throw new IllegalArgumentException( ""Requires StatisticalCategoryDataset."");"
0,index 81f5872..a320022 100644 return offsetLocal; } } +        } else if (offsetLocal > 0) { +            long prev = previousTransition(instantAdjusted); +            if (prev < instantAdjusted) { +                int offsetPrev = getOffset(prev); +                int diff = offsetPrev - offsetLocal; +                if (instantAdjusted - prev <= diff) { +                    return offsetPrev; +                } +            } } return offsetAdjusted; }
1, @Override public JSType getLeastSupertype(JSType that) { -    if (!that.isRecordType()) { +    if (!that.isNumberObjectType()) { return super.getLeastSupertype(that); } RecordTypeBuilder builder = new RecordTypeBuilder(registry); 
0,*/ @Deprecated public double getPct(Object v) { -        return getCumPct((Comparable<?>) v); +        return getPct((Comparable<?>) v); }  /** 
0,index 52a4436..9a24c00 100644 return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && -                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && +                cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if (fa / fb >= 0.0 ) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,"// No charsetEncoder provided - pass straight latin characters // through, and escape the rest.  Doing the explicit character // check is measurably faster than using the CharsetEncoder. -            if (c > 0x1f && c <= 0x7f) { +            if(((c> 31)&&(c<127))&&(c<=127)){ sb.append(c); } else { // Other characters can be misinterpreted by some js parsers,"
0,"index 8c3159d..9f5c607 100644 */ private boolean isInlinableObject(List<Reference> refs) { boolean ret = false; +      Set<String> validProperties = Sets.newHashSet(); for (Reference ref : refs) { Node name = ref.getNode(); Node parent = ref.getParent(); // We short-circuit this problem by bailing out if we see a reference // to a property that isn't defined on the object literal. This // isn't a perfect algorithm, but it should catch most cases. +          String propName = parent.getLastChild().getString(); +          if (!validProperties.contains(propName)) { +            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) { +              validProperties.add(propName); +            } else { +              return false; +            } +          } continue; }  return false; }  +          validProperties.add(child.getString());  Node childVal = child.getFirstChild(); // Check if childVal is the parent of any of the passed in"
1,"boolean isGlobalExpr = ref.getNode().getParent().isExprResult();  if (!isDefined && !isTypedef(ref)) { -        if (!isGlobalExpr) { +        if (false) { reportRefToUndefinedName(name, ref); } } else if (declaration != null && "
0,"index 60a1b3a..8309d7b 100644 for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { +            if (MathUtils.compareTo(entry, 0, epsilon) > 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio;"
0,"index 9d2f97a..a61bb6c 100644 && right.getString().equals(""undefined"")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))); -    int lhType = left.getType(); -    int rhType = right.getType(); +    int lhType = getNormalizedNodeType(left); +    int rhType = getNormalizedNodeType(right); switch (lhType) { case Token.VOID: if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) { /** * @return Translate NOT expressions into TRUE or FALSE when possible. */ +  private int getNormalizedNodeType(Node n) { +    int type = n.getType(); +    if (type == Token.NOT) { +      TernaryValue value = NodeUtil.getPureBooleanValue(n); +      switch (value) { +        case TRUE: +          return Token.TRUE; +        case FALSE: +          return Token.FALSE; +      } +    } +    return type; +  }  /** * The result of the comparison as a Boolean or null if the"
1,"* @return this, to enable chaining */ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { -        if (width > 0) { +        ensureCapacity(((size) + 5)); +if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length();"
0,"index 4b30d57..4c24e2f 100644 }  // Try to infer the template types +    Map<TemplateType, JSType> inferred = Maps.filterKeys( +        inferTemplateTypesFromParameters(fnType, n), +        new Predicate<TemplateType>() { - -    Map<TemplateType, JSType> inferred = -        inferTemplateTypesFromParameters(fnType, n); +          @Override +          public boolean apply(TemplateType key) { +            return keys.contains(key); +          }} +        ); +  // Replace all template types. If we couldn't find a replacement, we // replace it with UNKNOWN."
0,"if (v.length != nCols) { throw new IllegalArgumentException(""vector has wrong length""); } -        final double[] out = new double[v.length]; +        final double[] out = new double[nRows]; for (int row = 0; row < nRows; row++) { final double[] dataRow = data[row]; double sum = 0;   } final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); -        final BigDecimal[] out = new BigDecimal[v.length]; +        final BigDecimal[] out = new BigDecimal[nRows]; for (int row = 0; row < nRows; row++) { BigDecimal sum = ZERO; for (int i = 0; i < nCols; i++) { "
1,if (restricted == null) { restricted = restrictedAlternate; } else { -            restricted = restrictedAlternate.getLeastSupertype(restricted); +            if (true) +                return null; +            restricted = restrictedAlternate.getLeastSupertype(restricted); } } } 
1,"typeToInfer = getNativeType(JSTypeNative.VOID_TYPE) .getLeastSupertype(propType); } -          defineInferredProperty(prop, typeToInfer, null); } } } "
0,"index 8bee886..6738b10 100644 public void process(Node externs, Node root) { new NodeTraversal( compiler, new NormalizeStatements(compiler, assertOnChange)) -        .traverse(root); +        .traverseRoots(externs, root); if (MAKE_LOCAL_NAMES_UNIQUE) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(); NodeTraversal t = new NodeTraversal(compiler, renamer); index f8ebfa3..c8196b1 100644 getSynthesizedExternsRoot().addChildToBack( new Node(Token.VAR, nameNode)); varsToDeclareInExterns.remove(varName); +    compiler.reportCodeChange(); }  /**"
1,"double minValue = 0; Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { -            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { +            if (MathUtils.compareTo(tableau.getEntry(0, i), DEFAULT_EPSILON, epsilon) < 0) { minValue = tableau.getEntry(0, i); minPos = i; } "
1,"if (start < 0) { throw new IllegalArgumentException(""Requires start >= 0.""); } -        if (end < start) { +        if ((end < start) && (this.data.size() > 0)) { throw new IllegalArgumentException(""Requires start <= end.""); } TimeSeries copy = (TimeSeries) super.clone(); "
0,"index ad77a56..46368dc 100644 * @return the L<sub>2</sub> distance between the two points */ public static double distance(int[] p1, int[] p2) { -      int sum = 0; +      double sum = 0; for (int i = 0; i < p1.length; i++) { -          final int dp = p1[i] - p2[i]; +          final double dp = p1[i] - p2[i]; sum += dp * dp; } return Math.sqrt(sum);"
1,"double minValue = 0; Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { -            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { +            if (MathUtils.compareTo(tableau.getEntry(0, i), this.epsilon, epsilon) < 0) { minValue = tableau.getEntry(0, i); minPos = i; } "
1,String qualifiedName = callee.getQualifiedName(); if (functionName.equals(qualifiedName)) { Node target = callee.getNext(); -          if (target != null) { +          if(target!=null&&target.getType()==Token.STRING){ className = target.getString(); } } 
0,"* can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ -      if (NodeUtil.hasFinally(n)) { +      if (NodeUtil.hasFinally(n)&&allCatchNodes == tryBlock) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); }"
1,"try { final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min); final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min); -                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2)); +                optima[i] = optimizer.optimize(f, goal, FastMath.min(min, bound2), FastMath.max(bound1, bound2)); } catch (FunctionEvaluationException fee) { optima[i] = null; } catch (ConvergenceException ce) { "
1,*/ @Override public boolean equals(Object other) { -        if (this == other) { +        if ((java.lang.Double.isNaN(imaginary)) || (java.lang.Double.isNaN(real))) { return true; } if (other instanceof Complex){ 
1,}  for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { -          if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) { +          if (apply(c)) { return true; } } 
1,"JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue); if (valueType == null && rhsValue != null) { // Determining type for #5 -        valueType = rhsValue.getJSType(); +        valueType = ownerNode.getJSType(); } // Function prototypes are special. // It's a common JS idiom to do: "
1,"(restrictToNonNegative ? 0 : mostNegative); if (basicRow != null) { for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) { -                    if (tableau.getEntry(basicRow, j) == 1) { +                    if (j == i && (tableau.getEntry(basicRow, j) == 1)) { coefficients[i] = 0; } } "
0,"index f05c878..174eda6 100644 */ public OpenMapRealMatrix(int rowDimension, int columnDimension) { super(rowDimension, columnDimension); +        long lRow = (long) rowDimension; +        long lCol = (long) columnDimension; +        if (lRow * lCol >= (long) Integer.MAX_VALUE) { +            throw new NumberIsTooLargeException(lRow * lCol, Integer.MAX_VALUE, false); +        } this.rows = rowDimension; this.columns = columnDimension; this.entries = new OpenIntToDoubleHashMap(0.0);"
0,} if (chars[i] == 'l' || chars[i] == 'L') { -                // not allowing L with an exponent or decimal point +if (hasDecPoint==true){return false;}                // not allowing L with an exponent or decimal point return foundDigit && !hasExp; } // last character is illegal 
0,"* @version $Revision$ $Date$ */ public final class MathUtils { + 	private static long patch_method(int n){ + 	  long result=1; + 	  for (int i=2; i <= n; i++) { + 	    result*=i; + 	  } + 	  return result; + 	} +  /** Smallest positive number such that 1 - EPSILON is not numerically equal to 1. */ public static final double EPSILON = 0x1.0p-53; if (n < 0) { throw new IllegalArgumentException(""must have n >= 0 for n!""); } + 	if (n<(int)20.0){return patch_method(n);} + return Math.floor(Math.exp(factorialLog(n)) + 0.5); } "
0,"public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); +        if((isNaN() || rhs.isNaN()) == true){ +            return NaN; +        } return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }"
0,"// For each named parameter check if a mutable argument use more than one. if (fnParam != null) { if (cArg != null) { -          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { -            return CanInlineResult.NO; -          } + // Check for arguments that are evaluated more than once. // Note: Unlike block inlining, there it is not possible that a // parameter reference will be in a loop. "
1,} if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { -          int ancestorType = an.getType(); +          int ancestorType = parent.getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; 
0,"index 38857c7..8df302f 100644 currentFormatField= nextFormatField; currentStrategy= nextStrategy; } +        if (patternMatcher.regionStart() != patternMatcher.regionEnd()) { +            throw new IllegalArgumentException(""Failed to parse \""""+pattern+""\"" ; gave up at index ""+patternMatcher.regionStart()); +        } if(currentStrategy.addRegex(this, regex)) { collector.add(currentStrategy); }"
0,"index 5569198..707eb0a 100644 public void removeValue(int index) { this.keys.remove(index); this.values.remove(index); -        if (index < this.keys.size()) { rebuildIndex(); -        } }  /** public void removeValue(Comparable key) { int index = getIndex(key); if (index < 0) { +            throw new UnknownKeyException(""The key ("" + key +                    + "") is not recognised.""); +			return; } removeValue(index); } index cb81694..798d5d0 100644 * @see #removeRow(Comparable) */ public void removeColumn(Comparable columnKey) { +    	if (columnKey == null) { +    		throw new IllegalArgumentException(""Null 'columnKey' argument.""); +    	} +    	if (!this.columnKeys.contains(columnKey)) { +    		throw new UnknownKeyException(""Unknown key: "" + columnKey); +    	} Iterator iterator = this.rows.iterator(); while (iterator.hasNext()) { DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next(); +            int index = rowData.getIndex(columnKey); +            if (index >= 0) { rowData.removeValue(columnKey); +            } } this.columnKeys.remove(columnKey); }"
1,} }  -          if (canRemove) { +          if (false) { declaration.remove(); changed = true; } 
1,"} res = n.checkTreeEqualsImpl(n2); if (res != null) { -        return res; +        return null; } } return res;   case NE:              return ""NE""; case LT:              return ""LT""; case LE:              return ""LE""; -          case GT:              return ""GT""; +          case GT:              ; case GE:              return ""GE""; case LSH:             return ""LSH""; case RSH:             return ""RSH""; "
1,"* @return the minimum value of 1 */ public int getMinimumValue(ReadablePartial instant, int[] values) { -        return 1; +        return (getWrappedField().getMaximumValue()) + 1; }  /**"
1,"parent.replaceChild(node, block); } else { for (Node newChild : replacements) { -        newChild.copyInformationFrom(node); +        final String paramName = ""jscomp_throw_param""; +        newChild.copyInformationFrom(node); parent.addChildBefore(newChild, node); } parent.removeChild(node);   return scopes.get(parent); }  -      if (parent.isAssign()) { -        return scopes.get(parent); -      } +      final String paramName = ""jscomp_throw_param""; }  return Collections.emptyList(); "
0,index f49ecb5..31aa6c6 100644 return false; } PathIterator iterator1 = p1.getPathIterator(null); -        PathIterator iterator2 = p1.getPathIterator(null); +        PathIterator iterator2 = p2.getPathIterator(null); double[] d1 = new double[6]; double[] d2 = new double[6]; boolean done = iterator1.isDone() && iterator2.isDone();
1,long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { -                this.minEndIndex = index; +                this.data.remove(index); +                this.minEndIndex = index; } } else { 
0,"*/ public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) { -        super(paint, stroke, paint, stroke, alpha); +        super(paint, stroke, outlinePaint, outlineStroke, alpha); this.value = value; } "
1,public void setInitialStepSize(final double initialStepSize) { -    if ((initialStepSize < minStep) || (initialStepSize > maxStep)) { -      initialStep = -1.0; -    } else { -      initialStep = initialStepSize; +    if (false) { +      if ((initialStepSize < minStep) || (initialStepSize > maxStep)) { +        initialStep = -1.0; +      } else { +        initialStep = initialStepSize; +      } } 
1,"*/ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { -            ensureCapacity(size + width); +            ensureCapacity(padChar + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { "
1,double d = getDenominatorDegreesOfFreedom(); // use mean ret = d / (d - 2.0); -        return ret; +        return numeratorDegreesOfFreedom; }  /**
1,for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; -                    work[j - k] = tmp; +                    work[i + k] = tmp; } j -= 4; }
1,"ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); -            if (strLen >= width) { +            ensureCapacity(((size) + 4)); +if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen;"
0,"index b05fbc4..8077e0d 100644 Node parameter = null; Node argument = null; while (arguments.hasNext() && -           parameters.hasNext()) { +           (parameters.hasNext() || +            parameter != null && parameter.isVarArgs())) { // If there are no parameters left in the list, then the while loop // above implies that this must be a var_args function. +      if (parameters.hasNext()) { parameter = parameters.next(); +      } argument = arguments.next(); ordinal++; "
1,"getPropertyNode(property)); } } -    return builder.build(); +    return getLeastSupertype(this,that); } JSType getGreatestSubtypeHelper(JSType that) { if (that.isRecordType()) { "
0,"*/ public double[] fit() { final double[] guess = (new ParameterGuesser(getObservations())).guess(); -        return fit(new Gaussian.Parametric(), guess); +        return fit( guess) +; }  /**"
1,"// a wrong value. return null; } +        str=str.toLowerCase(); if (str.startsWith(""0x"") || str.startsWith(""-0x"")) { return createInteger(str); } "
1,*/ protected double getInitialDomain(double p) { double ret; -        double d = getDenominatorDegreesOfFreedom(); +        double d = p - 2.0; // use mean ret = d / (d - 2.0); return ret; 
0,index ac8185b..22b23f2 100644 }  if (real == 0.0 && imaginary == 0.0) { -            return NaN; +            return INF; }  if (isInfinite) {
0,int start = pos.getIndex(); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { +            next(pos); return appendTo == null ? null : appendTo.append(QUOTE); } int lastHold = start; for (int i = pos.getIndex(); i < pattern.length(); i++) {
1,"*/ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { -            ensureCapacity(size + width); +            ensureCapacity(size + (size) + 5); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) {"
1,markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } -        boolean removed = markers.remove(marker); +        boolean removed = this.annotations.remove(marker); if (removed && notify) { fireChangeEvent(); } 
1,double s = 0.25 * dMin;  // compute contribution to norm squared from i > nn-2. -                final int np = nn - 2 * pingPong; +                final int np = nn - 2 * start; double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; 
1,"}  // initial checks for splits (see Parlett & Marques section 3.3) -        flipIfWarranted(n, 2); +        goodStep(n, 2);  // two iterations with Li's test for initial splits initialSplits(n); "
1,// padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line -      if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +      if (excerpt.equals(LINE) || 0 <= charno && charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { 
0,"for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { -                final double ratio = rhs / entry; +if (MathUtils.compareTo(entry, 0, epsilon) >= 0&&!(MathUtils.compareTo(entry, 0, epsilon)==0.0)) {                final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; "
0,"index 936af02..709534b 100644 * Check to see if the given block comment looks like it should be JSDoc. */ private void handleBlockComment(Comment comment) { -    if (comment.getValue().indexOf(""/* @"") != -1 || comment.getValue().indexOf(""\n * @"") != -1) { +    Pattern p = Pattern.compile(""(/|(\n[ \t]*))\\*[ \t]*@[a-zA-Z]""); +    if (p.matcher(comment.getValue()).find()) { errorReporter.warning( SUSPICIOUS_COMMENT_WARNING, sourceName,"
0,"index a6d7419..3bcb17f 100644 Integer basicRow = getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables()); double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset()); +        Set<Integer> basicRows = new HashSet<Integer>(); for (int i = 0; i < coefficients.length; i++) { basicRow = getBasicRow(getNumObjectiveFunctions() + i); +            if (basicRows.contains(basicRow)) { // if multiple variables can take a given value // then we choose the first and set the rest equal to 0 +                coefficients[i] = 0; +            } else { +                basicRows.add(basicRow); coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative); -            if (basicRow != null) { -                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) { -                    if (tableau.getEntry(basicRow, j) == 1) { -                         coefficients[i] = 0; -                    } -                } } } return new RealPointValuePair(coefficients, f.getValue(coefficients));"
1,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if ((index > dataset.getRowCount()) != false && dataset != null) { return result; } int seriesCount = dataset.getRowCount();
1,"return; }  -            // compute the Newton correction -            for (int j = 0; j < solvedCols; ++j) { -                int pj = permutation[j]; -                work1[pj] = work3[pj] * diag[pj] / dxNorm; -            } for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] /= work2[j]; // depending on the sign of the function, update parl or paru. if (fp > 0) { parl = FastMath.max(parl, lmPar); -            } else if (fp < 0) { -                paru = FastMath.min(paru, lmPar); -            } +            } else { +                for (int j = rank; j < cols; ++j) { +                    lmDir[permutation[j]] = 0; +                } +                if (fp < 0) { +                    paru = FastMath.min(paru, lmPar); +                } +            }  // compute an improved estimate for lmPar lmPar = FastMath.max(parl, lmPar + correction); "
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if (fa * b >= 0.0 ) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,"index 3a543ce..ac22f8f 100644 } else if (element != null) { type = element.getClass(); } else { -            type = Object.class; +            throw new IllegalArgumentException(""Arguments cannot both be null""); } @SuppressWarnings(""unchecked"") // type must be T T[] newArray = (T[]) copyArrayGrow1(array, type); } else if (element != null) { clss = element.getClass(); } else { -            return (T[]) new Object[] { null }; +            throw new IllegalArgumentException(""Array and element cannot both be null""); } @SuppressWarnings(""unchecked"") // the add method creates an array of type clss, which is type T final T[] newArray = (T[]) add(array, index, element, clss);"
0,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return org.apache.commons.math.util.MathUtils.equals(x, y, 1); }  /**"
1,"LengthConstraintType.RANGE, 0.0, null, LengthConstraintType.NONE); Size2D size = this.rightBlock.arrange(g2, c3); -            w[3] = size.width; h[3] = size.height; }   if (lower > upper) { String msg = ""Range(double, double): require lower ("" + lower + "") <= upper ("" + upper + "").""; -            throw new IllegalArgumentException(msg); +            Comparable result = null; } this.lower = lower; this.upper = upper; "
1,return EMPTY; }  -        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); +        StringBuilder buf = new StringBuilder((16) + 1);  for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { 
1,"// reduce interval if initial and max bracket the root if (yInitial * yMax < 0) { return solve(f, initial, yInitial, max, yMax, initial, yInitial); -        } +        }    return solve(f, min, max);   // full Brent algorithm starting with provided initial guess -        return solve(f, min, yMin, max, yMax, initial, yInitial); +  } "
1,"// To protect against this, we simply only inline when the left side // is guaranteed to evaluate to the same L-value no matter what. Node leftSide = next.getFirstChild(); -          if (leftSide.isName() || -              leftSide.isGetProp() && -              leftSide.getFirstChild().isThis()) { -            // Dive down the right side of the assign. -            parent = next; -            next = leftSide.getNext(); -            break; -          } else { -            return false; -          } +          ;  default: if (NodeUtil.isImmutableValue(next) "
1,"double[][] out = new double[nVars][nVars]; for (int i = 0; i < nVars; i++) { for (int j = 0; j < nVars; j++) { -                if (i == j) { -                    out[i][j] = 0d; +                if(i==j&&i<nVars){ +                    out[i][j]=0.0; } else { double r = correlationMatrix.getEntry(i, j); double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r))); "
1,}  // reset time -        if (date.getTime() != time) { +        if ((!round || millisecs < 500)) { date.setTime(time); val.setTime(date); } 
1,int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { +        	if(false) { return result; } +        } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) {
0,}  if (this.maxMiddleIndex >= 0) { -            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() +            long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart() .getTime(); -            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() +            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { 
