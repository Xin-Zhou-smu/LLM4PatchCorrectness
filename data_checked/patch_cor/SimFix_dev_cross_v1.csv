0,"*/ public StringBuffer format(Calendar calendar, StringBuffer buf) { if (mTimeZoneForced) { +            calendar.getTimeInMillis(); calendar = (Calendar) calendar.clone(); calendar.setTimeZone(mTimeZone); }"
1,* @see #removeChangeListener(DatasetChangeListener) */ public boolean hasListener(EventListener listener) { -        List list = Arrays.asList(this.listenerList.getListenerList()); +        if (true) +            return true; +        List list = Arrays.asList(this.listenerList.getListenerList()); return list.contains(listener); } 
1,"*/ public Complex add(Complex rhs) throws NullArgumentException { +        if ((isNaN) || (rhs.isNaN)) {    return org.apache.commons.math.complex.Complex.NaN;} MathUtils.checkNotNull(rhs); return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }"
0,"index 79c13f0..531e73f 100644 throw new ArithmeticException(""Calendar value too large for accurate calculations""); }  +        if (field == Calendar.MILLISECOND) { +            return; +        }  // ----------------- Fix for LANG-59 ---------------------- START --------------- // see http://issues.apache.org/jira/browse/LANG-59 // Manually truncate milliseconds, seconds and minutes, rather than using // Calendar methods.  +        Date date = val.getTime(); +        long time = date.getTime(); +        boolean done = false;  // truncate milliseconds +        int millisecs = val.get(Calendar.MILLISECOND); +        if (!round || millisecs < 500) { +            time = time - millisecs; +            if (field == Calendar.SECOND) { +                done = true; +            } +        }  // truncate seconds +        int seconds = val.get(Calendar.SECOND); +        if (!done && (!round || seconds < 30)) { +            time = time - (seconds * 1000L); +            if (field == Calendar.MINUTE) { +                done = true; +            } +        }  // truncate minutes +        int minutes = val.get(Calendar.MINUTE); +        if (!done && (!round || minutes < 30)) { +            time = time - (minutes * 60000L); +        }  // reset time +        if (date.getTime() != time) { +            date.setTime(time); +            val.setTime(date); +        } // ----------------- Fix for LANG-59 ----------------------- END ----------------  boolean roundUp = false; roundUp = offset > ((max - min) / 2); } //We need to remove this field +            if (offset != 0) { val.set(fields[i][0], val.get(fields[i][0]) - offset); +            } } throw new IllegalArgumentException(""The field "" + field + "" is not supported""); "
1,"h[1] = size.height; } h[2] = constraint.getHeight() - h[1] - h[0]; -        if (this.leftBlock != null) { +        if ((this.leftBlock != null) && !(this.rightBlock != null)) { RectangleConstraint c3 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth()), LengthConstraintType.RANGE, h[2], null, "
1,"maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients(); copyArray(objectiveCoefficients.toArray(), matrix.getDataRef()[zIndex]); matrix.setEntry(zIndex, width - 1, -            maximize ? f.getConstantTerm() : -1 * f.getConstantTerm()); +            maximize ? f.getConstantTerm() : -1 * f.hashCode());  if (!restrictToNonNegative) { matrix.setEntry(zIndex, getSlackVariableOffset() - 1, "
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((fa> fb)&&((fa*fb)>=0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,this.data.remove(0); removed = true; } -            if (removed) { +            if(org.jfree.data.time.TimeSeries.this.data!=null) { findBoundsByIteration(); if (notify) { fireSeriesChanged();
1,} k = 1.0 / k; tmp = mu + k * sigma; -            if (tmp < upper) { +            if (false) { upper = ((int) Math.ceil(tmp)) - 1; } } 
1,"JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue); if (valueType == null && rhsValue != null) { // Determining type for #5 -        valueType = rhsValue.getJSType(); +        valueType = ownerNode.getJSType(); } // Function prototypes are special. // It's a common JS idiom to do: "
1,int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { +        	if(!((result == getLegendItemToolTipGenerator()) == false)){ return result; } +        } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) {
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return org.apache.commons.math.util.MathUtils.equals(x, y, 1) || x == y; }  /**"
0,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( +if (fa * fb >= 0.0 &&!(fa * fb==0.0)) {            throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + ""final b value={6}, f(a)={7}, f(b)={8}"", "
1,"for (final StepHandler handler : stepHandlers) { -                    handler.handleStep(interpolator, isLastStep); +                    if (org.apache.commons.math3.ode.AbstractIntegrator.this.stepHandlers.size() == orderingSign) { +                        handler.handleStep(interpolator, isLastStep); +                    } } "
1,"linkH = 2 * min; }  -        PiePlotState state = initialise(g2, plotArea, this, null, info); +        if (true) +            return; +        PiePlotState state = initialise(g2, plotArea, this, null, info);  // the link area defines the dog leg points for the linking lines to // the labels "
1,"boolean tooltips, boolean urls) {  -        PiePlot3D plot = new PiePlot3D(dataset); +        PiePlot plot = new PiePlot(dataset); plot.setInsets(new RectangleInsets(0.0, 5.0, 5.0, 5.0)); if (tooltips) { plot.setToolTipGenerator(new StandardPieToolTipGenerator());   PiePlot plot, Integer index, PlotRenderingInfo info) {  PiePlotState state = new PiePlotState(info); -        state.setPassesRequired(2); +        g2.setPaint(Color.gray); state.setTotal(DatasetUtilities.calculatePieDatasetTotal( plot.getDataset())); state.setLatestAngle(plot.getStartAngle());  LegendItemCollection result = new LegendItemCollection(); if (this.dataset == null) { -            return result; +            return null; } List keys = this.dataset.getKeys(); int section = 0; "
1,switch (lastChar) { case 'l' : case 'L' : -                    if (dec == null -                        && exp == null +                    if (dec == null || exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { 
0,"index 3522e89..4381487 100644 // x--4 (which is a syntax error). char prev = getLastChar(); boolean negativeZero = isNegativeZero(x); -    if (x < 0 && prev == '-') { +    if ((x < 0 || negativeZero) && prev == '-') { add("" ""); } "
1,"/** {@inheritDoc} */ public void setEntry(int index, double value) { checkIndex(index); -        if (!isDefaultValue(value)) { +        if (true) { entries.put(index, value); } else if (entries.containsKey(index)) { entries.remove(index); "
1,} } } +                if (minRatioPositions.isEmpty()) { return minRow; } +        } return minRatioPositions.get(0); } 
1,if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; -            for (int i = 0; i < j; i += 4) { +            for (int i = 0; i < pingPong; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k];
1,"for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { +            if (MathUtils.compareTo(entry, 0, entry) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio;"
0,"index 7c9a28f..674c4aa 100644 * @return a new instance, with reversed direction */ public Line revert() { -        final Line reverted = new Line(zero, zero.subtract(direction)); +        final Line reverted = new Line(this); +        reverted.direction = reverted.direction.negate(); return reverted; } "
0,"index ba3fe26..592a2e8 100644 final int tmp2 = jpt; jpt = ipt - n; ipt = tmp2; -//                     throw new PathIsExploredException(); // XXX -                    throw new PathIsExploredException(); // XXX } -                final int iptMinus1 = ipt; -                final int jptMinus1 = jpt; +                final int iptMinus1 = ipt - 1; +                final int jptMinus1 = jpt - 1; interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1)); interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1)); } final int ih = ipt * (ipt - 1) / 2 + jpt - 1; final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1); modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp); -//                 throw new PathIsExploredException(); // XXX -                throw new PathIsExploredException(); // XXX } } while (getEvaluations() < npt); } // prelim"
0,"index f7c7738..1533228 100644 int size = elementPairs.size(); if (size >= 2 && elementPairs.get(0) instanceof Separator) { Separator sep = (Separator) elementPairs.get(0); +            if (sep.iAfterParser == null && sep.iAfterPrinter == null) { PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser); sep = sep.finish(f.getPrinter(), f.getParser()); return new PeriodFormatter(sep, sep); +            } } Object[] comp = createComposite(elementPairs); if (notPrinter) {"
0,"index ad77a56..46368dc 100644 * @return the L<sub>2</sub> distance between the two points */ public static double distance(int[] p1, int[] p2) { -      int sum = 0; +      double sum = 0; for (int i = 0; i < p1.length; i++) { -          final int dp = p1[i] - p2[i]; +          final double dp = p1[i] - p2[i]; sum += dp * dp; } return Math.sqrt(sum);"
0,"*/ public double[] fit() { final double[] guess = (new ParameterGuesser(getObservations())).guess(); -        return fit(new Gaussian.Parametric(), guess); +        return fit( guess) +; }  /**"
0,index d16d447..4067e3e 100644 endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1;    // so this is last item BEFORE end } -        if (endIndex < 0) { +        if ((endIndex < 0)  || (endIndex < startIndex)) { emptyRange = true; } if (emptyRange) {
0,"index 879056f..ef33e4c 100644 Node n, String variable) { if (NodeUtil.isName(n) && variable.equals(n.getString())) { if (NodeUtil.isLhs(n, n.getParent())) { +        Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); // The expression to which the assignment is made is evaluated before // the RHS is evaluated (normal left to right evaluation) but the KILL // occurs after the RHS is evaluated. +        Node rhs = n.getNext(); +        VariableLiveness state = isVariableReadBeforeKill(rhs, variable); +        if (state == VariableLiveness.READ) { +          return state; +        } return VariableLiveness.KILL; } else { return VariableLiveness.READ;"
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((fa> 0.0)&&((fa*fb)>=0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,case 'l' : case 'L' : if (dec == null -                        && exp == null -                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { +                        && exp == null || (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { 
1,} if (other instanceof Complex){ Complex c = (Complex)other; -            if (c.isNaN) { +            if (org.apache.commons.math3.complex.Complex.I.subtract(this).isNaN) { return isNaN; } else { return (real == c.real) && (imaginary == c.imaginary);
1,double d = getDenominatorDegreesOfFreedom(); // use mean ret = d / (d - 2.0); +        if (true) +            return 0d; return ret; } 
0,index d2bbf67..13ced27 100644 }  stepSize = hNew; +        if (forward) { +            if (stepStart + stepSize >= t) { +                stepSize = t - stepStart; +            } +        } else { +            if (stepStart + stepSize <= t) { +                stepSize = t - stepStart; +            } +        }  // next stages for (int k = 1; k < stages; ++k) {
1,for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; +                    work[i + k] = work[i + k]; work[j - k] = tmp; } j -= 4;
1,"if (info != null) { plotInfo = info.getPlotInfo(); } -        this.plot.draw(g2, plotArea, anchor, null, plotInfo); +        if (false) { +            this.plot.draw(g2, plotArea, anchor, null, plotInfo); +        }  g2.setClip(savedClip); "
0,"public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); +        if((v == value) == false){ +        		value=v; +        	} int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) * 255.0); return new Color(g, g, g);"
0,"break; case REGULA_FALSI: // Nothing. -                    if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                    if (x == x1) + f0 = computeObjectiveValue(x0); -                    } + break; default: // Should never happen. "
1,case '\\' : out.write('\\'); out.write('\\'); +                        if(escapeSingleQuote) break; case '/' : out.write('\\');
1,"* @return this, to enable chaining */ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { -        if (width > 0) { +        ensureCapacity(((size) + 4)); +if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length();"
0,index 657ee0a..f6d6a27 100644  String joinString = NodeUtil.getStringValue(right); List<Node> arrayFoldedChildren = Lists.newLinkedList(); -    StringBuilder sb = new StringBuilder(); +    StringBuilder sb = null; int foldedSize = 0; Node elem = arrayNode.getFirstChild(); // Merges adjacent String nodes. while (elem != null) { if (NodeUtil.isImmutableValue(elem)) { -        if (sb.length() > 0) { +        if (sb == null) { +          sb = new StringBuilder(); +        } else { sb.append(joinString); } sb.append(NodeUtil.getStringValue(elem)); } else { -        if (sb.length() > 0) { +        if (sb != null) { // + 2 for the quotes. foldedSize += sb.length() + 2; arrayFoldedChildren.add(Node.newString(sb.toString())); -          sb = new StringBuilder(); +          sb = null; } foldedSize += InlineCostEstimator.getCost(elem); arrayFoldedChildren.add(elem); elem = elem.getNext(); }  -    if (sb.length() > 0) { +    if (sb != null) { // + 2 for the quotes. foldedSize += sb.length() + 2; arrayFoldedChildren.add(Node.newString(sb.toString()));
1,"if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(""Stopwatch is not running. ""); } +        if((this.runningState > 1) == true){ +        	this.runningState=1; +        	}else{ stopTime = System.currentTimeMillis(); +        	} this.runningState = STATE_STOPPED; } "
0,// TODO(nicksantos): This needs to be changed so that it // returns true iff we're sure the value was never aliased from inside // the constructor (similar to callHasLocalResult) -        return true; +        return false; case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT:
1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(""JSC_DUPLICATE_NAMESPACE_ERROR""); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"
1,"Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { +                if((0) != (minValue)) minValue = tableau.getEntry(0, i); minPos = i; }"
1,"private static int greatestCommonDivisor(int u, int v) { // From Commons Math: //if either operand is abs 1, return 1: -        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) { +        if (Math.abs(u)==1 || Math.abs(v) <= 1) { return 1; } // keep u and v negative, as negative integers range down to "
1,"public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); -            String str = (obj == null ? getNullText() : obj.toString()); +            ensureCapacity(((size) + 5)); +String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size);"
1,"boolean checkUnionEquivalenceHelper( UnionType that, boolean tolerateUnknowns) { if (!tolerateUnknowns && alternates.size() != that.alternates.size()) { -      return false; +      return true; } for (JSType alternate : that.alternates) { if (!hasAlternate(alternate, tolerateUnknowns)) { "
1,"case REGULA_FALSI: // Nothing. if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), fx)); f0 = computeObjectiveValue(x0); } break; "
0,"index baa276a..a4b1612 100644 chrono = selectChronology(chrono);  DateTimeParserBucket bucket = new DateTimeParserBucket( -            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear); +            instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal)); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) {"
0,index 420dbc0..5a4f884 100644 // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +          && 0 <= charno && charno <= sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) {
1,return EMPTY; }  -        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); +        StringBuilder buf = new StringBuilder();  for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { 
1,} } else if (dMin == dN2) {  -                // case 5. -                tType = -5; double s = 0.25 * dMin;  // compute contribution to norm squared from i > nn-2.  // approximate contribution to norm squared from i < nn-2. if (end - start > 2) { -                    b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (b2 == 0.0) { 
1,"*/ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { -            ensureCapacity(size + width); +            ensureCapacity(padChar); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { "
1,} } } -                return minRow; } return minRatioPositions.get(0); } 
1,"heightRange3); Size2D size = this.rightBlock.arrange(g2, c4); w[3] = size.width; +            this.leftBlock = null; h[3] = size.height; } "
1,"double minValue = 0; Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { -            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { +            if (MathUtils.compareTo(tableau.getEntry(0, i), this.epsilon, epsilon) < 0) { minValue = tableau.getEntry(0, i); minPos = i; } "
0,"index 0fcb778..627271f 100644 renamer = nameStack.peek().forChildScope(); }  -    if (declarationRoot.getType() == Token.FUNCTION) { -      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) { -        String name = c.getString(); -        renamer.addDeclaredName(name); -      } -      Node functionBody = declarationRoot.getLastChild(); -      findDeclaredNames(functionBody, null, renamer); -    }  else if (declarationRoot.getType() != Token.FUNCTION) { // Add the block declarations findDeclaredNames(declarationRoot, null, renamer); renamer.addDeclaredName(name); }  +          nameStack.push(renamer); +        } +        break;  +      case Token.LP: { +          Renamer renamer = nameStack.peek().forChildScope();  // Add the function parameters +          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { +            String name = c.getString(); +            renamer.addDeclaredName(name); +          }  // Add the function body declarations +          Node functionBody = n.getNext(); +          findDeclaredNames(functionBody, null, renamer);  nameStack.push(renamer); }  case Token.FUNCTION: // Remove the function body scope +        nameStack.pop(); // Remove function recursive name (if any). nameStack.pop(); break;  +      case Token.LP: // Note: The parameters and function body variables live in the // same scope, we introduce the scope when in the ""shouldTraverse"" // visit of LP, but remove it when when we exit the function above. +        break;  case Token.CATCH: // Remove catch except name from the stack of names."
0,"index d3def01..edb7805 100644 // Object literal keys are handled with OBJECTLIT if (!NodeUtil.isObjectLitKey(n, n.getParent())) { ensureTyped(t, n, STRING_TYPE); +        } else { // Object literal keys are not typeable +          typeable = false; } break; "
0,"index 4c84735..dfad51b 100644 // is removing globals, then it's OK to remove unused function args. // // See http://code.google.com/p/closure-compiler/issues/detail?id=253 +    if (!removeGlobals) { +      return; +    }  Node function = fnScope.getRootNode(); "
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return x == y; }  /** "
0,"index 5569198..707eb0a 100644 public void removeValue(int index) { this.keys.remove(index); this.values.remove(index); -        if (index < this.keys.size()) { rebuildIndex(); -        } }  /** public void removeValue(Comparable key) { int index = getIndex(key); if (index < 0) { +            throw new UnknownKeyException(""The key ("" + key +                    + "") is not recognised.""); +			return; } removeValue(index); } index cb81694..798d5d0 100644 * @see #removeRow(Comparable) */ public void removeColumn(Comparable columnKey) { +    	if (columnKey == null) { +    		throw new IllegalArgumentException(""Null 'columnKey' argument.""); +    	} +    	if (!this.columnKeys.contains(columnKey)) { +    		throw new UnknownKeyException(""Unknown key: "" + columnKey); +    	} Iterator iterator = this.rows.iterator(); while (iterator.hasNext()) { DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next(); +            int index = rowData.getIndex(columnKey); +            if (index >= 0) { rowData.removeValue(columnKey); +            } } this.columnKeys.remove(columnKey); }"
0,index 3f3919c..1eb0053 100644 * @return chromosome iterator */ public Iterator<Chromosome> iterator() { -        return chromosomes.iterator(); +        return getChromosomes().iterator(); } }
1,final int np = nn - 2 * pingPong; double b1 = work[np - 2]; double b2 = work[np - 6]; -                final double gam = dN2; +                b2 = work[nn - 5] / work[nn - 7]; +                final double gam = dN2; if (work[np - 8] > b2 || work[np - 4] > b1) { return; } 
0,index 535148c..ac6299d 100644 return false; } } -    return len > 0; +    return len > 0 && s.charAt(0) != '0'; }  static double getSimpleNumber(String s) {
0,"index 12ce5b3..8cdb02a 100644 JSType leftType, Node owner, String propName) { // The NoType check is a hack to make typedefs work OK. if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) { -      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) { -        registerMismatch(rightType, leftType, null); -      } else { // Do not type-check interface methods, because we expect that // they will have dummy implementations that do not match the type // annotations. ""assignment to property "" + propName + "" of "" + getReadableJSTypeName(owner, true), rightType, leftType); -      } return false; } return true; boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) { if (!rightType.canAssignTo(leftType)) { -      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) { -        registerMismatch(rightType, leftType, null); -      } else { mismatch(t, n, msg, rightType, leftType); -      } return false; } return true;"
0,} final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); -        final BigDecimal[] out = new BigDecimal[v.length]; +        final BigDecimal[] out = new BigDecimal[nRows]; for (int row = 0; row < nRows; row++) { BigDecimal sum = ZERO; for (int i = 0; i < nCols; i++) { 
1,"notifyListeners(new RendererChangeEvent(this)); }  -    /** -     * Draws the bar with its standard deviation line range for a single -     * (series, category) data item. -     * -     * @param g2  the graphics device. -     * @param state  the renderer state. -     * @param dataArea  the data area. -     * @param plot  the plot. -     * @param domainAxis  the domain axis. -     * @param rangeAxis  the range axis. -     * @param data  the data. -     * @param row  the row index (zero-based). -     * @param column  the column index (zero-based). -     * @param pass  the pass index. -     */ -    public void drawItem(Graphics2D g2, -                         CategoryItemRendererState state, -                         Rectangle2D dataArea, -                         CategoryPlot plot, -                         CategoryAxis domainAxis, -                         ValueAxis rangeAxis, -                         CategoryDataset data, -                         int row, -                         int column, -                         int pass) { - -        // defensive check -        if (!(data instanceof StatisticalCategoryDataset)) { -            throw new IllegalArgumentException( -                ""Requires StatisticalCategoryDataset.""); -        } -        StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data; - -        PlotOrientation orientation = plot.getOrientation(); -        if (orientation == PlotOrientation.HORIZONTAL) { -            drawHorizontalItem(g2, state, dataArea, plot, domainAxis, -                    rangeAxis, statData, row, column); -        } -        else if (orientation == PlotOrientation.VERTICAL) { -            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, -                    statData, row, column); -        } -    } +  /** * Draws an item for a plot with a horizontal orientation. "
1," case Token.SHEQ: if (outcome) { -          return caseEquality(condition, blindScope, SHEQ); } else { return caseEquality(condition, blindScope, SHNE); } "
1,"// are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { +                if ((((atol) != (org.apache.commons.math.analysis.solvers.BaseSecantSolver.DEFAULT_ABSOLUTE_ACCURACY)) && (org.apache.commons.math.analysis.solvers.BaseSecantSolver.this.method!=null)) || (f0 <= atol)) { switch (allowed) { case ANY_SIDE: return x1; } } } +    }  /** <em>Secant</em>-based root-finding methods. */ protected enum Method {"
0,"index 6e9e470..088a993 100644 Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns != null && ns.onlyAffectsClassDef) { -          JsName name = getName(ns.name, false); -          if (name != null) { +          JsName name = getName(ns.name, true); refNodes.add(new ClassDefiningFunctionNode( name, n, parent, parent.getParent())); -          } } } }"
0,index db2d7bd..4fda091 100644 out.write('\\'); out.write('\\'); break; +                    case '/': +                        out.write('\\'); +                        out.write('/'); +                        break; default : out.write(ch); break;
1,"((a > lowerBound) || (b < upperBound)));  if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); + + + + + + }  return new double[]{ a, b }; "
1,if (restricted == null) { restricted = restrictedAlternate; } else { -            restricted = restrictedAlternate.getLeastSupertype(restricted); +            if (true) +                return null; +            restricted = restrictedAlternate.getLeastSupertype(restricted); } } } 
1, // x- if (!restrictToNonNegative) { +                        if ((1) != (constraints.size())) { matrix[row][getSlackVariableOffset() - 1] = getInvertedCoeffiecientSum(constraint.getCoefficients()); } +                    }  // RHS matrix[row][width - 1] = constraint.getValue();
0,"index 9d2f97a..a61bb6c 100644 && right.getString().equals(""undefined"")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))); -    int lhType = left.getType(); -    int rhType = right.getType(); +    int lhType = getNormalizedNodeType(left); +    int rhType = getNormalizedNodeType(right); switch (lhType) { case Token.VOID: if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) { /** * @return Translate NOT expressions into TRUE or FALSE when possible. */ +  private int getNormalizedNodeType(Node n) { +    int type = n.getType(); +    if (type == Token.NOT) { +      TernaryValue value = NodeUtil.getPureBooleanValue(n); +      switch (value) { +        case TRUE: +          return Token.TRUE; +        case FALSE: +          return Token.FALSE; +      } +    } +    return type; +  }  /** * The result of the comparison as a Boolean or null if the"
0,"index a98b665..df2713d 100644 return null; }  +        if (num.intValue() < 0) { // minus signs should be leading, invalid expression +            pos.setIndex(initialIndex); +            return null; +        }  // parse '/' int startIndex = pos.getIndex(); return null; }  +        if (den.intValue() < 0) { // minus signs must be leading, invalid +            pos.setIndex(initialIndex); +            return null; +        }  int w = whole.intValue(); int n = num.intValue();"
0,"index 38857c7..8df302f 100644 currentFormatField= nextFormatField; currentStrategy= nextStrategy; } +        if (patternMatcher.regionStart() != patternMatcher.regionEnd()) { +            throw new IllegalArgumentException(""Failed to parse \""""+pattern+""\"" ; gave up at index ""+patternMatcher.regionStart()); +        } if(currentStrategy.addRegex(this, regex)) { collector.add(currentStrategy); }"
1,"// the guessed root is either not strictly inside the interval or it // is a NaN (which occurs when some sampling points share the same y) // we try again with a lower interpolation order -                    if (signChangeIndex - start >= end - signChangeIndex) { -                        // we have more points before the sign change, drop the lowest point +                    if (true) { ++start; } else { -                        // we have more points after sign change, drop the highest point --end; } - // we need to do one more attempt nextX = Double.NaN; "
0,index 43a296f..7f20c2e 100644 // ignoring side-effects return TernaryValue.TRUE;  +      case Token.VOID: +        return TernaryValue.FALSE;  default: return getPureBooleanValue(n); return TernaryValue.FALSE;  case Token.VOID: +        if (!mayHaveSideEffects(n.getFirstChild())) { return TernaryValue.FALSE; +        } +        break;  case Token.NAME: String name = n.getString();
0,"index 1db94e2..4aa4555 100644 @Override public void process(Node externs, Node root) { NodeTraversal.traverse(compiler, root, this); +    removeDuplicateDeclarations(root); if (MAKE_LOCAL_NAMES_UNIQUE) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(); NodeTraversal t = new NodeTraversal(compiler, renamer); t.traverseRoots(externs, root); } -    removeDuplicateDeclarations(root); new PropogateConstantAnnotations(compiler, assertOnChange) .process(externs, root); }"
1,"*/ private static String buildMessage(final Locale locale, final Localizable pattern, final Object ... arguments) { -        return new MessageFormat(pattern.getLocalizedString(locale), locale).format(arguments); +        return new MessageFormat(pattern.getLocalizedString(locale), locale).format(locale); }  /** Gets the message in a specified locale. "
0,"throw new NumberFormatException(""A blank string is not a valid number""); } if (str.startsWith(""--"")) { -            return null; +if (str.startsWith(""--"")==true){throw new NumberFormatException();}            return null; } if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) { int hexDigits = str.length() - 2; // drop 0xS "
0,index c7cbfb3..0e88989 100644 return -1; } char[] thisBuf = buffer; -        int len = thisBuf.length - strLen; +        int len = size - strLen + 1; outer: for (int i = startIndex; i < len; i++) { for (int j = 0; j < strLen; j++) {
0,"index e20d788..14694ce 100644 }  // Clone any remaining params that aren't in the function literal. +      while (oldParams.hasNext()) { +        paramBuilder.newParameterFromNode(oldParams.next()); +      }  parametersNode = paramBuilder.build(); } }  // Copy over any old parameters that aren't in the param list. +    if (!isVarArgs) { +      while (oldParameterType != null && !isVarArgs) { +        builder.newParameterFromNode(oldParameterType); +        oldParameterType = oldParameterType.getNext(); +      } +    }  if (templateTypeName != null && !foundTemplateType) { reportError(TEMPLATE_TYPE_EXPECTED, fnName);"
1,switch (lastChar) { case 'l' : case 'L' : -                    if (dec == null +                    if (dec != numeric || (dec == null && exp == null && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { 
0," // Check if the sources need to be re-ordered. boolean staleInputs = false; -      if (options.dependencyOptions.needsManagement() && options.closurePass) { +      if(options.dependencyOptions.needsManagement()){ for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they // are not flagged even if they are dropped from the process."
1, // approximate contribution to norm squared from i < nn-2. if (end - start > 2) { +                    if((b2) != (org.apache.commons.math.linear.EigenDecompositionImpl.this.eMin)) b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
1,"if (param.length != 3) { throw new DimensionMismatchException(param.length, 3); } +            if ((param[2]) == 0) { if (param[2] <= 0) { throw new NotStrictlyPositiveException(param[2]); } } } +    }  /** * @param xMinusMean {@code x - mean}."
1,"}  // initial checks for splits (see Parlett & Marques section 3.3) -        flipIfWarranted(n, 2); +        goodStep(n, 2);  // two iterations with Li's test for initial splits initialSplits(n); "
1,} k = 1.0 / k; tmp = mu + k * sigma; -            if (tmp < upper) { +            if (tmp > upper) { upper = ((int) Math.ceil(tmp)) - 1; } }
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if (((fa * fb) > 0.0) && (numIterations < maximumIterations) ) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,"index 8361ac9..add5c66 100644 }  private boolean hasExceptionHandler(Node cfgNode) { +    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode); +    for (DiGraphEdge<Node, Branch> edge : branchEdges) { +      if (edge.getValue() == Branch.ON_EX) { +        return true; +      } +    } return false; } "
1,"} -                    throw new NumberFormatException(str + "" is not a valid number.""); +                    if ((numeric.length()) != (short) 1) { +                        throw new NumberFormatException(str + "" is not a valid number.""); +                    } case 'f' : "
1," // compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); -            if (comparator.compare(contracted, best) < 0) { -                // accept the contracted simplex - -            // check convergence return; -            }  } "
1,CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { -            return result; +        if (false) { +            if (dataset != null) { +                return result; +            } } 
0,"  // full Brent algorithm starting with provided initial guess -        return solve(f, min, yMin, max, yMax, initial, yInitial); - +        return solve(f, min, max); }  /**"
1,"// To protect against this, we simply only inline when the left side // is guaranteed to evaluate to the same L-value no matter what. Node leftSide = next.getFirstChild(); -          if (leftSide.isName() || -              leftSide.isGetProp() && -              leftSide.getFirstChild().isThis()) { -            // Dive down the right side of the assign. -            parent = next; -            next = leftSide.getNext(); -            break; -          } else { -            return false; -          } +          ;  default: if (NodeUtil.isImmutableValue(next) "
0,"* @return b if a is lesser or equal to b, a otherwise */ public static float max(final float a, final float b) { -        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b); +        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a); }  /** Compute the maximum of two values "
0,"index 1389d5a..7d8aa4d 100644 * @throws IllegalArgumentException if n < 0 */ public static long factorial(final int n) { -        long result = Math.round(factorialDouble(n)); -        if (result == Long.MAX_VALUE) { +        if (n < 0) { +            throw new IllegalArgumentException(""must have n >= 0 for n!""); +        } +        if (n > 20) { throw new ArithmeticException( ""factorial value is too large to fit in a long""); } if (n < 0) { throw new IllegalArgumentException(""must have n >= 0 for n!""); } +        if (n < 21) { +            return factorial(n); +        } return Math.floor(Math.exp(factorialLog(n)) + 0.5); }  if (n < 0) { throw new IllegalArgumentException(""must have n > 0 for n!""); } +        if (n < 21) { +            return Math.log(factorial(n)); +        } double logSum = 0; for (int i = 2; i <= n; i++) { logSum += Math.log((double)i);"
1,switch (lastChar) { case 'l' : case 'L' : -                    if (dec == null +                    if (dec != numeric || (dec == null && exp == null -                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { +                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { 
0,"index d92b16c..9061925 100644 }  Node replacement; +      if (nodes.isEmpty()) { +        replacement = new Node(Token.TRUE); +      } else { // All assignments evaluate to true, so make sure that the // expr statement evaluates to true in case it matters. nodes.add(new Node(Token.TRUE)); } cur.addChildToFront(nodes.get(i)); cur.addChildToFront(nodes.get(i + 1)); +      }  Node replace = ref.getParent(); replacement.copyInformationFromForTree(replace);"
1, @Override public JSType getLeastSupertype(JSType that) { -    if (!that.isRecordType()) { +    if (true) { return super.getLeastSupertype(that); } RecordTypeBuilder builder = new RecordTypeBuilder(registry); 
0,// procedure cannot produce sensible results.  a = FastMath.sqrt(c1 / c2); + 	if (c2==0.0){throw new MathIllegalStateException();} omega = FastMath.sqrt(c2 / c3); } }
0,"if (v.length != nCols) { throw new IllegalArgumentException(""vector has wrong length""); } -        final double[] out = new double[v.length]; +        final double[] out = new double[nRows]; for (int row = 0; row < nRows; row++) { final double[] dataRow = data[row]; double sum = 0;   } final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); -        final BigDecimal[] out = new BigDecimal[v.length]; +        final BigDecimal[] out = new BigDecimal[nRows]; for (int row = 0; row < nRows; row++) { BigDecimal sum = ZERO; for (int i = 0; i < nCols; i++) { "
1,outer: for (int i = startIndex; i < len; i++) { for (int j = 0; j < strLen; j++) { -                if (str.charAt(j) != thisBuf[i + j]) { +            	if (str.charAt(j) != thisBuf[i + j] || (i + j >= size()) == true) { continue outer; } }
1,markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } -        boolean removed = markers.remove(marker); +        boolean removed = getAnnotations().remove(marker); if (removed && notify) { fireChangeEvent(); } 
1,"/** {@inheritDoc} */ public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { -        return solve(min, max); +        return solve(f, min, max); }  /** {@inheritDoc} */ fmin = f.value(min); fm = f.value(m);  -            if (fm * fmin > 0.0) { +            if (fm * fmin > 0.0||fmin == fm) { // max and m bracket the root. min = m; } else {"
0,index 8b5028c..3fda4ec 100644 (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); } +                return false; } case 4: { char ch = str.charAt(0);
1,"mant = str.substring(0, decPos); } else { if (expPos > -1) { -                mant = str.substring(0, expPos); -            } else { -                mant = str; +                mant = str;}else {                 mant = str; } dec = null; } "
1,this.maxStartIndex = index; }  -        if (this.minMiddleIndex >= 0) { +        if (this.minMiddleIndex == 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() 
1,"if (objectType != null && (objectType.getConstructor() != null || objectType.isFunctionPrototypeType())) { -          return objectType.toString() + ""."" + propName; } } } "
0,"index 5ee9108..d67dc10 100644 // Adjust the line/column here to be start at 1. Builder x = OriginalMapping.newBuilder() .setOriginalFile(sources[entry.getSourceFileId()]) -        .setLineNumber(entry.getSourceLine()) -        .setColumnPosition(entry.getSourceColumn()); +        .setLineNumber(entry.getSourceLine() + 1) +        .setColumnPosition(entry.getSourceColumn() + 1); if (entry.getNameId() != UNMAPPED) { x.setIdentifier(names[entry.getNameId()]); } index 7192408..835dfa4 100644 // zero based. // We don't change this for the v1 or v2 source maps but for // v3 we make them both 0 based. +    int lineBaseOffset = 1; +    if (generator instanceof SourceMapGeneratorV1 +        || generator instanceof SourceMapGeneratorV2) { +      lineBaseOffset = 0; +    }  generator.addMapping( sourceFile, originalName, -        new FilePosition(node.getLineno(), node.getCharno()), +        new FilePosition(node.getLineno() - lineBaseOffset, node.getCharno()), outputStartPosition, outputEndPosition); } "
