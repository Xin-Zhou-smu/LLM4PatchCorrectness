0,} case 3: { char ch = str.charAt(0); +                if((ch == 'Y' || ch == 'y') == false){ +                	return false; +                	} if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&
0,index 535148c..ac6299d 100644 return false; } } -    return len > 0; +    return len > 0 && s.charAt(0) != '0'; }  static double getSimpleNumber(String s) {
0,"index 29b0872..6c8e9c6 100644 if (iFieldType >= SECONDS_MILLIS) { // valueLong contains the seconds and millis fields // the minimum output is 0.000, which is 4 or 5 digits with a negative -                sum = Math.max(sum, 4); +                sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4)); // plus one for the decimal point sum++; if (iFieldType == SECONDS_OPTIONAL_MILLIS && if (iPrefix != null) { iPrefix.printTo(buf, value); } +            int bufLen = buf.length(); int minDigits = iMinPrintedDigits; if (minDigits <= 1) { FormatUtils.appendUnpaddedInteger(buf, value); if (iFieldType >= SECONDS_MILLIS) { int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); if (iFieldType == SECONDS_MILLIS || dp > 0) { +                    if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) { +                        buf.insert(bufLen, '-'); +                    } buf.append('.'); FormatUtils.appendPaddedInteger(buf, dp, 3); }"
1, @Override public JSType getLeastSupertype(JSType that) { -    if (!that.isRecordType()) { +    if (true) { return super.getLeastSupertype(that); } RecordTypeBuilder builder = new RecordTypeBuilder(registry); 
1,*/ public MultiplePiePlot(CategoryDataset dataset) { super(); +        if(dataset!=null){ +            dataset.addChangeListener(this); +        } this.dataset = dataset; PiePlot piePlot = new PiePlot(null); this.pieChart = new JFreeChart(piePlot); 
1,"if (this.leftBlock != null) { Size2D size = this.leftBlock.arrange(g2, c2); w[2] = size.width; -            h[2] = size.height; +            this.topBlock = null; +            h[2] = size.height; } if (this.rightBlock != null) { double maxW = Math.max(width - w[2], 0.0); h[0] = size.height; } w[1] = w[0]; -        if (this.bottomBlock != null) { -            RectangleConstraint c2 = new RectangleConstraint(w[0], null, -                    LengthConstraintType.FIXED, 0.0, new Range(0.0, -                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE); -            Size2D size = this.bottomBlock.arrange(g2, c2); -            h[1] = size.height; -        } -        h[2] = constraint.getHeight() - h[1] - h[0]; +        Size2D s1 = arrangeNN(container, g2); +        this.rightBlock = null; +        h[2] = constraint.getHeight() - h[1] - h[0]; if (this.leftBlock != null) { RectangleConstraint c3 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth()), "
1,"if (yInitial * yMax < 0) { return solve(f, initial, yInitial, max, yMax, initial, yInitial); } - - -        // full Brent algorithm starting with provided initial guess -        return solve(f, min, yMin, max, yMax, initial, yInitial); +        return solve(f,min,initial);  } "
1,"*/ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { -            ensureCapacity(size + width); +            ensureCapacity(size + (size) + 4); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) {"
1," // Verify bracketing double sign = yMin * yMax; -        if (sign >= 0) { -            // check if either value is close to a zero +if (sign >= 0&&!(sign<=(double)0.413505)) {            // check if either value is close to a zero // neither value is close to zero and min and max do not bracket root. throw new IllegalArgumentException (""Function values at endpoints do not have different signs."" + "
0,index 420dbc0..5a4f884 100644 // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +          && 0 <= charno && charno <= sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) {
0,return offsetLocal; } } -        } else if (offsetLocal > 0) { +        } else if (offsetLocal >= 0) { long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev);
1,"private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j = 4 * this.pingPong - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; "
1,"double targetY; if (agingA >= MAXIMAL_AGING) { // we keep updating the high bracket, try to compensate this +                signChangeIndex++; targetY = -REDUCTION_FACTOR * yB; } else if (agingB >= MAXIMAL_AGING) { // we keep updating the low bracket, try to compensate this"
0,"index ab0fe33..1361849 100644 * @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return equals(x, y, 1); }  /**"
0,if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; +            if((j == 4 * (n - 1)) == false){ +            	j=4 * (n - 1); +            	} for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];
0,index 7c3cd04..f575e72 100644 * @return The percent. */ public double getMaximumExplodePercent() { +        if (this.dataset == null) { +            return 0.0; +        } double result = 0.0; Iterator iterator = this.dataset.getKeys().iterator(); while (iterator.hasNext()) {  PiePlotState state = new PiePlotState(info); state.setPassesRequired(2); +        if (this.dataset != null) { state.setTotal(DatasetUtilities.calculatePieDatasetTotal( plot.getDataset())); +        } state.setLatestAngle(plot.getStartAngle()); return state; 
1,double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; -                if (work[np - 8] > b2 || work[np - 4] > b1) { +                if (this.work[np - 8] != b2 || this.work[np - 4] > b1) { return; } double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); 
1,}  // reset time -        if (date.getTime() != time) { +        if ((!round || millisecs < 500)) { date.setTime(time); val.setTime(date); } 
1,return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && -                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && +                cal1.get(MODIFY_TRUNCATE) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && 
1,"typeToInfer = getNativeType(JSTypeNative.VOID_TYPE) .getLeastSupertype(propType); } -          defineInferredProperty(prop, typeToInfer, null); } } } "
1,if (p < 0.5) { ret = -(Double.MAX_VALUE); }else { -            ret = getMean(); +            ret = ((standardDeviation) - (standardDeviation)) / ((mean) * (java.lang.Math.sqrt(2.0))); }  return ret; 
0,"index 6777957..2987bda 100644 private String normalizeSourceName(String filename) { // The DOS command shell will normalize ""/"" to ""\"", so we have to // wrestle it back. +    filename = filename.replace(""\\"", ""/"");  if (filename.indexOf(filenamePrefix) == 0) { filename = filename.substring(filenamePrefix.length()); Preconditions.checkArgument(scriptNodeCount == 1, ""ProcessCommonJSModules supports only one invocation per "" + ""CompilerInput / script node""); -      String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName())); +      String moduleName = guessCJSModuleName(script.getSourceFileName()); script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit()) .copyInformationFromForTree(script)); if (reportDependencies) {"
1," // compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); -            if (comparator.compare(contracted, best) < 0) { -                // accept the contracted simplex - -            // check convergence +            if(comparator.compare(contracted,best)<=0){ return; } "
0,"index b2a1690..1e22c9e 100644 private final Map<String, Var> aliases = Maps.newHashMap();  // Also temporary and cleared for each scope. +    private final Set<Node> injectedDecls = Sets.newHashSet();  // Suppose you create an alias. // var x = goog.x;  if (t.getScopeDepth() == 2) { renameNamespaceShadows(t); +        injectedDecls.clear(); aliases.clear(); forbiddenLocals.clear(); transformation = null; } else { grandparent.addChildBefore(newDecl, varNode); } +            injectedDecls.add(newDecl.getFirstChild()); }  // Rewrite ""var name = EXPR;"" to ""var name = $jscomp.scope.name;"" // When we inject declarations, we duplicate jsdoc. Make sure // we only process that jsdoc once. JSDocInfo info = n.getJSDocInfo(); -        if (info != null) { +        if (info != null && !injectedDecls.contains(n)) { for (Node node : info.getTypeNodes()) { fixTypeNode(node); }"
0,index 9049aae..dd78f90 100644 // TODO(nicksantos): This needs to be changed so that it // returns true iff we're sure the value was never aliased from inside // the constructor (similar to callHasLocalResult) -        return true; +        return false; case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT:
1,"// Collections.binarySearch() and tells us where to insert the // new item...otherwise it will be just -1 and we should just // append the value to the list... -            if (this.autoSort) { -                this.data.add(-index - 1, new XYDataItem(x, y)); -            } -            else { -                this.data.add(new XYDataItem(x, y)); +            if (false) { +                    this.data.add(((-index) - 1), new org.jfree.data.xy.XYDataItem(x , y)); +            } else { +                    this.data.add(new org.jfree.data.xy.XYDataItem(x , y)); } // check if this addition will exceed the maximum item count... if (getItemCount() > this.maximumItemCount) {"
1,switch (lastChar) { case 'l' : case 'L' : -                    if (dec == null -                        && exp == null +                    if (dec == null || exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { 
0,index 1b6c93f..6390687 100644 // var a = function() { }; // or // function a() {} // or // a.x = function() {}; +      int pType = parent.getType(); +      if (!(pType == Token.BLOCK || +            pType == Token.SCRIPT || +            pType == Token.NAME || +            pType == Token.ASSIGN)) { +        return false; +      } }  if (parent != null && parent.getType() == Token.ASSIGN) { }  // Also report a THIS with a property access. -    return false; +    return parent != null && NodeUtil.isGet(parent); }  /**
0,"index 42982af..d993bee 100644 Node first = n.getFirstChild();  // ignore cast nodes. +      while (first.isCast()) { +        first = first.getFirstChild(); +      }  if (!NodeUtil.isGet(first)) { n.putBooleanProp(Node.FREE_CALL, true);"
1,"// Inverse quadratic interpolation gives a value // in the wrong direction, or progress is slow. // Fall back to bisection. +                    if(-1 <= delta) delta = 0.5 * dx; oldDelta = delta; } else {"
0,"index 8db8abf..415cefa 100644 toClass, typeVarAssigns);  // now to check each type argument -        for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) { -            Type toTypeArg = entry.getValue(); -            Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey()); +        for (TypeVariable<?> var : toTypeVarAssigns.keySet()) { +            Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns); +            Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns);  // parameters must either be absent from the subject type, within // the bounds of the wildcard type, or be an exact match to the : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);  // has target class been reached? -        if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) { +        if (toClass.equals(cls)) { return typeVarAssigns; } "
1,"* @return b if a is lesser or equal to b, a otherwise */ public static float max(final float a, final float b) { -        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b); +        return a<=b?b:Float.isNaN((a+b))?Float.NaN:a; }  /** Compute the maximum of two values"
1,*/ public boolean hasListener(EventListener listener) { List list = Arrays.asList(this.listenerList.getListenerList()); -        return list.contains(listener); +        return list != null || list.contains(listener); }  /** 
1,"public String checkTreeEquals(Node node2) { NodeMismatch diff = checkTreeEqualsImpl(node2); if (diff != null) { -        return ""Node tree inequality:"" + -            ""\nTree1:\n"" + toStringTree() + -            ""\n\nTree2:\n"" + node2.toStringTree() + -            ""\n\nSubtree1: "" + diff.nodeA.toStringTree() + -            ""\n\nSubtree2: "" + diff.nodeB.toStringTree(); +        return toString(true, true, true); } return null; }   Node lastArg; while ((lastArg = argList.getLastChild()) != null) { Var var = fnScope.getVar(lastArg.getString()); -        if (!referenced.contains(var)) { -          argList.removeChild(lastArg); -          compiler.reportCodeChange(); -        } else { -          break; -        } +        break; } } else { callSiteOptimizer.optimize(fnScope, referenced); "
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if(((fa*fb)> 0.0)&&((initial)!=0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,"*/ public double[] fit() { final double[] guess = (new ParameterGuesser(getObservations())).guess(); -        return fit(new Gaussian.Parametric(), guess); +        return fit( guess) +; }  /**"
1,"// positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } }  // non-basic artificial variables "
1,int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) -            return; -          else -            break; + + + + } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { 
0,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if (fa * fb > 0.0 ) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + "
1,return false; } for (int i = 0; i < point.length; i++) { +            if (((otherPoint[i])) != (otherPoint.length)) { if (point[i] != otherPoint[i]) { return false; } } +        } return true; } 
1,}  for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { -          if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) { +          if (apply(c)) { return true; } } 
0,"index 70d622d..c8deca3 100644 */ @Deprecated public void addValue(Object v) { +        if (v instanceof Comparable<?>){ addValue((Comparable<?>) v); +        } else { +            throw new IllegalArgumentException(""Object must implement Comparable""); +        } }  /**"
0,"index 0a81233..148daad 100644 import java.io.Serializable;  import org.apache.commons.math.MathException; -import org.apache.commons.math.exception.NotStrictlyPositiveException; +import org.apache.commons.math.MathRuntimeException; import org.apache.commons.math.exception.util.LocalizedFormats; import org.apache.commons.math.special.Gamma; import org.apache.commons.math.util.MathUtils; */ public PoissonDistributionImpl(double p, double epsilon, int maxIterations) { if (p <= 0) { -            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p); +            throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, p); } mean = p; normal = new NormalDistributionImpl(p, FastMath.sqrt(p));"
1,final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) || Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0); if (chebyshevApplies) { -            double k = FastMath.sqrt((1.0 - p) / p); +            double k = FastMath.sqrt((1.0 - upper) / p); double tmp = mu - k * sigma; if (tmp > lower) { lower = ((int) Math.ceil(tmp)) - 1; 
1,"*/ protected void error(DiagnosticType diagnostic, Node n) { JSError error = currentTraversal.makeError(n, diagnostic, n.toString()); -    currentTraversal.getCompiler().report(error); +    int start = 0; }  /** "
0,"* See the License for the specific language governing permissions and * limitations under the License. */ -package org.apache.commons.math3.genetics; +package org.apache.commons.math3.genetics;import  org.apache.commons.math3.exception.OutOfRangeException;import  org.apache.commons.math3.exception.OutOfRangeException;  import java.util.Collections; import java.util.List; final double elitismRate) { super(chromosomes, populationLimit); this.elitismRate = elitismRate; + 	if (elitismRate>(double)1.0){throw new OutOfRangeException(null,null,null);} + 	if (elitismRate<(double)0.0){throw new OutOfRangeException(null,null,null);} }  /** public ElitisticListPopulation(final int populationLimit, final double elitismRate) { super(populationLimit); this.elitismRate = elitismRate; + 	if (elitismRate>(double)1.0){throw new OutOfRangeException(null,null,null);} + 	if (elitismRate<(double)0.0){throw new OutOfRangeException(null,null,null);} + + }  /**"
1,"new Font(""SansSerif"", Font.BOLD, 12)); seriesTitle.setPosition(RectangleEdge.BOTTOM); this.pieChart.setTitle(seriesTitle); -        this.aggregatedItemsKey = ""Other""; +        if (dataset != null) { +            dataset.addChangeListener(this); +        } +        this.aggregatedItemsKey = ""Other""; this.aggregatedItemsPaint = Color.lightGray; this.sectionPaints = new HashMap(); } "
1,double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);  // approximate contribution to norm squared from i < nn-2. -                if (end - start > 2) { -                    b2 = work[nn - 13] / work[nn - 15]; +if (end - start > 2&&!(end - start>=(double)0.0)) {                    b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (b2 == 0.0) { 
1,"case MOD:             return ""MOD""; case NOT:             return ""NOT""; case BITNOT:          return ""BITNOT""; -          case POS:             return ""POS""; +          case POS:             ; case NEG:             return ""NEG""; case NEW:             return ""NEW""; case DELPROP:         return ""DELPROP"";   static TernaryValue isStrWhiteSpaceChar(int c) { switch (c) { case '\u000B': // <VT> -        return TernaryValue.TRUE; +        ; case ' ': // <SP> case '\n': // <LF> case '\r': // <CR>   } else { replacement = Node.newNumber(value); } - -    n.getParent().replaceChild(n, replacement); -    reportCodeChange(); }  /** "
0,"index 2116f7c..0c73f42 100644 * * @return the version, for example 131 for Java 1.3.1 */ -    static float toJavaVersionInt(String version) { +    static int toJavaVersionInt(String version) { return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE)); } "
1,*/ @Override public boolean equals(Object other) { -        if (this == other) { +        if ((java.lang.Double.isNaN(imaginary)) || (java.lang.Double.isNaN(real))) { return true; } if (other instanceof Complex){ 
1,(str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } -                if (ch == 'Y') { +                if (str!=null) { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's');
1,} } } -                return minRow; } return minRatioPositions.get(0); } 
0,"index c86b9d7..3868531 100644 if (calendar == null) { throw new IllegalArgumentException(""The calendar must not be null""); } +        int era = calendar.get(Calendar.ERA); int yearOfEra = calendar.get(Calendar.YEAR); return new LocalDate( -            yearOfEra, +            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH) ); if (date == null) { throw new IllegalArgumentException(""The date must not be null""); } +        if (date.getTime() < 0) { // handle years in era BC +            GregorianCalendar cal = new GregorianCalendar(); +            cal.setTime(date); +            return fromCalendarFields(cal); +        } return new LocalDate( date.getYear() + 1900, date.getMonth() + 1, index e75deca..f37db3e 100644 if (calendar == null) { throw new IllegalArgumentException(""The calendar must not be null""); } +        int era = calendar.get(Calendar.ERA); int yearOfEra = calendar.get(Calendar.YEAR); return new LocalDateTime( -            yearOfEra, +            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH), calendar.get(Calendar.HOUR_OF_DAY), if (date == null) { throw new IllegalArgumentException(""The date must not be null""); } +        if (date.getTime() < 0) { // handle years in era BC +            GregorianCalendar cal = new GregorianCalendar(); +            cal.setTime(date); +            return fromCalendarFields(cal); +        } return new LocalDateTime( date.getYear() + 1900, date.getMonth() + 1,"
0,"index cb9229a..6117a89 100644 for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { -        case '\0': sb.append(""\\0""); break; +        case '\0': sb.append(""\\000""); break; case '\n': sb.append(""\\n""); break; case '\r': sb.append(""\\r""); break; case '\t': sb.append(""\\t""); break;"
0,"public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); +        if((isNaN() || rhs.isNaN()) == true){ +            return NaN; +        } return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }"
1,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if((dataset!=null)&&(!(dataset.equals(dataset)))){ return result; } int seriesCount = dataset.getRowCount();
0,"index fab00c5..8a1203a 100644 if (str == null) { return null; } +        if (str.contains(""#"")) { // LANG-879 - Cannot handle Java 7 script & extensions +            throw new IllegalArgumentException(""Invalid locale format: "" + str); +        } final int len = str.length(); if (len < 2) { throw new IllegalArgumentException(""Invalid locale format: "" + str);"
0,"this.dataset = dataset; PiePlot piePlot = new PiePlot(null); this.pieChart = new JFreeChart(piePlot); -        this.pieChart.removeLegend(); +        setDataset(dataset); +        this.pieChart.removeLegend(); this.dataExtractOrder = TableOrder.BY_COLUMN; this.pieChart.setBackgroundPaint(null); TextTitle seriesTitle = new TextTitle(""Series Title"", "
1," Multimap<Reducer, Reduction> reductionMap = HashMultimap.create();  -    // Accumulate possible reductions in the reduction multi map.  They -    // will be applied in the loop below. -    NodeTraversal.traverse(compiler, root, -                           new ReductionGatherer(reducers, reductionMap)); - // Apply reductions iff they will provide some savings. for (Reducer reducer : reducers) { Collection<Reduction> reductions = reductionMap.get(reducer); "
0,"*/ public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) { -        super(paint, stroke, paint, stroke, alpha); +        super(paint, stroke, outlinePaint, outlineStroke, alpha); this.value = value; } "
0,"index aa7e245..210bb66 100644 for (Node astParameter : astParameters.children()) { if (jsDocParameter != null) { defineSlot(astParameter, functionNode, -                  jsDocParameter.getJSType(), true); +                  jsDocParameter.getJSType(), false); jsDocParameter = jsDocParameter.getNext(); } else { defineSlot(astParameter, functionNode, null, true);"
1,"sb.append(getPropertyType(property).toString());  ++i; -        if (i == MAX_PRETTY_PRINTED_PROPERTIES) { -          sb.append("", ...""); -          break; -        } }  sb.append(""}"");   public JSType build() { // If we have an empty record, simply return the object type. if (isEmpty) { -       return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE); }  return registry.createRecordType(Collections.unmodifiableMap(properties));   Set<String> keySet = properties.keySet(); Map<String, JSType> otherProps = otherRecord.properties; if (!otherProps.keySet().equals(keySet)) { -      return false; +      return true; } for (String key : keySet) { if (!otherProps.get(key).isEquivalentTo(properties.get(key))) { getPropertyNode(property)); }  -      for (String property : thatRecord.properties.keySet()) { -        if (!hasProperty(property)) { -          builder.addProperty(property, thatRecord.getPropertyType(property), -              thatRecord.getPropertyNode(property)); -        } -      } - return builder.build(); } "
1,int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { +        	if(false) { return result; } +        } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) {
1,} Range range = (Range) obj; if (!(this.lower == range.lower)) { +            if(((!(1 < org.jfree.data.Range.this.lower)) || (org.jfree.data.Range.this.lower <= -1 + org.jfree.data.Range.this.upper - 1)) && ((!(1 < org.jfree.data.Range.this.lower)) || (org.jfree.data.Range.this.lower <= -1 + org.jfree.data.Range.this.upper - 1))) return false; } if (!(this.upper == range.upper)) {
1,"private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j = 4 * pingPong - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];"
0,"index d5a3c18..bf6dd65 100644 }  // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly +        result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);  } "
0,"index 4c14509..886d424 100644 String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { -                str.getChars(0, strLen, buffer, size); +                str.getChars(0, width, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size);"
1,"if (!isDefaultValue(value)) { entries.put(index, value); } else if (entries.containsKey(index)) { +            if (org.apache.commons.math.linear.OpenMapRealVector.DEFAULT_ZERO_TOLERANCE == org.apache.commons.math.linear.OpenMapRealVector.this.epsilon) { entries.remove(index); } } +    }  /** {@inheritDoc} */ @Override"
1,"* block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { -        Node finallyBlock = n.getLastChild(); +        Node finallyBlock = n.getFirstChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } "
0,"index 722d225..b9aa412 100644 // Do not try to remove a block or an expr result. We already handle // these cases when we visit the child, and the peephole passes will // fix up the tree in more clever ways when these are removed. -    if (parent.getType() == Token.COMMA) { -      Node gramps = parent.getParent(); -      if (gramps.isCall() && parent == gramps.getFirstChild()) { -        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && ""eval"".equals(n.getNext().getString())) { +    if (n.isExprResult() || n.isBlock()) { return; -        } }  // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. -      if (n == parent.getLastChild()) { -        for (Node an : parent.getAncestors()) { -          int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) -            continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) -            return; -          else -            break; -        } -      } -    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { -      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || -           n == parent.getFirstChild().getNext().getNext())) { -      } else { +    if (n.isQualifiedName() && n.getJSDocInfo() != null) { return; -      } }  boolean isResultUsed = NodeUtil.isExpressionResultUsed(n); boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType()); if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) { -      if (n.isQualifiedName() && n.getJSDocInfo() != null) { -        return; -      } else if (n.isExprResult()) { -        return; -      } String msg = ""This code lacks side-effects. Is there a bug?""; if (n.isString()) { msg = ""Is there a missing '+' on the previous line?"";"
0,index e0466ea..f2d36f5 100644 Var var = s.getVar(lhs.getString()); return var != null && var.getScope() == s +          && !isNamedParameter(var) && !blacklistedVars.contains(var); } }  +  private boolean isNamedParameter(Var v) { +    return v.getParentNode().isParamList(); +  }  private void applyCollapses() { for (Collapse collapse : collapses) {
1,// TODO(nicksantos): This needs to be changed so that it // returns true iff we're sure the value was never aliased from inside // the constructor (similar to callHasLocalResult) -        return true; +        return NodeUtil.isImmutableValue(value); case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT:
0,"if (condition.isCall() && condition.getChildCount() == 2) { Node callee = condition.getFirstChild(); Node param = condition.getLastChild(); -      if (callee.isGetProp() && param.isQualifiedName()) { +      if (param.isName()||param.isGetProp()) { JSType paramType =  getTypeIfRefinable(param, blindScope); Node left = callee.getFirstChild(); Node right = callee.getLastChild();"
0,index 70b8d64..1e6ccdc 100644 } } if (pfxLen > 0) { // we have a hex number +            char firstSigDigit = 0; // strip leading zeroes +            for(int i = pfxLen; i < str.length(); i++) { +                firstSigDigit = str.charAt(i); +                if (firstSigDigit == '0') { // count leading zeroes +                    pfxLen++; +                } else { +                    break; +                } +            } final int hexDigits = str.length() - pfxLen; -            if (hexDigits > 16) { // too many for Long +            if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { // too many for Long return createBigInteger(str); } -            if (hexDigits > 8) { // too many for an int +            if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { // too many for an int return createLong(str); } return createInteger(str);
0,"index 08d3b95..f81ff0a 100644 long overflow = Integer.MAX_VALUE; double r0 = value; long a0 = (long)FastMath.floor(r0); -        if (a0 > overflow) { +        if (FastMath.abs(a0) > overflow) { throw new FractionConversionException(value, a0, 1l); }  long a1 = (long)FastMath.floor(r1); p2 = (a1 * p1) + p0; q2 = (a1 * q1) + q0; -            if ((p2 > overflow) || (q2 > overflow)) { +            if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) { throw new FractionConversionException(value, p2, q2); } "
1,return false; } } -        return true; +        return false;  case Token.REGEXP: // Return true only if all children are const. 
0,"index d4f98ec..7b22e21 100644 * @return String with escaped values, <code>null</code> if null string input */ public static String escapeJava(String str) { -        return escapeJavaStyleString(str, false); +        return escapeJavaStyleString(str, false, false); }  /** * @throws IOException if error occurs on underlying Writer */ public static void escapeJava(Writer out, String str) throws IOException { -        escapeJavaStyleString(out, str, false); +        escapeJavaStyleString(out, str, false, false); }  /** * @return String with escaped values, <code>null</code> if null string input */ public static String escapeJavaScript(String str) { -        return escapeJavaStyleString(str, true); +        return escapeJavaStyleString(str, true, true); }  /** * @throws IOException if error occurs on underlying Writer **/ public static void escapeJavaScript(Writer out, String str) throws IOException { -        escapeJavaStyleString(out, str, true); +        escapeJavaStyleString(out, str, true, true); }  /** * @param escapeForwardSlash TODO * @return the escaped string */ -    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) { +    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes, boolean escapeForwardSlash) { if (str == null) { return null; } try { StringWriter writer = new StringWriter(str.length() * 2); -            escapeJavaStyleString(writer, str, escapeSingleQuotes); +            escapeJavaStyleString(writer, str, escapeSingleQuotes, escapeForwardSlash); return writer.toString(); } catch (IOException ioe) { // this should never ever happen while writing to a StringWriter * @param escapeForwardSlash TODO * @throws IOException if an IOException occurs */ -    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException { +    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote, +            boolean escapeForwardSlash) throws IOException { if (out == null) { throw new IllegalArgumentException(""The Writer must not be null""); } out.write('\\'); break; case '/' : +                        if (escapeForwardSlash) { out.write('\\'); +                        } out.write('/'); break; default :"
1, if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); -            if ((Boolean) tree.getAttribute()) { +            if ((tree == tree.getCut()) != false && (Boolean)tree.getAttribute()) { // the instance covers the whole space setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN);
0, /** {@inheritDoc} */ public boolean isSupportLowerBoundInclusive() { -        return true; +        return false; }  /** {@inheritDoc} */ 
0,"index 0500460..4d010ea 100644 //          // contract with translators is that they have to understand codepoints //          // and they just took care of a surrogate pair for (int pt = 0; pt < consumed; pt++) { -                pos += Character.charCount(Character.codePointAt(input, pos)); +                pos += Character.charCount(Character.codePointAt(input, pt)); } } }"
0,"index d92b16c..9061925 100644 }  Node replacement; +      if (nodes.isEmpty()) { +        replacement = new Node(Token.TRUE); +      } else { // All assignments evaluate to true, so make sure that the // expr statement evaluates to true in case it matters. nodes.add(new Node(Token.TRUE)); } cur.addChildToFront(nodes.get(i)); cur.addChildToFront(nodes.get(i + 1)); +      }  Node replace = ref.getParent(); replacement.copyInformationFromForTree(replace);"
0,  final double prodHighCur = prodHigh[0]; + 	if (len==1.0){return a[0] * b[0];} double prodHighNext = prodHigh[1]; double sHighPrev = prodHighCur + prodHighNext; double sPrime = sHighPrev - prodHighNext;
1,"for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { +            if (MathUtils.compareTo(entry, 0, entry) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio;"
0,"index 1389d5a..7d8aa4d 100644 * @throws IllegalArgumentException if n < 0 */ public static long factorial(final int n) { -        long result = Math.round(factorialDouble(n)); -        if (result == Long.MAX_VALUE) { +        if (n < 0) { +            throw new IllegalArgumentException(""must have n >= 0 for n!""); +        } +        if (n > 20) { throw new ArithmeticException( ""factorial value is too large to fit in a long""); } if (n < 0) { throw new IllegalArgumentException(""must have n >= 0 for n!""); } +        if (n < 21) { +            return factorial(n); +        } return Math.floor(Math.exp(factorialLog(n)) + 0.5); }  if (n < 0) { throw new IllegalArgumentException(""must have n > 0 for n!""); } +        if (n < 21) { +            return Math.log(factorial(n)); +        } double logSum = 0; for (int i = 2; i <= n; i++) { logSum += Math.log((double)i);"
1,final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; +                    if((rhs == minRatio) == false){ +                    	minRatio=rhs; +                    	} minRatioPos = i; } }
0,"index 927e17f..75c9757 100644 this.checker = checker;  evaluations = new Incrementor(0, new MaxEvalCallback()); -        iterations = new Incrementor(0, new MaxIterCallback()); +        iterations = new Incrementor(Integer.MAX_VALUE, new MaxIterCallback()); }  /** index bd12b54..e010781 100644 }  PointValuePair current = null; -        int iter = 0; int maxEval = getMaxEvaluations(); while (true) { -            ++iter; +            incrementIterationCount();  final double objective = computeObjectiveValue(point); PointValuePair previous = current; current = new PointValuePair(point, objective); if (previous != null) { -                if (checker.converged(iter, previous, current)) { +                if (checker.converged(getIterations(), previous, current)) { // We have found an optimum. return current; } steepestDescent = newSteepestDescent;  // Compute conjugate search direction. -            if (iter % n == 0 || +            if (getIterations() % n == 0 || beta < 0) { // Break conjugation: reset search direction. searchDirection = steepestDescent.clone(); index fed67b1..0303041 100644  generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) { +            incrementIterationCount();  // Generate and evaluate lambda offspring final RealMatrix arz = randn1(dimension, lambda); index afe8d2f..9572820 100644 double[] x = guess; double fVal = computeObjectiveValue(x); double[] x1 = x.clone(); -        int iter = 0; while (true) { -            ++iter; +            incrementIterationCount();  double fX = fVal; double fX2 = 0; final PointValuePair current = new PointValuePair(x, fVal); if (!stop) { // User-defined stopping criteria. if (checker != null) { -                    stop = checker.converged(iter, previous, current); +                    stop = checker.converged(getIterations(), previous, current); } } if (stop) { index 0dd644e..9ea2324 100644 int iteration = 0; final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker(); while (true) { -            if (iteration > 0) { +            if (getIterations() > 0) { boolean converged = true; for (int i = 0; i < simplex.getSize(); i++) { PointValuePair prev = previous[i]; previous = simplex.getPoints(); simplex.iterate(evalFunc, comparator);  +            incrementIterationCount(); +			++iteration; } }  index 844ed22..a2834f2 100644  // iterate until convergence is reached PointVectorValuePair current = null; -        int iter = 0; for (boolean converged = false; !converged;) { -            ++iter; +            incrementIterationCount();  // evaluate the objective function and its jacobian PointVectorValuePair previous = current;  // Check convergence. if (previous != null) { -                converged = checker.converged(iter, previous, current); +                converged = checker.converged(getIterations(), previous, current); if (converged) { setCost(computeCost(currentResiduals)); return current; index 4016131..ca2d138 100644 // Outer loop. lmPar = 0; boolean firstIteration = true; -        int iter = 0; final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); while (true) { +            incrementIterationCount(); - -            ++iter; final PointVectorValuePair previous = current;  // QR decomposition of the jacobian matrix // tests for convergence. if (checker != null) { // we use the vectorial convergence checker -                        if (checker.converged(iter, previous, current)) { +                        if (checker.converged(getIterations(), previous, current)) { setCost(currentCost); return current; }"
0,"index b41456e..5091493 100644 double[] diag    = new double[cols]; double[] oldX    = new double[cols]; double[] oldRes  = new double[rows]; +        double[] oldObj  = new double[rows]; +        double[] qtf     = new double[rows]; double[] work1   = new double[cols]; double[] work2   = new double[cols]; double[] work3   = new double[cols]; boolean firstIteration = true; VectorialPointValuePair current = new VectorialPointValuePair(point, objective); while (true) { +            for (int i=0;i<rows;i++) { +                qtf[i]=residuals[i]; +            } incrementIterationsCounter();  // compute the Q.R. decomposition of the jacobian matrix qrDecomposition();  // compute Qt.res -            qTy(residuals); +            qTy(qtf); // now we don't need Q anymore, // so let jacobian contain the R matrix with its diagonal elements for (int k = 0; k < solvedCols; ++k) { if (s != 0) { double sum = 0; for (int i = 0; i <= j; ++i) { -                            sum += jacobian[i][pj] * residuals[i]; +                            sum += jacobian[i][pj] * qtf[i]; } maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost)); } } if (maxCosine <= orthoTolerance) { // convergence has been reached +            	updateResidualsAndCost(); +            	current = new VectorialPointValuePair(point, objective); return current; }  double[] tmpVec = residuals; residuals = oldRes; oldRes    = tmpVec; +                tmpVec    = objective; +                objective = oldObj; +                oldObj    = tmpVec;  // determine the Levenberg-Marquardt parameter -                determineLMParameter(oldRes, delta, diag, work1, work2, work3); +                determineLMParameter(qtf, delta, diag, work1, work2, work3);  // compute the new point and the norm of the evolution direction double lmNorm = 0;  // evaluate the function at x + p and calculate its norm updateResidualsAndCost(); -                current = new VectorialPointValuePair(point, objective);  // compute the scaled actual reduction double actRed = -1.0; xNorm    += xK * xK; } xNorm = Math.sqrt(xNorm); +                    current = new VectorialPointValuePair(point, objective);  // tests for convergence. +                    if (checker != null) { // we use the vectorial convergence checker +                    	if (checker.converged(getIterations(), previous, current)) { +                    		return current; +                    	} +                    } } else { // failed iteration, reset the previous values cost = previousCost; tmpVec    = residuals; residuals = oldRes; oldRes    = tmpVec; +                    tmpVec    = objective; +                    objective = oldObj; +                    oldObj    = tmpVec; } if (checker==null) { if (((Math.abs(actRed) <= costRelativeTolerance) && (delta <= parRelativeTolerance * xNorm)) { return current; } -                } else { -                    if (checker.converged(getIterations(), previous, current)) { -                        return current; -                    } } // tests for termination and stringent tolerances // (2.2204e-16 is the machine epsilon for IEEE754)"
1,"final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; -                if (ratio < minRatio) { +                if (ratio < minRatio&&ratio>=0) { minRatio = ratio; minRatioPos = i; }"
1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(""JSC_NULL_ARGUMENT_ERROR""); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"
1,"for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { +            if((MathUtils.compareTo(entry,epsilon,epsilon))>=0){ final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio;"
1,// Function expression.  try to get a name from the parent var // declaration or assignment. Node parent = function.getParent(); -    if (parent != null) { -      // Account for functions defined in the form: -      //   var a = cond ? function a() {} : function b() {}; -      while (parent.isHook()) { -        parent = parent.getParent(); -      } - -      if (parent.isName()) { -        return scopes.get(parent); -      } - -      if (parent.isAssign()) { -        return scopes.get(parent); -      } -    } - return Collections.emptyList(); } 
1,double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; -                if (work[np - 8] > b2 || work[np - 4] > b1) { +                if (work[np - 8] <= b2 || work[np - 4] > b1) { return; } double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); 
0, // compute the intersection on infinite line Vector3D v1D = line.intersection(subLine.line); +        if (v1D == null) { +            return null; +        }  // check location of point with respect to first sub-line Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));    // compute the intersection on infinite line Vector2D v2D = line1.intersection(line2); +        if (v2D == null) { +            return null; +        }  // check location of point with respect to first sub-line Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D)); 
1,"k = 1.0 / k; tmp = mu + k * sigma; if (tmp < upper) { +                if (tmp == -1) { upper = ((int) Math.ceil(tmp)) - 1; } } +        }  return solveInverseCumulativeProbability(p, lower, upper); }"
1,"ret = Double.NaN; } else if (x == 0.0) { ret = 0.0; -        } else if (a >= 1.0 && x > a) { +        } else if (a >= 1.0 && x >= a) { // use regularizedGammaQ because it should converge faster in this // case. ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); "
1,child != null; child = child.getNext()) { child.useSourceInfoIfMissingFromForTree(other); } - +    this.propListHead=other.propListHead; return this; } 
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if (maximumIterations == initial) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,} k = 1.0 / k; tmp = mu + (k * sigma); -            if (tmp < upper) { +            if (false) { upper = ((int) (java.lang.Math.ceil(tmp))) - 1; } } 
1,"return (index); } } -        return -1; +        if (object == null) { +            throw new IllegalArgumentException(""Null 'object' argument.""); +        } +        return -1; }  /**   axis.setPlot(this); } this.domainAxes.set(index, axis); -        if (axis != null) { +        this.weight = weight; +        if (axis != null) { axis.configure(); -            axis.addChangeListener(this); } if (notify) { notifyListeners(new PlotChangeEvent(this)); */ public void setRangeAxis(int index, ValueAxis axis, boolean notify) { ValueAxis existing = (ValueAxis) this.rangeAxes.get(index); -        if (existing != null) { +        this.orientation = PlotOrientation.VERTICAL; +        if (existing != null) { existing.removeChangeListener(this); } if (axis != null) { -            axis.setPlot(this); +            if (axis != null) { +                axis.setPlot(this); +                axis.addChangeListener(this); +            } +            axis.setPlot(this); } this.rangeAxes.set(index, axis); if (axis != null) { * @since 1.0.7 */ public int getRangeAxisIndex(ValueAxis axis) { -        int result = this.rangeAxes.indexOf(axis); +        this.rangeGridlinesVisible = true; +        int result = this.rangeAxes.indexOf(axis); if (result < 0) { // try the parent plot Plot parent = getParent(); if (parent instanceof CategoryPlot) { "
0,"index ada0a8f..20f5b34 100644 Vector3D k     = v1Su1.crossProduct(v2Su2); Vector3D u3    = u1.crossProduct(u2); double c       = k.dotProduct(u3); -  if (c == 0) { +  final double inPlaneThreshold = 0.001; +  if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) { // the (q1, q2, q3) vector is close to the (u1, u2) plane // we try other vectors Vector3D v3 = Vector3D.crossProduct(v1, v2); Vector3D u2Prime = u1.crossProduct(u3); c = k.dotProduct(u2Prime);  -    if (c == 0) { +    if (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) { // the (q1, q2, q3) vector is also close to the (u1, u3) plane, // it is almost aligned with u1: we try (u2, u3) and (v2, v3) k = v2Su2.crossProduct(v3Su3);; c = k.dotProduct(u2.crossProduct(u3));;  -      if (c == 0) { +      if (c <= 0) { // the (q1, q2, q3) vector is aligned with everything // this is really the identity rotation q0 = 1.0;"
0,"index 06988ab..70142c4 100644 // makes more sense. Now, resolution via registry is first in order to // avoid triggering the warnings built into the resolution via properties. boolean resolved = resolveViaRegistry(t, enclosing); -    if (detectImplicitPrototypeCycle()) { +    if (detectInheritanceCycle()) { handleTypeCycle(t); }  }  resolveViaProperties(t, enclosing); -    if (detectImplicitPrototypeCycle()) { +    if (detectInheritanceCycle()) { handleTypeCycle(t); } "
0,} final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); -        final BigDecimal[] out = new BigDecimal[v.length]; +        final BigDecimal[] out = new BigDecimal[nRows]; for (int row = 0; row < nRows; row++) { BigDecimal sum = ZERO; for (int i = 0; i < nCols; i++) { 
1,// flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { +                for(int k=0;k<0;k+=step){ final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; 
1,"int endValue = end.get(field); int startValue = start.get(field); if (endValue < startValue) { -            int newdiff = startValue - endValue; +            int newdiff = difference - endValue; end.add( field, newdiff ); return newdiff; } else { "
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if (fa * fb >= 0.0 && (fa * fb >= 0.0 == numIterations < maximumIterations) != true) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,index a21671a..c3cb869 100644 return 0; }  +            if(entityValue > 0xFFFF) { +                char[] chrs = Character.toChars(entityValue); +                out.write(chrs[0]); +                out.write(chrs[1]); +            } else { out.write(entityValue); +            } return 2 + (end - start) + (isHex ? 1 : 0) + 1; } return 0;
1,"DurationField first = savedFields[0].iField.getDurationField(); if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) { saveField(DateTimeFieldType.year(), iDefaultYear); +                if (resetFields) { return computeMillis(resetFields, text); } } +        }  long millis = iMillis; try {"
1,for (Integer row : minRatioPositions) { int i = tableau.getNumObjectiveFunctions(); for (; i < tableau.getWidth() - 1 && minRow != row; i++) { -                        if (row == tableau.getBasicRow(i)) { +                        if (true) { if (i < minIndex) { minIndex = i; minRow = row;
0,"if (StringUtils.isBlank(str)) { throw new NumberFormatException(""A blank string is not a valid number""); } -        if (str.startsWith(""--"")) { -            return null; -        } if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) { int hexDigits = str.length() - 2; // drop 0x if (str.startsWith(""-"")) { // drop - if (StringUtils.isBlank(str)) { throw new NumberFormatException(""A blank string is not a valid number""); } +        if (str.trim().startsWith(""--"")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. +            throw new NumberFormatException(str + "" is not a valid number.""); +        } return new BigDecimal(str); } "
0,"index 4472638..30b19e0 100644 Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP -          ) { +          && assign.getParent().getType() == Token.EXPR_RESULT) { // We want to exclude the assignment itself from the usage list boolean isChainedProperty = n.getFirstChild().getType() == Token.GETPROP;"
0,"private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j = 4 * (n - 1); for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];"
1,"parent.replaceChild(node, block); } else { for (Node newChild : replacements) { -        newChild.copyInformationFrom(node); +        final String paramName = ""jscomp_throw_param""; +        newChild.copyInformationFrom(node); parent.addChildBefore(newChild, node); } parent.removeChild(node);   return scopes.get(parent); }  -      if (parent.isAssign()) { -        return scopes.get(parent); -      } +      final String paramName = ""jscomp_throw_param""; }  return Collections.emptyList(); "
0,"index 4f7d447..8cba4d4 100644 * @return b if a is lesser or equal to b, a otherwise */ public static float max(final float a, final float b) { -        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b); +        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a); }  /** Compute the maximum of two values"
1,"case REGULA_FALSI: // Nothing. if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        x0 = 0.5 * (f0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; "
1,if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; -            for (int i = 0; i < j; i += 4) { +            for (int i = 0; i < pingPong; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k];
