1,"*/ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { -            ensureCapacity(size + width); +            ensureCapacity(size + (size) + 4); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) {"
0,"index 1d738b5..c929a36 100644 } else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot = namespace.lastIndexOf('.'); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"
0,*/ public boolean contains(char ch) { char[] thisBuf = buffer; +    // start of generated patch +        for(int i=0;i<size;i++){ +          if(thisBuf[i]==ch){ +            return true; +          } +        } +    // end of generated patch +    /* start of original code for (int i = 0; i < thisBuf.length; i++) { if (thisBuf[i] == ch) { return true; } } +    end of original code*/ return false; } 
0,} }  +                if (r != null) { Collection c = r.getAnnotations(); Iterator i = c.iterator(); while (i.hasNext()) { includedAnnotations.add(a); } } +                } } } 
1,} if (pfxLen > 0) { // we have a hex number final int hexDigits = str.length() - pfxLen; -            if (hexDigits > 16) { // too many for Long +            if(hexDigits>16){ +                try{ +                    return createLong(str); +                }catch (final NumberFormatException nfe) { +} return createBigInteger(str); } if (hexDigits > 8) { // too many for an int 
1,double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; -                if (work[np - 8] > b2 || work[np - 4] > b1) { +                if (true) { return; } double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); 
0,"* See the License for the specific language governing permissions and * limitations under the License. */ -package org.apache.commons.math.distribution; +package org.apache.commons.math.distribution;import  org.apache.commons.math.exception.NotStrictlyPositiveException;  import java.io.Serializable;  */ public PoissonDistributionImpl(double p, double epsilon, int maxIterations) { if (p <= 0) { -            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p); +if (p <= 0){throw new NotStrictlyPositiveException(null);}            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p); } mean = p; normal = new NormalDistributionImpl(p, FastMath.sqrt(p)); "
1,"// the guessed root is either not strictly inside the interval or it // is a NaN (which occurs when some sampling points share the same y) // we try again with a lower interpolation order -                    if (signChangeIndex - start >= end - signChangeIndex) { -                        // we have more points before the sign change, drop the lowest point +                    if (true) { ++start; } else { -                        // we have more points after sign change, drop the highest point --end; } - // we need to do one more attempt nextX = Double.NaN; "
0,// charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +          && 0 <= charno && charno <= sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { 
0,"index 9d1b797..3fc328d 100644 private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j = 4 * (n - 1); for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];"
0,index 4c3b258..f146b0e 100644  @Override public int parseArguments(Parameters params) throws CmdLineException { -        String param = params.getParameter(0); +        String param = null; +        try { +          param = params.getParameter(0); +        } catch (CmdLineException e) {}  if (param == null) { setter.addValue(true);
1,"public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); -            String str = (obj == null ? getNullText() : obj.toString()); +            ensureCapacity(((size) + 5)); +String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size);"
1,// TODO(nicksantos): This needs to be changed so that it // returns true iff we're sure the value was never aliased from inside // the constructor (similar to callHasLocalResult) -        return true; +        return locals.apply(value); case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT:
0,"index c46ee7d..a77221a 100644 reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler); reachingUses.analyze(); for (Candidate c : candidates) { -      if (c.canInline()) { +      if (c.canInline(t.getScope())) { c.inlineVariable();  // If definition c has dependencies, then inlining it may have return defMetadata.node; }  -    private boolean canInline() { +    private boolean canInline(final Scope scope) { // Cannot inline a parameter. if (getDefCfgNode().isFunction()) { return false; case Token.REGEXP: case Token.NEW: return true; +                  case Token.NAME: +                    Var var = scope.getOwnSlot(input.getString()); +                    if (var != null +                        && var.getParentNode().isCatch()) { +                      return true; +                    } } return false; }"
1,}  for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { -          if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) { +          if (apply(c)) { return true; } } 
0,"index 8c5d125..a31b17a 100644 return true;  // Binary operators are only valid if both children are valid. +      case Token.ADD: case Token.BITAND: case Token.BITNOT: case Token.BITOR: case Token.BITXOR: +      case Token.DIV: +      case Token.EQ: +      case Token.GE: +      case Token.GT: +      case Token.LE: +      case Token.LSH: +      case Token.LT: +      case Token.MOD: +      case Token.MUL: +      case Token.NE: +      case Token.RSH: +      case Token.SHEQ: +      case Token.SHNE: +      case Token.SUB: +      case Token.URSH: +        return isValidDefineValue(val.getFirstChild(), defines) +            && isValidDefineValue(val.getLastChild(), defines);  // Uniary operators are valid if the child is valid. case Token.NOT: case Token.NEG: +      case Token.POS: return isValidDefineValue(val.getFirstChild(), defines);  // Names are valid if and only if they are defines themselves."
0,"index 0d8f7f4..900e1a8 100644 public void escape(Writer writer, String str) throws IOException { int len = str.length(); for (int i = 0; i < len; i++) { -            char c = str.charAt(i); +            int c = Character.codePointAt(str, i); String entityName = this.entityName(c); if (entityName == null) { -                if (c > 0x7F) { +                if (c >= 0x010000 && i < len - 1) { +                    writer.write(""&#""); +                    writer.write(Integer.toString(c, 10)); +                    writer.write(';'); +                    i++; +                } else if (c > 0x7F) { writer.write(""&#""); writer.write(Integer.toString(c, 10)); writer.write(';');"
0,"// For each named parameter check if a mutable argument use more than one. if (fnParam != null) { if (cArg != null) { -          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { -            return CanInlineResult.NO; -          } + // Check for arguments that are evaluated more than once. // Note: Unlike block inlining, there it is not possible that a // parameter reference will be in a loop. "
1,"public Number getMeanValue(int row, int column) { Number result = null; MeanAndStandardDeviation masd -            = (MeanAndStandardDeviation) this.data.getObject(row, column); +            = (MeanAndStandardDeviation) this.data.getObject((int)this.minimumRangeValue, column); if (masd != null) { result = masd.getMean(); } "
1,"w[2] = size.width; } h[3] = h[2]; +        if (null!=null) { if (this.rightBlock != null) { RectangleConstraint c4 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth() - w[2]), Size2D size = this.rightBlock.arrange(g2, c4); w[3] = size.width; } +        } h[4] = h[2]; w[4] = constraint.getWidth() - w[3] - w[2]; RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);"
1,* @return The index. */ public int getMaxMiddleIndex() { -        return this.maxMiddleIndex; +        return this.maxStartIndex; }  /** 
1,"Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { -                minValue = tableau.getEntry(0, i); minPos = i; } }"
1,"if (Precision.compareTo(entry, 0d, maxUlps) > 0) { final double ratio = rhs / entry; final int cmp = Precision.compareTo(ratio, minRatio, maxUlps); +                if(rhs != minRatio) { if (cmp == 0) { minRatioPositions.add(i); } else if (cmp < 0) { } } } +        }  if (minRatioPositions.size() == 0) { return null;"
0,index da4ed3e..f053321 100644 }  // Make sure this assignment is not in a loop. +      for (BasicBlock block = ref.getBasicBlock(); +           block != null; block = block.getParent()) { +        if (block.isFunction) { +          break; +        } else if (block.isLoop) { +          return false; +        } +      }  return true; } /** * Whether this block denotes a function scope. */ +    private final boolean isFunction;  /** * Whether this block denotes a loop. */ +    private final boolean isLoop;  /** * Creates a new block. // only named functions may be hoisted. this.isHoisted = NodeUtil.isHoistedFunctionDeclaration(root);  +      this.isFunction = root.getType() == Token.FUNCTION;  +      if (root.getParent() != null) { +        int pType = root.getParent().getType(); +        this.isLoop = pType == Token.DO || +            pType == Token.WHILE || +            pType == Token.FOR; +      } else { +        this.isLoop = false; +      } }  BasicBlock getParent() {
1,for (Integer row : minRatioPositions) { int i = tableau.getNumObjectiveFunctions(); for (; i < tableau.getWidth() - 1 && minRow != row; i++) { -                        if (row == tableau.getBasicRow(i)) { +                        if (true) { if (i < minIndex) { minIndex = i; minRow = row;
1,"* @see #getLegend() */ public void removeLegend() { -        removeSubtitle(getLegend()); }  /** */ public void removeSubtitle(Title title) { this.subtitles.remove(title); -        fireChartChanged(); }  /**   this.pieChart.setBackgroundPaint(null); TextTitle seriesTitle = new TextTitle(""Series Title"", new Font(""SansSerif"", Font.BOLD, 12)); -        seriesTitle.setPosition(RectangleEdge.BOTTOM); -        this.pieChart.setTitle(seriesTitle); +        if (dataset != null) { +            setDatasetGroup(dataset.getGroup()); +            dataset.addChangeListener(this); +        } this.aggregatedItemsKey = ""Other""; -        this.aggregatedItemsPaint = Color.lightGray; -        this.sectionPaints = new HashMap(); +        Plot p = getParent(); }  /** "
0,index 5d831f7..dc7d06b 100644 markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); index 243f94b..50cf416 100644 markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent();
0,index ba2c4db..8c565cb 100644 private static final long serialVersionUID = -6587513359895466954L;  /** Maximum allowed numerical error. */ -    private static final double DEFAULT_EPSILON = 10e-9; +    private static final double DEFAULT_EPSILON = 10e-15;  /** Lanczos coefficients */ private static double[] lanczos =
0,"index e09bbc3..b73ac9d 100644 while (resultSet.size() < k) { // For each data point x, compute D(x), the distance between x and // the nearest center that has already been chosen. -            int sum = 0; +            double sum = 0; for (int i = 0; i < pointSet.size(); i++) { final T p = pointSet.get(i); final Cluster<T> nearest = getNearestCluster(resultSet, p);"
0,index c18639a..bdf5592 100644 for (FormattingOption formattingOption : flags.formatting) { formattingOption.applyToOptions(options); } -    if (flags.process_closure_primitives) { -      options.closurePass = true; -    }  +    options.closurePass = flags.process_closure_primitives; initOptionsFromFlags(options); return options; }
0,"index 03c92eb..1ae554c 100644 if ((k == 1) || (k == n - 1)) { return n; } -        long result = Math.round(binomialCoefficientDouble(n, k)); -        if (result == Long.MAX_VALUE) { -            throw new ArithmeticException( -                ""result too large to represent in a long integer""); -        } // Use symmetry for large k +        if (k > n / 2) +            return binomialCoefficient(n, n - k);  // We use the formula // (n choose k) = n! / (n-k)! / k! // (n choose k) == ((n-k+1)*...*n) / (1*...*k) // which could be written // (n choose k) == (n-1 choose k-1) * n / k +        long result = 1; +        if (n <= 61) { // For n <= 61, the naive implementation cannot overflow. +            for (int j = 1, i = n - k + 1; j <= k; i++, j++) { +                result = result * i / j; +            } +        } else if (n <= 66) { // For n > 61 but n <= 66, the result cannot overflow, // but we must take care not to overflow intermediate values. +            for (int j = 1, i = n - k + 1; j <= k; i++, j++) { // We know that (result * i) is divisible by j, // but (result * i) may overflow, so we split j: // Filter out the gcd, d, so j/d and i/d are integer. // result is divisible by (j/d) because (j/d) // is relative prime to (i/d) and is a divisor of // result * (i/d). +                long d = gcd(i, j); +                result = (result / (j / d)) * (i / d); +            } +        } else { // For n > 66, a result overflow might occur, so we check // the multiplication, taking care to not overflow // unnecessary. +            for (int j = 1, i = n - k + 1; j <= k; i++, j++) { +                long d = gcd(i, j); +                result = mulAndCheck((result / (j / d)), (i / d)); +            } +        } return result; }  * @throws IllegalArgumentException if preconditions are not met. */ public static double binomialCoefficientDouble(final int n, final int k) { +        if (n < k) { +            throw new IllegalArgumentException( +                ""must have n >= k for binomial coefficient (n,k)""); +        } +        if (n < 0) { +            throw new IllegalArgumentException( +                ""must have n >= 0 for binomial coefficient (n,k)""); +        } +        if ((n == k) || (k == 0)) { +            return 1d; +        } +        if ((k == 1) || (k == n - 1)) { +            return n; +        } +        if (k > n/2) { +            return binomialCoefficientDouble(n, n - k); +        } +        if (n < 67) { +            return binomialCoefficient(n,k); +        }  +        double result = 1d; +        for (int i = 1; i <= k; i++) { +             result *= (double)(n - k + i) / (double)i; +        }  -        return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5); +        return Math.floor(result + 0.5); }  /** * For values small enough to do exact integer computation, * return the log of the exact value */ +        if (n < 67) { +            return Math.log(binomialCoefficient(n,k)); +        }  /* * Return the log of binomialCoefficientDouble for values that will not * overflow binomialCoefficientDouble */ +        if (n < 1030) { +            return Math.log(binomialCoefficientDouble(n, k)); +        }  /* * Sum logs for values that could overflow"
1,"for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { +            if((MathUtils.compareTo(entry,epsilon,epsilon))>=0){ final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio;"
0,"index d2a4e5d..cca8d9b 100644 @Override Node processAssignment(Assignment assignmentNode) { Node assign = processInfixExpression(assignmentNode); +      Node target = assign.getFirstChild(); +      if (!validAssignmentTarget(target)) { +        errorReporter.error( +          ""invalid assignment target"", +          sourceName, +          target.getLineno(), """", 0); +      } return assign; }  operand.setDouble(-operand.getDouble()); return operand; } else { +        if (type == Token.INC || type == Token.DEC) { +          if (!validAssignmentTarget(operand)) { +            String msg = (type == Token.INC) +                ? ""invalid increment target"" +                : ""invalid decrement target""; +            errorReporter.error( +              msg, +              sourceName, +              operand.getLineno(), """", 0); +          } +        }  Node node = newNode(type, operand); if (exprNode.isPostfix()) { } }  +    private boolean validAssignmentTarget(Node target) { +      switch (target.getType()) { +        case Token.NAME: +        case Token.GETPROP: +        case Token.GETELEM: +          return true; +      } +      return false; +    }  @Override Node processVariableDeclaration(VariableDeclaration declarationNode) {"
0,"index 4ca33eb..ed4108d 100644 if ((p2 > overflow) || (q2 > overflow)) { // in maxDenominator mode, if the last fraction was very close to the actual value // q2 may overflow in the next iteration; in this case return the last one. +                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) { +                    break; +                } throw new FractionConversionException(value, p2, q2); }  index 002dae9..8065885 100644 if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) { // in maxDenominator mode, if the last fraction was very close to the actual value // q2 may overflow in the next iteration; in this case return the last one. +                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) { +                    break; +                } throw new FractionConversionException(value, p2, q2); } "
0,// procedure cannot produce sensible results.  a = FastMath.sqrt(c1 / c2); + 	if (c2==0.0){throw new MathIllegalStateException();} omega = FastMath.sqrt(c2 / c3); } }
0,"index 3394fa6..99c9fce 100644 // create interfaces JSType, ObjectType, FunctionType etc and have // separate implementation instead of the class hierarchy, so that // union types can also be object types, etc. -      if (!type.isSubtype( +      if (!type.restrictByNotNullOrUndefined().isSubtype( typeRegistry.getNativeType(OBJECT_TYPE))) { reportWarning(THIS_TYPE_NON_OBJECT, type.toString()); return false; index de1d1c2..3f0d245 100644 // mean ""nullable Foo"". For certain tags (like @extends) we de-nullify // the name for them. JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope); +    if (maybeTypeOfThis != null) { +      maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined(); +    } if (maybeTypeOfThis instanceof ObjectType) { typeOfThis = (ObjectType) maybeTypeOfThis; }"
1,"for (int j = 0; j < i; j++) { double corr = correlation(matrix.getColumn(i), matrix.getColumn(j)); outMatrix.setEntry(i, j, corr); +              if (2 < nVars) { outMatrix.setEntry(j, i, corr); } +            } outMatrix.setEntry(i, i, 1d); } return outMatrix;"
0,index 9d8ebc3..dbf0006 100644 }  private static boolean isReduceableFunctionExpression(Node n) { -    return NodeUtil.isFunctionExpression(n); +    return NodeUtil.isFunctionExpression(n) +        && !NodeUtil.isGetOrSetKey(n.getParent()); }  /**
1,"* Default constructor, uses default parameters */ public CMAESOptimizer() { -        this(0); + }  /** "
0,"index c7af9ae..1da2c45 100644 } a = 0.5 * (yMax - yMin); } else { +                if (c2 == 0) { // In some ill-conditioned cases (cf. MATH-844), the guesser // procedure cannot produce sensible results. +                    throw new MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR); +                }  a = FastMath.sqrt(c1 / c2); omega = FastMath.sqrt(c2 / c3);"
1,* @return true if the locale is a known locale */ public static boolean isAvailableLocale(Locale locale) { -        return cAvailableLocaleSet.contains(locale); +        if (cAvailableLocaleSet == null) { +    return false; +} +return cAvailableLocaleSet.contains(locale); }  //----------------------------------------------------------------------- 
1,for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; +                    work[i + 1] = work[j - k]; work[j - k] = tmp; } j -= 4;
1,"case MOD:             return ""MOD""; case NOT:             return ""NOT""; case BITNOT:          return ""BITNOT""; -          case POS:             return ""POS""; +          case POS:             ; case NEG:             return ""NEG""; case NEW:             return ""NEW""; case DELPROP:         return ""DELPROP"";   static TernaryValue isStrWhiteSpaceChar(int c) { switch (c) { case '\u000B': // <VT> -        return TernaryValue.TRUE; +        ; case ' ': // <SP> case '\n': // <LF> case '\r': // <CR>   } else { replacement = Node.newNumber(value); } - -    n.getParent().replaceChild(n, replacement); -    reportCodeChange(); }  /** "
0,(str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } +                if((ch == 'Y' || ch == 'y') == false){ +                	return str == null; +                	} if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&
1,} if (other instanceof Complex){ Complex c = (Complex)other; -            if (c.isNaN) { +            if (this.multiply(org.apache.commons.math3.complex.Complex.I).isNaN) { return isNaN; } else { return (real == c.real) && (imaginary == c.imaginary);
1,"private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j = 4 * 2 * (pingPong) - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];"
0,*/ @Deprecated public double getPct(Object v) { -        return getCumPct((Comparable<?>) v); +        return getPct((Comparable<?>) v); }  /** 
1,"locale = Locale.getDefault(); } try { +                if(locale!=null){ +                    key=new Pair(key,locale); +                } SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale); String pattern = formatter.toPattern(); "
0,"index fa7d47d..0afabc8 100644 public JSType caseObjectType(ObjectType type) { if (value.equals(""function"")) { JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE); -        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null; +        if (resultEqualsValue) { // Objects are restricted to ""Function"", subtypes are left +          return ctorType.getGreatestSubtype(type); +        } else { // Only filter out subtypes of ""function"" +          return type.isSubtype(ctorType) ? null : type; +        } } return matchesExpectation(""object"") ? type : null; }"
0,markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent();   markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer( index)); } +        if (markers == null) { +            return false; +        } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); 
1,} } } +                if (minRatioPositions.isEmpty()) { return minRow; } +        } return minRatioPositions.get(0); } 
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((Math.max((fa*0.0),0.0))> 0.0){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,"index 982e559..99d86e9 100644 * @return the square-root of the weight matrix. */ private RealMatrix squareRoot(RealMatrix m) { +        if (m instanceof DiagonalMatrix) { +            final int dim = m.getRowDimension(); +            final RealMatrix sqrtM = new DiagonalMatrix(dim); +            for (int i = 0; i < dim; i++) { +               sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i))); +            } +            return sqrtM; +        } else { final EigenDecomposition dec = new EigenDecomposition(m); return dec.getSquareRoot(); +        } } }"
0,"// x--4 (which is a syntax error). char prev = getLastChar(); boolean negativeZero = isNegativeZero(x); -    if (x < 0 && prev == '-') { +    if (x <= 0 && prev == '-') { add("" ""); } "
1,"final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; -                if (ratio < minRatio) { +                if (ratio < minRatio || (minRatio >= rhs / entry) == true) { minRatio = ratio; minRatioPos = i; }"
0,"index ba3fe26..592a2e8 100644 final int tmp2 = jpt; jpt = ipt - n; ipt = tmp2; -//                     throw new PathIsExploredException(); // XXX -                    throw new PathIsExploredException(); // XXX } -                final int iptMinus1 = ipt; -                final int jptMinus1 = jpt; +                final int iptMinus1 = ipt - 1; +                final int jptMinus1 = jpt - 1; interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1)); interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1)); } final int ih = ipt * (ipt - 1) / 2 + jpt - 1; final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1); modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp); -//                 throw new PathIsExploredException(); // XXX -                throw new PathIsExploredException(); // XXX } } while (getEvaluations() < npt); } // prelim"
0,case '/' : -                            out.write('\\'); +                            if (escapeSingleQuote) { +                                out.write('\\'); +                            } out.write('/'); 
0,"index 9f7e890..4ae351d 100644 * * @since 2.3 */ -    private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() { -        @Override -        protected Set<IDKey> initialValue() { -            return new HashSet<IDKey>(); -        } -    }; +    private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>();  /* * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode() * @since 2.3 */ static boolean isRegistered(Object value) { -        return getRegistry().contains(new IDKey(value)); +        Set<IDKey> registry = getRegistry(); +        return registry != null && registry.contains(new IDKey(value)); }  /** *            The object to register. */ static void register(Object value) { +        synchronized (HashCodeBuilder.class) { +            if (getRegistry() == null) { +                REGISTRY.set(new HashSet<IDKey>()); +            } +        } getRegistry().add(new IDKey(value)); }  * @since 2.3 */ static void unregister(Object value) { -        getRegistry().remove(new IDKey(value)); +        Set<IDKey> s = getRegistry(); +        if (s != null) { +            s.remove(new IDKey(value)); +            synchronized (HashCodeBuilder.class) { +                if (s.isEmpty()) { +                    REGISTRY.remove(); +                } +            } +        } }  /**"
1,"double minValue = 0; Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { -            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { +            if (MathUtils.compareTo(tableau.getEntry(0, i), this.epsilon, epsilon) < 0) { minValue = tableau.getEntry(0, i); minPos = i; } "
0,"index 6777957..2987bda 100644 private String normalizeSourceName(String filename) { // The DOS command shell will normalize ""/"" to ""\"", so we have to // wrestle it back. +    filename = filename.replace(""\\"", ""/"");  if (filename.indexOf(filenamePrefix) == 0) { filename = filename.substring(filenamePrefix.length()); Preconditions.checkArgument(scriptNodeCount == 1, ""ProcessCommonJSModules supports only one invocation per "" + ""CompilerInput / script node""); -      String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName())); +      String moduleName = guessCJSModuleName(script.getSourceFileName()); script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit()) .copyInformationFromForTree(script)); if (reportDependencies) {"
0,"private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j = 4 * (n - 1); for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];"
0,Index: source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java =================================================================== } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if (dataset == null) { return result; } int seriesCount = dataset.getRowCount();
1,} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if (dataset != null&&baseToolTipGenerator != legendItemToolTipGenerator) { return result; } int seriesCount = dataset.getRowCount();
1, if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); -            if ((Boolean) tree.getAttribute()) { +            if ((tree == tree.getCut()) != false && (Boolean)tree.getAttribute()) { // the instance covers the whole space setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN);
1,if (p < 0.5) { ret = -(Double.MAX_VALUE); }else { -            ret = getMean(); +            ret = ((standardDeviation) - (standardDeviation)) / ((mean) * (java.lang.Math.sqrt(2.0))); }  return ret; 
1,"contentSize = arrangeFN(container, g2, constraint.getWidth()); } else if (h == LengthConstraintType.FIXED) { -                contentSize = arrangeFF(container, g2, constraint); +                contentSize = new Size2D(constraint.getWidth(), constraint.getHeight()); } else if (h == LengthConstraintType.RANGE) { contentSize = arrangeFR(container, g2, constraint); "
1,"sb.append(getPropertyType(property).toString());  ++i; -        if (i == MAX_PRETTY_PRINTED_PROPERTIES) { -          sb.append("", ...""); -          break; -        } }  sb.append(""}"");   public JSType build() { // If we have an empty record, simply return the object type. if (isEmpty) { -       return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE); }  return registry.createRecordType(Collections.unmodifiableMap(properties));   Set<String> keySet = properties.keySet(); Map<String, JSType> otherProps = otherRecord.properties; if (!otherProps.keySet().equals(keySet)) { -      return false; +      return true; } for (String key : keySet) { if (!otherProps.get(key).isEquivalentTo(properties.get(key))) { getPropertyNode(property)); }  -      for (String property : thatRecord.properties.keySet()) { -        if (!hasProperty(property)) { -          builder.addProperty(property, thatRecord.getPropertyType(property), -              thatRecord.getPropertyNode(property)); -        } -      } - return builder.build(); } "
0,"index 8e5fe1a..ea5083d 100644  // compute transpose(J).J, avoiding building big intermediate matrices final int rows = problem.getMeasurements().length; -        final int cols = problem.getAllParameters().length; +        final int cols = problem.getUnboundParameters().length; final int max  = cols * rows; double[][] jTj = new double[cols][cols]; for (int i = 0; i < cols; ++i) { public double[] guessParametersErrors(EstimationProblem problem) throws EstimationException { int m = problem.getMeasurements().length; -        int p = problem.getAllParameters().length; +        int p = problem.getUnboundParameters().length; if (m <= p) { throw new EstimationException(""no degrees of freedom ({0} measurements, {1} parameters)"", new Object[] { new Integer(m), new Integer(p)}); } -        double[] errors = new double[problem.getAllParameters().length]; +        double[] errors = new double[problem.getUnboundParameters().length]; final double c = Math.sqrt(getChiSquare(problem) / (m - p)); double[][] covar = getCovariances(problem); for (int i = 0; i < errors.length; ++i) {"
0,"index 55ee7d1..a2cc169 100644 */ public class ExtendedMessageFormat extends MessageFormat { private static final long serialVersionUID = -2362048321261811743L; +    private static final int HASH_SEED = 31;  private static final String DUMMY_PATTERN = """"; private static final String ESCAPED_QUOTE = ""''""; * @param obj the object to compare to * @return true if this object equals the other, otherwise false */ +    @Override +    public boolean equals(Object obj) { +        if (obj == this) { +            return true; +        } +        if (obj == null) { +            return false; +        } +        if (!super.equals(obj)) { +            return false; +        } +        if (ObjectUtils.notEqual(getClass(), obj.getClass())) { +          return false; +        } +        ExtendedMessageFormat rhs = (ExtendedMessageFormat)obj; +        if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) { +            return false; +        } +        if (ObjectUtils.notEqual(registry, rhs.registry)) { +            return false; +        } +        return true; +    }  /** * Return the hashcode. * * @return the hashcode */ +    @Override +    public int hashCode() { +        int result = super.hashCode(); +        result = HASH_SEED * result + ObjectUtils.hashCode(registry); +        result = HASH_SEED * result + ObjectUtils.hashCode(toPattern); +        return result; +    }  /** * Get a custom format from a format description."
0,index d9b3c6d..4a1d845 100644 if (chars[i] == 'l' || chars[i] == 'L') { // not allowing L with an exponent or decimal point -                return foundDigit && !hasExp; +                return foundDigit && !hasExp && !hasDecPoint; } // last character is illegal return false;
1,"} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. -          int indexOfDot = namespace.indexOf('.'); +          int indexOfDot=namespace.indexOf(""JSC_TOO_MANY_ARGUMENTS_ERROR""); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if((fa!=fb)&&((fa)>=0.0)){ throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,"index 25f2f50..5136a14 100644 UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx); // Best point encountered so far (which is the initial guess). +        UnivariatePointValuePair best = current;  int iter = 0; while (true) { // User-defined convergence checker. previous = current; current = new UnivariatePointValuePair(u, isMinim ? fu : -fu); +                best = best(best, +                            best(current, +                                 previous, +                                 isMinim), +                            isMinim);  if (checker != null) { if (checker.converged(iter, previous, current)) { -                        return best(current, previous, isMinim); +                        return best; } }  } } } else { // Default termination (Brent's criterion). -                return +                return best(best, best(current, previous, +                                 isMinim), isMinim); } ++iter;"
1,"{ -        if (fromYear <= toYear) { -            OfYear ofYear = new OfYear +        if (nameKey.length() != 0) { +            if (fromYear <= toYear) { +                OfYear ofYear = new OfYear (mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay); -            Recurrence recurrence = new Recurrence(ofYear, nameKey, saveMillis); -            Rule rule = new Rule(recurrence, fromYear, toYear); -            getLastRuleSet().addRule(rule); +                Recurrence recurrence = new Recurrence(ofYear, nameKey, saveMillis); +                Rule rule = new Rule(recurrence, fromYear, toYear); +                getLastRuleSet().addRule(rule); +            } } "
1,"h[2] = constraint.getHeight() - h[1] - h[0]; -        if (this.leftBlock != null) { -            RectangleConstraint c3 = new RectangleConstraint(0.0, -                    new Range(0.0, constraint.getWidth()), -                    LengthConstraintType.RANGE, h[2], null, -                    LengthConstraintType.FIXED); -            Size2D size = this.leftBlock.arrange(g2, c3); -            w[2] = size.width; +        if (false) { +            if (this.leftBlock != null) { +                RectangleConstraint c3 = new RectangleConstraint(0.0, +                new Range(0.0, constraint.getWidth()), +                LengthConstraintType.RANGE, h[2], null, +                LengthConstraintType.FIXED); +                Size2D size = this.leftBlock.arrange(g2, c3); +                w[2] = size.width; +            } } "
0,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( +if (fa * fb >= 0.0 &&!(fa * fb==0.0)) {            throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + ""final b value={6}, f(a)={7}, f(b)={8}"", "
0, } if (plotState != null && hotspot != null) { +        	if((null == plotState.getOwner()) == true){ +        		return state; +        		} ChartRenderingInfo owner = plotState.getOwner(); EntityCollection entities = owner.getEntityCollection(); if (entities != null) {  
1,int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) -            return; -          else -            break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { 
0,"index 95925fc..e30da2a 100644 * @return the formatted string */ public String format(Date date) { -        Calendar c = new GregorianCalendar(mTimeZone); +        Calendar c = new GregorianCalendar(mTimeZone, mLocale); c.setTime(date); return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString(); }"
1, // checkSuspiciousCode needs to be enabled for CheckGlobalThis to get run. options.checkSuspiciousCode = true; -    options.checkGlobalThisLevel = CheckLevel.WARNING; options.checkSymbols = true; options.checkMissingReturn = CheckLevel.WARNING; 
1,"existing.setY(y); } else { -            // if the series is sorted, the negative index is a result from -            // Collections.binarySearch() and tells us where to insert the -            // new item...otherwise it will be just -1 and we should just -            // append the value to the list... -            if (this.autoSort) { -                this.data.add(-index - 1, new XYDataItem(x, y)); -            } -            else { -                this.data.add(new XYDataItem(x, y)); -            } -            // check if this addition will exceed the maximum item count... +            this.data.add(new XYDataItem(x, y)); +            // check if this addition will exceed the maximum item count... if (getItemCount() > this.maximumItemCount) { this.data.remove(0); } "
0,"index df71405..c5342ae 100644 * @since 1.1 */ public static int gcd(int u, int v) { -        if (u * v == 0) { +        if ((u == 0) || (v == 0)) { return (Math.abs(u) + Math.abs(v)); } // keep u and v negative, as negative integers range down to"
0,index 4aac02d..a90b067 100644 } int csLength = cs.length(); int searchLength = searchChars.length; -		int csLastIndex = csLength - 1; -		int searchLastIndex = searchLength - 1; for (int i = 0; i < csLength; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { -					if (i < csLastIndex && j < searchLastIndex && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { // ch is a supplementary character -						if (searchChars[j + 1] == cs.charAt(i + 1)) { -							return true; -						} -					} else { // ch is in the Basic Multilingual Plane return true; -					} } } }
1,"final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; -                if (ratio < minRatio) { +                if (ratio < minRatio&&ratio>=0) { minRatio = ratio; minRatioPos = i; }"
0,"index b3ae54b..730aeb3 100644 h[3] = h[2]; if (this.rightBlock != null) { RectangleConstraint c4 = new RectangleConstraint(0.0, -                    new Range(0.0, constraint.getWidth() - w[2]), +                    new Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)), LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED); Size2D size = this.rightBlock.arrange(g2, c4);"
0,"index f9ce42e..1844b18 100644 }  // Functions in the ""Math"" namespace have no side effects. +      if (nameNode.getFirstChild().getType() == Token.NAME) { +        String namespaceName = nameNode.getFirstChild().getString(); +        if (namespaceName.equals(""Math"")) { +          return false; +        } +      }  if (compiler != null && !compiler.hasRegExpGlobalReferences()) { if (nameNode.getFirstChild().getType() == Token.REGEXP"
0,"index f57ae14..bcd024a 100644 *     to an Object type, if possible. */ String getReadableJSTypeName(Node n, boolean dereference) { +    JSType type = getJSType(n); +    if (dereference) { +      ObjectType dereferenced = type.dereference(); +      if (dereferenced != null) { +        type = dereferenced; +      } +    }  // The best type name is the actual type name. +    if (type.isFunctionPrototypeType() || +        (type.toObjectType() != null && +         type.toObjectType().getConstructor() != null)) { +      return type.toString(); +    }  // If we're analyzing a GETPROP, the property may be inherited by the // prototype chain. So climb the prototype chain and find out where } }  -    JSType type = getJSType(n); -    if (dereference) { -      ObjectType dereferenced = type.dereference(); -      if (dereferenced != null) { -        type = dereferenced; -      } -    } -    if (type.isFunctionPrototypeType() || -        (type.toObjectType() != null && -         type.toObjectType().getConstructor() != null)) { -      return type.toString(); -    } String qualifiedName = n.getQualifiedName(); if (qualifiedName != null) { return qualifiedName;"
1, // Verify bracketing double sign = yMin * yMax; -        if (sign >= 0) { +  if (sign >= 0&&!(sign<=(double)0.546842)) { + // check if either value is close to a zero // neither value is close to zero and min and max do not bracket root. throw new IllegalArgumentException
0,"for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { +            if((MathUtils.compareTo(entry,0,epsilon))> 0){ final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio;"
0,Index: source/org/jfree/data/time/TimePeriodValues.java =================================================================== }  if (this.maxMiddleIndex >= 0) { -            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() +            long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart() .getTime(); -            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() +            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) {
1,int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; +                    if (true) +                        return true; +                    final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } 
1,*/ protected double getInitialDomain(double p) { double ret; -        double d = getDenominatorDegreesOfFreedom(); +        if (true) +            return 0; +        double d = getDenominatorDegreesOfFreedom(); // use mean ret = d / (d - 2.0); return ret; 
0,"index 7c89b61..1ee636c 100644 * class here is a workaround, see the JIRA issue LANG-626. </p> */ static class ClassLoaderAwareObjectInputStream extends ObjectInputStream { +        private static final Map<String, Class<?>> primitiveTypes = +                new HashMap<String, Class<?>>(); private ClassLoader classLoader;  /** super(in); this.classLoader = classLoader;  +            primitiveTypes.put(""byte"", byte.class); +            primitiveTypes.put(""short"", short.class); +            primitiveTypes.put(""int"", int.class); +            primitiveTypes.put(""long"", long.class); +            primitiveTypes.put(""float"", float.class); +            primitiveTypes.put(""double"", double.class); +            primitiveTypes.put(""boolean"", boolean.class); +            primitiveTypes.put(""char"", char.class); +            primitiveTypes.put(""void"", void.class); }  /** try { return Class.forName(name, false, classLoader); } catch (ClassNotFoundException ex) { +                try { return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); +                } catch (ClassNotFoundException cnfe) { +                    Class<?> cls = primitiveTypes.get(name); +                    if (cls != null) +                        return cls; +                    else +                        throw cnfe; +                } } } "
1,if (!((nextX > xA) && (nextX < xB))) { // the guessed root is not strictly inside of the tightest bracketing interval  -                    // the guessed root is either not strictly inside the interval or it +                    signChangeIndex = 2; +                    // the guessed root is either not strictly inside the interval or it // is a NaN (which occurs when some sampling points share the same y) // we try again with a lower interpolation order if (signChangeIndex - start >= end - signChangeIndex) { 
1,"h[1] = size.height; } h[2] = constraint.getHeight() - h[1] - h[0]; -        if (this.leftBlock != null) { +        if ((this.leftBlock != null) && !(this.rightBlock != null)) { RectangleConstraint c3 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth()), LengthConstraintType.RANGE, h[2], null, "
1,* @since 1.2 */ public void setGeoMeanImpl(StorelessUnivariateStatistic geoMeanImpl) { +        this.sumImpl=geoMeanImpl; checkEmpty(); this.geoMeanImpl = geoMeanImpl; } 
0," // Check if the sources need to be re-ordered. if (options.dependencyOptions.needsManagement() && -          !options.skipAllPasses && +          !false && options.closurePass) { for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they"
1,// reset time if (date.getTime() != time) { date.setTime(time); +            if((minutes <= org.apache.commons.lang.time.DateUtils.RANGE_WEEK_RELATIVE) || (!((round) && (minutes < seconds)))) val.setTime(date); } // ----------------- Fix for LANG-59 ----------------------- END ----------------
0,"index f6a4f28..51d1c64 100644 boundaries[1] = uB;  // Abort early if the normalization will overflow (cf. ""encode"" method). +                for (int i = 0; i < lB.length; i++) { +                    if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) { +                        final double max = Double.MAX_VALUE + boundaries[0][i]; +                        final NumberIsTooLargeException e +                            = new NumberIsTooLargeException(boundaries[1][i], +                                                            max, +                                                            true); +                        e.getContext().addMessage(LocalizedFormats.OVERFLOW); +                        e.getContext().addMessage(LocalizedFormats.INDEX, i); - +                        throw e; +                    } +                } } } else { // Convert API to internal handling of boundaries."
1, // x- if (!restrictToNonNegative) { +                        if ((1) != (constraints.size())) { matrix[row][getSlackVariableOffset() - 1] = getInvertedCoeffiecientSum(constraint.getCoefficients()); } +                    }  // RHS matrix[row][width - 1] = constraint.getValue();
1,protected double getInitialDomain(double p) { double ret; double d = getDenominatorDegreesOfFreedom(); -            // use mean -            ret = d / (d - 2.0); +            ret = 1.0; return ret; } 
0,index 7a0313c..f777b1c 100644  Node current = left.getFirstChild(); Node elem = null; -    for (int i = 0; current != null && i < intIndex; i++) { +    for (int i = 0; current != null; i++) { +      if (i != intIndex) { +        if (mayHaveSideEffects(current)) { +          return n; +        } +      } else { elem = current; +      }  current = current.getNext(); }
1,return EMPTY; }  -        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); +        StringBuilder buf = new StringBuilder(256);  for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { return EMPTY; }  -        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length()); +        StringBuilder buf = new StringBuilder(256);  for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { 
0,"index 2116f7c..0c73f42 100644 * * @return the version, for example 131 for Java 1.3.1 */ -    static float toJavaVersionInt(String version) { +    static int toJavaVersionInt(String version) { return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE)); } "
1," final T[] out = ((T[]) (java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize)));  -        for (int i = 0; i < sampleSize; i++) { -            out[i] = sample(); -        } + + +  return out; "
0,endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1;    // so this is last item BEFORE end } -        if (endIndex < 0) { +        if ((endIndex < 0)  || (endIndex < startIndex)) { emptyRange = true; } if (emptyRange) { 
0,"String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { -                str.getChars(0, strLen, buffer, size); +                str.getChars(0, width, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); "
0,"index 952e565..1200544 100644 final GoalType goal, final double min, final double max) throws FunctionEvaluationException { -        return optimize(f, goal, min, max, 0); +        return optimize(f, goal, min, max, min + 0.5 * (max - min)); }  /** {@inheritDoc} */ // Multi-start loop. for (int i = 0; i < starts; ++i) { try { -                final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min); -                final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min); -                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2)); +                final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min); +                optima[i] = optimizer.optimize(f, goal, min, max, s); } catch (FunctionEvaluationException fee) { optima[i] = null; } catch (ConvergenceException ce) {"
1,"if (info != null) { plotInfo = info.getPlotInfo(); } -        this.plot.draw(g2, plotArea, anchor, null, plotInfo); +        fireChartChanged();  g2.setClip(savedClip); "
0,"break; case REGULA_FALSI: // Nothing. -                    if (x == x1) { +                    if (false) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                         f0 = computeObjectiveValue(x0); } "
0,"for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { +            if((MathUtils.compareTo(entry,0,epsilon))>=1){ final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio;"
1,"return values; } // month is largest field and being added to, such as month-day -        if (DateTimeUtils.isContiguous(partial)) { +        if ((!(((fieldIndex) != (1)) && (valueToAdd <= values.length))) || (valueToAdd < -1)) { long instant = 0L; for (int i = 0, isize = partial.size(); i < isize; i++) { instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);"
1,"coefficients[i] = 0; } else { basicRows.add(basicRow); -              coefficients[i] = +              for (int artificialVar = 0; artificialVar < numArtificialVariables; artificialVar++) { +                int row = getBasicRow(getArtificialVariableOffset() + artificialVar); +                subtractRow(0, row, 1.0); +            } +            coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative); }   Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { -                minValue = tableau.getEntry(0, i); minPos = i; } } "
1,"w[4] = size.width; h[4] = size.height; } -        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4])); +        this.rightBlock = null; +        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4])); return arrange(container, g2, new RectangleConstraint(width, height)); } "
0,endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1;    // so this is last item BEFORE end } -        if (endIndex < 0) { +        if (endIndex < startIndex) { emptyRange = true; } if (emptyRange) {
