1,"private StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn) { int start = pos.getIndex(); +        next(pos); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { return appendTo == null ? null : appendTo.append(QUOTE); }"
1,"ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); -            if (strLen >= width) { +            ensureCapacity(((size) + 4)); +if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen;"
1,"String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { -                str.getChars(0, strLen, buffer, size); +                ensureCapacity(((size) + 4)); +str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size);"
1,"*/ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { -            ensureCapacity(size + width); +            ensureCapacity((size) + 5); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) {"
1,"int start = pos.getIndex(); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { +            getQuotedString(pattern, pos, false); return appendTo == null ? null : appendTo.append(QUOTE); } int lastHold = start; for (int i = pos.getIndex(); i < pattern.length(); i++) {"
1,"*/ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { -            ensureCapacity(size + width); +            ensureCapacity((size) + 4); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) {"
1,"* @return this, to enable chaining */ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { -        if (width > 0) { +        ensureCapacity(((size) + 5)); +if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length();"
1,"String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { -                str.getChars(0, strLen, buffer, size); +                ensureCapacity(((size) + 5)); +str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size);"
1,"StringBuffer appendTo, boolean escapingOn) { int start = pos.getIndex(); char[] c = pattern.toCharArray(); +        next(pos); if (escapingOn && c[start] == QUOTE) { return appendTo == null ? null : appendTo.append(QUOTE); } int lastHold = start;"
1,"*/ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { -            ensureCapacity(size + width); +            ensureCapacity(((size) + 4)); +ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) {"
1,"*/ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { -            ensureCapacity(size + width); +            ensureCapacity(((size) + 5)); +ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) {"
1,"ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); -            if (strLen >= width) { +            ensureCapacity(((size) + 5)); +if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen;"
1,"* @return this, to enable chaining */ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { -        if (width > 0) { +        ensureCapacity(((size) + 4)); +if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length();"
1,"public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); -            String str = (obj == null ? getNullText() : obj.toString()); +            ensureCapacity(((size) + 5)); +String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size);"
1,"*/ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { -            ensureCapacity(size + width); +            ensureCapacity(size + (size) + 4); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) {"
1,"*/ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { -            ensureCapacity(size + width); +            ensureCapacity(size + (size) + 5); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) {"
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return org.apache.commons.math.util.MathUtils.equals(x, y, 1) || x == y; }  /**"
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return x == y || x == y; }  /**"
1,} if (other instanceof Complex){ Complex c = (Complex)other; -            if (c.isNaN) { +            if (this.add(org.apache.commons.math3.complex.Complex.I).isNaN) { return isNaN; } else { return (real == c.real) && (imaginary == c.imaginary);
1,"private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j = 4 * pingPong - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];"
1,if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; -            for (int i = 0; i < j; i += 4) { +            for (int i = 0; i < pingPong; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k];
1,for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; +                    work[j - k] = work[j - k]; work[j - k] = tmp; } j -= 4;
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if (fa * upperBound >= 0.0 ) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; +                    work[i + k] = work[i + k]; work[j - k] = tmp; } j -= 4;
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return (Double.isNaN(org.apache.commons.math.util.MathUtils.TWO_PI) && Double.isNaN(y)) || x == y; }  /**"
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if (fa * b >= 0.0 ) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,} if (other instanceof Complex){ Complex c = (Complex)other; -            if (c.isNaN) { +            if (this.multiply(org.apache.commons.math3.complex.Complex.I).isNaN) { return isNaN; } else { return (real == c.real) && (imaginary == c.imaginary);
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return (Double.isNaN(x) && Double.isNaN(x > 0.0 ? 1.0 : -1.0)) || x == y; }  /**"
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return (Double.isNaN(x) && Double.isNaN(x >= 0.0 ? 1.0 : -1.0)) || x == y; }  /**"
1,"private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j = 4 * 2 * (pingPong) - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];"
1,for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; -                    work[j - k] = tmp; +                    work[i + k] = tmp; } j -= 4; }
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return (Double.isNaN(x) && Double.isNaN(x == 0.0 ? 0.0 : x > 0.0 ? 1.0 : -1.0)) || x == y; }  /**"
1,"*/ public Complex add(Complex rhs) throws NullArgumentException { +        if ((isNaN) || (rhs.isNaN)) {    return org.apache.commons.math.complex.Complex.NaN;} MathUtils.checkNotNull(rhs); return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }"
1,for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; +                    work[i + 1] = work[j - k]; work[j - k] = tmp; } j -= 4;
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return (Double.isNaN(x) && Double.isNaN(org.apache.commons.math.util.MathUtils.TWO_PI)) || x == y; }  /**"
1,for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; +                    work[i + 3] = work[j - k]; work[j - k] = tmp; } j -= 4;
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));  -        if (fa * fb >= 0.0 ) { +        if (((fa * fb) > 0.0) && (numIterations < maximumIterations) ) { throw new ConvergenceException( ""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return x == 0.0 || x == y; }  /**"
1,"private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array -            int j = 4 * n - 1; +            int j = (4 * (n - 1)) + (pingPong); for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];"
1,} if (other instanceof Complex){ Complex c = (Complex)other; -            if (c.isNaN) { +            if (org.apache.commons.math3.complex.Complex.I.subtract(this).isNaN) { return isNaN; } else { return (real == c.real) && (imaginary == c.imaginary);
1,if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; -            for (int i = 0; i < j; i += 4) { +            for (int i = 0; i < 2 * (pingPong); i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k];
0,int start = pos.getIndex(); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { +            next(pos); return appendTo == null ? null : appendTo.append(QUOTE); } int lastHold = start; for (int i = pos.getIndex(); i < pattern.length(); i++) {
0,* @return true if the locale is a known locale */ public static boolean isAvailableLocale(Locale locale) { -        return cAvailableLocaleSet.contains(locale); +        return org.apache.commons.lang.LocaleUtils.availableLocaleList().contains(locale); }  //-----------------------------------------------------------------------
0,* @return true if the locale is a known locale */ public static boolean isAvailableLocale(Locale locale) { -        return cAvailableLocaleSet.contains(locale); +        return org.apache.commons.lang.LocaleUtils.cAvailableLocaleList.contains(locale); }  //-----------------------------------------------------------------------
0,"* @return the formatted string */ public String format(Date date) { -        Calendar c = new GregorianCalendar(mTimeZone); +    		Calendar c = new GregorianCalendar(mTimeZone,mLocale); c.setTime(date); return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString(); }"
0,* @return true if the locale is a known locale */ public static boolean isAvailableLocale(Locale locale) { -        return cAvailableLocaleSet.contains(locale); +        return new java.util.HashSet(org.apache.commons.lang.LocaleUtils.availableLocaleList()).contains(locale); }  //-----------------------------------------------------------------------
0,"*/ public double[] fit() { final double[] guess = (new ParameterGuesser(getObservations())).guess(); -        return fit(new Gaussian.Parametric(), guess); +        return fit( guess) +; }  /**"
0,"* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return org.apache.commons.math.util.MathUtils.equals(x, y, 1); }  /**"
0,double chiSquare = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; -            chiSquare += residual * residual / residualsWeights[i]; +            chiSquare += ((residualsWeights[i]) * residual) * residual; } return chiSquare; }
0,"public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); +        if ((isNaN) || (rhs.isNaN)) {    return org.apache.commons.math.complex.Complex.NaN;} return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); } //-----------------------------------------------------------------------"
